(this["webpackJsonp"] = this["webpackJsonp"] || []).push([["neo4j-driver"],{

/***/ "./node_modules/neo4j-driver/lib/driver.js":
/*!*************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/driver.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.WRITE = exports.READ = exports.Driver = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

var _connectionProvider = _interopRequireDefault(__webpack_require__(/*! ./internal/connection-provider */ "./node_modules/neo4j-driver/lib/internal/connection-provider.js"));

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./internal/bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

var _connectionProviderDirect = _interopRequireDefault(__webpack_require__(/*! ./internal/connection-provider-direct */ "./node_modules/neo4j-driver/lib/internal/connection-provider-direct.js"));

var _connectivityVerifier = _interopRequireDefault(__webpack_require__(/*! ./internal/connectivity-verifier */ "./node_modules/neo4j-driver/lib/internal/connectivity-verifier.js"));

var _constants = __webpack_require__(/*! ./internal/constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

var _logger = _interopRequireDefault(__webpack_require__(/*! ./internal/logger */ "./node_modules/neo4j-driver/lib/internal/logger.js"));

var _poolConfig = __webpack_require__(/*! ./internal/pool-config */ "./node_modules/neo4j-driver/lib/internal/pool-config.js");

var _session = _interopRequireDefault(__webpack_require__(/*! ./session */ "./node_modules/neo4j-driver/lib/session.js"));

var _sessionRx = _interopRequireDefault(__webpack_require__(/*! ./session-rx */ "./node_modules/neo4j-driver/lib/session-rx.js"));

var _requestMessage = __webpack_require__(/*! ./internal/request-message */ "./node_modules/neo4j-driver/lib/internal/request-message.js");

var _util = __webpack_require__(/*! ./internal/util */ "./node_modules/neo4j-driver/lib/internal/util.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_MAX_CONNECTION_LIFETIME = 60 * 60 * 1000; // 1 hour

/**
 * The default record fetch size. This is used in Bolt V4 protocol to pull query execution result in batches.
 * @type {number}
 */

var DEFAULT_FETCH_SIZE = 1000;
/**
 * Constant that represents read session access mode.
 * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.READ })`.
 * @type {string}
 */

var READ = _constants.ACCESS_MODE_READ;
/**
 * Constant that represents write session access mode.
 * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.WRITE })`.
 * @type {string}
 */

exports.READ = READ;
var WRITE = _constants.ACCESS_MODE_WRITE;
exports.WRITE = WRITE;
var idGenerator = 0;
/**
 * A driver maintains one or more {@link Session}s with a remote
 * Neo4j instance. Through the {@link Session}s you can send queries
 * and retrieve results from the database.
 *
 * Drivers are reasonably expensive to create - you should strive to keep one
 * driver instance around per Neo4j Instance you connect to.
 *
 * @access public
 */

var Driver = /*#__PURE__*/function () {
  /**
   * You should not be calling this directly, instead use {@link driver}.
   * @constructor
   * @protected
   * @param {ServerAddress} address
   * @param {string} userAgent
   * @param {Object} authToken
   * @param {Object} config
   */
  function Driver(address, userAgent) {
    var authToken = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck2["default"])(this, Driver);
    sanitizeConfig(config);
    this._id = idGenerator++;
    this._address = address;
    this._userAgent = userAgent;
    this._authToken = authToken;
    this._config = config;
    this._log = _logger["default"].create(config);
    /**
     * Reference to the connection provider. Initialized lazily by {@link _getOrCreateConnectionProvider}.
     * @type {ConnectionProvider}
     * @protected
     */

    this._connectionProvider = null;

    this._afterConstruction();
  }
  /**
   * Verifies connectivity of this driver by trying to open a connection with the provided driver options.
   *
   * @public
   * @param {Object} param - The object parameter
   * @param {string} param.database - The target database to verify connectivity for.
   * @returns {Promise<void>} promise resolved with server info or rejected with error.
   */


  (0, _createClass2["default"])(Driver, [{
    key: "verifyConnectivity",
    value: function verifyConnectivity() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$database = _ref.database,
          database = _ref$database === void 0 ? '' : _ref$database;

      var connectionProvider = this._getOrCreateConnectionProvider();

      var connectivityVerifier = new _connectivityVerifier["default"](connectionProvider);
      return connectivityVerifier.verify({
        database: database
      });
    }
    /**
     * Returns whether the server supports multi database capabilities based on the protocol
     * version negotiated via handshake.
     *
     * Note that this function call _always_ causes a round-trip to the server.
     *
     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.
     */

  }, {
    key: "supportsMultiDb",
    value: function supportsMultiDb() {
      var connectionProvider = this._getOrCreateConnectionProvider();

      return connectionProvider.supportsMultiDb();
    }
    /**
     * Returns whether the server supports transaction config capabilities based on the protocol
     * version negotiated via handshake.
     *
     * Note that this function call _always_ causes a round-trip to the server.
     *
     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.
     */

  }, {
    key: "supportsTransactionConfig",
    value: function supportsTransactionConfig() {
      var connectionProvider = this._getOrCreateConnectionProvider();

      return connectionProvider.supportsTransactionConfig();
    }
    /**
     * @protected
     * @returns {boolean}
     */

  }, {
    key: "_supportsRouting",
    value: function _supportsRouting() {
      return false;
    }
    /**
     * Returns boolean to indicate if driver has been configured with encryption enabled.
     *
     * @protected
     * @returns {boolean}
     */

  }, {
    key: "_isEncrypted",
    value: function _isEncrypted() {
      return this._config.encrypted === _util.ENCRYPTION_ON;
    }
    /**
     * Returns the configured trust strategy that the driver has been configured with.
     *
     * @protected
     * @returns {TrustStrategy}
     */

  }, {
    key: "_getTrust",
    value: function _getTrust() {
      return this._config.trust;
    }
    /**
     * Acquire a session to communicate with the database. The session will
     * borrow connections from the underlying connection pool as required and
     * should be considered lightweight and disposable.
     *
     * This comes with some responsibility - make sure you always call
     * {@link close} when you are done using a session, and likewise,
     * make sure you don't close your session before you are done using it. Once
     * it is closed, the underlying connection will be released to the connection
     * pool and made available for others to use.
     *
     * @public
     * @param {Object} param - The object parameter
     * @param {string} param.defaultAccessMode=WRITE - The access mode of this session, allowed values are {@link READ} and {@link WRITE}.
     * @param {string|string[]} param.bookmarks - The initial reference or references to some previous
     * transactions. Value is optional and absence indicates that that the bookmarks do not exist or are unknown.
     * @param {number} param.fetchSize - The record fetch size of each batch of this session.
     * Use {@link ALL} to always pull all records in one batch. This will override the config value set on driver config.
     * @param {string} param.database - The database this session will operate on.
     * @return {Session} new session.
     */

  }, {
    key: "session",
    value: function session() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$defaultAccessMo = _ref2.defaultAccessMode,
          defaultAccessMode = _ref2$defaultAccessMo === void 0 ? WRITE : _ref2$defaultAccessMo,
          bookmarkOrBookmarks = _ref2.bookmarks,
          _ref2$database = _ref2.database,
          database = _ref2$database === void 0 ? '' : _ref2$database,
          fetchSize = _ref2.fetchSize;

      return this._newSession({
        defaultAccessMode: defaultAccessMode,
        bookmarkOrBookmarks: bookmarkOrBookmarks,
        database: database,
        reactive: false,
        fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize)
      });
    }
    /**
     * Acquire a reactive session to communicate with the database. The session will
     * borrow connections from the underlying connection pool as required and
     * should be considered lightweight and disposable.
     *
     * This comes with some responsibility - make sure you always call
     * {@link close} when you are done using a session, and likewise,
     * make sure you don't close your session before you are done using it. Once
     * it is closed, the underlying connection will be released to the connection
     * pool and made available for others to use.
     *
     * @public
     * @param {Object} param
     * @param {string} param.defaultAccessMode=WRITE - The access mode of this session, allowed values are {@link READ} and {@link WRITE}.
     * @param {string|string[]} param.bookmarks - The initial reference or references to some previous transactions. Value is optional and
     * absence indicates that the bookmarks do not exist or are unknown.
     * @param {string} param.database - The database this session will operate on.
     * @returns {RxSession} new reactive session.
     */

  }, {
    key: "rxSession",
    value: function rxSession() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$defaultAccessMo = _ref3.defaultAccessMode,
          defaultAccessMode = _ref3$defaultAccessMo === void 0 ? WRITE : _ref3$defaultAccessMo,
          bookmarks = _ref3.bookmarks,
          _ref3$database = _ref3.database,
          database = _ref3$database === void 0 ? '' : _ref3$database,
          fetchSize = _ref3.fetchSize;

      return new _sessionRx["default"]({
        session: this._newSession({
          defaultAccessMode: defaultAccessMode,
          bookmarks: bookmarks,
          database: database,
          reactive: true,
          fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize)
        }),
        config: this._config
      });
    }
    /**
     * Close all open sessions and other associated resources. You should
     * make sure to use this when you are done with this driver instance.
     * @public
     * @return {Promise<void>} promise resolved when the driver is closed.
     */

  }, {
    key: "close",
    value: function close() {
      this._log.info("Driver ".concat(this._id, " closing"));

      if (this._connectionProvider) {
        return this._connectionProvider.close();
      }

      return Promise.resolve();
    }
    /**
     * @protected
     */

  }, {
    key: "_afterConstruction",
    value: function _afterConstruction() {
      this._log.info("Direct driver ".concat(this._id, " created for server address ").concat(this._address));
    }
    /**
     * @protected
     */

  }, {
    key: "_createConnectionProvider",
    value: function _createConnectionProvider(address, userAgent, authToken) {
      return new _connectionProviderDirect["default"]({
        id: this._id,
        config: this._config,
        log: this._log,
        address: address,
        userAgent: userAgent,
        authToken: authToken
      });
    }
    /**
     * @protected
     */

  }, {
    key: "_newSession",

    /**
     * @private
     */
    value: function _newSession(_ref4) {
      var defaultAccessMode = _ref4.defaultAccessMode,
          bookmarkOrBookmarks = _ref4.bookmarkOrBookmarks,
          database = _ref4.database,
          reactive = _ref4.reactive,
          fetchSize = _ref4.fetchSize;

      var sessionMode = Driver._validateSessionMode(defaultAccessMode);

      var connectionProvider = this._getOrCreateConnectionProvider();

      var bookmark = bookmarkOrBookmarks ? new _bookmark["default"](bookmarkOrBookmarks) : _bookmark["default"].empty();
      return new _session["default"]({
        mode: sessionMode,
        database: database,
        connectionProvider: connectionProvider,
        bookmark: bookmark,
        config: this._config,
        reactive: reactive,
        fetchSize: fetchSize
      });
    }
    /**
     * @private
     */

  }, {
    key: "_getOrCreateConnectionProvider",
    value: function _getOrCreateConnectionProvider() {
      if (!this._connectionProvider) {
        this._connectionProvider = this._createConnectionProvider(this._address, this._userAgent, this._authToken);
      }

      return this._connectionProvider;
    }
  }], [{
    key: "_validateSessionMode",
    value: function _validateSessionMode(rawMode) {
      var mode = rawMode || WRITE;

      if (mode !== _constants.ACCESS_MODE_READ && mode !== _constants.ACCESS_MODE_WRITE) {
        throw (0, _error.newError)('Illegal session mode ' + mode);
      }

      return mode;
    }
  }]);
  return Driver;
}();
/**
 * @private
 */


exports.Driver = Driver;

function sanitizeConfig(config) {
  config.maxConnectionLifetime = sanitizeIntValue(config.maxConnectionLifetime, DEFAULT_MAX_CONNECTION_LIFETIME);
  config.maxConnectionPoolSize = sanitizeIntValue(config.maxConnectionPoolSize, _poolConfig.DEFAULT_MAX_SIZE);
  config.connectionAcquisitionTimeout = sanitizeIntValue(config.connectionAcquisitionTimeout, _poolConfig.DEFAULT_ACQUISITION_TIMEOUT);
  config.fetchSize = validateFetchSizeValue(config.fetchSize, DEFAULT_FETCH_SIZE);
}
/**
 * @private
 */


function sanitizeIntValue(rawValue, defaultWhenAbsent) {
  var sanitizedValue = parseInt(rawValue, 10);

  if (sanitizedValue > 0 || sanitizedValue === 0) {
    return sanitizedValue;
  } else if (sanitizedValue < 0) {
    return Number.MAX_SAFE_INTEGER;
  } else {
    return defaultWhenAbsent;
  }
}
/**
 * @private
 */


function validateFetchSizeValue(rawValue, defaultWhenAbsent) {
  var fetchSize = parseInt(rawValue, 10);

  if (fetchSize > 0 || fetchSize === _requestMessage.ALL) {
    return fetchSize;
  } else if (fetchSize === 0 || fetchSize < 0) {
    throw new Error('The fetch size can only be a positive value or -1 for ALL. However fetchSize = ' + fetchSize);
  } else {
    return defaultWhenAbsent;
  }
}

var _default = Driver;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/error.js":
/*!************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/error.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.newError = newError;
exports.PROTOCOL_ERROR = exports.SESSION_EXPIRED = exports.SERVICE_UNAVAILABLE = exports.Neo4jError = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _wrapNativeSuper2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ "./node_modules/@babel/runtime/helpers/wrapNativeSuper.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// A common place for constructing error objects, to keep them
// uniform across the driver surface.

/**
 * Error code representing complete loss of service. Used by {@link Neo4jError#code}.
 * @type {string}
 */
var SERVICE_UNAVAILABLE = 'ServiceUnavailable';
/**
 * Error code representing transient loss of service. Used by {@link Neo4jError#code}.
 * @type {string}
 */

exports.SERVICE_UNAVAILABLE = SERVICE_UNAVAILABLE;
var SESSION_EXPIRED = 'SessionExpired';
/**
 * Error code representing serialization/deserialization issue in the Bolt protocol. Used by {@link Neo4jError#code}.
 * @type {string}
 */

exports.SESSION_EXPIRED = SESSION_EXPIRED;
var PROTOCOL_ERROR = 'ProtocolError';
/**
 * Create a new error from a message and error code
 * @param message the error message
 * @param code the error code
 * @return {Neo4jError} an {@link Neo4jError}
 * @private
 */

exports.PROTOCOL_ERROR = PROTOCOL_ERROR;

function newError(message) {
  var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'N/A';
  // TODO: Idea is that we can check the code here and throw sub-classes
  // of Neo4jError as appropriate
  return new Neo4jError(message, code);
}
/**
 * Class for all errors thrown/returned by the driver.
 */


var Neo4jError = /*#__PURE__*/function (_Error) {
  (0, _inherits2["default"])(Neo4jError, _Error);

  var _super = _createSuper(Neo4jError);

  /**
   * @constructor
   * @param {string} message - The error message.
   * @param {string} code - Optional error code. Will be populated when error originates in the database.
   */
  function Neo4jError(message) {
    var _this;

    var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'N/A';
    (0, _classCallCheck2["default"])(this, Neo4jError);
    _this = _super.call(this, message);
    /**
     * The error message
     * @type {string}
     */

    _this.message = message;
    /**
     * Optional error code. Will be populated when error originates in the database.
     * @type {string}
     */

    _this.code = code;
    /**
     * The name of the error.
     * @type {string}
     */

    _this.name = 'Neo4jError';
    return _this;
  }

  return Neo4jError;
}( /*#__PURE__*/(0, _wrapNativeSuper2["default"])(Error));

exports.Neo4jError = Neo4jError;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/graph-types.js":
/*!******************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/graph-types.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNode = isNode;
exports.isRelationship = isRelationship;
exports.isUnboundRelationship = isUnboundRelationship;
exports.isPath = isPath;
exports.isPathSegment = isPathSegment;
exports.PathSegment = exports.Path = exports.UnboundRelationship = exports.Relationship = exports.Node = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var IDENTIFIER_PROPERTY_ATTRIBUTES = {
  value: true,
  enumerable: false,
  configurable: false,
  writable: false
};
var NODE_IDENTIFIER_PROPERTY = '__isNode__';
var RELATIONSHIP_IDENTIFIER_PROPERTY = '__isRelationship__';
var UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY = '__isUnboundRelationship__';
var PATH_IDENTIFIER_PROPERTY = '__isPath__';
var PATH_SEGMENT_IDENTIFIER_PROPERTY = '__isPathSegment__';

function hasIdentifierProperty(obj, property) {
  return (obj && obj[property]) === true;
}
/**
 * Class for Node Type.
 */


var Node = /*#__PURE__*/function () {
  /**
   * @constructor
   * @protected
   * @param {Integer} identity - Unique identity
   * @param {Array<string>} labels - Array for all labels
   * @param {Object} properties - Map with node properties
   */
  function Node(identity, labels, properties) {
    (0, _classCallCheck2["default"])(this, Node);

    /**
     * Identity of the node.
     * @type {Integer}
     */
    this.identity = identity;
    /**
     * Labels of the node.
     * @type {string[]}
     */

    this.labels = labels;
    /**
     * Properties of the node.
     * @type {Object}
     */

    this.properties = properties;
  }
  /**
   * @ignore
   */


  (0, _createClass2["default"])(Node, [{
    key: "toString",
    value: function toString() {
      var s = '(' + this.identity;

      for (var i = 0; i < this.labels.length; i++) {
        s += ':' + this.labels[i];
      }

      var keys = Object.keys(this.properties);

      if (keys.length > 0) {
        s += ' {';

        for (var _i = 0; _i < keys.length; _i++) {
          if (_i > 0) s += ',';
          s += keys[_i] + ':' + JSON.stringify(this.properties[keys[_i]]);
        }

        s += '}';
      }

      s += ')';
      return s;
    }
  }]);
  return Node;
}();

exports.Node = Node;
Object.defineProperty(Node.prototype, NODE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Node} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Node}, `false` otherwise.
 */

function isNode(obj) {
  return hasIdentifierProperty(obj, NODE_IDENTIFIER_PROPERTY);
}
/**
 * Class for Relationship Type.
 */


var Relationship = /*#__PURE__*/function () {
  /**
   * @constructor
   * @protected
   * @param {Integer} identity - Unique identity
   * @param {Integer} start - Identity of start Node
   * @param {Integer} end - Identity of end Node
   * @param {string} type - Relationship type
   * @param {Object} properties - Map with relationship properties
   */
  function Relationship(identity, start, end, type, properties) {
    (0, _classCallCheck2["default"])(this, Relationship);

    /**
     * Identity of the relationship.
     * @type {Integer}
     */
    this.identity = identity;
    /**
     * Identity of the start node.
     * @type {Integer}
     */

    this.start = start;
    /**
     * Identity of the end node.
     * @type {Integer}
     */

    this.end = end;
    /**
     * Type of the relationship.
     * @type {string}
     */

    this.type = type;
    /**
     * Properties of the relationship.
     * @type {Object}
     */

    this.properties = properties;
  }
  /**
   * @ignore
   */


  (0, _createClass2["default"])(Relationship, [{
    key: "toString",
    value: function toString() {
      var s = '(' + this.start + ')-[:' + this.type;
      var keys = Object.keys(this.properties);

      if (keys.length > 0) {
        s += ' {';

        for (var i = 0; i < keys.length; i++) {
          if (i > 0) s += ',';
          s += keys[i] + ':' + JSON.stringify(this.properties[keys[i]]);
        }

        s += '}';
      }

      s += ']->(' + this.end + ')';
      return s;
    }
  }]);
  return Relationship;
}();

exports.Relationship = Relationship;
Object.defineProperty(Relationship.prototype, RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Relationship} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Relationship}, `false` otherwise.
 */

function isRelationship(obj) {
  return hasIdentifierProperty(obj, RELATIONSHIP_IDENTIFIER_PROPERTY);
}
/**
 * Class for UnboundRelationship Type.
 * @access private
 */


var UnboundRelationship = /*#__PURE__*/function () {
  /**
   * @constructor
   * @protected
   * @param {Integer} identity - Unique identity
   * @param {string} type - Relationship type
   * @param {Object} properties - Map with relationship properties
   */
  function UnboundRelationship(identity, type, properties) {
    (0, _classCallCheck2["default"])(this, UnboundRelationship);

    /**
     * Identity of the relationship.
     * @type {Integer}
     */
    this.identity = identity;
    /**
     * Type of the relationship.
     * @type {string}
     */

    this.type = type;
    /**
     * Properties of the relationship.
     * @type {Object}
     */

    this.properties = properties;
  }
  /**
   * Bind relationship
   *
   * @protected
   * @param {Integer} start - Identity of start node
   * @param {Integer} end - Identity of end node
   * @return {Relationship} - Created relationship
   */


  (0, _createClass2["default"])(UnboundRelationship, [{
    key: "bind",
    value: function bind(start, end) {
      return new Relationship(this.identity, start, end, this.type, this.properties);
    }
    /**
     * @ignore
     */

  }, {
    key: "toString",
    value: function toString() {
      var s = '-[:' + this.type;
      var keys = Object.keys(this.properties);

      if (keys.length > 0) {
        s += ' {';

        for (var i = 0; i < keys.length; i++) {
          if (i > 0) s += ',';
          s += keys[i] + ':' + JSON.stringify(this.properties[keys[i]]);
        }

        s += '}';
      }

      s += ']->';
      return s;
    }
  }]);
  return UnboundRelationship;
}();

exports.UnboundRelationship = UnboundRelationship;
Object.defineProperty(UnboundRelationship.prototype, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link UnboundRelationship} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link UnboundRelationship}, `false` otherwise.
 */

function isUnboundRelationship(obj) {
  return hasIdentifierProperty(obj, UNBOUNT_RELATIONSHIP_IDENTIFIER_PROPERTY);
}
/**
 * Class for PathSegment Type.
 */


var PathSegment =
/**
 * @constructor
 * @protected
 * @param {Node} start - start node
 * @param {Relationship} rel - relationship that connects start and end node
 * @param {Node} end - end node
 */
function PathSegment(start, rel, end) {
  (0, _classCallCheck2["default"])(this, PathSegment);

  /**
   * Start node.
   * @type {Node}
   */
  this.start = start;
  /**
   * Relationship.
   * @type {Relationship}
   */

  this.relationship = rel;
  /**
   * End node.
   * @type {Node}
   */

  this.end = end;
};

exports.PathSegment = PathSegment;
Object.defineProperty(PathSegment.prototype, PATH_SEGMENT_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link PathSegment} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link PathSegment}, `false` otherwise.
 */

function isPathSegment(obj) {
  return hasIdentifierProperty(obj, PATH_SEGMENT_IDENTIFIER_PROPERTY);
}
/**
 * Class for Path Type.
 */


var Path =
/**
 * @constructor
 * @protected
 * @param {Node} start  - start node
 * @param {Node} end - end node
 * @param {Array<PathSegment>} segments - Array of Segments
 */
function Path(start, end, segments) {
  (0, _classCallCheck2["default"])(this, Path);

  /**
   * Start node.
   * @type {Node}
   */
  this.start = start;
  /**
   * End node.
   * @type {Node}
   */

  this.end = end;
  /**
   * Segments.
   * @type {Array<PathSegment>}
   */

  this.segments = segments;
  /**
   * Length of the segments.
   * @type {Number}
   */

  this.length = segments.length;
};

exports.Path = Path;
Object.defineProperty(Path.prototype, PATH_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Path} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Path}, `false` otherwise.
 */

function isPath(obj) {
  return hasIdentifierProperty(obj, PATH_IDENTIFIER_PROPERTY);
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.driver = driver;
Object.defineProperty(exports, "int", {
  enumerable: true,
  get: function get() {
    return _integer["int"];
  }
});
Object.defineProperty(exports, "isInt", {
  enumerable: true,
  get: function get() {
    return _integer.isInt;
  }
});
Object.defineProperty(exports, "Neo4jError", {
  enumerable: true,
  get: function get() {
    return _error.Neo4jError;
  }
});
Object.defineProperty(exports, "isPoint", {
  enumerable: true,
  get: function get() {
    return _spatialTypes.isPoint;
  }
});
Object.defineProperty(exports, "isDate", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isDate;
  }
});
Object.defineProperty(exports, "isDateTime", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isDateTime;
  }
});
Object.defineProperty(exports, "isDuration", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isDuration;
  }
});
Object.defineProperty(exports, "isLocalDateTime", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isLocalDateTime;
  }
});
Object.defineProperty(exports, "isLocalTime", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isLocalTime;
  }
});
Object.defineProperty(exports, "isTime", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isTime;
  }
});
exports["default"] = exports.temporal = exports.spatial = exports.error = exports.session = exports.types = exports.logging = exports.auth = exports.integer = void 0;

var _integer = _interopRequireWildcard(__webpack_require__(/*! ./integer */ "./node_modules/neo4j-driver/lib/integer.js"));

var _graphTypes = __webpack_require__(/*! ./graph-types */ "./node_modules/neo4j-driver/lib/graph-types.js");

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

var _result = _interopRequireDefault(__webpack_require__(/*! ./result */ "./node_modules/neo4j-driver/lib/result.js"));

var _resultSummary = _interopRequireDefault(__webpack_require__(/*! ./result-summary */ "./node_modules/neo4j-driver/lib/result-summary.js"));

var _record = _interopRequireDefault(__webpack_require__(/*! ./record */ "./node_modules/neo4j-driver/lib/record.js"));

var _driver = __webpack_require__(/*! ./driver */ "./node_modules/neo4j-driver/lib/driver.js");

var _routingDriver = _interopRequireDefault(__webpack_require__(/*! ./routing-driver */ "./node_modules/neo4j-driver/lib/routing-driver.js"));

var _version = _interopRequireDefault(__webpack_require__(/*! ./version */ "./node_modules/neo4j-driver/lib/version.js"));

var _util = __webpack_require__(/*! ./internal/util */ "./node_modules/neo4j-driver/lib/internal/util.js");

var _urlUtil = _interopRequireDefault(__webpack_require__(/*! ./internal/url-util */ "./node_modules/neo4j-driver/lib/internal/url-util.js"));

var _spatialTypes = __webpack_require__(/*! ./spatial-types */ "./node_modules/neo4j-driver/lib/spatial-types.js");

var _temporalTypes = __webpack_require__(/*! ./temporal-types */ "./node_modules/neo4j-driver/lib/temporal-types.js");

var _serverAddress = _interopRequireDefault(__webpack_require__(/*! ./internal/server-address */ "./node_modules/neo4j-driver/lib/internal/server-address.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Construct a new Neo4j Driver. This is your main entry point for this
 * library.
 *
 * ## Configuration
 *
 * This function optionally takes a configuration argument. Available configuration
 * options are as follows:
 *
 *     {
 *       // Encryption level: ENCRYPTION_ON or ENCRYPTION_OFF.
 *       encrypted: ENCRYPTION_ON|ENCRYPTION_OFF
 *
 *       // Trust strategy to use if encryption is enabled. There is no mode to disable
 *       // trust other than disabling encryption altogether. The reason for
 *       // this is that if you don't know who you are talking to, it is easy for an
 *       // attacker to hijack your encrypted connection, rendering encryption pointless.
 *       //
 *       // TRUST_SYSTEM_CA_SIGNED_CERTIFICATES is the default choice. For NodeJS environments, this
 *       // means that you trust whatever certificates are in the default trusted certificate
 *       // store of the underlying system. For Browser environments, the trusted certificate
 *       // store is usually managed by the browser. Refer to your system or browser documentation
 *       // if you want to explicitly add a certificate as trusted.
 *       //
 *       // TRUST_CUSTOM_CA_SIGNED_CERTIFICATES is another option for trust verification -
 *       // whenever we establish an encrypted connection, we ensure the host is using
 *       // an encryption certificate that is in, or is signed by, a certificate given
 *       // as trusted through configuration. This option is only available for NodeJS environments.
 *       //
 *       // TRUST_ALL_CERTIFICATES means that you trust everything without any verifications
 *       // steps carried out.  This option is only available for NodeJS environments and should not
 *       // be used on production systems.
 *       trust: "TRUST_SYSTEM_CA_SIGNED_CERTIFICATES" | "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES" |
 *       "TRUST_ALL_CERTIFICATES",
 *
 *       // List of one or more paths to trusted encryption certificates. This only
 *       // works in the NodeJS bundle, and only matters if you use "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES".
 *       // The certificate files should be in regular X.509 PEM format.
 *       // For instance, ['./trusted.pem']
 *       trustedCertificates: [],
 *
 *       // The maximum total number of connections allowed to be managed by the connection pool, per host.
 *       // This includes both in-use and idle connections. No maximum connection pool size is imposed
 *       // by default.
 *       maxConnectionPoolSize: 100,
 *
 *       // The maximum allowed lifetime for a pooled connection in milliseconds. Pooled connections older than this
 *       // threshold will be closed and removed from the pool. Such discarding happens during connection acquisition
 *       // so that new session is never backed by an old connection. Setting this option to a low value will cause
 *       // a high connection churn and might result in a performance hit. It is recommended to set maximum lifetime
 *       // to a slightly smaller value than the one configured in network equipment (load balancer, proxy, firewall,
 *       // etc. can also limit maximum connection lifetime). No maximum lifetime limit is imposed by default. Zero
 *       // and negative values result in lifetime not being checked.
 *       maxConnectionLifetime: 60 * 60 * 1000, // 1 hour
 *
 *       // The maximum amount of time to wait to acquire a connection from the pool (to either create a new
 *       // connection or borrow an existing one.
 *       connectionAcquisitionTimeout: 60000, // 1 minute
 *
 *       // Specify the maximum time in milliseconds transactions are allowed to retry via
 *       // `Session#readTransaction()` and `Session#writeTransaction()` functions.
 *       // These functions will retry the given unit of work on `ServiceUnavailable`, `SessionExpired` and transient
 *       // errors with exponential backoff using initial delay of 1 second.
 *       // Default value is 30000 which is 30 seconds.
 *       maxTransactionRetryTime: 30000, // 30 seconds
 *
 *       // Specify socket connection timeout in milliseconds. Numeric values are expected. Negative and zero values
 *       // result in no timeout being applied. Connection establishment will be then bound by the timeout configured
 *       // on the operating system level. Default value is 30000, which is 30 seconds.
 *       connectionTimeout: 30000, // 30 seconds
 *
 *       // Make this driver always return native JavaScript numbers for integer values, instead of the
 *       // dedicated {@link Integer} class. Values that do not fit in native number bit range will be represented as
 *       // `Number.NEGATIVE_INFINITY` or `Number.POSITIVE_INFINITY`.
 *       // **Warning:** ResultSummary It is not always safe to enable this setting when JavaScript applications are not the only ones
 *       // interacting with the database. Stored numbers might in such case be not representable by native
 *       // {@link Number} type and thus driver will return lossy values. This might also happen when data was
 *       // initially imported using neo4j import tool and contained numbers larger than
 *       // `Number.MAX_SAFE_INTEGER`. Driver will then return positive infinity, which is lossy.
 *       // Default value for this option is `false` because native JavaScript numbers might result
 *       // in loss of precision in the general case.
 *       disableLosslessIntegers: false,
 *
 *       // Specify the logging configuration for the driver. Object should have two properties `level` and `logger`.
 *       //
 *       // Property `level` represents the logging level which should be one of: 'error', 'warn', 'info' or 'debug'. This property is optional and
 *       // its default value is 'info'. Levels have priorities: 'error': 0, 'warn': 1, 'info': 2, 'debug': 3. Enabling a certain level also enables all
 *       // levels with lower priority. For example: 'error', 'warn' and 'info' will be logged when 'info' level is configured.
 *       //
 *       // Property `logger` represents the logging function which will be invoked for every log call with an acceptable level. The function should
 *       // take two string arguments `level` and `message`. The function should not execute any blocking or long-running operations
 *       // because it is often executed on a hot path.
 *       //
 *       // No logging is done by default. See `neo4j.logging` object that contains predefined logging implementations.
 *       logging: {
 *         level: 'info',
 *         logger: (level, message) => console.log(level + ' ' + message)
 *       },
 *
 *       // Specify a custom server address resolver function used by the routing driver to resolve the initial address used to create the driver.
 *       // Such resolution happens:
 *       //  * during the very first rediscovery when driver is created
 *       //  * when all the known routers from the current routing table have failed and driver needs to fallback to the initial address
 *       //
 *       // In NodeJS environment driver defaults to performing a DNS resolution of the initial address using 'dns' module.
 *       // In browser environment driver uses the initial address as-is.
 *       // Value should be a function that takes a single string argument - the initial address. It should return an array of new addresses.
 *       // Address is a string of shape '<host>:<port>'. Provided function can return either a Promise resolved with an array of addresses
 *       // or array of addresses directly.
 *       resolver: function(address) {
 *         return ['127.0.0.1:8888', 'fallback.db.com:7687'];
 *       },
 *
 *      // Optionally override the default user agent name.
 *       userAgent: USER_AGENT
 *     }
 *
 * @param {string} url The URL for the Neo4j database, for instance "neo4j://localhost" and/or "bolt://localhost"
 * @param {Map<string,string>} authToken Authentication credentials. See {@link auth} for helpers.
 * @param {Object} config Configuration object. See the configuration section above for details.
 * @returns {Driver}
 */
function driver(url, authToken) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  (0, _util.assertString)(url, 'Bolt URL');

  var parsedUrl = _urlUtil["default"].parseDatabaseUrl(url); // Determine entryption/trust options from the URL.


  var routing = false;
  var encrypted = false;
  var trust;

  switch (parsedUrl.scheme) {
    case 'bolt':
      break;

    case 'bolt+s':
      encrypted = true;
      trust = 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES';
      break;

    case 'bolt+ssc':
      encrypted = true;
      trust = 'TRUST_ALL_CERTIFICATES';
      break;

    case 'neo4j':
      routing = true;
      break;

    case 'neo4j+s':
      encrypted = true;
      trust = 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES';
      routing = true;
      break;

    case 'neo4j+ssc':
      encrypted = true;
      trust = 'TRUST_ALL_CERTIFICATES';
      routing = true;
      break;

    default:
      throw new Error("Unknown scheme: ".concat(parsedUrl.scheme));
  } // Encryption enabled on URL, propagate trust to the config.


  if (encrypted) {
    // Check for configuration conflict between URL and config.
    if ('encrypted' in config || 'trust' in config) {
      throw new Error('Encryption/trust can only be configured either through URL or config, not both');
    }

    config.encrypted = _util.ENCRYPTION_ON;
    config.trust = trust;
  } // Sanitize authority token. Nicer error from server when a scheme is set.


  authToken = authToken || {};
  authToken.scheme = authToken.scheme || 'none'; // Use default user agent or user agent specified by user.

  config.userAgent = config.userAgent || USER_AGENT;

  if (routing) {
    return new _routingDriver["default"](_serverAddress["default"].fromUrl(parsedUrl.hostAndPort), parsedUrl.query, config.userAgent, authToken, config);
  } else {
    if (!(0, _util.isEmptyObjectOrNull)(parsedUrl.query)) {
      throw new Error("Parameters are not supported with none routed scheme. Given URL: '".concat(url, "'"));
    }

    return new _driver.Driver(_serverAddress["default"].fromUrl(parsedUrl.hostAndPort), config.userAgent, authToken, config);
  }
}
/**
 * @property {function(username: string, password: string, realm: ?string)} basic the function to create a
 * basic authentication token.
 * @property {function(base64EncodedTicket: string)} kerberos the function to create a Kerberos authentication token.
 * Accepts a single string argument - base64 encoded Kerberos ticket.
 * @property {function(principal: string, credentials: string, realm: string, scheme: string, parameters: ?object)} custom
 * the function to create a custom authentication token.
 */


var auth = {
  basic: function basic(username, password) {
    var realm = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

    if (realm) {
      return {
        scheme: 'basic',
        principal: username,
        credentials: password,
        realm: realm
      };
    } else {
      return {
        scheme: 'basic',
        principal: username,
        credentials: password
      };
    }
  },
  kerberos: function kerberos(base64EncodedTicket) {
    return {
      scheme: 'kerberos',
      principal: '',
      // This empty string is required for backwards compatibility.
      credentials: base64EncodedTicket
    };
  },
  custom: function custom(principal, credentials, realm, scheme) {
    var parameters = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;

    if (parameters) {
      return {
        scheme: scheme,
        principal: principal,
        credentials: credentials,
        realm: realm,
        parameters: parameters
      };
    } else {
      return {
        scheme: scheme,
        principal: principal,
        credentials: credentials,
        realm: realm
      };
    }
  }
};
exports.auth = auth;
var USER_AGENT = 'neo4j-javascript/' + _version["default"];
/**
 * Object containing predefined logging configurations. These are expected to be used as values of the driver config's `logging` property.
 * @property {function(level: ?string): object} console the function to create a logging config that prints all messages to `console.log` with
 * timestamp, level and message. It takes an optional `level` parameter which represents the maximum log level to be logged. Default value is 'info'.
 */

var logging = {
  console: function (_console) {
    function console(_x) {
      return _console.apply(this, arguments);
    }

    console.toString = function () {
      return _console.toString();
    };

    return console;
  }(function (level) {
    return {
      level: level,
      logger: function logger(level, message) {
        return console.log("".concat(global.Date.now(), " ").concat(level.toUpperCase(), " ").concat(message));
      }
    };
  })
};
/**
 * Object containing constructors for all neo4j types.
 */

exports.logging = logging;
var types = {
  Node: _graphTypes.Node,
  Relationship: _graphTypes.Relationship,
  UnboundRelationship: _graphTypes.UnboundRelationship,
  PathSegment: _graphTypes.PathSegment,
  Path: _graphTypes.Path,
  Result: _result["default"],
  ResultSummary: _resultSummary["default"],
  Record: _record["default"],
  Point: _spatialTypes.Point,
  Date: _temporalTypes.Date,
  DateTime: _temporalTypes.DateTime,
  Duration: _temporalTypes.Duration,
  LocalDateTime: _temporalTypes.LocalDateTime,
  LocalTime: _temporalTypes.LocalTime,
  Time: _temporalTypes.Time,
  Integer: _integer["default"]
};
/**
 * Object containing string constants representing session access modes.
 */

exports.types = types;
var session = {
  READ: _driver.READ,
  WRITE: _driver.WRITE
};
/**
 * Object containing string constants representing predefined {@link Neo4jError} codes.
 */

exports.session = session;
var error = {
  SERVICE_UNAVAILABLE: _error.SERVICE_UNAVAILABLE,
  SESSION_EXPIRED: _error.SESSION_EXPIRED,
  PROTOCOL_ERROR: _error.PROTOCOL_ERROR
};
/**
 * Object containing functions to work with {@link Integer} objects.
 */

exports.error = error;
var integer = {
  toNumber: _integer.toNumber,
  toString: _integer.toString,
  inSafeRange: _integer.inSafeRange
};
/**
 * Object containing functions to work with spatial types, like {@link Point}.
 */

exports.integer = integer;
var spatial = {
  isPoint: _spatialTypes.isPoint
};
/**
 * Object containing functions to work with temporal types, like {@link Time} or {@link Duration}.
 */

exports.spatial = spatial;
var temporal = {
  isDuration: _temporalTypes.isDuration,
  isLocalTime: _temporalTypes.isLocalTime,
  isTime: _temporalTypes.isTime,
  isDate: _temporalTypes.isDate,
  isLocalDateTime: _temporalTypes.isLocalDateTime,
  isDateTime: _temporalTypes.isDateTime
};
/**
 * @private
 */

exports.temporal = temporal;
var forExport = {
  driver: driver,
  "int": _integer["int"],
  isInt: _integer.isInt,
  isPoint: _spatialTypes.isPoint,
  isDuration: _temporalTypes.isDuration,
  isLocalTime: _temporalTypes.isLocalTime,
  isTime: _temporalTypes.isTime,
  isDate: _temporalTypes.isDate,
  isLocalDateTime: _temporalTypes.isLocalDateTime,
  isDateTime: _temporalTypes.isDateTime,
  integer: integer,
  Neo4jError: _error.Neo4jError,
  auth: auth,
  logging: logging,
  types: types,
  session: session,
  error: error,
  spatial: spatial,
  temporal: temporal
};
var _default = forExport;
exports["default"] = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/integer.js":
/*!**************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/integer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.toString = exports.toNumber = exports.inSafeRange = exports.isInt = exports["int"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// 64-bit Integer library, originally from Long.js by dcodeIO
// https://github.com/dcodeIO/Long.js
// License Apache 2

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 * See exported functions for more convenient ways of operating integers.
 * Use `int()` function to create new integers, `isInt()` to check if given object is integer,
 * `inSafeRange()` to check if it is safe to convert given value to native number,
 * `toNumber()` and `toString()` to convert given integer to number or string respectively.
 * @access public
 * @exports Integer
 * @class A Integer class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @constructor
 */
var Integer = /*#__PURE__*/function () {
  function Integer(low, high) {
    (0, _classCallCheck2["default"])(this, Integer);

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     * @expose
     */
    this.low = low | 0;
    /**
     * The high 32 bits as a signed value.
     * @type {number}
     * @expose
     */

    this.high = high | 0;
  } // The internal representation of an Integer is the two given signed, 32-bit values.
  // We use 32-bit pieces because these are the size of integers on which
  // JavaScript performs bit-operations.  For operations like addition and
  // multiplication, we split each number into 16 bit pieces, which can easily be
  // multiplied within JavaScript's floating-point representation without overflow
  // or change in sign.
  //
  // In the algorithms below, we frequently reduce the negative case to the
  // positive case by negating the input(s) and then post-processing the result.
  // Note that we must ALWAYS check specially whether those values are MIN_VALUE
  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
  // a positive number, it overflows back into a negative).  Not handling this
  // case would often result in infinite recursion.
  //
  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
  // methods on which they depend.


  (0, _createClass2["default"])(Integer, [{
    key: "inSafeRange",
    value: function inSafeRange() {
      return this.greaterThanOrEqual(Integer.MIN_SAFE_VALUE) && this.lessThanOrEqual(Integer.MAX_SAFE_VALUE);
    }
    /**
     * Converts the Integer to an exact javascript Number, assuming it is a 32 bit integer.
     * @returns {number}
     * @expose
     */

  }, {
    key: "toInt",
    value: function toInt() {
      return this.low;
    }
    /**
     * Converts the Integer to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     * @expose
     */

  }, {
    key: "toNumber",
    value: function toNumber() {
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    }
    /**
     * Converts the Integer to native number or -Infinity/+Infinity when it does not fit.
     * @return {number}
     * @package
     */

  }, {
    key: "toNumberOrInfinity",
    value: function toNumberOrInfinity() {
      if (this.lessThan(Integer.MIN_SAFE_VALUE)) {
        return Number.NEGATIVE_INFINITY;
      } else if (this.greaterThan(Integer.MAX_SAFE_VALUE)) {
        return Number.POSITIVE_INFINITY;
      } else {
        return this.toNumber();
      }
    }
    /**
     * Converts the Integer to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     * @expose
     */

  }, {
    key: "toString",
    value: function toString(radix) {
      radix = radix || 10;

      if (radix < 2 || radix > 36) {
        throw RangeError('radix out of range: ' + radix);
      }

      if (this.isZero()) {
        return '0';
      }

      var rem;

      if (this.isNegative()) {
        if (this.equals(Integer.MIN_VALUE)) {
          // We need to change the Integer value before it can be negated, so we remove
          // the bottom-most digit in this base and then recurse to do the rest.
          var radixInteger = Integer.fromNumber(radix);
          var div = this.div(radixInteger);
          rem = div.multiply(radixInteger).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return '-' + this.negate().toString(radix);
        }
      } // Do several (6) digits each time through the loop, so as to
      // minimize the calls to the very expensive emulated div.


      var radixToPower = Integer.fromNumber(Math.pow(radix, 6));
      rem = this;
      var result = '';

      while (true) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0;
        var digits = intval.toString(radix);
        rem = remDiv;

        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = '0' + digits;
          }

          result = '' + digits + result;
        }
      }
    }
    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     * @expose
     */

  }, {
    key: "getHighBits",
    value: function getHighBits() {
      return this.high;
    }
    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     * @expose
     */

  }, {
    key: "getLowBits",
    value: function getLowBits() {
      return this.low;
    }
    /**
     * Gets the number of bits needed to represent the absolute value of this Integer.
     * @returns {number}
     * @expose
     */

  }, {
    key: "getNumBitsAbs",
    value: function getNumBitsAbs() {
      if (this.isNegative()) {
        return this.equals(Integer.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();
      }

      var val = this.high !== 0 ? this.high : this.low;

      for (var bit = 31; bit > 0; bit--) {
        if ((val & 1 << bit) !== 0) {
          break;
        }
      }

      return this.high !== 0 ? bit + 33 : bit + 1;
    }
    /**
     * Tests if this Integer's value equals zero.
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "isZero",
    value: function isZero() {
      return this.high === 0 && this.low === 0;
    }
    /**
     * Tests if this Integer's value is negative.
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "isNegative",
    value: function isNegative() {
      return this.high < 0;
    }
    /**
     * Tests if this Integer's value is positive.
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "isPositive",
    value: function isPositive() {
      return this.high >= 0;
    }
    /**
     * Tests if this Integer's value is odd.
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "isOdd",
    value: function isOdd() {
      return (this.low & 1) === 1;
    }
    /**
     * Tests if this Integer's value is even.
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "isEven",
    value: function isEven() {
      return (this.low & 1) === 0;
    }
    /**
     * Tests if this Integer's value equals the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "equals",
    value: function equals(other) {
      if (!Integer.isInteger(other)) {
        other = Integer.fromValue(other);
      }

      return this.high === other.high && this.low === other.low;
    }
    /**
     * Tests if this Integer's value differs from the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "notEquals",
    value: function notEquals(other) {
      return !this.equals(
      /* validates */
      other);
    }
    /**
     * Tests if this Integer's value is less than the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "lessThan",
    value: function lessThan(other) {
      return this.compare(
      /* validates */
      other) < 0;
    }
    /**
     * Tests if this Integer's value is less than or equal the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "lessThanOrEqual",
    value: function lessThanOrEqual(other) {
      return this.compare(
      /* validates */
      other) <= 0;
    }
    /**
     * Tests if this Integer's value is greater than the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "greaterThan",
    value: function greaterThan(other) {
      return this.compare(
      /* validates */
      other) > 0;
    }
    /**
     * Tests if this Integer's value is greater than or equal the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "greaterThanOrEqual",
    value: function greaterThanOrEqual(other) {
      return this.compare(
      /* validates */
      other) >= 0;
    }
    /**
     * Compares this Integer's value with the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     * @expose
     */

  }, {
    key: "compare",
    value: function compare(other) {
      if (!Integer.isInteger(other)) {
        other = Integer.fromValue(other);
      }

      if (this.equals(other)) {
        return 0;
      }

      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();

      if (thisNeg && !otherNeg) {
        return -1;
      }

      if (!thisNeg && otherNeg) {
        return 1;
      } // At this point the sign bits are the same


      return this.subtract(other).isNegative() ? -1 : 1;
    }
    /**
     * Negates this Integer's value.
     * @returns {!Integer} Negated Integer
     * @expose
     */

  }, {
    key: "negate",
    value: function negate() {
      if (this.equals(Integer.MIN_VALUE)) {
        return Integer.MIN_VALUE;
      }

      return this.not().add(Integer.ONE);
    }
    /**
     * Returns the sum of this and the specified Integer.
     * @param {!Integer|number|string} addend Addend
     * @returns {!Integer} Sum
     * @expose
     */

  }, {
    key: "add",
    value: function add(addend) {
      if (!Integer.isInteger(addend)) {
        addend = Integer.fromValue(addend);
      } // Divide each number into 4 chunks of 16 bits, and then sum the chunks.


      var a48 = this.high >>> 16;
      var a32 = this.high & 0xffff;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xffff;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 0xffff;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 0xffff;
      var c48 = 0;
      var c32 = 0;
      var c16 = 0;
      var c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 0xffff;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c48 += a48 + b48;
      c48 &= 0xffff;
      return Integer.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    }
    /**
     * Returns the difference of this and the specified Integer.
     * @param {!Integer|number|string} subtrahend Subtrahend
     * @returns {!Integer} Difference
     * @expose
     */

  }, {
    key: "subtract",
    value: function subtract(subtrahend) {
      if (!Integer.isInteger(subtrahend)) {
        subtrahend = Integer.fromValue(subtrahend);
      }

      return this.add(subtrahend.negate());
    }
    /**
     * Returns the product of this and the specified Integer.
     * @param {!Integer|number|string} multiplier Multiplier
     * @returns {!Integer} Product
     * @expose
     */

  }, {
    key: "multiply",
    value: function multiply(multiplier) {
      if (this.isZero()) {
        return Integer.ZERO;
      }

      if (!Integer.isInteger(multiplier)) {
        multiplier = Integer.fromValue(multiplier);
      }

      if (multiplier.isZero()) {
        return Integer.ZERO;
      }

      if (this.equals(Integer.MIN_VALUE)) {
        return multiplier.isOdd() ? Integer.MIN_VALUE : Integer.ZERO;
      }

      if (multiplier.equals(Integer.MIN_VALUE)) {
        return this.isOdd() ? Integer.MIN_VALUE : Integer.ZERO;
      }

      if (this.isNegative()) {
        if (multiplier.isNegative()) {
          return this.negate().multiply(multiplier.negate());
        } else {
          return this.negate().multiply(multiplier).negate();
        }
      } else if (multiplier.isNegative()) {
        return this.multiply(multiplier.negate()).negate();
      } // If both longs are small, use float multiplication


      if (this.lessThan(TWO_PWR_24) && multiplier.lessThan(TWO_PWR_24)) {
        return Integer.fromNumber(this.toNumber() * multiplier.toNumber());
      } // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
      // We can skip products that would overflow.


      var a48 = this.high >>> 16;
      var a32 = this.high & 0xffff;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xffff;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 0xffff;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 0xffff;
      var c48 = 0;
      var c32 = 0;
      var c16 = 0;
      var c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 0xffff;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 0xffff;
      return Integer.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    }
    /**
     * Returns this Integer divided by the specified.
     * @param {!Integer|number|string} divisor Divisor
     * @returns {!Integer} Quotient
     * @expose
     */

  }, {
    key: "div",
    value: function div(divisor) {
      if (!Integer.isInteger(divisor)) {
        divisor = Integer.fromValue(divisor);
      }

      if (divisor.isZero()) {
        throw (0, _error.newError)('division by zero');
      }

      if (this.isZero()) {
        return Integer.ZERO;
      }

      var approx, rem, res;

      if (this.equals(Integer.MIN_VALUE)) {
        if (divisor.equals(Integer.ONE) || divisor.equals(Integer.NEG_ONE)) {
          return Integer.MIN_VALUE;
        }

        if (divisor.equals(Integer.MIN_VALUE)) {
          return Integer.ONE;
        } else {
          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
          var halfThis = this.shiftRight(1);
          approx = halfThis.div(divisor).shiftLeft(1);

          if (approx.equals(Integer.ZERO)) {
            return divisor.isNegative() ? Integer.ONE : Integer.NEG_ONE;
          } else {
            rem = this.subtract(divisor.multiply(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.equals(Integer.MIN_VALUE)) {
        return Integer.ZERO;
      }

      if (this.isNegative()) {
        if (divisor.isNegative()) {
          return this.negate().div(divisor.negate());
        }

        return this.negate().div(divisor).negate();
      } else if (divisor.isNegative()) {
        return this.div(divisor.negate()).negate();
      } // Repeat the following until the remainder is less than other:  find a
      // floating-point that approximates remainder / other *from below*, add this
      // into the result, and subtract it from the remainder.  It is critical that
      // the approximate value is less than or equal to the real value so that the
      // remainder never becomes negative.


      res = Integer.ZERO;
      rem = this;

      while (rem.greaterThanOrEqual(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.

        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48); // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.

        var approxRes = Integer.fromNumber(approx);
        var approxRem = approxRes.multiply(divisor);

        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Integer.fromNumber(approx);
          approxRem = approxRes.multiply(divisor);
        } // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.


        if (approxRes.isZero()) {
          approxRes = Integer.ONE;
        }

        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }

      return res;
    }
    /**
     * Returns this Integer modulo the specified.
     * @param {!Integer|number|string} divisor Divisor
     * @returns {!Integer} Remainder
     * @expose
     */

  }, {
    key: "modulo",
    value: function modulo(divisor) {
      if (!Integer.isInteger(divisor)) {
        divisor = Integer.fromValue(divisor);
      }

      return this.subtract(this.div(divisor).multiply(divisor));
    }
    /**
     * Returns the bitwise NOT of this Integer.
     * @returns {!Integer}
     * @expose
     */

  }, {
    key: "not",
    value: function not() {
      return Integer.fromBits(~this.low, ~this.high);
    }
    /**
     * Returns the bitwise AND of this Integer and the specified.
     * @param {!Integer|number|string} other Other Integer
     * @returns {!Integer}
     * @expose
     */

  }, {
    key: "and",
    value: function and(other) {
      if (!Integer.isInteger(other)) {
        other = Integer.fromValue(other);
      }

      return Integer.fromBits(this.low & other.low, this.high & other.high);
    }
    /**
     * Returns the bitwise OR of this Integer and the specified.
     * @param {!Integer|number|string} other Other Integer
     * @returns {!Integer}
     * @expose
     */

  }, {
    key: "or",
    value: function or(other) {
      if (!Integer.isInteger(other)) {
        other = Integer.fromValue(other);
      }

      return Integer.fromBits(this.low | other.low, this.high | other.high);
    }
    /**
     * Returns the bitwise XOR of this Integer and the given one.
     * @param {!Integer|number|string} other Other Integer
     * @returns {!Integer}
     * @expose
     */

  }, {
    key: "xor",
    value: function xor(other) {
      if (!Integer.isInteger(other)) {
        other = Integer.fromValue(other);
      }

      return Integer.fromBits(this.low ^ other.low, this.high ^ other.high);
    }
    /**
     * Returns this Integer with bits shifted to the left by the given amount.
     * @param {number|!Integer} numBits Number of bits
     * @returns {!Integer} Shifted Integer
     * @expose
     */

  }, {
    key: "shiftLeft",
    value: function shiftLeft(numBits) {
      if (Integer.isInteger(numBits)) {
        numBits = numBits.toInt();
      }

      if ((numBits &= 63) === 0) {
        return this;
      } else if (numBits < 32) {
        return Integer.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits);
      } else {
        return Integer.fromBits(0, this.low << numBits - 32);
      }
    }
    /**
     * Returns this Integer with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Integer} numBits Number of bits
     * @returns {!Integer} Shifted Integer
     * @expose
     */

  }, {
    key: "shiftRight",
    value: function shiftRight(numBits) {
      if (Integer.isInteger(numBits)) {
        numBits = numBits.toInt();
      }

      if ((numBits &= 63) === 0) {
        return this;
      } else if (numBits < 32) {
        return Integer.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits);
      } else {
        return Integer.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1);
      }
    }
  }]);
  return Integer;
}();
/**
 * An indicator used to reliably determine if an object is a Integer or not.
 * @type {boolean}
 * @const
 * @expose
 * @private
 */


Integer.__isInteger__ = true;
Object.defineProperty(Integer.prototype, '__isInteger__', {
  value: true,
  enumerable: false,
  configurable: false
});
/**
 * Tests if the specified object is a Integer.
 * @access private
 * @param {*} obj Object
 * @returns {boolean}
 * @expose
 */

Integer.isInteger = function (obj) {
  return (obj && obj.__isInteger__) === true;
};
/**
 * A cache of the Integer representations of small integer values.
 * @type {!Object}
 * @inner
 * @private
 */


var INT_CACHE = {};
/**
 * Returns a Integer representing the given 32 bit integer value.
 * @access private
 * @param {number} value The 32 bit integer in question
 * @returns {!Integer} The corresponding Integer value
 * @expose
 */

Integer.fromInt = function (value) {
  var obj, cachedObj;
  value = value | 0;

  if (value >= -128 && value < 128) {
    cachedObj = INT_CACHE[value];

    if (cachedObj) {
      return cachedObj;
    }
  }

  obj = new Integer(value, value < 0 ? -1 : 0, false);

  if (value >= -128 && value < 128) {
    INT_CACHE[value] = obj;
  }

  return obj;
};
/**
 * Returns a Integer representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @access private
 * @param {number} value The number in question
 * @returns {!Integer} The corresponding Integer value
 * @expose
 */


Integer.fromNumber = function (value) {
  if (isNaN(value) || !isFinite(value)) {
    return Integer.ZERO;
  }

  if (value <= -TWO_PWR_63_DBL) {
    return Integer.MIN_VALUE;
  }

  if (value + 1 >= TWO_PWR_63_DBL) {
    return Integer.MAX_VALUE;
  }

  if (value < 0) {
    return Integer.fromNumber(-value).negate();
  }

  return new Integer(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0);
};
/**
 * Returns a Integer representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @access private
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @returns {!Integer} The corresponding Integer value
 * @expose
 */


Integer.fromBits = function (lowBits, highBits) {
  return new Integer(lowBits, highBits);
};
/**
 * Returns a Integer representation of the given string, written using the specified radix.
 * @access private
 * @param {string} str The textual representation of the Integer
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Integer} The corresponding Integer value
 * @expose
 */


Integer.fromString = function (str, radix) {
  if (str.length === 0) {
    throw (0, _error.newError)('number format error: empty string');
  }

  if (str === 'NaN' || str === 'Infinity' || str === '+Infinity' || str === '-Infinity') {
    return Integer.ZERO;
  }

  radix = radix || 10;

  if (radix < 2 || radix > 36) {
    throw (0, _error.newError)('radix out of range: ' + radix);
  }

  var p;

  if ((p = str.indexOf('-')) > 0) {
    throw (0, _error.newError)('number format error: interior "-" character: ' + str);
  } else if (p === 0) {
    return Integer.fromString(str.substring(1), radix).negate();
  } // Do several (8) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.


  var radixToPower = Integer.fromNumber(Math.pow(radix, 8));
  var result = Integer.ZERO;

  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i);
    var value = parseInt(str.substring(i, i + size), radix);

    if (size < 8) {
      var power = Integer.fromNumber(Math.pow(radix, size));
      result = result.multiply(power).add(Integer.fromNumber(value));
    } else {
      result = result.multiply(radixToPower);
      result = result.add(Integer.fromNumber(value));
    }
  }

  return result;
};
/**
 * Converts the specified value to a Integer.
 * @access private
 * @param {!Integer|number|string|!{low: number, high: number}} val Value
 * @returns {!Integer}
 * @expose
 */


Integer.fromValue = function (val) {
  if (val
  /* is compatible */
  instanceof Integer) {
    return val;
  }

  if (typeof val === 'number') {
    return Integer.fromNumber(val);
  }

  if (typeof val === 'string') {
    return Integer.fromString(val);
  } // Throws for non-objects, converts non-instanceof Integer:


  return new Integer(val.low, val.high);
};
/**
 * Converts the specified value to a number.
 * @access private
 * @param {!Integer|number|string|!{low: number, high: number}} val Value
 * @returns {number}
 * @expose
 */


Integer.toNumber = function (val) {
  return Integer.fromValue(val).toNumber();
};
/**
 * Converts the specified value to a string.
 * @access private
 * @param {!Integer|number|string|!{low: number, high: number}} val Value
 * @param {number} radix optional radix for string conversion, defaults to 10
 * @returns {string}
 * @expose
 */


Integer.toString = function (val, radix) {
  return Integer.fromValue(val).toString(radix);
};
/**
 * Checks if the given value is in the safe range in order to be converted to a native number
 * @access private
 * @param {!Integer|number|string|!{low: number, high: number}} val Value
 * @param {number} radix optional radix for string conversion, defaults to 10
 * @returns {boolean}
 * @expose
 */


Integer.inSafeRange = function (val) {
  return Integer.fromValue(val).inSafeRange();
};
/**
 * @type {number}
 * @const
 * @inner
 * @private
 */


var TWO_PWR_16_DBL = 1 << 16;
/**
 * @type {number}
 * @const
 * @inner
 * @private
 */

var TWO_PWR_24_DBL = 1 << 24;
/**
 * @type {number}
 * @const
 * @inner
 * @private
 */

var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
/**
 * @type {number}
 * @const
 * @inner
 * @private
 */

var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
/**
 * @type {number}
 * @const
 * @inner
 * @private
 */

var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
/**
 * @type {!Integer}
 * @const
 * @inner
 * @private
 */

var TWO_PWR_24 = Integer.fromInt(TWO_PWR_24_DBL);
/**
 * Signed zero.
 * @type {!Integer}
 * @expose
 */

Integer.ZERO = Integer.fromInt(0);
/**
 * Signed one.
 * @type {!Integer}
 * @expose
 */

Integer.ONE = Integer.fromInt(1);
/**
 * Signed negative one.
 * @type {!Integer}
 * @expose
 */

Integer.NEG_ONE = Integer.fromInt(-1);
/**
 * Maximum signed value.
 * @type {!Integer}
 * @expose
 */

Integer.MAX_VALUE = Integer.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);
/**
 * Minimum signed value.
 * @type {!Integer}
 * @expose
 */

Integer.MIN_VALUE = Integer.fromBits(0, 0x80000000 | 0, false);
/**
 * Minimum safe value.
 * @type {!Integer}
 * @expose
 */

Integer.MIN_SAFE_VALUE = Integer.fromBits(0x1 | 0, 0xffffffffffe00000 | 0);
/**
 * Maximum safe value.
 * @type {!Integer}
 * @expose
 */

Integer.MAX_SAFE_VALUE = Integer.fromBits(0xffffffff | 0, 0x1fffff | 0);
/**
 * Cast value to Integer type.
 * @access public
 * @param {Mixed} value - The value to use.
 * @return {Integer} - An object of type Integer.
 */

var _int = Integer.fromValue;
/**
 * Check if a variable is of Integer type.
 * @access public
 * @param {Mixed} value - The variable to check.
 * @return {Boolean} - Is it of the Integer type?
 */

exports["int"] = _int;
var isInt = Integer.isInteger;
/**
 * Check if a variable can be safely converted to a number
 * @access public
 * @param {Mixed} value - The variable to check
 * @return {Boolean} - true if it is safe to call toNumber on variable otherwise false
 */

exports.isInt = isInt;
var inSafeRange = Integer.inSafeRange;
/**
 * Converts a variable to a number
 * @access public
 * @param {Mixed} value - The variable to convert
 * @return {number} - the variable as a number
 */

exports.inSafeRange = inSafeRange;
var toNumber = Integer.toNumber;
/**
 * Converts the integer to a string representation
 * @access public
 * @param {Mixed} value - The variable to convert
 * @param {number} radix - radix to use in string conversion, defaults to 10
 * @return {string} - returns a string representation of the integer
 */

exports.toNumber = toNumber;
var toString = Integer.toString;
exports.toString = toString;
var _default = Integer;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-util.js":
/*!**********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/bolt-protocol-util.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertDatabaseIsEmpty = assertDatabaseIsEmpty;
exports.assertTxConfigIsEmpty = assertTxConfigIsEmpty;

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {TxConfig} txConfig the auto-commit transaction configuration.
 * @param {Connection} connection the connection.
 * @param {ResultStreamObserver} observer the response observer.
 */
function assertTxConfigIsEmpty(txConfig, connection, observer) {
  if (txConfig && !txConfig.isEmpty()) {
    var error = (0, _error.newError)('Driver is connected to the database that does not support transaction configuration. ' + 'Please upgrade to neo4j 3.5.0 or later in order to use this functionality'); // unsupported API was used, consider this a fatal error for the current connection

    connection._handleFatalError(error);

    observer.onError(error);
    throw error;
  }
}
/**
 * Asserts that the passed-in database name is empty.
 * @param {string} database
 * @param {Connection} connection
 */


function assertDatabaseIsEmpty(database, connection, observer) {
  if (database) {
    var error = (0, _error.newError)('Driver is connected to the database that does not support multiple databases. ' + 'Please upgrade to neo4j 4.0.0 or later in order to use this functionality'); // unsupported API was used, consider this a fatal error for the current connection

    connection._handleFatalError(error);

    observer.onError(error);
    throw error;
  }
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v1.js":
/*!********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/bolt-protocol-v1.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _boltProtocolUtil = __webpack_require__(/*! ./bolt-protocol-util */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-util.js");

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

var _chunking = __webpack_require__(/*! ./chunking */ "./node_modules/neo4j-driver/lib/internal/chunking.js");

var _connection = _interopRequireDefault(__webpack_require__(/*! ./connection */ "./node_modules/neo4j-driver/lib/internal/connection.js"));

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

var v1 = _interopRequireWildcard(__webpack_require__(/*! ./packstream-v1 */ "./node_modules/neo4j-driver/lib/internal/packstream-v1.js"));

var _requestMessage = _interopRequireDefault(__webpack_require__(/*! ./request-message */ "./node_modules/neo4j-driver/lib/internal/request-message.js"));

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

var _txConfig = _interopRequireDefault(__webpack_require__(/*! ./tx-config */ "./node_modules/neo4j-driver/lib/internal/tx-config.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BoltProtocol = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Connection} connection the connection.
   * @param {Chunker} chunker the chunker.
   * @param {boolean} disableLosslessIntegers if this connection should convert all received integers to native JS numbers.
   */
  function BoltProtocol(connection, chunker, disableLosslessIntegers) {
    (0, _classCallCheck2["default"])(this, BoltProtocol);
    this._connection = connection;
    this._packer = this._createPacker(chunker);
    this._unpacker = this._createUnpacker(disableLosslessIntegers);
  }
  /**
   * Returns the numerical version identifier for this protocol
   */


  (0, _createClass2["default"])(BoltProtocol, [{
    key: "packer",

    /**
     * Get the packer.
     * @return {Packer} the protocol's packer.
     */
    value: function packer() {
      return this._packer;
    }
    /**
     * Get the unpacker.
     * @return {Unpacker} the protocol's unpacker.
     */

  }, {
    key: "unpacker",
    value: function unpacker() {
      return this._unpacker;
    }
    /**
     * Transform metadata received in SUCCESS message before it is passed to the handler.
     * @param {Object} metadata the received metadata.
     * @return {Object} transformed metadata.
     */

  }, {
    key: "transformMetadata",
    value: function transformMetadata(metadata) {
      return metadata;
    }
    /**
     * Perform initialization and authentication of the underlying connection.
     * @param {Object} param
     * @param {string} param.userAgent the user agent.
     * @param {Object} param.authToken the authentication token.
     * @param {function(err: Error)} param.onError the callback to invoke on error.
     * @param {function()} param.onComplete the callback to invoke on completion.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "initialize",
    value: function initialize() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          userAgent = _ref.userAgent,
          authToken = _ref.authToken,
          onError = _ref.onError,
          onComplete = _ref.onComplete;

      var observer = new _streamObservers.LoginObserver({
        connection: this._connection,
        afterError: onError,
        afterComplete: onComplete
      });

      this._connection.write(_requestMessage["default"].init(userAgent, authToken), observer, true);

      return observer;
    }
    /**
     * Perform protocol related operations for closing this connection
     */

  }, {
    key: "prepareToClose",
    value: function prepareToClose() {} // no need to notify the database in this protocol version

    /**
     * Begin an explicit transaction.
     * @param {Object} param
     * @param {Bookmark} param.bookmark the bookmark.
     * @param {TxConfig} param.txConfig the configuration.
     * @param {string} param.database the target database name.
     * @param {string} param.mode the access mode.
     * @param {function(err: Error)} param.beforeError the callback to invoke before handling the error.
     * @param {function(err: Error)} param.afterError the callback to invoke after handling the error.
     * @param {function()} param.beforeComplete the callback to invoke before handling the completion.
     * @param {function()} param.afterComplete the callback to invoke after handling the completion.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "beginTransaction",
    value: function beginTransaction() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          bookmark = _ref2.bookmark,
          txConfig = _ref2.txConfig,
          database = _ref2.database,
          mode = _ref2.mode,
          beforeError = _ref2.beforeError,
          afterError = _ref2.afterError,
          beforeComplete = _ref2.beforeComplete,
          afterComplete = _ref2.afterComplete;

      return this.run('BEGIN', bookmark ? bookmark.asBeginTransactionParameters() : {}, {
        bookmark: bookmark,
        txConfig: txConfig,
        database: database,
        mode: mode,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete,
        flush: false
      });
    }
    /**
     * Commit the explicit transaction.
     * @param {Object} param
     * @param {function(err: Error)} param.beforeError the callback to invoke before handling the error.
     * @param {function(err: Error)} param.afterError the callback to invoke after handling the error.
     * @param {function()} param.beforeComplete the callback to invoke before handling the completion.
     * @param {function()} param.afterComplete the callback to invoke after handling the completion.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "commitTransaction",
    value: function commitTransaction() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          beforeError = _ref3.beforeError,
          afterError = _ref3.afterError,
          beforeComplete = _ref3.beforeComplete,
          afterComplete = _ref3.afterComplete;

      // WRITE access mode is used as a place holder here, it has
      // no effect on behaviour for Bolt V1 & V2
      return this.run('COMMIT', {}, {
        bookmark: _bookmark["default"].empty(),
        txConfig: _txConfig["default"].empty(),
        mode: _constants.ACCESS_MODE_WRITE,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
    }
    /**
     * Rollback the explicit transaction.
     * @param {Object} param
     * @param {function(err: Error)} param.beforeError the callback to invoke before handling the error.
     * @param {function(err: Error)} param.afterError the callback to invoke after handling the error.
     * @param {function()} param.beforeComplete the callback to invoke before handling the completion.
     * @param {function()} param.afterComplete the callback to invoke after handling the completion.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "rollbackTransaction",
    value: function rollbackTransaction() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          beforeError = _ref4.beforeError,
          afterError = _ref4.afterError,
          beforeComplete = _ref4.beforeComplete,
          afterComplete = _ref4.afterComplete;

      // WRITE access mode is used as a place holder here, it has
      // no effect on behaviour for Bolt V1 & V2
      return this.run('ROLLBACK', {}, {
        bookmark: _bookmark["default"].empty(),
        txConfig: _txConfig["default"].empty(),
        mode: _constants.ACCESS_MODE_WRITE,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
    }
    /**
     * Send a Cypher query through the underlying connection.
     * @param {string} query the cypher query.
     * @param {Object} parameters the query parameters.
     * @param {Object} param
     * @param {Bookmark} param.bookmark the bookmark.
     * @param {TxConfig} param.txConfig the transaction configuration.
     * @param {string} param.database the target database name.
     * @param {string} param.mode the access mode.
     * @param {function(keys: string[])} param.beforeKeys the callback to invoke before handling the keys.
     * @param {function(keys: string[])} param.afterKeys the callback to invoke after handling the keys.
     * @param {function(err: Error)} param.beforeError the callback to invoke before handling the error.
     * @param {function(err: Error)} param.afterError the callback to invoke after handling the error.
     * @param {function()} param.beforeComplete the callback to invoke before handling the completion.
     * @param {function()} param.afterComplete the callback to invoke after handling the completion.
     * @param {boolean} param.flush whether to flush the buffered messages.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "run",
    value: function run(query, parameters) {
      var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          bookmark = _ref5.bookmark,
          txConfig = _ref5.txConfig,
          database = _ref5.database,
          mode = _ref5.mode,
          beforeKeys = _ref5.beforeKeys,
          afterKeys = _ref5.afterKeys,
          beforeError = _ref5.beforeError,
          afterError = _ref5.afterError,
          beforeComplete = _ref5.beforeComplete,
          afterComplete = _ref5.afterComplete,
          _ref5$flush = _ref5.flush,
          flush = _ref5$flush === void 0 ? true : _ref5$flush;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeKeys: beforeKeys,
        afterKeys: afterKeys,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      }); // bookmark and mode are ignored in this version of the protocol

      (0, _boltProtocolUtil.assertTxConfigIsEmpty)(txConfig, this._connection, observer); // passing in a database name on this protocol version throws an error

      (0, _boltProtocolUtil.assertDatabaseIsEmpty)(database, this._connection, observer);

      this._connection.write(_requestMessage["default"].run(query, parameters), observer, false);

      this._connection.write(_requestMessage["default"].pullAll(), observer, flush);

      return observer;
    }
    /**
     * Send a RESET through the underlying connection.
     * @param {Object} param
     * @param {function(err: Error)} param.onError the callback to invoke on error.
     * @param {function()} param.onComplete the callback to invoke on completion.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "reset",
    value: function reset() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          onError = _ref6.onError,
          onComplete = _ref6.onComplete;

      var observer = new _streamObservers.ResetObserver({
        connection: this._connection,
        onError: onError,
        onComplete: onComplete
      });

      this._connection.write(_requestMessage["default"].reset(), observer, true);

      return observer;
    }
  }, {
    key: "_createPacker",
    value: function _createPacker(chunker) {
      return new v1.Packer(chunker);
    }
  }, {
    key: "_createUnpacker",
    value: function _createUnpacker(disableLosslessIntegers) {
      return new v1.Unpacker(disableLosslessIntegers);
    }
  }, {
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V1;
    }
  }]);
  return BoltProtocol;
}();

exports["default"] = BoltProtocol;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v2.js":
/*!********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/bolt-protocol-v2.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _boltProtocolV = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v1 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v1.js"));

var v2 = _interopRequireWildcard(__webpack_require__(/*! ./packstream-v2 */ "./node_modules/neo4j-driver/lib/internal/packstream-v2.js"));

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var BoltProtocol = /*#__PURE__*/function (_BoltProtocolV) {
  (0, _inherits2["default"])(BoltProtocol, _BoltProtocolV);

  var _super = _createSuper(BoltProtocol);

  function BoltProtocol() {
    (0, _classCallCheck2["default"])(this, BoltProtocol);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(BoltProtocol, [{
    key: "_createPacker",
    value: function _createPacker(chunker) {
      return new v2.Packer(chunker);
    }
  }, {
    key: "_createUnpacker",
    value: function _createUnpacker(disableLosslessIntegers) {
      return new v2.Unpacker(disableLosslessIntegers);
    }
  }, {
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V2;
    }
  }]);
  return BoltProtocol;
}(_boltProtocolV["default"]);

exports["default"] = BoltProtocol;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v3.js":
/*!********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/bolt-protocol-v3.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _boltProtocolV = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v2 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v2.js"));

var _requestMessage = _interopRequireDefault(__webpack_require__(/*! ./request-message */ "./node_modules/neo4j-driver/lib/internal/request-message.js"));

var _boltProtocolUtil = __webpack_require__(/*! ./bolt-protocol-util */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-util.js");

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var noOpObserver = new _streamObservers.StreamObserver();

var BoltProtocol = /*#__PURE__*/function (_BoltProtocolV) {
  (0, _inherits2["default"])(BoltProtocol, _BoltProtocolV);

  var _super = _createSuper(BoltProtocol);

  function BoltProtocol() {
    (0, _classCallCheck2["default"])(this, BoltProtocol);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(BoltProtocol, [{
    key: "transformMetadata",
    value: function transformMetadata(metadata) {
      if ('t_first' in metadata) {
        // Bolt V3 uses shorter key 't_first' to represent 'result_available_after'
        // adjust the key to be the same as in Bolt V1 so that ResultSummary can retrieve the value
        metadata.result_available_after = metadata.t_first;
        delete metadata.t_first;
      }

      if ('t_last' in metadata) {
        // Bolt V3 uses shorter key 't_last' to represent 'result_consumed_after'
        // adjust the key to be the same as in Bolt V1 so that ResultSummary can retrieve the value
        metadata.result_consumed_after = metadata.t_last;
        delete metadata.t_last;
      }

      return metadata;
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          userAgent = _ref.userAgent,
          authToken = _ref.authToken,
          onError = _ref.onError,
          onComplete = _ref.onComplete;

      var observer = new _streamObservers.LoginObserver({
        connection: this._connection,
        afterError: onError,
        afterComplete: onComplete
      });

      this._connection.write(_requestMessage["default"].hello(userAgent, authToken), observer, true);

      return observer;
    }
  }, {
    key: "prepareToClose",
    value: function prepareToClose() {
      this._connection.write(_requestMessage["default"].goodbye(), noOpObserver, true);
    }
  }, {
    key: "beginTransaction",
    value: function beginTransaction() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          bookmark = _ref2.bookmark,
          txConfig = _ref2.txConfig,
          database = _ref2.database,
          mode = _ref2.mode,
          beforeError = _ref2.beforeError,
          afterError = _ref2.afterError,
          beforeComplete = _ref2.beforeComplete,
          afterComplete = _ref2.afterComplete;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
      observer.prepareToHandleSingleResponse(); // passing in a database name on this protocol version throws an error

      (0, _boltProtocolUtil.assertDatabaseIsEmpty)(database, this._connection, observer);

      this._connection.write(_requestMessage["default"].begin({
        bookmark: bookmark,
        txConfig: txConfig,
        mode: mode
      }), observer, true);

      return observer;
    }
  }, {
    key: "commitTransaction",
    value: function commitTransaction() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          beforeError = _ref3.beforeError,
          afterError = _ref3.afterError,
          beforeComplete = _ref3.beforeComplete,
          afterComplete = _ref3.afterComplete;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
      observer.prepareToHandleSingleResponse();

      this._connection.write(_requestMessage["default"].commit(), observer, true);

      return observer;
    }
  }, {
    key: "rollbackTransaction",
    value: function rollbackTransaction() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          beforeError = _ref4.beforeError,
          afterError = _ref4.afterError,
          beforeComplete = _ref4.beforeComplete,
          afterComplete = _ref4.afterComplete;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
      observer.prepareToHandleSingleResponse();

      this._connection.write(_requestMessage["default"].rollback(), observer, true);

      return observer;
    }
  }, {
    key: "run",
    value: function run(query, parameters) {
      var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          bookmark = _ref5.bookmark,
          txConfig = _ref5.txConfig,
          database = _ref5.database,
          mode = _ref5.mode,
          beforeKeys = _ref5.beforeKeys,
          afterKeys = _ref5.afterKeys,
          beforeError = _ref5.beforeError,
          afterError = _ref5.afterError,
          beforeComplete = _ref5.beforeComplete,
          afterComplete = _ref5.afterComplete,
          _ref5$flush = _ref5.flush,
          flush = _ref5$flush === void 0 ? true : _ref5$flush;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeKeys: beforeKeys,
        afterKeys: afterKeys,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      }); // passing in a database name on this protocol version throws an error

      (0, _boltProtocolUtil.assertDatabaseIsEmpty)(database, this._connection, observer);

      this._connection.write(_requestMessage["default"].runWithMetadata(query, parameters, {
        bookmark: bookmark,
        txConfig: txConfig,
        mode: mode
      }), observer, false);

      this._connection.write(_requestMessage["default"].pullAll(), observer, flush);

      return observer;
    }
  }, {
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V3;
    }
  }]);
  return BoltProtocol;
}(_boltProtocolV["default"]);

exports["default"] = BoltProtocol;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v4x0.js":
/*!**********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/bolt-protocol-v4x0.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _boltProtocolV = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v3 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v3.js"));

var _requestMessage = _interopRequireWildcard(__webpack_require__(/*! ./request-message */ "./node_modules/neo4j-driver/lib/internal/request-message.js"));

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var BoltProtocol = /*#__PURE__*/function (_BoltProtocolV) {
  (0, _inherits2["default"])(BoltProtocol, _BoltProtocolV);

  var _super = _createSuper(BoltProtocol);

  function BoltProtocol() {
    (0, _classCallCheck2["default"])(this, BoltProtocol);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(BoltProtocol, [{
    key: "beginTransaction",
    value: function beginTransaction() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          bookmark = _ref.bookmark,
          txConfig = _ref.txConfig,
          database = _ref.database,
          mode = _ref.mode,
          beforeError = _ref.beforeError,
          afterError = _ref.afterError,
          beforeComplete = _ref.beforeComplete,
          afterComplete = _ref.afterComplete;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
      observer.prepareToHandleSingleResponse();

      this._connection.write(_requestMessage["default"].begin({
        bookmark: bookmark,
        txConfig: txConfig,
        database: database,
        mode: mode
      }), observer, true);

      return observer;
    }
  }, {
    key: "run",
    value: function run(query, parameters) {
      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          bookmark = _ref2.bookmark,
          txConfig = _ref2.txConfig,
          database = _ref2.database,
          mode = _ref2.mode,
          beforeKeys = _ref2.beforeKeys,
          afterKeys = _ref2.afterKeys,
          beforeError = _ref2.beforeError,
          afterError = _ref2.afterError,
          beforeComplete = _ref2.beforeComplete,
          afterComplete = _ref2.afterComplete,
          _ref2$flush = _ref2.flush,
          flush = _ref2$flush === void 0 ? true : _ref2$flush,
          _ref2$reactive = _ref2.reactive,
          reactive = _ref2$reactive === void 0 ? false : _ref2$reactive,
          _ref2$fetchSize = _ref2.fetchSize,
          fetchSize = _ref2$fetchSize === void 0 ? _requestMessage.ALL : _ref2$fetchSize;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        reactive: reactive,
        fetchSize: fetchSize,
        moreFunction: this._requestMore,
        discardFunction: this._requestDiscard,
        beforeKeys: beforeKeys,
        afterKeys: afterKeys,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
      var flushRun = reactive;

      this._connection.write(_requestMessage["default"].runWithMetadata(query, parameters, {
        bookmark: bookmark,
        txConfig: txConfig,
        database: database,
        mode: mode
      }), observer, flushRun && flush);

      if (!reactive) {
        this._connection.write(_requestMessage["default"].pull({
          n: fetchSize
        }), observer, flush);
      }

      return observer;
    }
  }, {
    key: "_requestMore",
    value: function _requestMore(connection, stmtId, n, observer) {
      connection.write(_requestMessage["default"].pull({
        stmtId: stmtId,
        n: n
      }), observer, true);
    }
  }, {
    key: "_requestDiscard",
    value: function _requestDiscard(connection, stmtId, observer) {
      connection.write(_requestMessage["default"].discard({
        stmtId: stmtId
      }), observer, true);
    }
  }, {
    key: "_noOp",
    value: function _noOp() {}
  }, {
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V4_0;
    }
  }]);
  return BoltProtocol;
}(_boltProtocolV["default"]);

exports["default"] = BoltProtocol;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v4x1.js":
/*!**********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/bolt-protocol-v4x1.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _boltProtocolV4x = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v4x0 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v4x0.js"));

var _requestMessage = _interopRequireWildcard(__webpack_require__(/*! ./request-message */ "./node_modules/neo4j-driver/lib/internal/request-message.js"));

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var BoltProtocol = /*#__PURE__*/function (_BoltProtocolV) {
  (0, _inherits2["default"])(BoltProtocol, _BoltProtocolV);

  var _super = _createSuper(BoltProtocol);

  /**
   * @constructor
   * @param {Connection} connection the connection.
   * @param {Chunker} chunker the chunker.
   * @param {boolean} disableLosslessIntegers if this connection should convert all received integers to native JS numbers.
   * @param {Object} serversideRouting
   */
  function BoltProtocol(connection, chunker, disableLosslessIntegers, serversideRouting) {
    var _this;

    (0, _classCallCheck2["default"])(this, BoltProtocol);
    _this = _super.call(this, connection, chunker, disableLosslessIntegers);
    _this._serversideRouting = serversideRouting;
    return _this;
  }

  (0, _createClass2["default"])(BoltProtocol, [{
    key: "initialize",
    value: function initialize() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          userAgent = _ref.userAgent,
          authToken = _ref.authToken,
          onError = _ref.onError,
          onComplete = _ref.onComplete;

      var observer = new _streamObservers.LoginObserver({
        connection: this._connection,
        afterError: onError,
        afterComplete: onComplete
      });

      this._connection.write(_requestMessage["default"].hello(userAgent, authToken, this._serversideRouting), observer, true);

      return observer;
    }
  }, {
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V4_1;
    }
  }]);
  return BoltProtocol;
}(_boltProtocolV4x["default"]);

exports["default"] = BoltProtocol;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/bookmark.js":
/*!************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/bookmark.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BOOKMARKS_KEY = 'bookmarks';

var Bookmark = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {string|string[]} values single bookmark as string or multiple bookmarks as a string array.
   */
  function Bookmark(values) {
    (0, _classCallCheck2["default"])(this, Bookmark);
    this._values = asStringArray(values);
  }

  (0, _createClass2["default"])(Bookmark, [{
    key: "isEmpty",

    /**
     * Check if the given bookmark is meaningful and can be send to the database.
     * @return {boolean} returns `true` bookmark has a value, `false` otherwise.
     */
    value: function isEmpty() {
      return this._values.length === 0;
    }
    /**
     * Get all bookmark values as an array.
     * @return {string[]} all values.
     */

  }, {
    key: "values",
    value: function values() {
      return this._values;
    }
    /**
     * Get this bookmark as an object for begin transaction call.
     * @return {Object} the value of this bookmark as object.
     */

  }, {
    key: "asBeginTransactionParameters",
    value: function asBeginTransactionParameters() {
      if (this.isEmpty()) {
        return {};
      } // Driver sends {bookmark: "max", bookmarks: ["one", "two", "max"]} instead of simple
      // {bookmarks: ["one", "two", "max"]} for backwards compatibility reasons. Old servers can only accept single
      // bookmark that is why driver has to parse and compare given list of bookmarks. This functionality will
      // eventually be removed.


      return (0, _defineProperty2["default"])({}, BOOKMARKS_KEY, this._values);
    }
  }], [{
    key: "empty",
    value: function empty() {
      return EMPTY_BOOKMARK;
    }
  }]);
  return Bookmark;
}();

exports["default"] = Bookmark;
var EMPTY_BOOKMARK = new Bookmark(null);
/**
 * Converts given value to an array.
 * @param {string|string[]|Array} [value=undefined] argument to convert.
 * @return {string[]} value converted to an array.
 */

function asStringArray(value) {
  if (!value) {
    return [];
  }

  if (util.isString(value)) {
    return [value];
  }

  if (Array.isArray(value)) {
    var result = [];
    var flattenedValue = flattenArray(value);

    for (var i = 0; i < flattenedValue.length; i++) {
      var element = flattenedValue[i]; // if it is undefined or null, ignore it

      if (element !== undefined && element !== null) {
        if (!util.isString(element)) {
          throw new TypeError("Bookmark value should be a string, given: '".concat(element, "'"));
        }

        result.push(element);
      }
    }

    return result;
  }

  throw new TypeError("Bookmark should either be a string or a string array, given: '".concat(value, "'"));
}
/**
 * Recursively flattens an array so that the result becomes a single array
 * of values, which does not include any sub-arrays
 *
 * @param {Array} value
 */


function flattenArray(values) {
  return values.reduce(function (dest, value) {
    return Array.isArray(value) ? dest.concat(flattenArray(value)) : dest.concat(value);
  }, []);
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/browser/browser-buf.js":
/*!***********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/browser/browser-buf.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _baseBuf = _interopRequireDefault(__webpack_require__(/*! ../buf/base-buf */ "./node_modules/neo4j-driver/lib/internal/buf/base-buf.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var HeapBuffer = /*#__PURE__*/function (_BaseBuffer) {
  (0, _inherits2["default"])(HeapBuffer, _BaseBuffer);

  var _super = _createSuper(HeapBuffer);

  function HeapBuffer(arg) {
    var _this;

    (0, _classCallCheck2["default"])(this, HeapBuffer);
    var buffer = arg instanceof ArrayBuffer ? arg : new ArrayBuffer(arg);
    _this = _super.call(this, buffer.byteLength);
    _this._buffer = buffer;
    _this._view = new DataView(_this._buffer);
    return _this;
  }

  (0, _createClass2["default"])(HeapBuffer, [{
    key: "putUInt8",
    value: function putUInt8(position, val) {
      this._view.setUint8(position, val);
    }
  }, {
    key: "getUInt8",
    value: function getUInt8(position) {
      return this._view.getUint8(position);
    }
  }, {
    key: "putInt8",
    value: function putInt8(position, val) {
      this._view.setInt8(position, val);
    }
  }, {
    key: "getInt8",
    value: function getInt8(position) {
      return this._view.getInt8(position);
    }
  }, {
    key: "getFloat64",
    value: function getFloat64(position) {
      return this._view.getFloat64(position);
    }
  }, {
    key: "putFloat64",
    value: function putFloat64(position, val) {
      this._view.setFloat64(position, val);
    }
  }, {
    key: "getSlice",
    value: function getSlice(start, length) {
      if (this._buffer.slice) {
        return new HeapBuffer(this._buffer.slice(start, start + length));
      } else {
        // Some platforms (eg. phantomjs) don't support slice, so fall back to a copy
        // We do this rather than return a SliceBuffer, because sliceBuffer cannot
        // be passed to native network write ops etc - we need ArrayBuffer for that
        var copy = new HeapBuffer(length);

        for (var i = 0; i < length; i++) {
          copy.putUInt8(i, this.getUInt8(i + start));
        }

        return copy;
      }
    }
    /**
     * Specific to HeapBuffer, this gets a DataView from the
     * current position and of the specified length.
     */

  }, {
    key: "readView",
    value: function readView(length) {
      return new DataView(this._buffer, this._updatePos(length), length);
    }
  }]);
  return HeapBuffer;
}(_baseBuf["default"]);

exports["default"] = HeapBuffer;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/browser/browser-channel.js":
/*!***************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/browser/browser-channel.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _browserBuf = _interopRequireDefault(__webpack_require__(/*! ./browser-buf */ "./node_modules/neo4j-driver/lib/internal/browser/browser-buf.js"));

var _error = __webpack_require__(/*! ../../error */ "./node_modules/neo4j-driver/lib/error.js");

var _util = __webpack_require__(/*! ../util */ "./node_modules/neo4j-driver/lib/internal/util.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Just to be sure that these values are with us even after WebSocket is injected
// for tests.
var WS_CONNECTING = 0;
var WS_OPEN = 1;
var WS_CLOSING = 2;
var WS_CLOSED = 3;
/**
 * Create a new WebSocketChannel to be used in web browsers.
 * @access private
 */

var WebSocketChannel = /*#__PURE__*/function () {
  /**
   * Create new instance
   * @param {ChannelConfig} config - configuration for this channel.
   * @param {function(): string} protocolSupplier - function that detects protocol of the web page. Should only be used in tests.
   */
  function WebSocketChannel(config) {
    var protocolSupplier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : detectWebPageProtocol;
    var socketFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (url) {
      return new WebSocket(url);
    };
    (0, _classCallCheck2["default"])(this, WebSocketChannel);
    this._open = true;
    this._pending = [];
    this._error = null;
    this._handleConnectionError = this._handleConnectionError.bind(this);
    this._config = config;

    var _determineWebSocketSc = determineWebSocketScheme(config, protocolSupplier),
        scheme = _determineWebSocketSc.scheme,
        error = _determineWebSocketSc.error;

    if (error) {
      this._error = error;
      return;
    }

    this._ws = createWebSocket(scheme, config.address, socketFactory);
    this._ws.binaryType = 'arraybuffer';
    var self = this; // All connection errors are not sent to the error handler
    // we must also check for dirty close calls

    this._ws.onclose = function (e) {
      if (e && !e.wasClean) {
        self._handleConnectionError();
      }
    };

    this._ws.onopen = function () {
      // Connected! Cancel the connection timeout
      self._clearConnectionTimeout(); // Drain all pending messages


      var pending = self._pending;
      self._pending = null;

      for (var i = 0; i < pending.length; i++) {
        self.write(pending[i]);
      }
    };

    this._ws.onmessage = function (event) {
      if (self.onmessage) {
        var b = new _browserBuf["default"](event.data);
        self.onmessage(b);
      }
    };

    this._ws.onerror = this._handleConnectionError;
    this._connectionTimeoutFired = false;
    this._connectionTimeoutId = this._setupConnectionTimeout();
  }

  (0, _createClass2["default"])(WebSocketChannel, [{
    key: "_handleConnectionError",
    value: function _handleConnectionError() {
      if (this._connectionTimeoutFired) {
        // timeout fired - not connected within configured time
        this._error = (0, _error.newError)("Failed to establish connection in ".concat(this._config.connectionTimeout, "ms"), this._config.connectionErrorCode);

        if (this.onerror) {
          this.onerror(this._error);
        }

        return;
      } // onerror triggers on websocket close as well.. don't get me started.


      if (this._open) {
        // http://stackoverflow.com/questions/25779831/how-to-catch-websocket-connection-to-ws-xxxnn-failed-connection-closed-be
        this._error = (0, _error.newError)('WebSocket connection failure. Due to security ' + 'constraints in your web browser, the reason for the failure is not available ' + 'to this Neo4j Driver. Please use your browsers development console to determine ' + 'the root cause of the failure. Common reasons include the database being ' + 'unavailable, using the wrong connection URL or temporary network problems. ' + 'If you have enabled encryption, ensure your browser is configured to trust the ' + 'certificate Neo4j is configured to use. WebSocket `readyState` is: ' + this._ws.readyState, this._config.connectionErrorCode);

        if (this.onerror) {
          this.onerror(this._error);
        }
      }
    }
    /**
     * Write the passed in buffer to connection
     * @param {HeapBuffer} buffer - Buffer to write
     */

  }, {
    key: "write",
    value: function write(buffer) {
      // If there is a pending queue, push this on that queue. This means
      // we are not yet connected, so we queue things locally.
      if (this._pending !== null) {
        this._pending.push(buffer);
      } else if (buffer instanceof _browserBuf["default"]) {
        try {
          this._ws.send(buffer._buffer);
        } catch (error) {
          if (this._ws.readyState !== WS_OPEN) {
            // Websocket has been closed
            this._handleConnectionError();
          } else {
            // Some other error occured
            throw error;
          }
        }
      } else {
        throw (0, _error.newError)("Don't know how to send buffer: " + buffer);
      }
    }
    /**
     * Close the connection
     * @returns {Promise} A promise that will be resolved after channel is closed
     */

  }, {
    key: "close",
    value: function close() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (_this._ws && _this._ws.readyState !== WS_CLOSED) {
          _this._open = false;

          _this._clearConnectionTimeout();

          _this._ws.onclose = function () {
            return resolve();
          };

          _this._ws.close();
        } else {
          resolve();
        }
      });
    }
    /**
     * Set connection timeout on the given WebSocket, if configured.
     * @return {number} the timeout id or null.
     * @private
     */

  }, {
    key: "_setupConnectionTimeout",
    value: function _setupConnectionTimeout() {
      var _this2 = this;

      var timeout = this._config.connectionTimeout;

      if (timeout) {
        var webSocket = this._ws;
        return setTimeout(function () {
          if (webSocket.readyState !== WS_OPEN) {
            _this2._connectionTimeoutFired = true;
            webSocket.close();
          }
        }, timeout);
      }

      return null;
    }
    /**
     * Remove active connection timeout, if any.
     * @private
     */

  }, {
    key: "_clearConnectionTimeout",
    value: function _clearConnectionTimeout() {
      var timeoutId = this._connectionTimeoutId;

      if (timeoutId || timeoutId === 0) {
        this._connectionTimeoutFired = false;
        this._connectionTimeoutId = null;
        clearTimeout(timeoutId);
      }
    }
  }]);
  return WebSocketChannel;
}();

exports["default"] = WebSocketChannel;

function createWebSocket(scheme, address, socketFactory) {
  var url = scheme + '://' + address.asHostPort();

  try {
    return socketFactory(url);
  } catch (error) {
    if (isIPv6AddressIssueOnWindows(error, address)) {
      // WebSocket in IE and Edge browsers on Windows do not support regular IPv6 address syntax because they contain ':'.
      // It's an invalid character for UNC (https://en.wikipedia.org/wiki/IPv6_address#Literal_IPv6_addresses_in_UNC_path_names)
      // and Windows requires IPv6 to be changes in the following way:
      //   1) replace all ':' with '-'
      //   2) replace '%' with 's' for link-local address
      //   3) append '.ipv6-literal.net' suffix
      // only then resulting string can be considered a valid IPv6 address. Yes, this is extremely weird!
      // For more details see:
      //   https://social.msdn.microsoft.com/Forums/ie/en-US/06cca73b-63c2-4bf9-899b-b229c50449ff/whether-ie10-websocket-support-ipv6?forum=iewebdevelopment
      //   https://www.itdojo.com/ipv6-addresses-and-unc-path-names-overcoming-illegal/
      // Creation of WebSocket with unconverted address results in SyntaxError without message or stacktrace.
      // That is why here we "catch" SyntaxError and rewrite IPv6 address if needed.
      var windowsFriendlyUrl = asWindowsFriendlyIPv6Address(scheme, address);
      return socketFactory(windowsFriendlyUrl);
    } else {
      throw error;
    }
  }
}

function isIPv6AddressIssueOnWindows(error, address) {
  return error.name === 'SyntaxError' && isIPv6Address(address.asHostPort());
}

function isIPv6Address(hostAndPort) {
  return hostAndPort.charAt(0) === '[' && hostAndPort.indexOf(']') !== -1;
}

function asWindowsFriendlyIPv6Address(scheme, address) {
  // replace all ':' with '-'
  var hostWithoutColons = address.host().replace(new RegExp(':', 'g'), '-'); // replace '%' with 's' for link-local IPv6 address like 'fe80::1%lo0'

  var hostWithoutPercent = hostWithoutColons.replace('%', 's'); // append magic '.ipv6-literal.net' suffix

  var ipv6Host = hostWithoutPercent + '.ipv6-literal.net';
  return "".concat(scheme, "://").concat(ipv6Host, ":").concat(address.port());
}
/**
 * @param {ChannelConfig} config - configuration for the channel.
 * @param {function(): string} protocolSupplier - function that detects protocol of the web page.
 * @return {{scheme: string|null, error: Neo4jError|null}} object containing either scheme or error.
 */


function determineWebSocketScheme(config, protocolSupplier) {
  var encryptionOn = isEncryptionExplicitlyTurnedOn(config);
  var encryptionOff = isEncryptionExplicitlyTurnedOff(config);
  var trust = config.trust;
  var secureProtocol = isProtocolSecure(protocolSupplier);
  verifyEncryptionSettings(encryptionOn, encryptionOff, secureProtocol);

  if (encryptionOff) {
    // encryption explicitly turned off in the config
    return {
      scheme: 'ws',
      error: null
    };
  }

  if (secureProtocol) {
    // driver is used in a secure https web page, use 'wss'
    return {
      scheme: 'wss',
      error: null
    };
  }

  if (encryptionOn) {
    // encryption explicitly requested in the config
    if (!trust || trust === 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES') {
      // trust strategy not specified or the only supported strategy is specified
      return {
        scheme: 'wss',
        error: null
      };
    } else {
      var error = (0, _error.newError)('The browser version of this driver only supports one trust ' + "strategy, 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES'. " + trust + ' is not supported. Please ' + 'either use TRUST_SYSTEM_CA_SIGNED_CERTIFICATES or disable encryption by setting ' + '`encrypted:"' + _util.ENCRYPTION_OFF + '"` in the driver configuration.');
      return {
        scheme: null,
        error: error
      };
    }
  } // default to unencrypted web socket


  return {
    scheme: 'ws',
    error: null
  };
}
/**
 * @param {ChannelConfig} config - configuration for the channel.
 * @return {boolean} `true` if encryption enabled in the config, `false` otherwise.
 */


function isEncryptionExplicitlyTurnedOn(config) {
  return config.encrypted === true || config.encrypted === _util.ENCRYPTION_ON;
}
/**
 * @param {ChannelConfig} config - configuration for the channel.
 * @return {boolean} `true` if encryption disabled in the config, `false` otherwise.
 */


function isEncryptionExplicitlyTurnedOff(config) {
  return config.encrypted === false || config.encrypted === _util.ENCRYPTION_OFF;
}
/**
 * @param {function(): string} protocolSupplier - function that detects protocol of the web page.
 * @return {boolean} `true` if protocol returned by the given function is secure, `false` otherwise.
 */


function isProtocolSecure(protocolSupplier) {
  var protocol = typeof protocolSupplier === 'function' ? protocolSupplier() : '';
  return protocol && protocol.toLowerCase().indexOf('https') >= 0;
}

function verifyEncryptionSettings(encryptionOn, encryptionOff, secureProtocol) {
  if (encryptionOn && !secureProtocol) {
    // encryption explicitly turned on for a driver used on a HTTP web page
    console.warn('Neo4j driver is configured to use secure WebSocket on a HTTP web page. ' + 'WebSockets might not work in a mixed content environment. ' + 'Please consider configuring driver to not use encryption.');
  } else if (encryptionOff && secureProtocol) {
    // encryption explicitly turned off for a driver used on a HTTPS web page
    console.warn('Neo4j driver is configured to use insecure WebSocket on a HTTPS web page. ' + 'WebSockets might not work in a mixed content environment. ' + 'Please consider configuring driver to use encryption.');
  }
}

function detectWebPageProtocol() {
  return typeof window !== 'undefined' && window.location ? window.location.protocol : null;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/browser/browser-host-name-resolver.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/browser/browser-host-name-resolver.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _baseHostNameResolver = _interopRequireDefault(__webpack_require__(/*! ../resolver/base-host-name-resolver */ "./node_modules/neo4j-driver/lib/internal/resolver/base-host-name-resolver.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var BrowserHostNameResolver = /*#__PURE__*/function (_BaseHostNameResolver) {
  (0, _inherits2["default"])(BrowserHostNameResolver, _BaseHostNameResolver);

  var _super = _createSuper(BrowserHostNameResolver);

  function BrowserHostNameResolver() {
    (0, _classCallCheck2["default"])(this, BrowserHostNameResolver);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(BrowserHostNameResolver, [{
    key: "resolve",
    value: function resolve(address) {
      return this._resolveToItself(address);
    }
  }]);
  return BrowserHostNameResolver;
}(_baseHostNameResolver["default"]);

exports["default"] = BrowserHostNameResolver;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/browser/browser-utf8.js":
/*!************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/browser/browser-utf8.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _browserBuf = _interopRequireDefault(__webpack_require__(/*! ../browser/browser-buf */ "./node_modules/neo4j-driver/lib/internal/browser/browser-buf.js"));

var _textEncodingUtf = __webpack_require__(/*! text-encoding-utf-8 */ "./node_modules/text-encoding-utf-8/lib/encoding.lib.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var encoder = new _textEncodingUtf.TextEncoder('utf-8');
var decoder = new _textEncodingUtf.TextDecoder('utf-8');

function encode(str) {
  return new _browserBuf["default"](encoder.encode(str).buffer);
}

function decode(buffer, length) {
  if (buffer instanceof _browserBuf["default"]) {
    return decoder.decode(buffer.readView(Math.min(length, buffer.length - buffer.position)));
  } else {
    // Copy the given buffer into a regular buffer and decode that
    var tmpBuf = new _browserBuf["default"](length);

    for (var i = 0; i < length; i++) {
      tmpBuf.writeUInt8(buffer.readUInt8());
    }

    tmpBuf.reset();
    return decoder.decode(tmpBuf.readView(length));
  }
}

var _default = {
  encode: encode,
  decode: decode
};
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/browser/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/browser/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utf8 = exports.HostNameResolver = exports.Channel = exports.alloc = void 0;

var _browserBuf = _interopRequireDefault(__webpack_require__(/*! ./browser-buf */ "./node_modules/neo4j-driver/lib/internal/browser/browser-buf.js"));

var _browserChannel = _interopRequireDefault(__webpack_require__(/*! ./browser-channel */ "./node_modules/neo4j-driver/lib/internal/browser/browser-channel.js"));

var _browserHostNameResolver = _interopRequireDefault(__webpack_require__(/*! ./browser-host-name-resolver */ "./node_modules/neo4j-driver/lib/internal/browser/browser-host-name-resolver.js"));

var _browserUtf = _interopRequireDefault(__webpack_require__(/*! ./browser-utf8 */ "./node_modules/neo4j-driver/lib/internal/browser/browser-utf8.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*

This module exports a set of components to be used in browser environment.
They are not compatible with NodeJS environment.
All files import/require APIs from `node/index.js` by default.
Such imports are replaced at build time with `browser/index.js` when building a browser bundle.

NOTE: exports in this module should have exactly the same names/structure as exports in `node/index.js`.

 */
var alloc = function alloc(arg) {
  return new _browserBuf["default"](arg);
};

exports.alloc = alloc;
var Channel = _browserChannel["default"];
exports.Channel = Channel;
var HostNameResolver = _browserHostNameResolver["default"];
exports.HostNameResolver = HostNameResolver;
var utf8 = _browserUtf["default"];
exports.utf8 = utf8;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/buf/base-buf.js":
/*!****************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/buf/base-buf.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Common base with default implementation for most buffer methods.
 * Buffers are stateful - they track a current "position", this helps greatly
 * when reading and writing from them incrementally. You can also ignore the
 * stateful read/write methods.
 * readXXX and writeXXX-methods move the inner position of the buffer.
 * putXXX and getXXX-methods do not.
 * @access private
 */
var BaseBuffer = /*#__PURE__*/function () {
  /**
   * Create a instance with the injected size.
   * @constructor
   * @param {Integer} size
   */
  function BaseBuffer(size) {
    (0, _classCallCheck2["default"])(this, BaseBuffer);
    this.position = 0;
    this.length = size;
  }

  (0, _createClass2["default"])(BaseBuffer, [{
    key: "getUInt8",
    value: function getUInt8(position) {
      throw new Error('Not implemented');
    }
  }, {
    key: "getInt8",
    value: function getInt8(position) {
      throw new Error('Not implemented');
    }
  }, {
    key: "getFloat64",
    value: function getFloat64(position) {
      throw new Error('Not implemented');
    }
  }, {
    key: "putUInt8",
    value: function putUInt8(position, val) {
      throw new Error('Not implemented');
    }
  }, {
    key: "putInt8",
    value: function putInt8(position, val) {
      throw new Error('Not implemented');
    }
  }, {
    key: "putFloat64",
    value: function putFloat64(position, val) {
      throw new Error('Not implemented');
    }
    /**
     * @param p
     */

  }, {
    key: "getInt16",
    value: function getInt16(p) {
      return this.getInt8(p) << 8 | this.getUInt8(p + 1);
    }
    /**
     * @param p
     */

  }, {
    key: "getUInt16",
    value: function getUInt16(p) {
      return this.getUInt8(p) << 8 | this.getUInt8(p + 1);
    }
    /**
     * @param p
     */

  }, {
    key: "getInt32",
    value: function getInt32(p) {
      return this.getInt8(p) << 24 | this.getUInt8(p + 1) << 16 | this.getUInt8(p + 2) << 8 | this.getUInt8(p + 3);
    }
    /**
     * @param p
     */

  }, {
    key: "getUInt32",
    value: function getUInt32(p) {
      return this.getUInt8(p) << 24 | this.getUInt8(p + 1) << 16 | this.getUInt8(p + 2) << 8 | this.getUInt8(p + 3);
    }
    /**
     * @param p
     */

  }, {
    key: "getInt64",
    value: function getInt64(p) {
      return this.getInt8(p) << 56 | this.getUInt8(p + 1) << 48 | this.getUInt8(p + 2) << 40 | this.getUInt8(p + 3) << 32 | this.getUInt8(p + 4) << 24 | this.getUInt8(p + 5) << 16 | this.getUInt8(p + 6) << 8 | this.getUInt8(p + 7);
    }
    /**
     * Get a slice of this buffer. This method does not copy any data,
     * but simply provides a slice view of this buffer
     * @param start
     * @param length
     */

  }, {
    key: "getSlice",
    value: function getSlice(start, length) {
      return new SliceBuffer(start, length, this);
    }
    /**
     * @param p
     * @param val
     */

  }, {
    key: "putInt16",
    value: function putInt16(p, val) {
      this.putInt8(p, val >> 8);
      this.putUInt8(p + 1, val & 0xff);
    }
    /**
     * @param p
     * @param val
     */

  }, {
    key: "putUInt16",
    value: function putUInt16(p, val) {
      this.putUInt8(p, val >> 8 & 0xff);
      this.putUInt8(p + 1, val & 0xff);
    }
    /**
     * @param p
     * @param val
     */

  }, {
    key: "putInt32",
    value: function putInt32(p, val) {
      this.putInt8(p, val >> 24);
      this.putUInt8(p + 1, val >> 16 & 0xff);
      this.putUInt8(p + 2, val >> 8 & 0xff);
      this.putUInt8(p + 3, val & 0xff);
    }
    /**
     * @param p
     * @param val
     */

  }, {
    key: "putUInt32",
    value: function putUInt32(p, val) {
      this.putUInt8(p, val >> 24 & 0xff);
      this.putUInt8(p + 1, val >> 16 & 0xff);
      this.putUInt8(p + 2, val >> 8 & 0xff);
      this.putUInt8(p + 3, val & 0xff);
    }
    /**
     * @param p
     * @param val
     */

  }, {
    key: "putInt64",
    value: function putInt64(p, val) {
      this.putInt8(p, val >> 48);
      this.putUInt8(p + 1, val >> 42 & 0xff);
      this.putUInt8(p + 2, val >> 36 & 0xff);
      this.putUInt8(p + 3, val >> 30 & 0xff);
      this.putUInt8(p + 4, val >> 24 & 0xff);
      this.putUInt8(p + 5, val >> 16 & 0xff);
      this.putUInt8(p + 6, val >> 8 & 0xff);
      this.putUInt8(p + 7, val & 0xff);
    }
    /**
     * @param position
     * @param other
     */

  }, {
    key: "putBytes",
    value: function putBytes(position, other) {
      for (var i = 0, end = other.remaining(); i < end; i++) {
        this.putUInt8(position + i, other.readUInt8());
      }
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readUInt8",
    value: function readUInt8() {
      return this.getUInt8(this._updatePos(1));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readInt8",
    value: function readInt8() {
      return this.getInt8(this._updatePos(1));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readUInt16",
    value: function readUInt16() {
      return this.getUInt16(this._updatePos(2));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readUInt32",
    value: function readUInt32() {
      return this.getUInt32(this._updatePos(4));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readInt16",
    value: function readInt16() {
      return this.getInt16(this._updatePos(2));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readInt32",
    value: function readInt32() {
      return this.getInt32(this._updatePos(4));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readInt64",
    value: function readInt64() {
      return this.getInt32(this._updatePos(8));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readFloat64",
    value: function readFloat64() {
      return this.getFloat64(this._updatePos(8));
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeUInt8",
    value: function writeUInt8(val) {
      this.putUInt8(this._updatePos(1), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeInt8",
    value: function writeInt8(val) {
      this.putInt8(this._updatePos(1), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeInt16",
    value: function writeInt16(val) {
      this.putInt16(this._updatePos(2), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeInt32",
    value: function writeInt32(val) {
      this.putInt32(this._updatePos(4), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeUInt32",
    value: function writeUInt32(val) {
      this.putUInt32(this._updatePos(4), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeInt64",
    value: function writeInt64(val) {
      this.putInt64(this._updatePos(8), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeFloat64",
    value: function writeFloat64(val) {
      this.putFloat64(this._updatePos(8), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeBytes",
    value: function writeBytes(val) {
      this.putBytes(this._updatePos(val.remaining()), val);
    }
    /**
     * Get a slice of this buffer. This method does not copy any data,
     * but simply provides a slice view of this buffer
     * @param length
     */

  }, {
    key: "readSlice",
    value: function readSlice(length) {
      return this.getSlice(this._updatePos(length), length);
    }
  }, {
    key: "_updatePos",
    value: function _updatePos(length) {
      var p = this.position;
      this.position += length;
      return p;
    }
    /**
     * Get remaining
     */

  }, {
    key: "remaining",
    value: function remaining() {
      return this.length - this.position;
    }
    /**
     * Has remaining
     */

  }, {
    key: "hasRemaining",
    value: function hasRemaining() {
      return this.remaining() > 0;
    }
    /**
     * Reset position state
     */

  }, {
    key: "reset",
    value: function reset() {
      this.position = 0;
    }
    /**
     * Get string representation of buffer and it's state.
     * @return {string} Buffer as a string
     */

  }, {
    key: "toString",
    value: function toString() {
      return this.constructor.name + '( position=' + this.position + ' )\n  ' + this.toHex();
    }
    /**
     * Get string representation of buffer.
     * @return {string} Buffer as a string
     */

  }, {
    key: "toHex",
    value: function toHex() {
      var out = '';

      for (var i = 0; i < this.length; i++) {
        var hexByte = this.getUInt8(i).toString(16);

        if (hexByte.length === 1) {
          hexByte = '0' + hexByte;
        }

        out += hexByte;

        if (i !== this.length - 1) {
          out += ' ';
        }
      }

      return out;
    }
  }]);
  return BaseBuffer;
}();
/**
 * Represents a view as slice of another buffer.
 * @access private
 */


exports["default"] = BaseBuffer;

var SliceBuffer = /*#__PURE__*/function (_BaseBuffer) {
  (0, _inherits2["default"])(SliceBuffer, _BaseBuffer);

  var _super = _createSuper(SliceBuffer);

  function SliceBuffer(start, length, inner) {
    var _this;

    (0, _classCallCheck2["default"])(this, SliceBuffer);
    _this = _super.call(this, length);
    _this._start = start;
    _this._inner = inner;
    return _this;
  }

  (0, _createClass2["default"])(SliceBuffer, [{
    key: "putUInt8",
    value: function putUInt8(position, val) {
      this._inner.putUInt8(this._start + position, val);
    }
  }, {
    key: "getUInt8",
    value: function getUInt8(position) {
      return this._inner.getUInt8(this._start + position);
    }
  }, {
    key: "putInt8",
    value: function putInt8(position, val) {
      this._inner.putInt8(this._start + position, val);
    }
  }, {
    key: "putFloat64",
    value: function putFloat64(position, val) {
      this._inner.putFloat64(this._start + position, val);
    }
  }, {
    key: "getInt8",
    value: function getInt8(position) {
      return this._inner.getInt8(this._start + position);
    }
  }, {
    key: "getFloat64",
    value: function getFloat64(position) {
      return this._inner.getFloat64(this._start + position);
    }
  }]);
  return SliceBuffer;
}(BaseBuffer);

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/buf/combined-buf.js":
/*!********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/buf/combined-buf.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _baseBuf = _interopRequireDefault(__webpack_require__(/*! ./base-buf */ "./node_modules/neo4j-driver/lib/internal/buf/base-buf.js"));

var _node = __webpack_require__(/*! ../node */ "./node_modules/neo4j-driver/lib/internal/browser/index.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Buffer that combines multiple buffers, exposing them as one single buffer.
 */
var CombinedBuffer = /*#__PURE__*/function (_BaseBuffer) {
  (0, _inherits2["default"])(CombinedBuffer, _BaseBuffer);

  var _super = _createSuper(CombinedBuffer);

  function CombinedBuffer(buffers) {
    var _this;

    (0, _classCallCheck2["default"])(this, CombinedBuffer);
    var length = 0;

    for (var i = 0; i < buffers.length; i++) {
      length += buffers[i].length;
    }

    _this = _super.call(this, length);
    _this._buffers = buffers;
    return _this;
  }

  (0, _createClass2["default"])(CombinedBuffer, [{
    key: "getUInt8",
    value: function getUInt8(position) {
      // Surely there's a faster way to do this.. some sort of lookup table thing?
      for (var i = 0; i < this._buffers.length; i++) {
        var buffer = this._buffers[i]; // If the position is not in the current buffer, skip the current buffer

        if (position >= buffer.length) {
          position -= buffer.length;
        } else {
          return buffer.getUInt8(position);
        }
      }
    }
  }, {
    key: "getInt8",
    value: function getInt8(position) {
      // Surely there's a faster way to do this.. some sort of lookup table thing?
      for (var i = 0; i < this._buffers.length; i++) {
        var buffer = this._buffers[i]; // If the position is not in the current buffer, skip the current buffer

        if (position >= buffer.length) {
          position -= buffer.length;
        } else {
          return buffer.getInt8(position);
        }
      }
    }
  }, {
    key: "getFloat64",
    value: function getFloat64(position) {
      // At some point, a more efficient impl. For now, we copy the 8 bytes
      // we want to read and depend on the platform impl of IEEE 754.
      var b = (0, _node.alloc)(8);

      for (var i = 0; i < 8; i++) {
        b.putUInt8(i, this.getUInt8(position + i));
      }

      return b.getFloat64(0);
    }
  }]);
  return CombinedBuffer;
}(_baseBuf["default"]);

exports["default"] = CombinedBuffer;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/channel-config.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/channel-config.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _util = __webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_CONNECTION_TIMEOUT_MILLIS = 30000; // 30 seconds by default

var ALLOWED_VALUES_ENCRYPTED = [null, undefined, true, false, _util.ENCRYPTION_ON, _util.ENCRYPTION_OFF];
var ALLOWED_VALUES_TRUST = [null, undefined, 'TRUST_ALL_CERTIFICATES', 'TRUST_CUSTOM_CA_SIGNED_CERTIFICATES', 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES'];

var ChannelConfig =
/**
 * @constructor
 * @param {ServerAddress} address the address for the channel to connect to.
 * @param {Object} driverConfig the driver config provided by the user when driver is created.
 * @param {string} connectionErrorCode the default error code to use on connection errors.
 */
function ChannelConfig(address, driverConfig, connectionErrorCode) {
  (0, _classCallCheck2["default"])(this, ChannelConfig);
  this.address = address;
  this.encrypted = extractEncrypted(driverConfig);
  this.trust = extractTrust(driverConfig);
  this.trustedCertificates = extractTrustedCertificates(driverConfig);
  this.knownHostsPath = extractKnownHostsPath(driverConfig);
  this.connectionErrorCode = connectionErrorCode || _error.SERVICE_UNAVAILABLE;
  this.connectionTimeout = extractConnectionTimeout(driverConfig);
};

exports["default"] = ChannelConfig;

function extractEncrypted(driverConfig) {
  var value = driverConfig.encrypted;

  if (ALLOWED_VALUES_ENCRYPTED.indexOf(value) === -1) {
    throw (0, _error.newError)("Illegal value of the encrypted setting ".concat(value, ". Expected one of ").concat(ALLOWED_VALUES_ENCRYPTED));
  }

  return value;
}

function extractTrust(driverConfig) {
  var value = driverConfig.trust;

  if (ALLOWED_VALUES_TRUST.indexOf(value) === -1) {
    throw (0, _error.newError)("Illegal value of the trust setting ".concat(value, ". Expected one of ").concat(ALLOWED_VALUES_TRUST));
  }

  return value;
}

function extractTrustedCertificates(driverConfig) {
  return driverConfig.trustedCertificates || [];
}

function extractKnownHostsPath(driverConfig) {
  return driverConfig.knownHosts || null;
}

function extractConnectionTimeout(driverConfig) {
  var configuredTimeout = parseInt(driverConfig.connectionTimeout, 10);

  if (configuredTimeout === 0) {
    // timeout explicitly configured to 0
    return null;
  } else if (configuredTimeout && configuredTimeout < 0) {
    // timeout explicitly configured to a negative value
    return null;
  } else if (!configuredTimeout) {
    // timeout not configured, use default value
    return DEFAULT_CONNECTION_TIMEOUT_MILLIS;
  } else {
    // timeout configured, use the provided value
    return configuredTimeout;
  }
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/chunking.js":
/*!************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/chunking.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dechunker = exports.Chunker = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _baseBuf = _interopRequireDefault(__webpack_require__(/*! ./buf/base-buf */ "./node_modules/neo4j-driver/lib/internal/buf/base-buf.js"));

var _node = __webpack_require__(/*! ./node */ "./node_modules/neo4j-driver/lib/internal/browser/index.js");

var _combinedBuf = _interopRequireDefault(__webpack_require__(/*! ./buf/combined-buf */ "./node_modules/neo4j-driver/lib/internal/buf/combined-buf.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var _CHUNK_HEADER_SIZE = 2;
var _MESSAGE_BOUNDARY = 0x00;
var _DEFAULT_BUFFER_SIZE = 1400; // http://stackoverflow.com/questions/2613734/maximum-packet-size-for-a-tcp-connection

/**
 * Looks like a writable buffer, chunks output transparently into a channel below.
 * @access private
 */

var Chunker = /*#__PURE__*/function (_BaseBuffer) {
  (0, _inherits2["default"])(Chunker, _BaseBuffer);

  var _super = _createSuper(Chunker);

  function Chunker(channel, bufferSize) {
    var _this;

    (0, _classCallCheck2["default"])(this, Chunker);
    _this = _super.call(this, 0);
    _this._bufferSize = bufferSize || _DEFAULT_BUFFER_SIZE;
    _this._ch = channel;
    _this._buffer = (0, _node.alloc)(_this._bufferSize);
    _this._currentChunkStart = 0;
    _this._chunkOpen = false;
    return _this;
  }

  (0, _createClass2["default"])(Chunker, [{
    key: "putUInt8",
    value: function putUInt8(position, val) {
      this._ensure(1);

      this._buffer.writeUInt8(val);
    }
  }, {
    key: "putInt8",
    value: function putInt8(position, val) {
      this._ensure(1);

      this._buffer.writeInt8(val);
    }
  }, {
    key: "putFloat64",
    value: function putFloat64(position, val) {
      this._ensure(8);

      this._buffer.writeFloat64(val);
    }
  }, {
    key: "putBytes",
    value: function putBytes(position, data) {
      // TODO: If data is larger than our chunk size or so, we're very likely better off just passing this buffer on
      // rather than doing the copy here TODO: *however* note that we need some way to find out when the data has been
      // written (and thus the buffer can be re-used) if we take that approach
      while (data.remaining() > 0) {
        // Ensure there is an open chunk, and that it has at least one byte of space left
        this._ensure(1);

        if (this._buffer.remaining() > data.remaining()) {
          this._buffer.writeBytes(data);
        } else {
          this._buffer.writeBytes(data.readSlice(this._buffer.remaining()));
        }
      }

      return this;
    }
  }, {
    key: "flush",
    value: function flush() {
      if (this._buffer.position > 0) {
        this._closeChunkIfOpen(); // Local copy and clear the buffer field. This ensures that the buffer is not re-released if the flush call fails


        var out = this._buffer;
        this._buffer = null;

        this._ch.write(out.getSlice(0, out.position)); // Alloc a new output buffer. We assume we're using NodeJS's buffer pooling under the hood here!


        this._buffer = (0, _node.alloc)(this._bufferSize);
        this._chunkOpen = false;
      }

      return this;
    }
    /**
     * Bolt messages are encoded in one or more chunks, and the boundary between two messages
     * is encoded as a 0-length chunk, `00 00`. This inserts such a message boundary, closing
     * any currently open chunk as needed
     */

  }, {
    key: "messageBoundary",
    value: function messageBoundary() {
      this._closeChunkIfOpen();

      if (this._buffer.remaining() < _CHUNK_HEADER_SIZE) {
        this.flush();
      } // Write message boundary


      this._buffer.writeInt16(_MESSAGE_BOUNDARY);
    }
    /** Ensure at least the given size is available for writing */

  }, {
    key: "_ensure",
    value: function _ensure(size) {
      var toWriteSize = this._chunkOpen ? size : size + _CHUNK_HEADER_SIZE;

      if (this._buffer.remaining() < toWriteSize) {
        this.flush();
      }

      if (!this._chunkOpen) {
        this._currentChunkStart = this._buffer.position;
        this._buffer.position = this._buffer.position + _CHUNK_HEADER_SIZE;
        this._chunkOpen = true;
      }
    }
  }, {
    key: "_closeChunkIfOpen",
    value: function _closeChunkIfOpen() {
      if (this._chunkOpen) {
        var chunkSize = this._buffer.position - (this._currentChunkStart + _CHUNK_HEADER_SIZE);

        this._buffer.putUInt16(this._currentChunkStart, chunkSize);

        this._chunkOpen = false;
      }
    }
  }]);
  return Chunker;
}(_baseBuf["default"]);
/**
 * Combines chunks until a complete message is gathered up, and then forwards that
 * message to an 'onmessage' listener.
 * @access private
 */


exports.Chunker = Chunker;

var Dechunker = /*#__PURE__*/function () {
  function Dechunker() {
    (0, _classCallCheck2["default"])(this, Dechunker);
    this._currentMessage = [];
    this._partialChunkHeader = 0;
    this._state = this.AWAITING_CHUNK;
  }

  (0, _createClass2["default"])(Dechunker, [{
    key: "AWAITING_CHUNK",
    value: function AWAITING_CHUNK(buf) {
      if (buf.remaining() >= 2) {
        // Whole header available, read that
        return this._onHeader(buf.readUInt16());
      } else {
        // Only one byte available, read that and wait for the second byte
        this._partialChunkHeader = buf.readUInt8() << 8;
        return this.IN_HEADER;
      }
    }
  }, {
    key: "IN_HEADER",
    value: function IN_HEADER(buf) {
      // First header byte read, now we read the next one
      return this._onHeader((this._partialChunkHeader | buf.readUInt8()) & 0xffff);
    }
  }, {
    key: "IN_CHUNK",
    value: function IN_CHUNK(buf) {
      if (this._chunkSize <= buf.remaining()) {
        // Current packet is larger than current chunk, or same size:
        this._currentMessage.push(buf.readSlice(this._chunkSize));

        return this.AWAITING_CHUNK;
      } else {
        // Current packet is smaller than the chunk we're reading, split the current chunk itself up
        this._chunkSize -= buf.remaining();

        this._currentMessage.push(buf.readSlice(buf.remaining()));

        return this.IN_CHUNK;
      }
    }
  }, {
    key: "CLOSED",
    value: function CLOSED(buf) {} // no-op

    /** Called when a complete chunk header has been received */

  }, {
    key: "_onHeader",
    value: function _onHeader(header) {
      if (header === 0) {
        // Message boundary
        var message;

        switch (this._currentMessage.length) {
          case 0:
            // Keep alive chunk, sent by server to keep network alive.
            return this.AWAITING_CHUNK;

          case 1:
            // All data in one chunk, this signals the end of that chunk.
            message = this._currentMessage[0];
            break;

          default:
            // A large chunk of data received, this signals that the last chunk has been received.
            message = new _combinedBuf["default"](this._currentMessage);
            break;
        }

        this._currentMessage = [];
        this.onmessage(message);
        return this.AWAITING_CHUNK;
      } else {
        this._chunkSize = header;
        return this.IN_CHUNK;
      }
    }
  }, {
    key: "write",
    value: function write(buf) {
      while (buf.hasRemaining()) {
        this._state = this._state(buf);
      }
    }
  }]);
  return Dechunker;
}();

exports.Dechunker = Dechunker;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-channel.js":
/*!**********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-channel.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _node = __webpack_require__(/*! ./node */ "./node_modules/neo4j-driver/lib/internal/browser/index.js");

var _chunking = __webpack_require__(/*! ./chunking */ "./node_modules/neo4j-driver/lib/internal/chunking.js");

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _channelConfig = _interopRequireDefault(__webpack_require__(/*! ./channel-config */ "./node_modules/neo4j-driver/lib/internal/channel-config.js"));

var _protocolHandshaker = _interopRequireDefault(__webpack_require__(/*! ./protocol-handshaker */ "./node_modules/neo4j-driver/lib/internal/protocol-handshaker.js"));

var _connection = _interopRequireDefault(__webpack_require__(/*! ./connection */ "./node_modules/neo4j-driver/lib/internal/connection.js"));

var _boltProtocolV = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v1 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v1.js"));

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

// Signature bytes for each response message type
var SUCCESS = 0x70; // 0111 0000 // SUCCESS <metadata>

var RECORD = 0x71; // 0111 0001 // RECORD <value>

var IGNORED = 0x7e; // 0111 1110 // IGNORED <metadata>

var FAILURE = 0x7f; // 0111 1111 // FAILURE <metadata>

function NO_OP() {}

var NO_OP_OBSERVER = {
  onNext: NO_OP,
  onCompleted: NO_OP,
  onError: NO_OP
};
var idGenerator = 0;

var ChannelConnection = /*#__PURE__*/function (_Connection) {
  (0, _inherits2["default"])(ChannelConnection, _Connection);

  var _super = _createSuper(ChannelConnection);

  /**
   * @constructor
   * @param {Channel} channel - channel with a 'write' function and a 'onmessage' callback property.
   * @param {ConnectionErrorHandler} errorHandler the error handler.
   * @param {ServerAddress} address - the server address to connect to.
   * @param {Logger} log - the configured logger.
   * @param {boolean} disableLosslessIntegers if this connection should convert all received integers to native JS numbers.
   */
  function ChannelConnection(channel, errorHandler, address, log) {
    var _this;

    var disableLosslessIntegers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var serversideRouting = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    (0, _classCallCheck2["default"])(this, ChannelConnection);
    _this = _super.call(this, errorHandler);
    _this._id = idGenerator++;
    _this._address = address;
    _this._server = {
      address: address.asHostPort()
    };
    _this.creationTimestamp = Date.now();
    _this._disableLosslessIntegers = disableLosslessIntegers;
    _this._pendingObservers = [];
    _this._currentObserver = undefined;
    _this._ch = channel;
    _this._dechunker = new _chunking.Dechunker();
    _this._chunker = new _chunking.Chunker(channel);
    _this._log = log;
    _this._serversideRouting = serversideRouting; // connection from the database, returned in response for HELLO message and might not be available

    _this._dbConnectionId = null; // bolt protocol is initially not initialized

    /**
     * @private
     * @type {BoltProtocol}
     */

    _this._protocol = null; // error extracted from a FAILURE message

    _this._currentFailure = null; // Set to true on fatal errors, to get this out of connection pool.

    _this._isBroken = false;

    if (_this._log.isDebugEnabled()) {
      _this._log.debug("".concat((0, _assertThisInitialized2["default"])(_this), " created towards ").concat(address));
    }

    return _this;
  }
  /**
   * Crete new connection to the provided address. Returned connection is not connected.
   * @param {ServerAddress} address - the Bolt endpoint to connect to.
   * @param {Object} config - the driver configuration.
   * @param {ConnectionErrorHandler} errorHandler - the error handler for connection errors.
   * @param {Logger} log - configured logger.
   * @return {Connection} - new connection.
   */


  (0, _createClass2["default"])(ChannelConnection, [{
    key: "connect",

    /**
     * Connect to the target address, negotiate Bolt protocol and send initialization message.
     * @param {string} userAgent the user agent for this driver.
     * @param {Object} authToken the object containing auth information.
     * @return {Promise<Connection>} promise resolved with the current connection if connection is successful. Rejected promise otherwise.
     */
    value: function connect(userAgent, authToken) {
      var _this2 = this;

      return this._negotiateProtocol().then(function () {
        return _this2._initialize(userAgent, authToken);
      });
    }
    /**
     * Execute Bolt protocol handshake to initialize the protocol version.
     * @return {Promise<Connection>} promise resolved with the current connection if handshake is successful. Rejected promise otherwise.
     */

  }, {
    key: "_negotiateProtocol",
    value: function _negotiateProtocol() {
      var _this3 = this;

      var protocolHandshaker = new _protocolHandshaker["default"](this, this._ch, this._chunker, this._disableLosslessIntegers, this._log, this._serversideRouting);
      return new Promise(function (resolve, reject) {
        var handshakeErrorHandler = function handshakeErrorHandler(error) {
          _this3._handleFatalError(error);

          reject(error);
        };

        _this3._ch.onerror = handshakeErrorHandler.bind(_this3);

        if (_this3._ch._error) {
          // channel is already broken
          handshakeErrorHandler(_this3._ch._error);
        }

        _this3._ch.onmessage = function (buffer) {
          try {
            // read the response buffer and initialize the protocol
            _this3._protocol = protocolHandshaker.createNegotiatedProtocol(buffer); // reset the error handler to just handle errors and forget about the handshake promise

            _this3._ch.onerror = _this3._handleFatalError.bind(_this3); // Ok, protocol running. Simply forward all messages to the dechunker

            _this3._ch.onmessage = function (buf) {
              return _this3._dechunker.write(buf);
            }; // setup dechunker to dechunk messages and forward them to the message handler


            _this3._dechunker.onmessage = function (buf) {
              _this3._handleMessage(_this3._protocol.unpacker().unpack(buf));
            }; // forward all pending bytes to the dechunker


            if (buffer.hasRemaining()) {
              _this3._dechunker.write(buffer.readSlice(buffer.remaining()));
            }

            resolve(_this3);
          } catch (e) {
            _this3._handleFatalError(e);

            reject(e);
          }
        };

        protocolHandshaker.writeHandshakeRequest();
      });
    }
    /**
     * Perform protocol-specific initialization which includes authentication.
     * @param {string} userAgent the user agent for this driver.
     * @param {Object} authToken the object containing auth information.
     * @return {Promise<Connection>} promise resolved with the current connection if initialization is successful. Rejected promise otherwise.
     */

  }, {
    key: "_initialize",
    value: function _initialize(userAgent, authToken) {
      var _this4 = this;

      var self = this;
      return new Promise(function (resolve, reject) {
        _this4._protocol.initialize({
          userAgent: userAgent,
          authToken: authToken,
          onError: function onError(err) {
            return reject(err);
          },
          onComplete: function onComplete() {
            return resolve(self);
          }
        });
      });
    }
    /**
     * Get the Bolt protocol for the connection.
     * @return {BoltProtocol} the protocol.
     */

  }, {
    key: "protocol",
    value: function protocol() {
      return this._protocol;
    }
  }, {
    key: "write",

    /**
     * Write a message to the network channel.
     * @param {RequestMessage} message the message to write.
     * @param {ResultStreamObserver} observer the response observer.
     * @param {boolean} flush `true` if flush should happen after the message is written to the buffer.
     */
    value: function write(message, observer, flush) {
      var _this5 = this;

      var queued = this._queueObserver(observer);

      if (queued) {
        if (this._log.isDebugEnabled()) {
          this._log.debug("".concat(this, " C: ").concat(message));
        }

        this._protocol.packer().packStruct(message.signature, message.fields.map(function (field) {
          return _this5._packable(field);
        }));

        this._chunker.messageBoundary();

        if (flush) {
          this._chunker.flush();
        }
      }
    }
    /**
     * "Fatal" means the connection is dead. Only call this if something
     * happens that cannot be recovered from. This will lead to all subscribers
     * failing, and the connection getting ejected from the session pool.
     *
     * @param error an error object, forwarded to all current and future subscribers
     */

  }, {
    key: "_handleFatalError",
    value: function _handleFatalError(error) {
      this._isBroken = true;
      this._error = this.handleAndTransformError(error, this._address);

      if (this._log.isErrorEnabled()) {
        this._log.error("".concat(this, " experienced a fatal error ").concat(JSON.stringify(this._error)));
      }

      if (this._currentObserver && this._currentObserver.onError) {
        this._currentObserver.onError(this._error);
      }

      while (this._pendingObservers.length > 0) {
        var observer = this._pendingObservers.shift();

        if (observer && observer.onError) {
          observer.onError(this._error);
        }
      }
    }
  }, {
    key: "_handleMessage",
    value: function _handleMessage(msg) {
      if (this._isBroken) {
        // ignore all incoming messages when this connection is broken. all previously pending observers failed
        // with the fatal error. all future observers will fail with same fatal error.
        return;
      }

      var payload = msg.fields[0];

      switch (msg.signature) {
        case RECORD:
          if (this._log.isDebugEnabled()) {
            this._log.debug("".concat(this, " S: RECORD ").concat(JSON.stringify(msg)));
          }

          this._currentObserver.onNext(payload);

          break;

        case SUCCESS:
          if (this._log.isDebugEnabled()) {
            this._log.debug("".concat(this, " S: SUCCESS ").concat(JSON.stringify(msg)));
          }

          try {
            var metadata = this._protocol.transformMetadata(payload);

            this._currentObserver.onCompleted(metadata);
          } finally {
            this._updateCurrentObserver();
          }

          break;

        case FAILURE:
          if (this._log.isDebugEnabled()) {
            this._log.debug("".concat(this, " S: FAILURE ").concat(JSON.stringify(msg)));
          }

          try {
            var error = (0, _error.newError)(payload.message, payload.code);
            this._currentFailure = this.handleAndTransformError(error, this._address);

            this._currentObserver.onError(this._currentFailure);
          } finally {
            this._updateCurrentObserver(); // Things are now broken. Pending observers will get FAILURE messages routed until we are done handling this failure.


            this._resetOnFailure();
          }

          break;

        case IGNORED:
          if (this._log.isDebugEnabled()) {
            this._log.debug("".concat(this, " S: IGNORED ").concat(JSON.stringify(msg)));
          }

          try {
            if (this._currentFailure && this._currentObserver.onError) {
              this._currentObserver.onError(this._currentFailure);
            } else if (this._currentObserver.onError) {
              this._currentObserver.onError((0, _error.newError)('Ignored either because of an error or RESET'));
            }
          } finally {
            this._updateCurrentObserver();
          }

          break;

        default:
          this._handleFatalError((0, _error.newError)('Unknown Bolt protocol message: ' + msg));

      }
    }
    /**
     * Send a RESET-message to the database. Message is immediately flushed to the network.
     * @return {Promise<void>} promise resolved when SUCCESS-message response arrives, or failed when other response messages arrives.
     */

  }, {
    key: "resetAndFlush",
    value: function resetAndFlush() {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        _this6._protocol.reset({
          onError: function onError(error) {
            if (_this6._isBroken) {
              // handling a fatal error, no need to raise a protocol violation
              reject(error);
            } else {
              var neo4jError = _this6._handleProtocolError('Received FAILURE as a response for RESET: ' + error);

              reject(neo4jError);
            }
          },
          onComplete: function onComplete() {
            resolve();
          }
        });
      });
    }
  }, {
    key: "_resetOnFailure",
    value: function _resetOnFailure() {
      var _this7 = this;

      this._protocol.reset({
        onError: function onError() {
          _this7._currentFailure = null;
        },
        onComplete: function onComplete() {
          _this7._currentFailure = null;
        }
      });
    }
  }, {
    key: "_queueObserver",
    value: function _queueObserver(observer) {
      if (this._isBroken) {
        if (observer && observer.onError) {
          observer.onError(this._error);
        }

        return false;
      }

      observer = observer || NO_OP_OBSERVER;
      observer.onCompleted = observer.onCompleted || NO_OP;
      observer.onError = observer.onError || NO_OP;
      observer.onNext = observer.onNext || NO_OP;

      if (this._currentObserver === undefined) {
        this._currentObserver = observer;
      } else {
        this._pendingObservers.push(observer);
      }

      return true;
    }
    /*
     * Pop next pending observer form the list of observers and make it current observer.
     * @protected
     */

  }, {
    key: "_updateCurrentObserver",
    value: function _updateCurrentObserver() {
      this._currentObserver = this._pendingObservers.shift();
    }
    /** Check if this connection is in working condition */

  }, {
    key: "isOpen",
    value: function isOpen() {
      return !this._isBroken && this._ch._open;
    }
    /**
     * Call close on the channel.
     * @returns {Promise<void>} - A promise that will be resolved when the underlying channel is closed.
     */

  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(this, " closing"));
                }

                if (this._protocol && this.isOpen()) {
                  // protocol has been initialized and this connection is healthy
                  // notify the database about the upcoming close of the connection
                  this._protocol.prepareToClose();
                }

                _context.next = 4;
                return this._ch.close();

              case 4:
                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(this, " closed"));
                }

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "toString",
    value: function toString() {
      return "Connection [".concat(this.id, "][").concat(this.databaseId || '', "]");
    }
  }, {
    key: "_packable",
    value: function _packable(value) {
      return this._protocol.packer().packable(value);
    }
  }, {
    key: "_handleProtocolError",
    value: function _handleProtocolError(message) {
      this._currentFailure = null;

      this._updateCurrentObserver();

      var error = (0, _error.newError)(message, _error.PROTOCOL_ERROR);

      this._handleFatalError(error);

      return error;
    }
  }, {
    key: "id",
    get: function get() {
      return this._id;
    }
  }, {
    key: "databaseId",
    get: function get() {
      return this._dbConnectionId;
    },
    set: function set(value) {
      this._dbConnectionId = value;
    }
  }, {
    key: "address",
    get: function get() {
      return this._address;
    }
    /**
     * Get the version of the connected server.
     * Available only after initialization
     *
     * @returns {ServerVersion} version
     */

  }, {
    key: "version",
    get: function get() {
      return this._server.version;
    },
    set: function set(value) {
      this._server.version = value;
    }
  }, {
    key: "server",
    get: function get() {
      return this._server;
    }
  }], [{
    key: "create",
    value: function create(address, config, errorHandler, log) {
      var serversideRouting = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var channelConfig = new _channelConfig["default"](address, config, errorHandler.errorCode());
      return new ChannelConnection(new _node.Channel(channelConfig), errorHandler, address, log, config.disableLosslessIntegers, serversideRouting);
    }
  }]);
  return ChannelConnection;
}(_connection["default"]);

exports["default"] = ChannelConnection;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-delegate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-delegate.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _connection = _interopRequireDefault(__webpack_require__(/*! ./connection */ "./node_modules/neo4j-driver/lib/internal/connection.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var DelegateConnection = /*#__PURE__*/function (_Connection) {
  (0, _inherits2["default"])(DelegateConnection, _Connection);

  var _super = _createSuper(DelegateConnection);

  /**
   * @param delegate {Connection} the delegated connection
   * @param errorHandler {ConnectionErrorHandler} the error handler
   */
  function DelegateConnection(delegate, errorHandler) {
    var _this;

    (0, _classCallCheck2["default"])(this, DelegateConnection);
    _this = _super.call(this, errorHandler);

    if (errorHandler) {
      _this._originalErrorHandler = delegate._errorHandler;
      delegate._errorHandler = _this._errorHandler;
    }

    _this._delegate = delegate;
    return _this;
  }

  (0, _createClass2["default"])(DelegateConnection, [{
    key: "isOpen",
    value: function isOpen() {
      return this._delegate.isOpen();
    }
  }, {
    key: "protocol",
    value: function protocol() {
      return this._delegate.protocol();
    }
  }, {
    key: "connect",
    value: function connect(userAgent, authToken) {
      return this._delegate.connect(userAgent, authToken);
    }
  }, {
    key: "write",
    value: function write(message, observer, flush) {
      return this._delegate.write(message, observer, flush);
    }
  }, {
    key: "resetAndFlush",
    value: function resetAndFlush() {
      return this._delegate.resetAndFlush();
    }
  }, {
    key: "close",
    value: function close() {
      return this._delegate.close();
    }
  }, {
    key: "_release",
    value: function _release() {
      if (this._originalErrorHandler) {
        this._delegate._errorHandler = this._originalErrorHandler;
      }

      return this._delegate._release();
    }
  }, {
    key: "id",
    get: function get() {
      return this._delegate.id;
    }
  }, {
    key: "databaseId",
    get: function get() {
      return this._delegate.databaseId;
    },
    set: function set(value) {
      this._delegate.databaseId = value;
    }
  }, {
    key: "server",
    get: function get() {
      return this._delegate.server;
    }
  }, {
    key: "address",
    get: function get() {
      return this._delegate.address;
    }
  }, {
    key: "version",
    get: function get() {
      return this._delegate.version;
    },
    set: function set(value) {
      this._delegate.version = value;
    }
  }]);
  return DelegateConnection;
}(_connection["default"]);

exports["default"] = DelegateConnection;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-error-handler.js":
/*!****************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-error-handler.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ConnectionErrorHandler = /*#__PURE__*/function () {
  function ConnectionErrorHandler(errorCode, handleUnavailability, handleWriteFailure) {
    (0, _classCallCheck2["default"])(this, ConnectionErrorHandler);
    this._errorCode = errorCode;
    this._handleUnavailability = handleUnavailability || noOpHandler;
    this._handleWriteFailure = handleWriteFailure || noOpHandler;
  }
  /**
   * Error code to use for network errors.
   * @return {string} the error code.
   */


  (0, _createClass2["default"])(ConnectionErrorHandler, [{
    key: "errorCode",
    value: function errorCode() {
      return this._errorCode;
    }
    /**
     * Handle and transform the error.
     * @param {Neo4jError} error the original error.
     * @param {ServerAddress} address the address of the connection where the error happened.
     * @return {Neo4jError} new error that should be propagated to the user.
     */

  }, {
    key: "handleAndTransformError",
    value: function handleAndTransformError(error, address) {
      if (isAvailabilityError(error)) {
        return this._handleUnavailability(error, address);
      }

      if (isFailureToWrite(error)) {
        return this._handleWriteFailure(error, address);
      }

      return error;
    }
  }]);
  return ConnectionErrorHandler;
}();

exports["default"] = ConnectionErrorHandler;

function isAvailabilityError(error) {
  if (error) {
    return error.code === _error.SESSION_EXPIRED || error.code === _error.SERVICE_UNAVAILABLE || error.code === 'Neo.TransientError.General.DatabaseUnavailable';
  }

  return false;
}

function isFailureToWrite(error) {
  if (error) {
    return error.code === 'Neo.ClientError.Cluster.NotALeader' || error.code === 'Neo.ClientError.General.ForbiddenOnReadOnlyDatabase';
  }

  return false;
}

function noOpHandler(error) {
  return error;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-holder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-holder.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EMPTY_CONNECTION_HOLDER = exports["default"] = void 0;

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _util = __webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js");

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Utility to lazily initialize connections and return them back to the pool when unused.
 */
var ConnectionHolder = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {string} mode - the access mode for new connection holder.
   * @param {string} database - the target database name.
   * @param {ConnectionProvider} connectionProvider - the connection provider to acquire connections from.
   */
  function ConnectionHolder() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$mode = _ref.mode,
        mode = _ref$mode === void 0 ? _constants.ACCESS_MODE_WRITE : _ref$mode,
        _ref$database = _ref.database,
        database = _ref$database === void 0 ? '' : _ref$database,
        bookmark = _ref.bookmark,
        connectionProvider = _ref.connectionProvider;

    (0, _classCallCheck2["default"])(this, ConnectionHolder);
    this._mode = mode;
    this._database = database ? (0, _util.assertString)(database, 'database') : '';
    this._bookmark = bookmark || _bookmark["default"].empty();
    this._connectionProvider = connectionProvider;
    this._referenceCount = 0;
    this._connectionPromise = Promise.resolve(null);
  }
  /**
   * Returns the assigned access mode.
   * @returns {string} access mode
   */


  (0, _createClass2["default"])(ConnectionHolder, [{
    key: "mode",
    value: function mode() {
      return this._mode;
    }
    /**
     * Returns the target database name
     * @returns {string} the database name
     */

  }, {
    key: "database",
    value: function database() {
      return this._database;
    }
    /**
     * Make this holder initialize new connection if none exists already.
     * @return {boolean}
     */

  }, {
    key: "initializeConnection",
    value: function initializeConnection() {
      if (this._referenceCount === 0) {
        this._connectionPromise = this._connectionProvider.acquireConnection({
          accessMode: this._mode,
          database: this._database,
          bookmark: this._bookmark
        });
      } else {
        this._referenceCount++;
        return false;
      }

      this._referenceCount++;
      return true;
    }
    /**
     * Get the current connection promise.
     * @return {Promise<Connection>} promise resolved with the current connection.
     */

  }, {
    key: "getConnection",
    value: function getConnection() {
      return this._connectionPromise;
    }
    /**
     * Notify this holder that single party does not require current connection any more.
     * @return {Promise<Connection>} promise resolved with the current connection, never a rejected promise.
     */

  }, {
    key: "releaseConnection",
    value: function releaseConnection() {
      if (this._referenceCount === 0) {
        return this._connectionPromise;
      }

      this._referenceCount--;

      if (this._referenceCount === 0) {
        return this._releaseConnection();
      }

      return this._connectionPromise;
    }
    /**
     * Closes this holder and releases current connection (if any) despite any existing users.
     * @return {Promise<Connection>} promise resolved when current connection is released to the pool.
     */

  }, {
    key: "close",
    value: function close() {
      if (this._referenceCount === 0) {
        return this._connectionPromise;
      }

      this._referenceCount = 0;
      return this._releaseConnection();
    }
    /**
     * Return the current pooled connection instance to the connection pool.
     * We don't pool Session instances, to avoid users using the Session after they've called close.
     * The `Session` object is just a thin wrapper around Connection anyway, so it makes little difference.
     * @return {Promise} - promise resolved then connection is returned to the pool.
     * @private
     */

  }, {
    key: "_releaseConnection",
    value: function _releaseConnection() {
      this._connectionPromise = this._connectionPromise.then(function (connection) {
        if (connection) {
          return connection.resetAndFlush()["catch"](ignoreError).then(function () {
            return connection._release();
          });
        } else {
          return Promise.resolve();
        }
      })["catch"](ignoreError);
      return this._connectionPromise;
    }
  }]);
  return ConnectionHolder;
}();

exports["default"] = ConnectionHolder;

var EmptyConnectionHolder = /*#__PURE__*/function (_ConnectionHolder) {
  (0, _inherits2["default"])(EmptyConnectionHolder, _ConnectionHolder);

  var _super = _createSuper(EmptyConnectionHolder);

  function EmptyConnectionHolder() {
    (0, _classCallCheck2["default"])(this, EmptyConnectionHolder);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(EmptyConnectionHolder, [{
    key: "initializeConnection",
    value: function initializeConnection() {
      // nothing to initialize
      return true;
    }
  }, {
    key: "getConnection",
    value: function getConnection() {
      return Promise.reject((0, _error.newError)('This connection holder does not serve connections'));
    }
  }, {
    key: "releaseConnection",
    value: function releaseConnection() {
      return Promise.resolve();
    }
  }, {
    key: "close",
    value: function close() {
      return Promise.resolve();
    }
  }]);
  return EmptyConnectionHolder;
}(ConnectionHolder); // eslint-disable-next-line handle-callback-err


function ignoreError(error) {}
/**
 * Connection holder that does not manage any connections.
 * @type {ConnectionHolder}
 */


var EMPTY_CONNECTION_HOLDER = new EmptyConnectionHolder();
exports.EMPTY_CONNECTION_HOLDER = EMPTY_CONNECTION_HOLDER;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-provider-direct.js":
/*!******************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-provider-direct.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _connectionProviderPooled = _interopRequireDefault(__webpack_require__(/*! ./connection-provider-pooled */ "./node_modules/neo4j-driver/lib/internal/connection-provider-pooled.js"));

var _connectionDelegate = _interopRequireDefault(__webpack_require__(/*! ./connection-delegate */ "./node_modules/neo4j-driver/lib/internal/connection-delegate.js"));

var _connectionChannel = _interopRequireDefault(__webpack_require__(/*! ./connection-channel */ "./node_modules/neo4j-driver/lib/internal/connection-channel.js"));

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var DirectConnectionProvider = /*#__PURE__*/function (_PooledConnectionProv) {
  (0, _inherits2["default"])(DirectConnectionProvider, _PooledConnectionProv);

  var _super = _createSuper(DirectConnectionProvider);

  function DirectConnectionProvider(_ref) {
    var _this;

    var id = _ref.id,
        config = _ref.config,
        log = _ref.log,
        address = _ref.address,
        userAgent = _ref.userAgent,
        authToken = _ref.authToken;
    (0, _classCallCheck2["default"])(this, DirectConnectionProvider);
    _this = _super.call(this, {
      id: id,
      config: config,
      log: log,
      userAgent: userAgent,
      authToken: authToken
    });
    _this._address = address;
    return _this;
  }
  /**
   * See {@link ConnectionProvider} for more information about this method and
   * its arguments.
   */


  (0, _createClass2["default"])(DirectConnectionProvider, [{
    key: "acquireConnection",
    value: function acquireConnection() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          accessMode = _ref2.accessMode,
          database = _ref2.database,
          bookmarks = _ref2.bookmarks;

      return this._connectionPool.acquire(this._address).then(function (connection) {
        return new _connectionDelegate["default"](connection, null);
      });
    }
  }, {
    key: "_hasProtocolVersion",
    value: function () {
      var _hasProtocolVersion2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(versionPredicate) {
        var connection, protocol;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                connection = _connectionChannel["default"].create(this._address, this._config, this._createConnectionErrorHandler(), this._log);
                _context.prev = 1;
                _context.next = 4;
                return connection._negotiateProtocol();

              case 4:
                protocol = connection.protocol();

                if (!protocol) {
                  _context.next = 7;
                  break;
                }

                return _context.abrupt("return", versionPredicate(protocol.version));

              case 7:
                return _context.abrupt("return", false);

              case 8:
                _context.prev = 8;
                _context.next = 11;
                return connection.close();

              case 11:
                return _context.finish(8);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1,, 8, 12]]);
      }));

      function _hasProtocolVersion(_x) {
        return _hasProtocolVersion2.apply(this, arguments);
      }

      return _hasProtocolVersion;
    }()
  }, {
    key: "supportsMultiDb",
    value: function () {
      var _supportsMultiDb = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._hasProtocolVersion(function (version) {
                  return version >= _constants.BOLT_PROTOCOL_V4_0;
                });

              case 2:
                return _context2.abrupt("return", _context2.sent);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function supportsMultiDb() {
        return _supportsMultiDb.apply(this, arguments);
      }

      return supportsMultiDb;
    }()
  }, {
    key: "supportsTransactionConfig",
    value: function () {
      var _supportsTransactionConfig = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._hasProtocolVersion(function (version) {
                  return version >= _constants.BOLT_PROTOCOL_V3;
                });

              case 2:
                return _context3.abrupt("return", _context3.sent);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function supportsTransactionConfig() {
        return _supportsTransactionConfig.apply(this, arguments);
      }

      return supportsTransactionConfig;
    }()
  }]);
  return DirectConnectionProvider;
}(_connectionProviderPooled["default"]);

exports["default"] = DirectConnectionProvider;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-provider-pooled.js":
/*!******************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-provider-pooled.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _connectionChannel = _interopRequireDefault(__webpack_require__(/*! ./connection-channel */ "./node_modules/neo4j-driver/lib/internal/connection-channel.js"));

var _pool = _interopRequireDefault(__webpack_require__(/*! ./pool */ "./node_modules/neo4j-driver/lib/internal/pool.js"));

var _poolConfig = _interopRequireDefault(__webpack_require__(/*! ./pool-config */ "./node_modules/neo4j-driver/lib/internal/pool-config.js"));

var _connectionErrorHandler = _interopRequireDefault(__webpack_require__(/*! ./connection-error-handler */ "./node_modules/neo4j-driver/lib/internal/connection-error-handler.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _connectionProvider = _interopRequireDefault(__webpack_require__(/*! ./connection-provider */ "./node_modules/neo4j-driver/lib/internal/connection-provider.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var PooledConnectionProvider = /*#__PURE__*/function (_ConnectionProvider) {
  (0, _inherits2["default"])(PooledConnectionProvider, _ConnectionProvider);

  var _super = _createSuper(PooledConnectionProvider);

  function PooledConnectionProvider(_ref) {
    var _this;

    var id = _ref.id,
        config = _ref.config,
        log = _ref.log,
        userAgent = _ref.userAgent,
        authToken = _ref.authToken;
    var createChannelConnectionHook = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _classCallCheck2["default"])(this, PooledConnectionProvider);
    _this = _super.call(this);
    _this._id = id;
    _this._config = config;
    _this._log = log;
    _this._userAgent = userAgent;
    _this._authToken = authToken;

    _this._createChannelConnection = createChannelConnectionHook || function (address) {
      return _connectionChannel["default"].create(address, _this._config, _this._createConnectionErrorHandler(), _this._log);
    };

    _this._connectionPool = new _pool["default"]({
      create: _this._createConnection.bind((0, _assertThisInitialized2["default"])(_this)),
      destroy: _this._destroyConnection.bind((0, _assertThisInitialized2["default"])(_this)),
      validate: _this._validateConnection.bind((0, _assertThisInitialized2["default"])(_this)),
      installIdleObserver: PooledConnectionProvider._installIdleObserverOnConnection.bind((0, _assertThisInitialized2["default"])(_this)),
      removeIdleObserver: PooledConnectionProvider._removeIdleObserverOnConnection.bind((0, _assertThisInitialized2["default"])(_this)),
      config: _poolConfig["default"].fromDriverConfig(config),
      log: _this._log
    });
    _this._openConnections = {};
    return _this;
  }

  (0, _createClass2["default"])(PooledConnectionProvider, [{
    key: "_createConnectionErrorHandler",
    value: function _createConnectionErrorHandler() {
      return new _connectionErrorHandler["default"](_error.SERVICE_UNAVAILABLE);
    }
    /**
     * Create a new connection and initialize it.
     * @return {Promise<Connection>} promise resolved with a new connection or rejected when failed to connect.
     * @access private
     */

  }, {
    key: "_createConnection",
    value: function _createConnection(address, release) {
      var _this2 = this;

      var connection = this._createChannelConnection(address);

      connection._release = function () {
        return release(address, connection);
      };

      this._openConnections[connection.id] = connection;
      return connection.connect(this._userAgent, this._authToken)["catch"](function (error) {
        // let's destroy this connection
        _this2._destroyConnection(connection); // propagate the error because connection failed to connect / initialize


        throw error;
      });
    }
    /**
     * Check that a connection is usable
     * @return {boolean} true if the connection is open
     * @access private
     **/

  }, {
    key: "_validateConnection",
    value: function _validateConnection(conn) {
      if (!conn.isOpen()) {
        return false;
      }

      var maxConnectionLifetime = this._config.maxConnectionLifetime;
      var lifetime = Date.now() - conn.creationTimestamp;
      return lifetime <= maxConnectionLifetime;
    }
    /**
     * Dispose of a connection.
     * @return {Connection} the connection to dispose.
     * @access private
     */

  }, {
    key: "_destroyConnection",
    value: function _destroyConnection(conn) {
      delete this._openConnections[conn.id];
      return conn.close();
    }
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._connectionPool.close();

              case 2:
                _context.next = 4;
                return Promise.all(Object.values(this._openConnections).map(function (c) {
                  return c.close();
                }));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }], [{
    key: "_installIdleObserverOnConnection",
    value: function _installIdleObserverOnConnection(conn, observer) {
      conn._queueObserver(observer);
    }
  }, {
    key: "_removeIdleObserverOnConnection",
    value: function _removeIdleObserverOnConnection(conn) {
      conn._updateCurrentObserver();
    }
  }]);
  return PooledConnectionProvider;
}(_connectionProvider["default"]);

exports["default"] = PooledConnectionProvider;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-provider-routing.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-provider-routing.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _driver = __webpack_require__(/*! ../driver */ "./node_modules/neo4j-driver/lib/driver.js");

var _session = _interopRequireDefault(__webpack_require__(/*! ../session */ "./node_modules/neo4j-driver/lib/session.js"));

var _routingTable = _interopRequireDefault(__webpack_require__(/*! ./routing-table */ "./node_modules/neo4j-driver/lib/internal/routing-table.js"));

var _rediscovery = _interopRequireDefault(__webpack_require__(/*! ./rediscovery */ "./node_modules/neo4j-driver/lib/internal/rediscovery.js"));

var _routingUtil = _interopRequireDefault(__webpack_require__(/*! ./routing-util */ "./node_modules/neo4j-driver/lib/internal/routing-util.js"));

var _node = __webpack_require__(/*! ./node */ "./node_modules/neo4j-driver/lib/internal/browser/index.js");

var _connectionProviderSingle = _interopRequireDefault(__webpack_require__(/*! ./connection-provider-single */ "./node_modules/neo4j-driver/lib/internal/connection-provider-single.js"));

var _connectionProviderPooled = _interopRequireDefault(__webpack_require__(/*! ./connection-provider-pooled */ "./node_modules/neo4j-driver/lib/internal/connection-provider-pooled.js"));

var _connectionErrorHandler = _interopRequireDefault(__webpack_require__(/*! ./connection-error-handler */ "./node_modules/neo4j-driver/lib/internal/connection-error-handler.js"));

var _connectionDelegate = _interopRequireDefault(__webpack_require__(/*! ./connection-delegate */ "./node_modules/neo4j-driver/lib/internal/connection-delegate.js"));

var _leastConnectedLoadBalancingStrategy = _interopRequireDefault(__webpack_require__(/*! ./least-connected-load-balancing-strategy */ "./node_modules/neo4j-driver/lib/internal/least-connected-load-balancing-strategy.js"));

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

var _connectionChannel = _interopRequireDefault(__webpack_require__(/*! ./connection-channel */ "./node_modules/neo4j-driver/lib/internal/connection-channel.js"));

var _integer = __webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js");

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var UNAUTHORIZED_ERROR_CODE = 'Neo.ClientError.Security.Unauthorized';
var DATABASE_NOT_FOUND_ERROR_CODE = 'Neo.ClientError.Database.DatabaseNotFound';
var SYSTEM_DB_NAME = 'system';
var DEFAULT_DB_NAME = '';
var DEFAULT_ROUTING_TABLE_PURGE_DELAY = (0, _integer["int"])(30000);

var RoutingConnectionProvider = /*#__PURE__*/function (_PooledConnectionProv) {
  (0, _inherits2["default"])(RoutingConnectionProvider, _PooledConnectionProv);

  var _super = _createSuper(RoutingConnectionProvider);

  function RoutingConnectionProvider(_ref) {
    var _this;

    var id = _ref.id,
        address = _ref.address,
        routingContext = _ref.routingContext,
        hostNameResolver = _ref.hostNameResolver,
        config = _ref.config,
        log = _ref.log,
        userAgent = _ref.userAgent,
        authToken = _ref.authToken,
        routingTablePurgeDelay = _ref.routingTablePurgeDelay;
    (0, _classCallCheck2["default"])(this, RoutingConnectionProvider);
    _this = _super.call(this, {
      id: id,
      config: config,
      log: log,
      userAgent: userAgent,
      authToken: authToken
    }, function (address) {
      return _connectionChannel["default"].create(address, _this._config, _this._createConnectionErrorHandler(), _this._log, routingContext || {});
    });
    _this._seedRouter = address;
    _this._routingTables = {};
    _this._rediscovery = new _rediscovery["default"](new _routingUtil["default"](routingContext, address.toString()));
    _this._loadBalancingStrategy = new _leastConnectedLoadBalancingStrategy["default"](_this._connectionPool);
    _this._hostNameResolver = hostNameResolver;
    _this._dnsResolver = new _node.HostNameResolver();
    _this._log = log;
    _this._useSeedRouter = true;
    _this._routingTablePurgeDelay = routingTablePurgeDelay ? (0, _integer["int"])(routingTablePurgeDelay) : DEFAULT_ROUTING_TABLE_PURGE_DELAY;
    return _this;
  }

  (0, _createClass2["default"])(RoutingConnectionProvider, [{
    key: "_createConnectionErrorHandler",
    value: function _createConnectionErrorHandler() {
      // connection errors mean SERVICE_UNAVAILABLE for direct driver but for routing driver they should only
      // result in SESSION_EXPIRED because there might still exist other servers capable of serving the request
      return new _connectionErrorHandler["default"](_error.SESSION_EXPIRED);
    }
  }, {
    key: "_handleUnavailability",
    value: function _handleUnavailability(error, address, database) {
      this._log.warn("Routing driver ".concat(this._id, " will forget ").concat(address, " for database '").concat(database, "' because of an error ").concat(error.code, " '").concat(error.message, "'"));

      this.forget(address, database || '');
      return error;
    }
  }, {
    key: "_handleWriteFailure",
    value: function _handleWriteFailure(error, address, database) {
      this._log.warn("Routing driver ".concat(this._id, " will forget writer ").concat(address, " for database '").concat(database, "' because of an error ").concat(error.code, " '").concat(error.message, "'"));

      this.forgetWriter(address, database || '');
      return (0, _error.newError)('No longer possible to write to server at ' + address, _error.SESSION_EXPIRED);
    }
    /**
     * See {@link ConnectionProvider} for more information about this method and
     * its arguments.
     */

  }, {
    key: "acquireConnection",
    value: function () {
      var _acquireConnection = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var _this2 = this;

        var _ref2,
            accessMode,
            database,
            bookmark,
            name,
            address,
            databaseSpecificErrorHandler,
            routingTable,
            connection,
            transformed,
            _args = arguments;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _ref2 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, accessMode = _ref2.accessMode, database = _ref2.database, bookmark = _ref2.bookmark;
                databaseSpecificErrorHandler = new _connectionErrorHandler["default"](_error.SESSION_EXPIRED, function (error, address) {
                  return _this2._handleUnavailability(error, address, database);
                }, function (error, address) {
                  return _this2._handleWriteFailure(error, address, database);
                });
                _context.next = 4;
                return this._freshRoutingTable({
                  accessMode: accessMode,
                  database: database || DEFAULT_DB_NAME,
                  bookmark: bookmark
                });

              case 4:
                routingTable = _context.sent;

                if (!(accessMode === _driver.READ)) {
                  _context.next = 10;
                  break;
                }

                address = this._loadBalancingStrategy.selectReader(routingTable.readers);
                name = 'read';
                _context.next = 16;
                break;

              case 10:
                if (!(accessMode === _driver.WRITE)) {
                  _context.next = 15;
                  break;
                }

                address = this._loadBalancingStrategy.selectWriter(routingTable.writers);
                name = 'write';
                _context.next = 16;
                break;

              case 15:
                throw (0, _error.newError)('Illegal mode ' + accessMode);

              case 16:
                if (address) {
                  _context.next = 18;
                  break;
                }

                throw (0, _error.newError)("Failed to obtain connection towards ".concat(name, " server. Known routing table is: ").concat(routingTable), _error.SESSION_EXPIRED);

              case 18:
                _context.prev = 18;
                _context.next = 21;
                return this._acquireConnectionToServer(address, name, routingTable);

              case 21:
                connection = _context.sent;
                return _context.abrupt("return", new _connectionDelegate["default"](connection, databaseSpecificErrorHandler));

              case 25:
                _context.prev = 25;
                _context.t0 = _context["catch"](18);
                transformed = databaseSpecificErrorHandler.handleAndTransformError(_context.t0, address);
                throw transformed;

              case 29:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[18, 25]]);
      }));

      function acquireConnection() {
        return _acquireConnection.apply(this, arguments);
      }

      return acquireConnection;
    }()
  }, {
    key: "_hasProtocolVersion",
    value: function () {
      var _hasProtocolVersion2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(versionPredicate) {
        var addresses, lastError, i, connection, protocol;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._resolveSeedRouter(this._seedRouter);

              case 2:
                addresses = _context2.sent;
                i = 0;

              case 4:
                if (!(i < addresses.length)) {
                  _context2.next = 25;
                  break;
                }

                connection = _connectionChannel["default"].create(addresses[i], this._config, this._createConnectionErrorHandler(), this._log);
                _context2.prev = 6;
                _context2.next = 9;
                return connection._negotiateProtocol();

              case 9:
                protocol = connection.protocol();

                if (!protocol) {
                  _context2.next = 12;
                  break;
                }

                return _context2.abrupt("return", versionPredicate(protocol.version));

              case 12:
                return _context2.abrupt("return", false);

              case 15:
                _context2.prev = 15;
                _context2.t0 = _context2["catch"](6);
                lastError = _context2.t0;

              case 18:
                _context2.prev = 18;
                _context2.next = 21;
                return connection.close();

              case 21:
                return _context2.finish(18);

              case 22:
                i++;
                _context2.next = 4;
                break;

              case 25:
                if (!lastError) {
                  _context2.next = 27;
                  break;
                }

                throw lastError;

              case 27:
                return _context2.abrupt("return", false);

              case 28:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 15, 18, 22]]);
      }));

      function _hasProtocolVersion(_x) {
        return _hasProtocolVersion2.apply(this, arguments);
      }

      return _hasProtocolVersion;
    }()
  }, {
    key: "supportsMultiDb",
    value: function () {
      var _supportsMultiDb = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._hasProtocolVersion(function (version) {
                  return version >= _constants.BOLT_PROTOCOL_V4_0;
                });

              case 2:
                return _context3.abrupt("return", _context3.sent);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function supportsMultiDb() {
        return _supportsMultiDb.apply(this, arguments);
      }

      return supportsMultiDb;
    }()
  }, {
    key: "supportsTransactionConfig",
    value: function () {
      var _supportsTransactionConfig = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._hasProtocolVersion(function (version) {
                  return version >= _constants.BOLT_PROTOCOL_V3;
                });

              case 2:
                return _context4.abrupt("return", _context4.sent);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function supportsTransactionConfig() {
        return _supportsTransactionConfig.apply(this, arguments);
      }

      return supportsTransactionConfig;
    }()
  }, {
    key: "forget",
    value: function forget(address, database) {
      if (database || database === '') {
        this._routingTables[database].forget(address);
      } else {
        Object.values(this._routingTables).forEach(function (routingTable) {
          return routingTable.forget(address);
        });
      } // We're firing and forgetting this operation explicitly and listening for any
      // errors to avoid unhandled promise rejection


      this._connectionPool.purge(address)["catch"](function () {});
    }
  }, {
    key: "forgetWriter",
    value: function forgetWriter(address, database) {
      if (database || database === '') {
        this._routingTables[database].forgetWriter(address);
      } else {
        Object.values(this._routingTables).forEach(function (routingTable) {
          return routingTable.forgetWriter(address);
        });
      }
    }
  }, {
    key: "_acquireConnectionToServer",
    value: function _acquireConnectionToServer(address, serverName, routingTable) {
      return this._connectionPool.acquire(address);
    }
  }, {
    key: "_freshRoutingTable",
    value: function _freshRoutingTable() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          accessMode = _ref3.accessMode,
          database = _ref3.database,
          bookmark = _ref3.bookmark;

      var currentRoutingTable = this._routingTables[database] || new _routingTable["default"]({
        database: database
      });

      if (!currentRoutingTable.isStaleFor(accessMode)) {
        return currentRoutingTable;
      }

      this._log.info("Routing table is stale for database: \"".concat(database, "\" and access mode: \"").concat(accessMode, "\": ").concat(currentRoutingTable));

      return this._refreshRoutingTable(currentRoutingTable, bookmark);
    }
  }, {
    key: "_refreshRoutingTable",
    value: function _refreshRoutingTable(currentRoutingTable, bookmark) {
      var knownRouters = currentRoutingTable.routers;

      if (this._useSeedRouter) {
        return this._fetchRoutingTableFromSeedRouterFallbackToKnownRouters(knownRouters, currentRoutingTable, bookmark);
      }

      return this._fetchRoutingTableFromKnownRoutersFallbackToSeedRouter(knownRouters, currentRoutingTable, bookmark);
    }
  }, {
    key: "_fetchRoutingTableFromSeedRouterFallbackToKnownRouters",
    value: function () {
      var _fetchRoutingTableFromSeedRouterFallbackToKnownRouters2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(knownRouters, currentRoutingTable, bookmark) {
        var seenRouters, newRoutingTable;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                // we start with seed router, no routers were probed before
                seenRouters = [];
                _context5.next = 3;
                return this._fetchRoutingTableUsingSeedRouter(seenRouters, this._seedRouter, currentRoutingTable, bookmark);

              case 3:
                newRoutingTable = _context5.sent;

                if (!newRoutingTable) {
                  _context5.next = 8;
                  break;
                }

                this._useSeedRouter = false;
                _context5.next = 11;
                break;

              case 8:
                _context5.next = 10;
                return this._fetchRoutingTableUsingKnownRouters(knownRouters, currentRoutingTable, bookmark);

              case 10:
                newRoutingTable = _context5.sent;

              case 11:
                _context5.next = 13;
                return this._applyRoutingTableIfPossible(currentRoutingTable, newRoutingTable);

              case 13:
                return _context5.abrupt("return", _context5.sent);

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _fetchRoutingTableFromSeedRouterFallbackToKnownRouters(_x2, _x3, _x4) {
        return _fetchRoutingTableFromSeedRouterFallbackToKnownRouters2.apply(this, arguments);
      }

      return _fetchRoutingTableFromSeedRouterFallbackToKnownRouters;
    }()
  }, {
    key: "_fetchRoutingTableFromKnownRoutersFallbackToSeedRouter",
    value: function () {
      var _fetchRoutingTableFromKnownRoutersFallbackToSeedRouter2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(knownRouters, currentRoutingTable, bookmark) {
        var newRoutingTable;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this._fetchRoutingTableUsingKnownRouters(knownRouters, currentRoutingTable, bookmark);

              case 2:
                newRoutingTable = _context6.sent;

                if (newRoutingTable) {
                  _context6.next = 7;
                  break;
                }

                _context6.next = 6;
                return this._fetchRoutingTableUsingSeedRouter(knownRouters, this._seedRouter, currentRoutingTable, bookmark);

              case 6:
                newRoutingTable = _context6.sent;

              case 7:
                _context6.next = 9;
                return this._applyRoutingTableIfPossible(currentRoutingTable, newRoutingTable);

              case 9:
                return _context6.abrupt("return", _context6.sent);

              case 10:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _fetchRoutingTableFromKnownRoutersFallbackToSeedRouter(_x5, _x6, _x7) {
        return _fetchRoutingTableFromKnownRoutersFallbackToSeedRouter2.apply(this, arguments);
      }

      return _fetchRoutingTableFromKnownRoutersFallbackToSeedRouter;
    }()
  }, {
    key: "_fetchRoutingTableUsingKnownRouters",
    value: function () {
      var _fetchRoutingTableUsingKnownRouters2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(knownRouters, currentRoutingTable, bookmark) {
        var newRoutingTable, lastRouterIndex;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._fetchRoutingTable(knownRouters, currentRoutingTable, bookmark);

              case 2:
                newRoutingTable = _context7.sent;

                if (!newRoutingTable) {
                  _context7.next = 5;
                  break;
                }

                return _context7.abrupt("return", newRoutingTable);

              case 5:
                // returned routing table was undefined, this means a connection error happened and the last known
                // router did not return a valid routing table, so we need to forget it
                lastRouterIndex = knownRouters.length - 1;

                RoutingConnectionProvider._forgetRouter(currentRoutingTable, knownRouters, lastRouterIndex);

                return _context7.abrupt("return", null);

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _fetchRoutingTableUsingKnownRouters(_x8, _x9, _x10) {
        return _fetchRoutingTableUsingKnownRouters2.apply(this, arguments);
      }

      return _fetchRoutingTableUsingKnownRouters;
    }()
  }, {
    key: "_fetchRoutingTableUsingSeedRouter",
    value: function () {
      var _fetchRoutingTableUsingSeedRouter2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(seenRouters, seedRouter, routingTable, bookmark) {
        var resolvedAddresses, newAddresses;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this._resolveSeedRouter(seedRouter);

              case 2:
                resolvedAddresses = _context8.sent;
                // filter out all addresses that we've already tried
                newAddresses = resolvedAddresses.filter(function (address) {
                  return seenRouters.indexOf(address) < 0;
                });
                _context8.next = 6;
                return this._fetchRoutingTable(newAddresses, routingTable, bookmark);

              case 6:
                return _context8.abrupt("return", _context8.sent);

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _fetchRoutingTableUsingSeedRouter(_x11, _x12, _x13, _x14) {
        return _fetchRoutingTableUsingSeedRouter2.apply(this, arguments);
      }

      return _fetchRoutingTableUsingSeedRouter;
    }()
  }, {
    key: "_resolveSeedRouter",
    value: function () {
      var _resolveSeedRouter2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(seedRouter) {
        var _this3 = this;

        var resolvedAddresses, dnsResolvedAddresses;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._hostNameResolver.resolve(seedRouter);

              case 2:
                resolvedAddresses = _context9.sent;
                _context9.next = 5;
                return Promise.all(resolvedAddresses.map(function (address) {
                  return _this3._dnsResolver.resolve(address);
                }));

              case 5:
                dnsResolvedAddresses = _context9.sent;
                return _context9.abrupt("return", [].concat.apply([], dnsResolvedAddresses));

              case 7:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function _resolveSeedRouter(_x15) {
        return _resolveSeedRouter2.apply(this, arguments);
      }

      return _resolveSeedRouter;
    }()
  }, {
    key: "_fetchRoutingTable",
    value: function _fetchRoutingTable(routerAddresses, routingTable, bookmark) {
      var _this4 = this;

      return routerAddresses.reduce( /*#__PURE__*/function () {
        var _ref4 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(refreshedTablePromise, currentRouter, currentIndex) {
          var newRoutingTable, previousRouterIndex, session;
          return _regenerator["default"].wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  _context10.next = 2;
                  return refreshedTablePromise;

                case 2:
                  newRoutingTable = _context10.sent;

                  if (!newRoutingTable) {
                    _context10.next = 7;
                    break;
                  }

                  return _context10.abrupt("return", newRoutingTable);

                case 7:
                  // returned routing table was undefined, this means a connection error happened and we need to forget the
                  // previous router and try the next one
                  previousRouterIndex = currentIndex - 1;

                  RoutingConnectionProvider._forgetRouter(routingTable, routerAddresses, previousRouterIndex);

                case 9:
                  _context10.next = 11;
                  return _this4._createSessionForRediscovery(currentRouter, bookmark);

                case 11:
                  session = _context10.sent;

                  if (!session) {
                    _context10.next = 27;
                    break;
                  }

                  _context10.prev = 13;
                  _context10.next = 16;
                  return _this4._rediscovery.lookupRoutingTableOnRouter(session, routingTable.database, currentRouter);

                case 16:
                  return _context10.abrupt("return", _context10.sent);

                case 19:
                  _context10.prev = 19;
                  _context10.t0 = _context10["catch"](13);

                  if (!(_context10.t0 && _context10.t0.code === DATABASE_NOT_FOUND_ERROR_CODE)) {
                    _context10.next = 23;
                    break;
                  }

                  throw _context10.t0;

                case 23:
                  _this4._log.warn("unable to fetch routing table because of an error ".concat(_context10.t0));

                  return _context10.abrupt("return", null);

                case 25:
                  _context10.next = 28;
                  break;

                case 27:
                  return _context10.abrupt("return", null);

                case 28:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10, null, [[13, 19]]);
        }));

        return function (_x16, _x17, _x18) {
          return _ref4.apply(this, arguments);
        };
      }(), Promise.resolve(null));
    }
  }, {
    key: "_createSessionForRediscovery",
    value: function () {
      var _createSessionForRediscovery2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(routerAddress, bookmark) {
        var connection, connectionProvider, protocolVersion;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.prev = 0;
                _context11.next = 3;
                return this._connectionPool.acquire(routerAddress);

              case 3:
                connection = _context11.sent;
                connectionProvider = new _connectionProviderSingle["default"](connection);
                protocolVersion = connection.protocol().version;

                if (!(protocolVersion < 4.0)) {
                  _context11.next = 8;
                  break;
                }

                return _context11.abrupt("return", new _session["default"]({
                  mode: _driver.WRITE,
                  bookmark: _bookmark["default"].empty(),
                  connectionProvider: connectionProvider
                }));

              case 8:
                return _context11.abrupt("return", new _session["default"]({
                  mode: _driver.READ,
                  database: SYSTEM_DB_NAME,
                  bookmark: bookmark,
                  connectionProvider: connectionProvider
                }));

              case 11:
                _context11.prev = 11;
                _context11.t0 = _context11["catch"](0);

                if (!(_context11.t0 && _context11.t0.code === UNAUTHORIZED_ERROR_CODE)) {
                  _context11.next = 15;
                  break;
                }

                throw _context11.t0;

              case 15:
                return _context11.abrupt("return", null);

              case 16:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[0, 11]]);
      }));

      function _createSessionForRediscovery(_x19, _x20) {
        return _createSessionForRediscovery2.apply(this, arguments);
      }

      return _createSessionForRediscovery;
    }()
  }, {
    key: "_applyRoutingTableIfPossible",
    value: function () {
      var _applyRoutingTableIfPossible2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12(currentRoutingTable, newRoutingTable) {
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (newRoutingTable) {
                  _context12.next = 2;
                  break;
                }

                throw (0, _error.newError)("Could not perform discovery. No routing servers available. Known routing table: ".concat(currentRoutingTable), _error.SERVICE_UNAVAILABLE);

              case 2:
                if (newRoutingTable.writers.length === 0) {
                  // use seed router next time. this is important when cluster is partitioned. it tries to make sure driver
                  // does not always get routing table without writers because it talks exclusively to a minority partition
                  this._useSeedRouter = true;
                }

                _context12.next = 5;
                return this._updateRoutingTable(newRoutingTable);

              case 5:
                return _context12.abrupt("return", newRoutingTable);

              case 6:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function _applyRoutingTableIfPossible(_x21, _x22) {
        return _applyRoutingTableIfPossible2.apply(this, arguments);
      }

      return _applyRoutingTableIfPossible;
    }()
  }, {
    key: "_updateRoutingTable",
    value: function () {
      var _updateRoutingTable2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13(newRoutingTable) {
        var _this5 = this;

        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this._connectionPool.keepAll(newRoutingTable.allServers());

              case 2:
                // filter out expired to purge (expired for a pre-configured amount of time) routing table entries
                Object.values(this._routingTables).forEach(function (value) {
                  if (value.isExpiredFor(_this5._routingTablePurgeDelay)) {
                    delete _this5._routingTables[value.database];
                  }
                }); // make this driver instance aware of the new table

                this._routingTables[newRoutingTable.database] = newRoutingTable;

                this._log.info("Updated routing table ".concat(newRoutingTable));

              case 5:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function _updateRoutingTable(_x23) {
        return _updateRoutingTable2.apply(this, arguments);
      }

      return _updateRoutingTable;
    }()
  }], [{
    key: "_forgetRouter",
    value: function _forgetRouter(routingTable, routersArray, routerIndex) {
      var address = routersArray[routerIndex];

      if (routingTable && address) {
        routingTable.forgetRouter(address);
      }
    }
  }]);
  return RoutingConnectionProvider;
}(_connectionProviderPooled["default"]);

exports["default"] = RoutingConnectionProvider;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-provider-single.js":
/*!******************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-provider-single.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _connectionProvider = _interopRequireDefault(__webpack_require__(/*! ./connection-provider */ "./node_modules/neo4j-driver/lib/internal/connection-provider.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var SingleConnectionProvider = /*#__PURE__*/function (_ConnectionProvider) {
  (0, _inherits2["default"])(SingleConnectionProvider, _ConnectionProvider);

  var _super = _createSuper(SingleConnectionProvider);

  function SingleConnectionProvider(connection) {
    var _this;

    (0, _classCallCheck2["default"])(this, SingleConnectionProvider);
    _this = _super.call(this);
    _this._connection = connection;
    return _this;
  }
  /**
   * See {@link ConnectionProvider} for more information about this method and
   * its arguments.
   */


  (0, _createClass2["default"])(SingleConnectionProvider, [{
    key: "acquireConnection",
    value: function acquireConnection() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          accessMode = _ref.accessMode,
          database = _ref.database,
          bookmarks = _ref.bookmarks;

      var connection = this._connection;
      this._connection = null;
      return Promise.resolve(connection);
    }
  }]);
  return SingleConnectionProvider;
}(_connectionProvider["default"]);

exports["default"] = SingleConnectionProvider;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-provider.js":
/*!***********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-provider.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ConnectionProvider = /*#__PURE__*/function () {
  function ConnectionProvider() {
    (0, _classCallCheck2["default"])(this, ConnectionProvider);
  }

  (0, _createClass2["default"])(ConnectionProvider, [{
    key: "acquireConnection",

    /**
     * This method acquires a connection against the specified database.
     *
     * Access mode and Bookmarks only applies to routing driver. Access mode only
     * differentiates the target server for the connection, where WRITE selects a
     * WRITER server, whereas READ selects a READ server. Bookmarks, when specified,
     * is only passed to the routing discovery procedure, for the system database to
     * synchronize on creation of databases and is never used in direct drivers.
     *
     * @param {object} param - object parameter
     * @param {string} param.accessMode - the access mode for the to-be-acquired connection
     * @param {string} param.database - the target database for the to-be-acquired connection
     * @param {Bookmark} param.bookmarks - the bookmarks to send to routing discovery
     */
    value: function acquireConnection() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          accessMode = _ref.accessMode,
          database = _ref.database,
          bookmarks = _ref.bookmarks;

      throw new Error('not implemented');
    }
    /**
     * This method checks whether the backend database supports multi database functionality
     * by checking protocol handshake result.
     *
     * @returns {Promise<boolean>}
     */

  }, {
    key: "supportsMultiDb",
    value: function supportsMultiDb() {
      throw new Error('not implemented');
    }
    /**
     * This method checks whether the backend database supports transaction config functionality
     * by checking protocol handshake result.
     *
     * @returns {Promise<boolean>}
     */

  }, {
    key: "supportsTransactionConfig",
    value: function supportsTransactionConfig() {
      throw new Error('not implemented');
    }
    /**
     * Closes this connection provider along with its internals (connections, pools, etc.)
     *
     * @returns {Promise<void>}
     */

  }, {
    key: "close",
    value: function close() {
      throw new Error('not implemented');
    }
  }]);
  return ConnectionProvider;
}();

exports["default"] = ConnectionProvider;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection.js":
/*!**************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

var _boltProtocolV = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v1 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v1.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Connection = /*#__PURE__*/function () {
  /**
   * @param {ConnectionErrorHandler} errorHandler the error handler
   */
  function Connection(errorHandler) {
    (0, _classCallCheck2["default"])(this, Connection);
    this._errorHandler = errorHandler;
  }

  (0, _createClass2["default"])(Connection, [{
    key: "isOpen",

    /**
     * @returns {boolean} whether this connection is in a working condition
     */
    value: function isOpen() {
      throw new Error('not implemented');
    }
    /**
     * @returns {BoltProtocol} the underlying bolt protocol assigned to this connection
     */

  }, {
    key: "protocol",
    value: function protocol() {
      throw new Error('not implemented');
    }
    /**
     * @returns {ServerAddress} the server address this connection is opened against
     */

  }, {
    key: "connect",

    /**
     * Connect to the target address, negotiate Bolt protocol and send initialization message.
     * @param {string} userAgent the user agent for this driver.
     * @param {Object} authToken the object containing auth information.
     * @return {Promise<Connection>} promise resolved with the current connection if connection is successful. Rejected promise otherwise.
     */
    value: function connect(userAgent, authToken) {
      throw new Error('not implemented');
    }
    /**
     * Write a message to the network channel.
     * @param {RequestMessage} message the message to write.
     * @param {ResultStreamObserver} observer the response observer.
     * @param {boolean} flush `true` if flush should happen after the message is written to the buffer.
     */

  }, {
    key: "write",
    value: function write(message, observer, flush) {
      throw new Error('not implemented');
    }
    /**
     * Send a RESET-message to the database. Message is immediately flushed to the network.
     * @return {Promise<void>} promise resolved when SUCCESS-message response arrives, or failed when other response messages arrives.
     */

  }, {
    key: "resetAndFlush",
    value: function resetAndFlush() {
      throw new Error('not implemented');
    }
    /**
     * Call close on the channel.
     * @returns {Promise<void>} - A promise that will be resolved when the connection is closed.
     *
     */

  }, {
    key: "close",
    value: function close() {
      throw new Error('not implemented');
    }
    /**
     *
     * @param error
     * @param address
     * @returns {Neo4jError|*}
     */

  }, {
    key: "handleAndTransformError",
    value: function handleAndTransformError(error, address) {
      if (this._errorHandler) {
        return this._errorHandler.handleAndTransformError(error, address);
      }

      return error;
    }
  }, {
    key: "id",
    get: function get() {
      throw new Error('not implemented');
    }
  }, {
    key: "databaseId",
    get: function get() {
      throw new Error('not implemented');
    },
    set: function set(value) {
      throw new Error('not implemented');
    }
  }, {
    key: "address",
    get: function get() {
      throw new Error('not implemented');
    }
    /**
     * @returns {ServerVersion} the version of the server this connection is connected to
     */

  }, {
    key: "version",
    get: function get() {
      throw new Error('not implemented');
    },
    set: function set(value) {
      throw new Error('not implemented');
    }
  }, {
    key: "server",
    get: function get() {
      throw new Error('not implemented');
    }
  }]);
  return Connection;
}();

exports["default"] = Connection;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connectivity-verifier.js":
/*!*************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connectivity-verifier.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _connectionHolder = _interopRequireDefault(__webpack_require__(/*! ./connection-holder */ "./node_modules/neo4j-driver/lib/internal/connection-holder.js"));

var _driver = __webpack_require__(/*! ../driver */ "./node_modules/neo4j-driver/lib/driver.js");

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Verifies connectivity using the given connection provider.
 */
var ConnectivityVerifier = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {ConnectionProvider} connectionProvider the provider to obtain connections from.
   */
  function ConnectivityVerifier(connectionProvider) {
    (0, _classCallCheck2["default"])(this, ConnectivityVerifier);
    this._connectionProvider = connectionProvider;
  }
  /**
   * Try to obtain a working connection from the connection provider.
   * @returns {Promise<object>} promise resolved with server info or rejected with error.
   */


  (0, _createClass2["default"])(ConnectivityVerifier, [{
    key: "verify",
    value: function verify() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$database = _ref.database,
          database = _ref$database === void 0 ? '' : _ref$database;

      return acquireAndReleaseDummyConnection(this._connectionProvider, database);
    }
  }]);
  return ConnectivityVerifier;
}();
/**
 * @private
 * @param {ConnectionProvider} connectionProvider the provider to obtain connections from.
 * @return {Promise<object>} promise resolved with server info or rejected with error.
 */


exports["default"] = ConnectivityVerifier;

function acquireAndReleaseDummyConnection(connectionProvider, database) {
  var connectionHolder = new _connectionHolder["default"]({
    mode: _driver.READ,
    database: database,
    connectionProvider: connectionProvider
  });
  connectionHolder.initializeConnection();
  return connectionHolder.getConnection().then(function (connection) {
    // able to establish a connection
    return connectionHolder.close().then(function () {
      return connection.server;
    });
  })["catch"](function (error) {
    // failed to establish a connection
    return connectionHolder.close()["catch"](function (ignoredError) {// ignore connection release error
    }).then(function () {
      return Promise.reject(error);
    });
  });
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/constants.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BOLT_PROTOCOL_V4_1 = exports.BOLT_PROTOCOL_V4_0 = exports.BOLT_PROTOCOL_V3 = exports.BOLT_PROTOCOL_V2 = exports.BOLT_PROTOCOL_V1 = exports.ACCESS_MODE_WRITE = exports.ACCESS_MODE_READ = void 0;

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ACCESS_MODE_READ = 'READ';
exports.ACCESS_MODE_READ = ACCESS_MODE_READ;
var ACCESS_MODE_WRITE = 'WRITE';
exports.ACCESS_MODE_WRITE = ACCESS_MODE_WRITE;
var BOLT_PROTOCOL_V1 = 1;
exports.BOLT_PROTOCOL_V1 = BOLT_PROTOCOL_V1;
var BOLT_PROTOCOL_V2 = 2;
exports.BOLT_PROTOCOL_V2 = BOLT_PROTOCOL_V2;
var BOLT_PROTOCOL_V3 = 3;
exports.BOLT_PROTOCOL_V3 = BOLT_PROTOCOL_V3;
var BOLT_PROTOCOL_V4_0 = 4.0;
exports.BOLT_PROTOCOL_V4_0 = BOLT_PROTOCOL_V4_0;
var BOLT_PROTOCOL_V4_1 = 4.1;
exports.BOLT_PROTOCOL_V4_1 = BOLT_PROTOCOL_V4_1;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/least-connected-load-balancing-strategy.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/least-connected-load-balancing-strategy.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _roundRobinArrayIndex = _interopRequireDefault(__webpack_require__(/*! ./round-robin-array-index */ "./node_modules/neo4j-driver/lib/internal/round-robin-array-index.js"));

var _loadBalancingStrategy = _interopRequireDefault(__webpack_require__(/*! ./load-balancing-strategy */ "./node_modules/neo4j-driver/lib/internal/load-balancing-strategy.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var LeastConnectedLoadBalancingStrategy = /*#__PURE__*/function (_LoadBalancingStrateg) {
  (0, _inherits2["default"])(LeastConnectedLoadBalancingStrategy, _LoadBalancingStrateg);

  var _super = _createSuper(LeastConnectedLoadBalancingStrategy);

  /**
   * @constructor
   * @param {Pool} connectionPool the connection pool of this driver.
   */
  function LeastConnectedLoadBalancingStrategy(connectionPool) {
    var _this;

    (0, _classCallCheck2["default"])(this, LeastConnectedLoadBalancingStrategy);
    _this = _super.call(this);
    _this._readersIndex = new _roundRobinArrayIndex["default"]();
    _this._writersIndex = new _roundRobinArrayIndex["default"]();
    _this._connectionPool = connectionPool;
    return _this;
  }
  /**
   * @inheritDoc
   */


  (0, _createClass2["default"])(LeastConnectedLoadBalancingStrategy, [{
    key: "selectReader",
    value: function selectReader(knownReaders) {
      return this._select(knownReaders, this._readersIndex);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "selectWriter",
    value: function selectWriter(knownWriters) {
      return this._select(knownWriters, this._writersIndex);
    }
  }, {
    key: "_select",
    value: function _select(addresses, roundRobinIndex) {
      var length = addresses.length;

      if (length === 0) {
        return null;
      } // choose start index for iteration in round-robin fashion


      var startIndex = roundRobinIndex.next(length);
      var index = startIndex;
      var leastConnectedAddress = null;
      var leastActiveConnections = Number.MAX_SAFE_INTEGER; // iterate over the array to find least connected address

      do {
        var address = addresses[index];

        var activeConnections = this._connectionPool.activeResourceCount(address);

        if (activeConnections < leastActiveConnections) {
          leastConnectedAddress = address;
          leastActiveConnections = activeConnections;
        } // loop over to the start of the array when end is reached


        if (index === length - 1) {
          index = 0;
        } else {
          index++;
        }
      } while (index !== startIndex);

      return leastConnectedAddress;
    }
  }]);
  return LeastConnectedLoadBalancingStrategy;
}(_loadBalancingStrategy["default"]);

exports["default"] = LeastConnectedLoadBalancingStrategy;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/load-balancing-strategy.js":
/*!***************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/load-balancing-strategy.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A facility to select most appropriate reader or writer among the given addresses for request processing.
 */
var LoadBalancingStrategy = /*#__PURE__*/function () {
  function LoadBalancingStrategy() {
    (0, _classCallCheck2["default"])(this, LoadBalancingStrategy);
  }

  (0, _createClass2["default"])(LoadBalancingStrategy, [{
    key: "selectReader",

    /**
     * Select next most appropriate reader from the list of given readers.
     * @param {string[]} knownReaders an array of currently known readers to select from.
     * @return {string} most appropriate reader or `null` if given array is empty.
     */
    value: function selectReader(knownReaders) {
      throw new Error('Abstract function');
    }
    /**
     * Select next most appropriate writer from the list of given writers.
     * @param {string[]} knownWriters an array of currently known writers to select from.
     * @return {string} most appropriate writer or `null` if given array is empty.
     */

  }, {
    key: "selectWriter",
    value: function selectWriter(knownWriters) {
      throw new Error('Abstract function');
    }
  }]);
  return LoadBalancingStrategy;
}();

exports["default"] = LoadBalancingStrategy;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/logger.js":
/*!**********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/logger.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _levels;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var ERROR = 'error';
var WARN = 'warn';
var INFO = 'info';
var DEBUG = 'debug';
var DEFAULT_LEVEL = INFO;
var levels = (_levels = {}, (0, _defineProperty2["default"])(_levels, ERROR, 0), (0, _defineProperty2["default"])(_levels, WARN, 1), (0, _defineProperty2["default"])(_levels, INFO, 2), (0, _defineProperty2["default"])(_levels, DEBUG, 3), _levels);
/**
 * Logger used by the driver to notify about various internal events. Single logger should be used per driver.
 */

var Logger = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {string} level the enabled logging level.
   * @param {function(level: string, message: string)} loggerFunction the function to write the log level and message.
   */
  function Logger(level, loggerFunction) {
    (0, _classCallCheck2["default"])(this, Logger);
    this._level = level;
    this._loggerFunction = loggerFunction;
  }
  /**
   * Create a new logger based on the given driver configuration.
   * @param {Object} driverConfig the driver configuration as supplied by the user.
   * @return {Logger} a new logger instance or a no-op logger when not configured.
   */


  (0, _createClass2["default"])(Logger, [{
    key: "isErrorEnabled",

    /**
     * Check if error logging is enabled, i.e. it is not a no-op implementation.
     * @return {boolean} `true` when enabled, `false` otherwise.
     */
    value: function isErrorEnabled() {
      return isLevelEnabled(this._level, ERROR);
    }
    /**
     * Log an error message.
     * @param {string} message the message to log.
     */

  }, {
    key: "error",
    value: function error(message) {
      if (this.isErrorEnabled()) {
        this._loggerFunction(ERROR, message);
      }
    }
    /**
     * Check if warn logging is enabled, i.e. it is not a no-op implementation.
     * @return {boolean} `true` when enabled, `false` otherwise.
     */

  }, {
    key: "isWarnEnabled",
    value: function isWarnEnabled() {
      return isLevelEnabled(this._level, WARN);
    }
    /**
     * Log an warning message.
     * @param {string} message the message to log.
     */

  }, {
    key: "warn",
    value: function warn(message) {
      if (this.isWarnEnabled()) {
        this._loggerFunction(WARN, message);
      }
    }
    /**
     * Check if info logging is enabled, i.e. it is not a no-op implementation.
     * @return {boolean} `true` when enabled, `false` otherwise.
     */

  }, {
    key: "isInfoEnabled",
    value: function isInfoEnabled() {
      return isLevelEnabled(this._level, INFO);
    }
    /**
     * Log an info message.
     * @param {string} message the message to log.
     */

  }, {
    key: "info",
    value: function info(message) {
      if (this.isInfoEnabled()) {
        this._loggerFunction(INFO, message);
      }
    }
    /**
     * Check if debug logging is enabled, i.e. it is not a no-op implementation.
     * @return {boolean} `true` when enabled, `false` otherwise.
     */

  }, {
    key: "isDebugEnabled",
    value: function isDebugEnabled() {
      return isLevelEnabled(this._level, DEBUG);
    }
    /**
     * Log a debug message.
     * @param {string} message the message to log.
     */

  }, {
    key: "debug",
    value: function debug(message) {
      if (this.isDebugEnabled()) {
        this._loggerFunction(DEBUG, message);
      }
    }
  }], [{
    key: "create",
    value: function create(driverConfig) {
      if (driverConfig && driverConfig.logging) {
        var loggingConfig = driverConfig.logging;
        var level = extractConfiguredLevel(loggingConfig);
        var loggerFunction = extractConfiguredLogger(loggingConfig);
        return new Logger(level, loggerFunction);
      }

      return this.noOp();
    }
    /**
     * Create a no-op logger implementation.
     * @return {Logger} the no-op logger implementation.
     */

  }, {
    key: "noOp",
    value: function noOp() {
      return noOpLogger;
    }
  }]);
  return Logger;
}();

var NoOpLogger = /*#__PURE__*/function (_Logger) {
  (0, _inherits2["default"])(NoOpLogger, _Logger);

  var _super = _createSuper(NoOpLogger);

  function NoOpLogger() {
    (0, _classCallCheck2["default"])(this, NoOpLogger);
    return _super.call(this, null, null);
  }

  (0, _createClass2["default"])(NoOpLogger, [{
    key: "isErrorEnabled",
    value: function isErrorEnabled() {
      return false;
    }
  }, {
    key: "error",
    value: function error(message) {}
  }, {
    key: "isWarnEnabled",
    value: function isWarnEnabled() {
      return false;
    }
  }, {
    key: "warn",
    value: function warn(message) {}
  }, {
    key: "isInfoEnabled",
    value: function isInfoEnabled() {
      return false;
    }
  }, {
    key: "info",
    value: function info(message) {}
  }, {
    key: "isDebugEnabled",
    value: function isDebugEnabled() {
      return false;
    }
  }, {
    key: "debug",
    value: function debug(message) {}
  }]);
  return NoOpLogger;
}(Logger);

var noOpLogger = new NoOpLogger();
/**
 * Check if the given logging level is enabled.
 * @param {string} configuredLevel the configured level.
 * @param {string} targetLevel the level to check.
 * @return {boolean} value of `true` when enabled, `false` otherwise.
 */

function isLevelEnabled(configuredLevel, targetLevel) {
  return levels[configuredLevel] >= levels[targetLevel];
}
/**
 * Extract the configured logging level from the driver's logging configuration.
 * @param {Object} loggingConfig the logging configuration.
 * @return {string} the configured log level or default when none configured.
 */


function extractConfiguredLevel(loggingConfig) {
  if (loggingConfig && loggingConfig.level) {
    var configuredLevel = loggingConfig.level;
    var value = levels[configuredLevel];

    if (!value && value !== 0) {
      throw (0, _error.newError)("Illegal logging level: ".concat(configuredLevel, ". Supported levels are: ").concat(Object.keys(levels)));
    }

    return configuredLevel;
  }

  return DEFAULT_LEVEL;
}
/**
 * Extract the configured logger function from the driver's logging configuration.
 * @param {Object} loggingConfig the logging configuration.
 * @return {function(level: string, message: string)} the configured logging function.
 */


function extractConfiguredLogger(loggingConfig) {
  if (loggingConfig && loggingConfig.logger) {
    var configuredLogger = loggingConfig.logger;

    if (configuredLogger && typeof configuredLogger === 'function') {
      return configuredLogger;
    }
  }

  throw (0, _error.newError)("Illegal logger function: ".concat(loggingConfig.logger));
}

var _default = Logger;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/packstream-v1.js":
/*!*****************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/packstream-v1.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Structure = exports.Unpacker = exports.Packer = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _node = __webpack_require__(/*! ./node */ "./node_modules/neo4j-driver/lib/internal/browser/index.js");

var _integer = _interopRequireWildcard(__webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _graphTypes = __webpack_require__(/*! ../graph-types */ "./node_modules/neo4j-driver/lib/graph-types.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TINY_STRING = 0x80;
var TINY_LIST = 0x90;
var TINY_MAP = 0xa0;
var TINY_STRUCT = 0xb0;
var NULL = 0xc0;
var FLOAT_64 = 0xc1;
var FALSE = 0xc2;
var TRUE = 0xc3;
var INT_8 = 0xc8;
var INT_16 = 0xc9;
var INT_32 = 0xca;
var INT_64 = 0xcb;
var STRING_8 = 0xd0;
var STRING_16 = 0xd1;
var STRING_32 = 0xd2;
var LIST_8 = 0xd4;
var LIST_16 = 0xd5;
var LIST_32 = 0xd6;
var BYTES_8 = 0xcc;
var BYTES_16 = 0xcd;
var BYTES_32 = 0xce;
var MAP_8 = 0xd8;
var MAP_16 = 0xd9;
var MAP_32 = 0xda;
var STRUCT_8 = 0xdc;
var STRUCT_16 = 0xdd;
var NODE = 0x4e;
var NODE_STRUCT_SIZE = 3;
var RELATIONSHIP = 0x52;
var RELATIONSHIP_STRUCT_SIZE = 5;
var UNBOUND_RELATIONSHIP = 0x72;
var UNBOUND_RELATIONSHIP_STRUCT_SIZE = 3;
var PATH = 0x50;
var PATH_STRUCT_SIZE = 3;
/**
 * A Structure have a signature and fields.
 * @access private
 */

var Structure = /*#__PURE__*/function () {
  /**
   * Create new instance
   */
  function Structure(signature, fields) {
    (0, _classCallCheck2["default"])(this, Structure);
    this.signature = signature;
    this.fields = fields;
  }

  (0, _createClass2["default"])(Structure, [{
    key: "toString",
    value: function toString() {
      var fieldStr = '';

      for (var i = 0; i < this.fields.length; i++) {
        if (i > 0) {
          fieldStr += ', ';
        }

        fieldStr += this.fields[i];
      }

      return 'Structure(' + this.signature + ', [' + fieldStr + '])';
    }
  }]);
  return Structure;
}();
/**
 * Class to pack
 * @access private
 */


exports.Structure = Structure;

var Packer = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Chunker} channel the chunker backed by a network channel.
   */
  function Packer(channel) {
    (0, _classCallCheck2["default"])(this, Packer);
    this._ch = channel;
    this._byteArraysSupported = true;
  }
  /**
   * Creates a packable function out of the provided value
   * @param x the value to pack
   * @returns Function
   */


  (0, _createClass2["default"])(Packer, [{
    key: "packable",
    value: function packable(x) {
      var _this = this;

      if (x === null) {
        return function () {
          return _this._ch.writeUInt8(NULL);
        };
      } else if (x === true) {
        return function () {
          return _this._ch.writeUInt8(TRUE);
        };
      } else if (x === false) {
        return function () {
          return _this._ch.writeUInt8(FALSE);
        };
      } else if (typeof x === 'number') {
        return function () {
          return _this.packFloat(x);
        };
      } else if (typeof x === 'string') {
        return function () {
          return _this.packString(x);
        };
      } else if ((0, _integer.isInt)(x)) {
        return function () {
          return _this.packInteger(x);
        };
      } else if (x instanceof Int8Array) {
        return function () {
          return _this.packBytes(x);
        };
      } else if (x instanceof Array) {
        return function () {
          _this.packListHeader(x.length);

          for (var _i = 0; _i < x.length; _i++) {
            _this.packable(x[_i] === undefined ? null : x[_i])();
          }
        };
      } else if (isIterable(x)) {
        return this.packableIterable(x);
      } else if (x instanceof _graphTypes.Node) {
        return this._nonPackableValue("It is not allowed to pass nodes in query parameters, given: ".concat(x));
      } else if (x instanceof _graphTypes.Relationship) {
        return this._nonPackableValue("It is not allowed to pass relationships in query parameters, given: ".concat(x));
      } else if (x instanceof _graphTypes.Path) {
        return this._nonPackableValue("It is not allowed to pass paths in query parameters, given: ".concat(x));
      } else if (x instanceof Structure) {
        var packableFields = [];

        for (var i = 0; i < x.fields.length; i++) {
          packableFields[i] = this.packable(x.fields[i]);
        }

        return function () {
          return _this.packStruct(x.signature, packableFields);
        };
      } else if ((0, _typeof2["default"])(x) === 'object') {
        return function () {
          var keys = Object.keys(x);
          var count = 0;

          for (var _i2 = 0; _i2 < keys.length; _i2++) {
            if (x[keys[_i2]] !== undefined) {
              count++;
            }
          }

          _this.packMapHeader(count);

          for (var _i3 = 0; _i3 < keys.length; _i3++) {
            var key = keys[_i3];

            if (x[key] !== undefined) {
              _this.packString(key);

              _this.packable(x[key])();
            }
          }
        };
      } else {
        return this._nonPackableValue("Unable to pack the given value: ".concat(x));
      }
    }
  }, {
    key: "packableIterable",
    value: function packableIterable(iterable) {
      try {
        var array = Array.from(iterable);
        return this.packable(array);
      } catch (e) {
        // handle errors from iterable to array conversion
        throw (0, _error.newError)("Cannot pack given iterable, ".concat(e.message, ": ").concat(iterable));
      }
    }
    /**
     * Packs a struct
     * @param signature the signature of the struct
     * @param packableFields the fields of the struct, make sure you call `packable on all fields`
     */

  }, {
    key: "packStruct",
    value: function packStruct(signature, packableFields) {
      packableFields = packableFields || [];
      this.packStructHeader(packableFields.length, signature);

      for (var i = 0; i < packableFields.length; i++) {
        packableFields[i]();
      }
    }
  }, {
    key: "packInteger",
    value: function packInteger(x) {
      var high = x.high;
      var low = x.low;

      if (x.greaterThanOrEqual(-0x10) && x.lessThan(0x80)) {
        this._ch.writeInt8(low);
      } else if (x.greaterThanOrEqual(-0x80) && x.lessThan(-0x10)) {
        this._ch.writeUInt8(INT_8);

        this._ch.writeInt8(low);
      } else if (x.greaterThanOrEqual(-0x8000) && x.lessThan(0x8000)) {
        this._ch.writeUInt8(INT_16);

        this._ch.writeInt16(low);
      } else if (x.greaterThanOrEqual(-0x80000000) && x.lessThan(0x80000000)) {
        this._ch.writeUInt8(INT_32);

        this._ch.writeInt32(low);
      } else {
        this._ch.writeUInt8(INT_64);

        this._ch.writeInt32(high);

        this._ch.writeInt32(low);
      }
    }
  }, {
    key: "packFloat",
    value: function packFloat(x) {
      this._ch.writeUInt8(FLOAT_64);

      this._ch.writeFloat64(x);
    }
  }, {
    key: "packString",
    value: function packString(x) {
      var bytes = _node.utf8.encode(x);

      var size = bytes.length;

      if (size < 0x10) {
        this._ch.writeUInt8(TINY_STRING | size);

        this._ch.writeBytes(bytes);
      } else if (size < 0x100) {
        this._ch.writeUInt8(STRING_8);

        this._ch.writeUInt8(size);

        this._ch.writeBytes(bytes);
      } else if (size < 0x10000) {
        this._ch.writeUInt8(STRING_16);

        this._ch.writeUInt8(size / 256 >> 0);

        this._ch.writeUInt8(size % 256);

        this._ch.writeBytes(bytes);
      } else if (size < 0x100000000) {
        this._ch.writeUInt8(STRING_32);

        this._ch.writeUInt8((size / 16777216 >> 0) % 256);

        this._ch.writeUInt8((size / 65536 >> 0) % 256);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);

        this._ch.writeBytes(bytes);
      } else {
        throw (0, _error.newError)('UTF-8 strings of size ' + size + ' are not supported');
      }
    }
  }, {
    key: "packListHeader",
    value: function packListHeader(size) {
      if (size < 0x10) {
        this._ch.writeUInt8(TINY_LIST | size);
      } else if (size < 0x100) {
        this._ch.writeUInt8(LIST_8);

        this._ch.writeUInt8(size);
      } else if (size < 0x10000) {
        this._ch.writeUInt8(LIST_16);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);
      } else if (size < 0x100000000) {
        this._ch.writeUInt8(LIST_32);

        this._ch.writeUInt8((size / 16777216 >> 0) % 256);

        this._ch.writeUInt8((size / 65536 >> 0) % 256);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);
      } else {
        throw (0, _error.newError)('Lists of size ' + size + ' are not supported');
      }
    }
  }, {
    key: "packBytes",
    value: function packBytes(array) {
      if (this._byteArraysSupported) {
        this.packBytesHeader(array.length);

        for (var i = 0; i < array.length; i++) {
          this._ch.writeInt8(array[i]);
        }
      } else {
        throw (0, _error.newError)('Byte arrays are not supported by the database this driver is connected to');
      }
    }
  }, {
    key: "packBytesHeader",
    value: function packBytesHeader(size) {
      if (size < 0x100) {
        this._ch.writeUInt8(BYTES_8);

        this._ch.writeUInt8(size);
      } else if (size < 0x10000) {
        this._ch.writeUInt8(BYTES_16);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);
      } else if (size < 0x100000000) {
        this._ch.writeUInt8(BYTES_32);

        this._ch.writeUInt8((size / 16777216 >> 0) % 256);

        this._ch.writeUInt8((size / 65536 >> 0) % 256);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);
      } else {
        throw (0, _error.newError)('Byte arrays of size ' + size + ' are not supported');
      }
    }
  }, {
    key: "packMapHeader",
    value: function packMapHeader(size) {
      if (size < 0x10) {
        this._ch.writeUInt8(TINY_MAP | size);
      } else if (size < 0x100) {
        this._ch.writeUInt8(MAP_8);

        this._ch.writeUInt8(size);
      } else if (size < 0x10000) {
        this._ch.writeUInt8(MAP_16);

        this._ch.writeUInt8(size / 256 >> 0);

        this._ch.writeUInt8(size % 256);
      } else if (size < 0x100000000) {
        this._ch.writeUInt8(MAP_32);

        this._ch.writeUInt8((size / 16777216 >> 0) % 256);

        this._ch.writeUInt8((size / 65536 >> 0) % 256);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);
      } else {
        throw (0, _error.newError)('Maps of size ' + size + ' are not supported');
      }
    }
  }, {
    key: "packStructHeader",
    value: function packStructHeader(size, signature) {
      if (size < 0x10) {
        this._ch.writeUInt8(TINY_STRUCT | size);

        this._ch.writeUInt8(signature);
      } else if (size < 0x100) {
        this._ch.writeUInt8(STRUCT_8);

        this._ch.writeUInt8(size);

        this._ch.writeUInt8(signature);
      } else if (size < 0x10000) {
        this._ch.writeUInt8(STRUCT_16);

        this._ch.writeUInt8(size / 256 >> 0);

        this._ch.writeUInt8(size % 256);
      } else {
        throw (0, _error.newError)('Structures of size ' + size + ' are not supported');
      }
    }
  }, {
    key: "disableByteArrays",
    value: function disableByteArrays() {
      this._byteArraysSupported = false;
    }
  }, {
    key: "_nonPackableValue",
    value: function _nonPackableValue(message) {
      return function () {
        throw (0, _error.newError)(message, _error.PROTOCOL_ERROR);
      };
    }
  }]);
  return Packer;
}();
/**
 * Class to unpack
 * @access private
 */


exports.Packer = Packer;

var Unpacker = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.
   */
  function Unpacker() {
    var disableLosslessIntegers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    (0, _classCallCheck2["default"])(this, Unpacker);
    this._disableLosslessIntegers = disableLosslessIntegers;
  }

  (0, _createClass2["default"])(Unpacker, [{
    key: "unpack",
    value: function unpack(buffer) {
      var marker = buffer.readUInt8();
      var markerHigh = marker & 0xf0;
      var markerLow = marker & 0x0f;

      if (marker === NULL) {
        return null;
      }

      var _boolean = this._unpackBoolean(marker);

      if (_boolean !== null) {
        return _boolean;
      }

      var numberOrInteger = this._unpackNumberOrInteger(marker, buffer);

      if (numberOrInteger !== null) {
        if (this._disableLosslessIntegers && (0, _integer.isInt)(numberOrInteger)) {
          return numberOrInteger.toNumberOrInfinity();
        }

        return numberOrInteger;
      }

      var string = this._unpackString(marker, markerHigh, markerLow, buffer);

      if (string !== null) {
        return string;
      }

      var list = this._unpackList(marker, markerHigh, markerLow, buffer);

      if (list !== null) {
        return list;
      }

      var byteArray = this._unpackByteArray(marker, buffer);

      if (byteArray !== null) {
        return byteArray;
      }

      var map = this._unpackMap(marker, markerHigh, markerLow, buffer);

      if (map !== null) {
        return map;
      }

      var struct = this._unpackStruct(marker, markerHigh, markerLow, buffer);

      if (struct !== null) {
        return struct;
      }

      throw (0, _error.newError)('Unknown packed value with marker ' + marker.toString(16));
    }
  }, {
    key: "unpackInteger",
    value: function unpackInteger(buffer) {
      var marker = buffer.readUInt8();

      var result = this._unpackInteger(marker, buffer);

      if (result == null) {
        throw (0, _error.newError)('Unable to unpack integer value with marker ' + marker.toString(16));
      }

      return result;
    }
  }, {
    key: "_unpackBoolean",
    value: function _unpackBoolean(marker) {
      if (marker === TRUE) {
        return true;
      } else if (marker === FALSE) {
        return false;
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackNumberOrInteger",
    value: function _unpackNumberOrInteger(marker, buffer) {
      if (marker === FLOAT_64) {
        return buffer.readFloat64();
      } else {
        return this._unpackInteger(marker, buffer);
      }
    }
  }, {
    key: "_unpackInteger",
    value: function _unpackInteger(marker, buffer) {
      if (marker >= 0 && marker < 128) {
        return (0, _integer["int"])(marker);
      } else if (marker >= 240 && marker < 256) {
        return (0, _integer["int"])(marker - 256);
      } else if (marker === INT_8) {
        return (0, _integer["int"])(buffer.readInt8());
      } else if (marker === INT_16) {
        return (0, _integer["int"])(buffer.readInt16());
      } else if (marker === INT_32) {
        var b = buffer.readInt32();
        return (0, _integer["int"])(b);
      } else if (marker === INT_64) {
        var high = buffer.readInt32();
        var low = buffer.readInt32();
        return new _integer["default"](low, high);
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackString",
    value: function _unpackString(marker, markerHigh, markerLow, buffer) {
      if (markerHigh === TINY_STRING) {
        return _node.utf8.decode(buffer, markerLow);
      } else if (marker === STRING_8) {
        return _node.utf8.decode(buffer, buffer.readUInt8());
      } else if (marker === STRING_16) {
        return _node.utf8.decode(buffer, buffer.readUInt16());
      } else if (marker === STRING_32) {
        return _node.utf8.decode(buffer, buffer.readUInt32());
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackList",
    value: function _unpackList(marker, markerHigh, markerLow, buffer) {
      if (markerHigh === TINY_LIST) {
        return this._unpackListWithSize(markerLow, buffer);
      } else if (marker === LIST_8) {
        return this._unpackListWithSize(buffer.readUInt8(), buffer);
      } else if (marker === LIST_16) {
        return this._unpackListWithSize(buffer.readUInt16(), buffer);
      } else if (marker === LIST_32) {
        return this._unpackListWithSize(buffer.readUInt32(), buffer);
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackListWithSize",
    value: function _unpackListWithSize(size, buffer) {
      var value = [];

      for (var i = 0; i < size; i++) {
        value.push(this.unpack(buffer));
      }

      return value;
    }
  }, {
    key: "_unpackByteArray",
    value: function _unpackByteArray(marker, buffer) {
      if (marker === BYTES_8) {
        return this._unpackByteArrayWithSize(buffer.readUInt8(), buffer);
      } else if (marker === BYTES_16) {
        return this._unpackByteArrayWithSize(buffer.readUInt16(), buffer);
      } else if (marker === BYTES_32) {
        return this._unpackByteArrayWithSize(buffer.readUInt32(), buffer);
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackByteArrayWithSize",
    value: function _unpackByteArrayWithSize(size, buffer) {
      var value = new Int8Array(size);

      for (var i = 0; i < size; i++) {
        value[i] = buffer.readInt8();
      }

      return value;
    }
  }, {
    key: "_unpackMap",
    value: function _unpackMap(marker, markerHigh, markerLow, buffer) {
      if (markerHigh === TINY_MAP) {
        return this._unpackMapWithSize(markerLow, buffer);
      } else if (marker === MAP_8) {
        return this._unpackMapWithSize(buffer.readUInt8(), buffer);
      } else if (marker === MAP_16) {
        return this._unpackMapWithSize(buffer.readUInt16(), buffer);
      } else if (marker === MAP_32) {
        return this._unpackMapWithSize(buffer.readUInt32(), buffer);
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackMapWithSize",
    value: function _unpackMapWithSize(size, buffer) {
      var value = {};

      for (var i = 0; i < size; i++) {
        var key = this.unpack(buffer);
        value[key] = this.unpack(buffer);
      }

      return value;
    }
  }, {
    key: "_unpackStruct",
    value: function _unpackStruct(marker, markerHigh, markerLow, buffer) {
      if (markerHigh === TINY_STRUCT) {
        return this._unpackStructWithSize(markerLow, buffer);
      } else if (marker === STRUCT_8) {
        return this._unpackStructWithSize(buffer.readUInt8(), buffer);
      } else if (marker === STRUCT_16) {
        return this._unpackStructWithSize(buffer.readUInt16(), buffer);
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackStructWithSize",
    value: function _unpackStructWithSize(structSize, buffer) {
      var signature = buffer.readUInt8();

      if (signature === NODE) {
        return this._unpackNode(structSize, buffer);
      } else if (signature === RELATIONSHIP) {
        return this._unpackRelationship(structSize, buffer);
      } else if (signature === UNBOUND_RELATIONSHIP) {
        return this._unpackUnboundRelationship(structSize, buffer);
      } else if (signature === PATH) {
        return this._unpackPath(structSize, buffer);
      } else {
        return this._unpackUnknownStruct(signature, structSize, buffer);
      }
    }
  }, {
    key: "_unpackNode",
    value: function _unpackNode(structSize, buffer) {
      this._verifyStructSize('Node', NODE_STRUCT_SIZE, structSize);

      return new _graphTypes.Node(this.unpack(buffer), // Identity
      this.unpack(buffer), // Labels
      this.unpack(buffer) // Properties
      );
    }
  }, {
    key: "_unpackRelationship",
    value: function _unpackRelationship(structSize, buffer) {
      this._verifyStructSize('Relationship', RELATIONSHIP_STRUCT_SIZE, structSize);

      return new _graphTypes.Relationship(this.unpack(buffer), // Identity
      this.unpack(buffer), // Start Node Identity
      this.unpack(buffer), // End Node Identity
      this.unpack(buffer), // Type
      this.unpack(buffer) // Properties
      );
    }
  }, {
    key: "_unpackUnboundRelationship",
    value: function _unpackUnboundRelationship(structSize, buffer) {
      this._verifyStructSize('UnboundRelationship', UNBOUND_RELATIONSHIP_STRUCT_SIZE, structSize);

      return new _graphTypes.UnboundRelationship(this.unpack(buffer), // Identity
      this.unpack(buffer), // Type
      this.unpack(buffer) // Properties
      );
    }
  }, {
    key: "_unpackPath",
    value: function _unpackPath(structSize, buffer) {
      this._verifyStructSize('Path', PATH_STRUCT_SIZE, structSize);

      var nodes = this.unpack(buffer);
      var rels = this.unpack(buffer);
      var sequence = this.unpack(buffer);
      var segments = [];
      var prevNode = nodes[0];

      for (var i = 0; i < sequence.length; i += 2) {
        var nextNode = nodes[sequence[i + 1]];
        var relIndex = sequence[i];
        var rel = void 0;

        if (relIndex > 0) {
          rel = rels[relIndex - 1];

          if (rel instanceof _graphTypes.UnboundRelationship) {
            // To avoid duplication, relationships in a path do not contain
            // information about their start and end nodes, that's instead
            // inferred from the path sequence. This is us inferring (and,
            // for performance reasons remembering) the start/end of a rel.
            rels[relIndex - 1] = rel = rel.bind(prevNode.identity, nextNode.identity);
          }
        } else {
          rel = rels[-relIndex - 1];

          if (rel instanceof _graphTypes.UnboundRelationship) {
            // See above
            rels[-relIndex - 1] = rel = rel.bind(nextNode.identity, prevNode.identity);
          }
        } // Done hydrating one path segment.


        segments.push(new _graphTypes.PathSegment(prevNode, rel, nextNode));
        prevNode = nextNode;
      }

      return new _graphTypes.Path(nodes[0], nodes[nodes.length - 1], segments);
    }
  }, {
    key: "_unpackUnknownStruct",
    value: function _unpackUnknownStruct(signature, structSize, buffer) {
      var result = new Structure(signature, []);

      for (var i = 0; i < structSize; i++) {
        result.fields.push(this.unpack(buffer));
      }

      return result;
    }
  }, {
    key: "_verifyStructSize",
    value: function _verifyStructSize(structName, expectedSize, actualSize) {
      if (expectedSize !== actualSize) {
        throw (0, _error.newError)("Wrong struct size for ".concat(structName, ", expected ").concat(expectedSize, " but was ").concat(actualSize), _error.PROTOCOL_ERROR);
      }
    }
  }]);
  return Unpacker;
}();

exports.Unpacker = Unpacker;

function isIterable(obj) {
  if (obj == null) {
    return false;
  }

  return typeof obj[Symbol.iterator] === 'function';
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/packstream-v2.js":
/*!*****************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/packstream-v2.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Unpacker = exports.Packer = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var v1 = _interopRequireWildcard(__webpack_require__(/*! ./packstream-v1 */ "./node_modules/neo4j-driver/lib/internal/packstream-v1.js"));

var _spatialTypes = __webpack_require__(/*! ../spatial-types */ "./node_modules/neo4j-driver/lib/spatial-types.js");

var _temporalTypes = __webpack_require__(/*! ../temporal-types */ "./node_modules/neo4j-driver/lib/temporal-types.js");

var _integer = __webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js");

var _temporalUtil = __webpack_require__(/*! ./temporal-util */ "./node_modules/neo4j-driver/lib/internal/temporal-util.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var POINT_2D = 0x58;
var POINT_2D_STRUCT_SIZE = 3;
var POINT_3D = 0x59;
var POINT_3D_STRUCT_SIZE = 4;
var DURATION = 0x45;
var DURATION_STRUCT_SIZE = 4;
var LOCAL_TIME = 0x74;
var LOCAL_TIME_STRUCT_SIZE = 1;
var TIME = 0x54;
var TIME_STRUCT_SIZE = 2;
var DATE = 0x44;
var DATE_STRUCT_SIZE = 1;
var LOCAL_DATE_TIME = 0x64;
var LOCAL_DATE_TIME_STRUCT_SIZE = 2;
var DATE_TIME_WITH_ZONE_OFFSET = 0x46;
var DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;
var DATE_TIME_WITH_ZONE_ID = 0x66;
var DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;

var Packer = /*#__PURE__*/function (_v1$Packer) {
  (0, _inherits2["default"])(Packer, _v1$Packer);

  var _super = _createSuper(Packer);

  function Packer() {
    (0, _classCallCheck2["default"])(this, Packer);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(Packer, [{
    key: "disableByteArrays",
    value: function disableByteArrays() {
      throw new Error('Bolt V2 should always support byte arrays');
    }
  }, {
    key: "packable",
    value: function packable(obj) {
      var _this = this;

      if ((0, _spatialTypes.isPoint)(obj)) {
        return function () {
          return packPoint(obj, _this);
        };
      } else if ((0, _temporalTypes.isDuration)(obj)) {
        return function () {
          return packDuration(obj, _this);
        };
      } else if ((0, _temporalTypes.isLocalTime)(obj)) {
        return function () {
          return packLocalTime(obj, _this);
        };
      } else if ((0, _temporalTypes.isTime)(obj)) {
        return function () {
          return packTime(obj, _this);
        };
      } else if ((0, _temporalTypes.isDate)(obj)) {
        return function () {
          return packDate(obj, _this);
        };
      } else if ((0, _temporalTypes.isLocalDateTime)(obj)) {
        return function () {
          return packLocalDateTime(obj, _this);
        };
      } else if ((0, _temporalTypes.isDateTime)(obj)) {
        return function () {
          return packDateTime(obj, _this);
        };
      } else {
        return (0, _get2["default"])((0, _getPrototypeOf2["default"])(Packer.prototype), "packable", this).call(this, obj);
      }
    }
  }]);
  return Packer;
}(v1.Packer);

exports.Packer = Packer;

var Unpacker = /*#__PURE__*/function (_v1$Unpacker) {
  (0, _inherits2["default"])(Unpacker, _v1$Unpacker);

  var _super2 = _createSuper(Unpacker);

  /**
   * @constructor
   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.
   */
  function Unpacker() {
    var disableLosslessIntegers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    (0, _classCallCheck2["default"])(this, Unpacker);
    return _super2.call(this, disableLosslessIntegers);
  }

  (0, _createClass2["default"])(Unpacker, [{
    key: "_unpackUnknownStruct",
    value: function _unpackUnknownStruct(signature, structSize, buffer) {
      if (signature === POINT_2D) {
        return unpackPoint2D(this, structSize, buffer);
      } else if (signature === POINT_3D) {
        return unpackPoint3D(this, structSize, buffer);
      } else if (signature === DURATION) {
        return unpackDuration(this, structSize, buffer);
      } else if (signature === LOCAL_TIME) {
        return unpackLocalTime(this, structSize, buffer, this._disableLosslessIntegers);
      } else if (signature === TIME) {
        return unpackTime(this, structSize, buffer, this._disableLosslessIntegers);
      } else if (signature === DATE) {
        return unpackDate(this, structSize, buffer, this._disableLosslessIntegers);
      } else if (signature === LOCAL_DATE_TIME) {
        return unpackLocalDateTime(this, structSize, buffer, this._disableLosslessIntegers);
      } else if (signature === DATE_TIME_WITH_ZONE_OFFSET) {
        return unpackDateTimeWithZoneOffset(this, structSize, buffer, this._disableLosslessIntegers);
      } else if (signature === DATE_TIME_WITH_ZONE_ID) {
        return unpackDateTimeWithZoneId(this, structSize, buffer, this._disableLosslessIntegers);
      } else {
        return (0, _get2["default"])((0, _getPrototypeOf2["default"])(Unpacker.prototype), "_unpackUnknownStruct", this).call(this, signature, structSize, buffer, this._disableLosslessIntegers);
      }
    }
  }]);
  return Unpacker;
}(v1.Unpacker);
/**
 * Pack given 2D or 3D point.
 * @param {Point} point the point value to pack.
 * @param {Packer} packer the packer to use.
 */


exports.Unpacker = Unpacker;

function packPoint(point, packer) {
  var is2DPoint = point.z === null || point.z === undefined;

  if (is2DPoint) {
    packPoint2D(point, packer);
  } else {
    packPoint3D(point, packer);
  }
}
/**
 * Pack given 2D point.
 * @param {Point} point the point value to pack.
 * @param {Packer} packer the packer to use.
 */


function packPoint2D(point, packer) {
  var packableStructFields = [packer.packable((0, _integer["int"])(point.srid)), packer.packable(point.x), packer.packable(point.y)];
  packer.packStruct(POINT_2D, packableStructFields);
}
/**
 * Pack given 3D point.
 * @param {Point} point the point value to pack.
 * @param {Packer} packer the packer to use.
 */


function packPoint3D(point, packer) {
  var packableStructFields = [packer.packable((0, _integer["int"])(point.srid)), packer.packable(point.x), packer.packable(point.y), packer.packable(point.z)];
  packer.packStruct(POINT_3D, packableStructFields);
}
/**
 * Unpack 2D point value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @return {Point} the unpacked 2D point value.
 */


function unpackPoint2D(unpacker, structSize, buffer) {
  unpacker._verifyStructSize('Point2D', POINT_2D_STRUCT_SIZE, structSize);

  return new _spatialTypes.Point(unpacker.unpack(buffer), // srid
  unpacker.unpack(buffer), // x
  unpacker.unpack(buffer), // y
  undefined // z
  );
}
/**
 * Unpack 3D point value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @return {Point} the unpacked 3D point value.
 */


function unpackPoint3D(unpacker, structSize, buffer) {
  unpacker._verifyStructSize('Point3D', POINT_3D_STRUCT_SIZE, structSize);

  return new _spatialTypes.Point(unpacker.unpack(buffer), // srid
  unpacker.unpack(buffer), // x
  unpacker.unpack(buffer), // y
  unpacker.unpack(buffer) // z
  );
}
/**
 * Pack given duration.
 * @param {Duration} value the duration value to pack.
 * @param {Packer} packer the packer to use.
 */


function packDuration(value, packer) {
  var months = (0, _integer["int"])(value.months);
  var days = (0, _integer["int"])(value.days);
  var seconds = (0, _integer["int"])(value.seconds);
  var nanoseconds = (0, _integer["int"])(value.nanoseconds);
  var packableStructFields = [packer.packable(months), packer.packable(days), packer.packable(seconds), packer.packable(nanoseconds)];
  packer.packStruct(DURATION, packableStructFields);
}
/**
 * Unpack duration value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @return {Duration} the unpacked duration value.
 */


function unpackDuration(unpacker, structSize, buffer) {
  unpacker._verifyStructSize('Duration', DURATION_STRUCT_SIZE, structSize);

  var months = unpacker.unpack(buffer);
  var days = unpacker.unpack(buffer);
  var seconds = unpacker.unpack(buffer);
  var nanoseconds = unpacker.unpack(buffer);
  return new _temporalTypes.Duration(months, days, seconds, nanoseconds);
}
/**
 * Pack given local time.
 * @param {LocalTime} value the local time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packLocalTime(value, packer) {
  var nanoOfDay = (0, _temporalUtil.localTimeToNanoOfDay)(value.hour, value.minute, value.second, value.nanosecond);
  var packableStructFields = [packer.packable(nanoOfDay)];
  packer.packStruct(LOCAL_TIME, packableStructFields);
}
/**
 * Unpack local time value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result local time should be native JS numbers.
 * @return {LocalTime} the unpacked local time value.
 */


function unpackLocalTime(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('LocalTime', LOCAL_TIME_STRUCT_SIZE, structSize);

  var nanoOfDay = unpacker.unpackInteger(buffer);
  var result = (0, _temporalUtil.nanoOfDayToLocalTime)(nanoOfDay);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}
/**
 * Pack given time.
 * @param {Time} value the time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packTime(value, packer) {
  var nanoOfDay = (0, _temporalUtil.localTimeToNanoOfDay)(value.hour, value.minute, value.second, value.nanosecond);
  var offsetSeconds = (0, _integer["int"])(value.timeZoneOffsetSeconds);
  var packableStructFields = [packer.packable(nanoOfDay), packer.packable(offsetSeconds)];
  packer.packStruct(TIME, packableStructFields);
}
/**
 * Unpack time value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result time should be native JS numbers.
 * @return {Time} the unpacked time value.
 */


function unpackTime(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('Time', TIME_STRUCT_SIZE, structSize);

  var nanoOfDay = unpacker.unpackInteger(buffer);
  var offsetSeconds = unpacker.unpackInteger(buffer);
  var localTime = (0, _temporalUtil.nanoOfDayToLocalTime)(nanoOfDay);
  var result = new _temporalTypes.Time(localTime.hour, localTime.minute, localTime.second, localTime.nanosecond, offsetSeconds);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}
/**
 * Pack given neo4j date.
 * @param {Date} value the date value to pack.
 * @param {Packer} packer the packer to use.
 */


function packDate(value, packer) {
  var epochDay = (0, _temporalUtil.dateToEpochDay)(value.year, value.month, value.day);
  var packableStructFields = [packer.packable(epochDay)];
  packer.packStruct(DATE, packableStructFields);
}
/**
 * Unpack neo4j date value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result date should be native JS numbers.
 * @return {Date} the unpacked neo4j date value.
 */


function unpackDate(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('Date', DATE_STRUCT_SIZE, structSize);

  var epochDay = unpacker.unpackInteger(buffer);
  var result = (0, _temporalUtil.epochDayToDate)(epochDay);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}
/**
 * Pack given local date time.
 * @param {LocalDateTime} value the local date time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packLocalDateTime(value, packer) {
  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);
  var nano = (0, _integer["int"])(value.nanosecond);
  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano)];
  packer.packStruct(LOCAL_DATE_TIME, packableStructFields);
}
/**
 * Unpack local date time value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result local date-time should be native JS numbers.
 * @return {LocalDateTime} the unpacked local date time value.
 */


function unpackLocalDateTime(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('LocalDateTime', LOCAL_DATE_TIME_STRUCT_SIZE, structSize);

  var epochSecond = unpacker.unpackInteger(buffer);
  var nano = unpacker.unpackInteger(buffer);
  var result = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}
/**
 * Pack given date time.
 * @param {DateTime} value the date time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packDateTime(value, packer) {
  if (value.timeZoneId) {
    packDateTimeWithZoneId(value, packer);
  } else {
    packDateTimeWithZoneOffset(value, packer);
  }
}
/**
 * Pack given date time with zone offset.
 * @param {DateTime} value the date time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packDateTimeWithZoneOffset(value, packer) {
  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);
  var nano = (0, _integer["int"])(value.nanosecond);
  var timeZoneOffsetSeconds = (0, _integer["int"])(value.timeZoneOffsetSeconds);
  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneOffsetSeconds)];
  packer.packStruct(DATE_TIME_WITH_ZONE_OFFSET, packableStructFields);
}
/**
 * Unpack date time with zone offset value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.
 * @return {DateTime} the unpacked date time with zone offset value.
 */


function unpackDateTimeWithZoneOffset(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, structSize);

  var epochSecond = unpacker.unpackInteger(buffer);
  var nano = unpacker.unpackInteger(buffer);
  var timeZoneOffsetSeconds = unpacker.unpackInteger(buffer);
  var localDateTime = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);
  var result = new _temporalTypes.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}
/**
 * Pack given date time with zone id.
 * @param {DateTime} value the date time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packDateTimeWithZoneId(value, packer) {
  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);
  var nano = (0, _integer["int"])(value.nanosecond);
  var timeZoneId = value.timeZoneId;
  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneId)];
  packer.packStruct(DATE_TIME_WITH_ZONE_ID, packableStructFields);
}
/**
 * Unpack date time with zone id value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.
 * @return {DateTime} the unpacked date time with zone id value.
 */


function unpackDateTimeWithZoneId(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, structSize);

  var epochSecond = unpacker.unpackInteger(buffer);
  var nano = unpacker.unpackInteger(buffer);
  var timeZoneId = unpacker.unpack(buffer);
  var localDateTime = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);
  var result = new _temporalTypes.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, null, timeZoneId);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}

function convertIntegerPropsIfNeeded(obj, disableLosslessIntegers) {
  if (!disableLosslessIntegers) {
    return obj;
  }

  var clone = Object.create(Object.getPrototypeOf(obj));

  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      var value = obj[prop];
      clone[prop] = (0, _integer.isInt)(value) ? value.toNumberOrInfinity() : value;
    }
  }

  Object.freeze(clone);
  return clone;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/pool-config.js":
/*!***************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/pool-config.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_ACQUISITION_TIMEOUT = exports.DEFAULT_MAX_SIZE = exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_MAX_SIZE = 100;
exports.DEFAULT_MAX_SIZE = DEFAULT_MAX_SIZE;
var DEFAULT_ACQUISITION_TIMEOUT = 60 * 1000; // 60 seconds

exports.DEFAULT_ACQUISITION_TIMEOUT = DEFAULT_ACQUISITION_TIMEOUT;

var PoolConfig = /*#__PURE__*/function () {
  function PoolConfig(maxSize, acquisitionTimeout) {
    (0, _classCallCheck2["default"])(this, PoolConfig);
    this.maxSize = valueOrDefault(maxSize, DEFAULT_MAX_SIZE);
    this.acquisitionTimeout = valueOrDefault(acquisitionTimeout, DEFAULT_ACQUISITION_TIMEOUT);
  }

  (0, _createClass2["default"])(PoolConfig, null, [{
    key: "defaultConfig",
    value: function defaultConfig() {
      return new PoolConfig(DEFAULT_MAX_SIZE, DEFAULT_ACQUISITION_TIMEOUT);
    }
  }, {
    key: "fromDriverConfig",
    value: function fromDriverConfig(config) {
      var maxSizeConfigured = isConfigured(config.maxConnectionPoolSize);
      var maxSize = maxSizeConfigured ? config.maxConnectionPoolSize : DEFAULT_MAX_SIZE;
      var acquisitionTimeoutConfigured = isConfigured(config.connectionAcquisitionTimeout);
      var acquisitionTimeout = acquisitionTimeoutConfigured ? config.connectionAcquisitionTimeout : DEFAULT_ACQUISITION_TIMEOUT;
      return new PoolConfig(maxSize, acquisitionTimeout);
    }
  }]);
  return PoolConfig;
}();

exports["default"] = PoolConfig;

function valueOrDefault(value, defaultValue) {
  return value === 0 || value ? value : defaultValue;
}

function isConfigured(value) {
  return value === 0 || value;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/pool.js":
/*!********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/pool.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _poolConfig = _interopRequireDefault(__webpack_require__(/*! ./pool-config */ "./node_modules/neo4j-driver/lib/internal/pool-config.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _logger = _interopRequireDefault(__webpack_require__(/*! ./logger */ "./node_modules/neo4j-driver/lib/internal/logger.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Pool = /*#__PURE__*/function () {
  /**
   * @param {function(address: ServerAddress, function(address: ServerAddress, resource: object): Promise<object>): Promise<object>} create
   *                an allocation function that creates a promise with a new resource. It's given an address for which to
   *                allocate the connection and a function that will return the resource to the pool if invoked, which is
   *                meant to be called on .dispose or .close or whatever mechanism the resource uses to finalize.
   * @param {function(resource: object): Promise<void>} destroy
   *                called with the resource when it is evicted from this pool
   * @param {function(resource: object): boolean} validate
   *                called at various times (like when an instance is acquired and when it is returned.
   *                If this returns false, the resource will be evicted
   * @param {function(resource: object, observer: { onError }): void} installIdleObserver
   *                called when the resource is released back to pool
   * @param {function(resource: object): void} removeIdleObserver
   *                called when the resource is acquired from the pool
   * @param {PoolConfig} config configuration for the new driver.
   * @param {Logger} log the driver logger.
   */
  function Pool() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$create = _ref.create,
        create = _ref$create === void 0 ? function (address, release) {
      return Promise.resolve();
    } : _ref$create,
        _ref$destroy = _ref.destroy,
        destroy = _ref$destroy === void 0 ? function (conn) {
      return Promise.resolve();
    } : _ref$destroy,
        _ref$validate = _ref.validate,
        validate = _ref$validate === void 0 ? function (conn) {
      return true;
    } : _ref$validate,
        _ref$installIdleObser = _ref.installIdleObserver,
        installIdleObserver = _ref$installIdleObser === void 0 ? function (conn, observer) {} : _ref$installIdleObser,
        _ref$removeIdleObserv = _ref.removeIdleObserver,
        removeIdleObserver = _ref$removeIdleObserv === void 0 ? function (conn) {} : _ref$removeIdleObserv,
        _ref$config = _ref.config,
        config = _ref$config === void 0 ? _poolConfig["default"].defaultConfig() : _ref$config,
        _ref$log = _ref.log,
        log = _ref$log === void 0 ? _logger["default"].noOp() : _ref$log;

    (0, _classCallCheck2["default"])(this, Pool);
    this._create = create;
    this._destroy = destroy;
    this._validate = validate;
    this._installIdleObserver = installIdleObserver;
    this._removeIdleObserver = removeIdleObserver;
    this._maxSize = config.maxSize;
    this._acquisitionTimeout = config.acquisitionTimeout;
    this._pools = {};
    this._pendingCreates = {};
    this._acquireRequests = {};
    this._activeResourceCounts = {};
    this._release = this._release.bind(this);
    this._log = log;
    this._closed = false;
  }
  /**
   * Acquire and idle resource fom the pool or create a new one.
   * @param {ServerAddress} address the address for which we're acquiring.
   * @return {Object} resource that is ready to use.
   */


  (0, _createClass2["default"])(Pool, [{
    key: "acquire",
    value: function acquire(address) {
      var _this = this;

      return this._acquire(address).then(function (resource) {
        var key = address.asKey();

        if (resource) {
          resourceAcquired(key, _this._activeResourceCounts);

          if (_this._log.isDebugEnabled()) {
            _this._log.debug("".concat(resource, " acquired from the pool ").concat(key));
          }

          return resource;
        } // We're out of resources and will try to acquire later on when an existing resource is released.


        var allRequests = _this._acquireRequests;
        var requests = allRequests[key];

        if (!requests) {
          allRequests[key] = [];
        }

        return new Promise(function (resolve, reject) {
          var request;
          var timeoutId = setTimeout(function () {
            // acquisition timeout fired
            // remove request from the queue of pending requests, if it's still there
            // request might've been taken out by the release operation
            var pendingRequests = allRequests[key];

            if (pendingRequests) {
              allRequests[key] = pendingRequests.filter(function (item) {
                return item !== request;
              });
            }

            if (request.isCompleted()) {// request already resolved/rejected by the release operation; nothing to do
            } else {
              // request is still pending and needs to be failed
              var activeCount = _this.activeResourceCount(address);

              var idleCount = _this.has(address) ? _this._pools[key].length : 0;
              request.reject((0, _error.newError)("Connection acquisition timed out in ".concat(_this._acquisitionTimeout, " ms. Poos status: Active conn count = ").concat(activeCount, ", Idle conn count = ").concat(idleCount, ".")));
            }
          }, _this._acquisitionTimeout);
          request = new PendingRequest(key, resolve, reject, timeoutId, _this._log);
          allRequests[key].push(request);
        });
      });
    }
    /**
     * Destroy all idle resources for the given address.
     * @param {ServerAddress} address the address of the server to purge its pool.
     * @returns {Promise<void>} A promise that is resolved when the resources are purged
     */

  }, {
    key: "purge",
    value: function purge(address) {
      return this._purgeKey(address.asKey());
    }
    /**
     * Destroy all idle resources in this pool.
     * @returns {Promise<void>} A promise that is resolved when the resources are purged
     */

  }, {
    key: "close",
    value: function close() {
      var _this2 = this;

      this._closed = true;
      return Promise.all(Object.keys(this._pools).map(function (key) {
        return _this2._purgeKey(key);
      }));
    }
    /**
     * Keep the idle resources for the provided addresses and purge the rest.
     * @returns {Promise<void>} A promise that is resolved when the other resources are purged
     */

  }, {
    key: "keepAll",
    value: function keepAll(addresses) {
      var _this3 = this;

      var keysToKeep = addresses.map(function (a) {
        return a.asKey();
      });
      var keysPresent = Object.keys(this._pools);
      var keysToPurge = keysPresent.filter(function (k) {
        return keysToKeep.indexOf(k) === -1;
      });
      return Promise.all(keysToPurge.map(function (key) {
        return _this3._purgeKey(key);
      }));
    }
    /**
     * Check if this pool contains resources for the given address.
     * @param {ServerAddress} address the address of the server to check.
     * @return {boolean} `true` when pool contains entries for the given key, <code>false</code> otherwise.
     */

  }, {
    key: "has",
    value: function has(address) {
      return address.asKey() in this._pools;
    }
    /**
     * Get count of active (checked out of the pool) resources for the given key.
     * @param {ServerAddress} address the address of the server to check.
     * @return {number} count of resources acquired by clients.
     */

  }, {
    key: "activeResourceCount",
    value: function activeResourceCount(address) {
      return this._activeResourceCounts[address.asKey()] || 0;
    }
  }, {
    key: "_acquire",
    value: function () {
      var _acquire2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(address) {
        var key, pool, _resource, numConnections, resource;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._closed) {
                  _context.next = 2;
                  break;
                }

                throw (0, _error.newError)('Pool is closed, it is no more able to serve requests.');

              case 2:
                key = address.asKey();
                pool = this._pools[key];

                if (!pool) {
                  pool = [];
                  this._pools[key] = pool;
                  this._pendingCreates[key] = 0;
                }

              case 5:
                if (!pool.length) {
                  _context.next = 16;
                  break;
                }

                _resource = pool.pop();

                if (!this._validate(_resource)) {
                  _context.next = 12;
                  break;
                }

                if (this._removeIdleObserver) {
                  this._removeIdleObserver(_resource);
                } // idle resource is valid and can be acquired


                return _context.abrupt("return", Promise.resolve(_resource));

              case 12:
                _context.next = 14;
                return this._destroy(_resource);

              case 14:
                _context.next = 5;
                break;

              case 16:
                if (!(this._maxSize > 0)) {
                  _context.next = 20;
                  break;
                }

                // Include pending creates when checking pool size since these probably will add
                // to the number when fulfilled.
                numConnections = this.activeResourceCount(address) + this._pendingCreates[key];

                if (!(numConnections >= this._maxSize)) {
                  _context.next = 20;
                  break;
                }

                return _context.abrupt("return", null);

              case 20:
                // there exist no idle valid resources, create a new one for acquisition
                // Keep track of how many pending creates there are to avoid making too many connections.
                this._pendingCreates[key] = this._pendingCreates[key] + 1;
                _context.prev = 21;
                _context.next = 24;
                return this._create(address, this._release);

              case 24:
                resource = _context.sent;

              case 25:
                _context.prev = 25;
                this._pendingCreates[key] = this._pendingCreates[key] - 1;
                return _context.finish(25);

              case 28:
                return _context.abrupt("return", resource);

              case 29:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[21,, 25, 28]]);
      }));

      function _acquire(_x) {
        return _acquire2.apply(this, arguments);
      }

      return _acquire;
    }()
  }, {
    key: "_release",
    value: function () {
      var _release2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(address, resource) {
        var _this4 = this;

        var key, pool;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                key = address.asKey();
                pool = this._pools[key];

                if (!pool) {
                  _context2.next = 14;
                  break;
                }

                if (this._validate(resource)) {
                  _context2.next = 9;
                  break;
                }

                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(resource, " destroyed and can't be released to the pool ").concat(key, " because it is not functional"));
                }

                _context2.next = 7;
                return this._destroy(resource);

              case 7:
                _context2.next = 12;
                break;

              case 9:
                if (this._installIdleObserver) {
                  this._installIdleObserver(resource, {
                    onError: function onError(error) {
                      _this4._log.debug("Idle connection ".concat(resource, " destroyed because of error: ").concat(error));

                      var pool = _this4._pools[key];

                      if (pool) {
                        _this4._pools[key] = pool.filter(function (r) {
                          return r !== resource;
                        });
                      } // let's not care about background clean-ups due to errors but just trigger the destroy
                      // process for the resource, we especially catch any errors and ignore them to avoid
                      // unhandled promise rejection warnings


                      _this4._destroy(resource)["catch"](function () {});
                    }
                  });
                }

                pool.push(resource);

                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(resource, " released to the pool ").concat(key));
                }

              case 12:
                _context2.next = 17;
                break;

              case 14:
                // key has been purged, don't put it back, just destroy the resource
                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(resource, " destroyed and can't be released to the pool ").concat(key, " because pool has been purged"));
                }

                _context2.next = 17;
                return this._destroy(resource);

              case 17:
                resourceReleased(key, this._activeResourceCounts);

                this._processPendingAcquireRequests(address);

              case 19:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _release(_x2, _x3) {
        return _release2.apply(this, arguments);
      }

      return _release;
    }()
  }, {
    key: "_purgeKey",
    value: function () {
      var _purgeKey2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(key) {
        var pool, resource;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                pool = this._pools[key] || [];

              case 1:
                if (!pool.length) {
                  _context3.next = 8;
                  break;
                }

                resource = pool.pop();

                if (this._removeIdleObserver) {
                  this._removeIdleObserver(resource);
                }

                _context3.next = 6;
                return this._destroy(resource);

              case 6:
                _context3.next = 1;
                break;

              case 8:
                delete this._pools[key];

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _purgeKey(_x4) {
        return _purgeKey2.apply(this, arguments);
      }

      return _purgeKey;
    }()
  }, {
    key: "_processPendingAcquireRequests",
    value: function _processPendingAcquireRequests(address) {
      var _this5 = this;

      var key = address.asKey();
      var requests = this._acquireRequests[key];

      if (requests) {
        var pendingRequest = requests.shift(); // pop a pending acquire request

        if (pendingRequest) {
          this._acquire(address)["catch"](function (error) {
            // failed to acquire/create a new connection to resolve the pending acquire request
            // propagate the error by failing the pending request
            pendingRequest.reject(error);
            return null;
          }).then(function (resource) {
            if (resource) {
              // managed to acquire a valid resource from the pool
              if (pendingRequest.isCompleted()) {
                // request has been completed, most likely failed by a timeout
                // return the acquired resource back to the pool
                _this5._release(address, resource);
              } else {
                // request is still pending and can be resolved with the newly acquired resource
                resourceAcquired(key, _this5._activeResourceCounts); // increment the active counter

                pendingRequest.resolve(resource); // resolve the pending request with the acquired resource
              }
            }
          });
        } else {
          delete this._acquireRequests[key];
        }
      }
    }
  }]);
  return Pool;
}();
/**
 * Increment active (checked out of the pool) resource counter.
 * @param {string} key the resource group identifier (server address for connections).
 * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.
 */


function resourceAcquired(key, activeResourceCounts) {
  var currentCount = activeResourceCounts[key] || 0;
  activeResourceCounts[key] = currentCount + 1;
}
/**
 * Decrement active (checked out of the pool) resource counter.
 * @param {string} key the resource group identifier (server address for connections).
 * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.
 */


function resourceReleased(key, activeResourceCounts) {
  var currentCount = activeResourceCounts[key] || 0;
  var nextCount = currentCount - 1;

  if (nextCount > 0) {
    activeResourceCounts[key] = nextCount;
  } else {
    delete activeResourceCounts[key];
  }
}

var PendingRequest = /*#__PURE__*/function () {
  function PendingRequest(key, resolve, reject, timeoutId, log) {
    (0, _classCallCheck2["default"])(this, PendingRequest);
    this._key = key;
    this._resolve = resolve;
    this._reject = reject;
    this._timeoutId = timeoutId;
    this._log = log;
    this._completed = false;
  }

  (0, _createClass2["default"])(PendingRequest, [{
    key: "isCompleted",
    value: function isCompleted() {
      return this._completed;
    }
  }, {
    key: "resolve",
    value: function resolve(resource) {
      if (this._completed) {
        return;
      }

      this._completed = true;
      clearTimeout(this._timeoutId);

      if (this._log.isDebugEnabled()) {
        this._log.debug("".concat(resource, " acquired from the pool ").concat(this._key));
      }

      this._resolve(resource);
    }
  }, {
    key: "reject",
    value: function reject(error) {
      if (this._completed) {
        return;
      }

      this._completed = true;
      clearTimeout(this._timeoutId);

      this._reject(error);
    }
  }]);
  return PendingRequest;
}();

var _default = Pool;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/protocol-handshaker.js":
/*!***********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/protocol-handshaker.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _node = __webpack_require__(/*! ./node */ "./node_modules/neo4j-driver/lib/internal/browser/index.js");

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _boltProtocolV = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v1 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v1.js"));

var _boltProtocolV2 = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v2 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v2.js"));

var _boltProtocolV3 = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v3 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v3.js"));

var _boltProtocolV4x = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v4x0 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v4x0.js"));

var _boltProtocolV4x2 = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v4x1 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v4x1.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BOLT_MAGIC_PREAMBLE = 0x6060b017;

var ProtocolHandshaker = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Connection} connection the connection owning this protocol.
   * @param {Channel} channel the network channel.
   * @param {Chunker} chunker the message chunker.
   * @param {boolean} disableLosslessIntegers flag to use native JS numbers.
   * @param {Logger} log the logger.
   */
  function ProtocolHandshaker(connection, channel, chunker, disableLosslessIntegers, log) {
    var serversideRouting = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    (0, _classCallCheck2["default"])(this, ProtocolHandshaker);
    this._connection = connection;
    this._channel = channel;
    this._chunker = chunker;
    this._disableLosslessIntegers = disableLosslessIntegers;
    this._log = log;
    this._serversideRouting = serversideRouting;
  }
  /**
   * Write a Bolt handshake into the underlying network channel.
   */


  (0, _createClass2["default"])(ProtocolHandshaker, [{
    key: "writeHandshakeRequest",
    value: function writeHandshakeRequest() {
      this._channel.write(newHandshakeBuffer());
    }
    /**
     * Read the given handshake response and create the negotiated bolt protocol.
     * @param {BaseBuffer} buffer byte buffer containing the handshake response.
     * @return {BoltProtocol} bolt protocol corresponding to the version suggested by the database.
     * @throws {Neo4jError} when bolt protocol can't be instantiated.
     */

  }, {
    key: "createNegotiatedProtocol",
    value: function createNegotiatedProtocol(buffer) {
      var h = [buffer.readUInt8(), buffer.readUInt8(), buffer.readUInt8(), buffer.readUInt8()];

      if (h[0] === 0x48 && h[1] === 0x54 && h[2] === 0x54 && h[3] === 0x50) {
        throw (0, _error.newError)('Server responded HTTP. Make sure you are not trying to connect to the http endpoint ' + '(HTTP defaults to port 7474 whereas BOLT defaults to port 7687)');
      }

      var negotiatedVersion = Number(h[3] + '.' + h[2]);

      if (this._log.isDebugEnabled()) {
        this._log.debug("".concat(this._connection, " negotiated protocol version ").concat(negotiatedVersion));
      }

      return this._createProtocolWithVersion(negotiatedVersion);
    }
    /**
     * @return {BoltProtocol}
     * @private
     */

  }, {
    key: "_createProtocolWithVersion",
    value: function _createProtocolWithVersion(version) {
      switch (version) {
        case 1:
          return new _boltProtocolV["default"](this._connection, this._chunker, this._disableLosslessIntegers);

        case 2:
          return new _boltProtocolV2["default"](this._connection, this._chunker, this._disableLosslessIntegers);

        case 3:
          return new _boltProtocolV3["default"](this._connection, this._chunker, this._disableLosslessIntegers);

        case 4.0:
          return new _boltProtocolV4x["default"](this._connection, this._chunker, this._disableLosslessIntegers);

        case 4.1:
          return new _boltProtocolV4x2["default"](this._connection, this._chunker, this._disableLosslessIntegers, this._serversideRouting);

        default:
          throw (0, _error.newError)('Unknown Bolt protocol version: ' + version);
      }
    }
  }]);
  return ProtocolHandshaker;
}();
/**
 * @return {BaseBuffer}
 * @private
 */


exports["default"] = ProtocolHandshaker;

function newHandshakeBuffer() {
  var handshakeBuffer = (0, _node.alloc)(5 * 4); // magic preamble

  handshakeBuffer.writeInt32(BOLT_MAGIC_PREAMBLE); // proposed versions

  handshakeBuffer.writeInt32(1 << 8 | 4);
  handshakeBuffer.writeInt32(4);
  handshakeBuffer.writeInt32(3);
  handshakeBuffer.writeInt32(2); // reset the reader position

  handshakeBuffer.reset();
  return handshakeBuffer;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/rediscovery.js":
/*!***************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/rediscovery.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _routingTable = _interopRequireDefault(__webpack_require__(/*! ./routing-table */ "./node_modules/neo4j-driver/lib/internal/routing-table.js"));

var _routingUtil = _interopRequireDefault(__webpack_require__(/*! ./routing-util */ "./node_modules/neo4j-driver/lib/internal/routing-util.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Rediscovery = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {RoutingUtil} routingUtil the util to use.
   */
  function Rediscovery(routingUtil) {
    (0, _classCallCheck2["default"])(this, Rediscovery);
    this._routingUtil = routingUtil;
  }
  /**
   * Try to fetch new routing table from the given router.
   * @param {Session} session the session to use.
   * @param {string} database the database for which to lookup routing table.
   * @param {string} routerAddress the URL of the router.
   * @return {Promise<RoutingTable>} promise resolved with new routing table or null when connection error happened.
   */


  (0, _createClass2["default"])(Rediscovery, [{
    key: "lookupRoutingTableOnRouter",
    value: function () {
      var _lookupRoutingTableOnRouter = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(session, database, routerAddress) {
        var records, record, expirationTime, _this$_routingUtil$pa, routers, readers, writers;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._routingUtil.callRoutingProcedure(session, database, routerAddress);

              case 2:
                records = _context.sent;

                if (!(records === null)) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return", null);

              case 5:
                if (!(records.length !== 1)) {
                  _context.next = 7;
                  break;
                }

                throw (0, _error.newError)('Illegal response from router "' + routerAddress + '". ' + 'Received ' + records.length + ' records but expected only one.\n' + JSON.stringify(records), _error.PROTOCOL_ERROR);

              case 7:
                record = records[0];
                expirationTime = this._routingUtil.parseTtl(record, routerAddress);
                _this$_routingUtil$pa = this._routingUtil.parseServers(record, routerAddress), routers = _this$_routingUtil$pa.routers, readers = _this$_routingUtil$pa.readers, writers = _this$_routingUtil$pa.writers;

                Rediscovery._assertNonEmpty(routers, 'routers', routerAddress);

                Rediscovery._assertNonEmpty(readers, 'readers', routerAddress); // case with no writers is processed higher in the promise chain because only RoutingDriver knows
                // how to deal with such table and how to treat router that returned such table


                return _context.abrupt("return", new _routingTable["default"]({
                  database: database,
                  routers: routers,
                  readers: readers,
                  writers: writers,
                  expirationTime: expirationTime
                }));

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function lookupRoutingTableOnRouter(_x, _x2, _x3) {
        return _lookupRoutingTableOnRouter.apply(this, arguments);
      }

      return lookupRoutingTableOnRouter;
    }()
  }], [{
    key: "_assertNonEmpty",
    value: function _assertNonEmpty(serverAddressesArray, serversName, routerAddress) {
      if (serverAddressesArray.length === 0) {
        throw (0, _error.newError)('Received no ' + serversName + ' from router ' + routerAddress, _error.PROTOCOL_ERROR);
      }
    }
  }]);
  return Rediscovery;
}();

exports["default"] = Rediscovery;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/request-message.js":
/*!*******************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/request-message.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.ALL = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

var _integer = __webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js");

var _util = __webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
// Signature bytes for each request message type
var INIT = 0x01; // 0000 0001 // INIT <user_agent> <authentication_token>

var ACK_FAILURE = 0x0e; // 0000 1110 // ACK_FAILURE - unused

var RESET = 0x0f; // 0000 1111 // RESET

var RUN = 0x10; // 0001 0000 // RUN <query> <parameters>

var DISCARD_ALL = 0x2f; // 0010 1111 // DISCARD_ALL - unused

var PULL_ALL = 0x3f; // 0011 1111 // PULL_ALL

var HELLO = 0x01; // 0000 0001 // HELLO <metadata>

var GOODBYE = 0x02; // 0000 0010 // GOODBYE

var BEGIN = 0x11; // 0001 0001 // BEGIN <metadata>

var COMMIT = 0x12; // 0001 0010 // COMMIT

var ROLLBACK = 0x13; // 0001 0011 // ROLLBACK

var DISCARD = 0x2f; // 0010 1111 // DISCARD

var PULL = 0x3f; // 0011 1111 // PULL

var READ_MODE = 'r';
/* eslint-enable no-unused-vars */

var NO_STATEMENT_ID = -1;
var ALL = -1;
exports.ALL = ALL;

var RequestMessage = /*#__PURE__*/function () {
  function RequestMessage(signature, fields, toString) {
    (0, _classCallCheck2["default"])(this, RequestMessage);
    this.signature = signature;
    this.fields = fields;
    this.toString = toString;
  }
  /**
   * Create a new INIT message.
   * @param {string} clientName the client name.
   * @param {Object} authToken the authentication token.
   * @return {RequestMessage} new INIT message.
   */


  (0, _createClass2["default"])(RequestMessage, null, [{
    key: "init",
    value: function init(clientName, authToken) {
      return new RequestMessage(INIT, [clientName, authToken], function () {
        return "INIT ".concat(clientName, " {...}");
      });
    }
    /**
     * Create a new RUN message.
     * @param {string} query the cypher query.
     * @param {Object} parameters the query parameters.
     * @return {RequestMessage} new RUN message.
     */

  }, {
    key: "run",
    value: function run(query, parameters) {
      return new RequestMessage(RUN, [query, parameters], function () {
        return "RUN ".concat(query, " ").concat(JSON.stringify(parameters));
      });
    }
    /**
     * Get a PULL_ALL message.
     * @return {RequestMessage} the PULL_ALL message.
     */

  }, {
    key: "pullAll",
    value: function pullAll() {
      return PULL_ALL_MESSAGE;
    }
    /**
     * Get a RESET message.
     * @return {RequestMessage} the RESET message.
     */

  }, {
    key: "reset",
    value: function reset() {
      return RESET_MESSAGE;
    }
    /**
     * Create a new HELLO message.
     * @param {string} userAgent the user agent.
     * @param {Object} authToken the authentication token.
     * @param {Object} optional server side routing, set to routing context to turn on server side routing (> 4.1)
     * @return {RequestMessage} new HELLO message.
     */

  }, {
    key: "hello",
    value: function hello(userAgent, authToken) {
      var routing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var metadata = Object.assign({
        user_agent: userAgent
      }, authToken);

      if (routing != null) {
        metadata.routing = routing;
      }

      return new RequestMessage(HELLO, [metadata], function () {
        return "HELLO {user_agent: '".concat(userAgent, "', ...}");
      });
    }
    /**
     * Create a new BEGIN message.
     * @param {Bookmark} bookmark the bookmark.
     * @param {TxConfig} txConfig the configuration.
     * @param {string} database the database name.
     * @param {string} mode the access mode.
     * @return {RequestMessage} new BEGIN message.
     */

  }, {
    key: "begin",
    value: function begin() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          bookmark = _ref.bookmark,
          txConfig = _ref.txConfig,
          database = _ref.database,
          mode = _ref.mode;

      var metadata = buildTxMetadata(bookmark, txConfig, database, mode);
      return new RequestMessage(BEGIN, [metadata], function () {
        return "BEGIN ".concat(JSON.stringify(metadata));
      });
    }
    /**
     * Get a COMMIT message.
     * @return {RequestMessage} the COMMIT message.
     */

  }, {
    key: "commit",
    value: function commit() {
      return COMMIT_MESSAGE;
    }
    /**
     * Get a ROLLBACK message.
     * @return {RequestMessage} the ROLLBACK message.
     */

  }, {
    key: "rollback",
    value: function rollback() {
      return ROLLBACK_MESSAGE;
    }
    /**
     * Create a new RUN message with additional metadata.
     * @param {string} query the cypher query.
     * @param {Object} parameters the query parameters.
     * @param {Bookmark} bookmark the bookmark.
     * @param {TxConfig} txConfig the configuration.
     * @param {string} database the database name.
     * @param {string} mode the access mode.
     * @return {RequestMessage} new RUN message with additional metadata.
     */

  }, {
    key: "runWithMetadata",
    value: function runWithMetadata(query, parameters) {
      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          bookmark = _ref2.bookmark,
          txConfig = _ref2.txConfig,
          database = _ref2.database,
          mode = _ref2.mode;

      var metadata = buildTxMetadata(bookmark, txConfig, database, mode);
      return new RequestMessage(RUN, [query, parameters, metadata], function () {
        return "RUN ".concat(query, " ").concat(JSON.stringify(parameters), " ").concat(JSON.stringify(metadata));
      });
    }
    /**
     * Get a GOODBYE message.
     * @return {RequestMessage} the GOODBYE message.
     */

  }, {
    key: "goodbye",
    value: function goodbye() {
      return GOODBYE_MESSAGE;
    }
    /**
     * Generates a new PULL message with additional metadata.
     * @param {Integer|number} stmtId
     * @param {Integer|number} n
     * @return {RequestMessage} the PULL message.
     */

  }, {
    key: "pull",
    value: function pull() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$stmtId = _ref3.stmtId,
          stmtId = _ref3$stmtId === void 0 ? NO_STATEMENT_ID : _ref3$stmtId,
          _ref3$n = _ref3.n,
          n = _ref3$n === void 0 ? ALL : _ref3$n;

      var metadata = buildStreamMetadata(stmtId || NO_STATEMENT_ID, n || ALL);
      return new RequestMessage(PULL, [metadata], function () {
        return "PULL ".concat(JSON.stringify(metadata));
      });
    }
    /**
     * Generates a new DISCARD message with additional metadata.
     * @param {Integer|number} stmtId
     * @param {Integer|number} n
     * @return {RequestMessage} the PULL message.
     */

  }, {
    key: "discard",
    value: function discard() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref4$stmtId = _ref4.stmtId,
          stmtId = _ref4$stmtId === void 0 ? NO_STATEMENT_ID : _ref4$stmtId,
          _ref4$n = _ref4.n,
          n = _ref4$n === void 0 ? ALL : _ref4$n;

      var metadata = buildStreamMetadata(stmtId || NO_STATEMENT_ID, n || ALL);
      return new RequestMessage(DISCARD, [metadata], function () {
        return "DISCARD ".concat(JSON.stringify(metadata));
      });
    }
  }]);
  return RequestMessage;
}();
/**
 * Create an object that represent transaction metadata.
 * @param {Bookmark} bookmark the bookmark.
 * @param {TxConfig} txConfig the configuration.
 * @param {string} database the database name.
 * @param {string} mode the access mode.
 * @return {Object} a metadata object.
 */


exports["default"] = RequestMessage;

function buildTxMetadata(bookmark, txConfig, database, mode) {
  var metadata = {};

  if (!bookmark.isEmpty()) {
    metadata.bookmarks = bookmark.values();
  }

  if (txConfig.timeout) {
    metadata.tx_timeout = txConfig.timeout;
  }

  if (txConfig.metadata) {
    metadata.tx_metadata = txConfig.metadata;
  }

  if (database) {
    metadata.db = (0, _util.assertString)(database, 'database');
  }

  if (mode === _constants.ACCESS_MODE_READ) {
    metadata.mode = READ_MODE;
  }

  return metadata;
}
/**
 * Create an object that represents streaming metadata.
 * @param {Integer|number} stmtId The query id to stream its results.
 * @param {Integer|number} n The number of records to stream.
 * @returns {Object} a metadata object.
 */


function buildStreamMetadata(stmtId, n) {
  var metadata = {
    n: (0, _integer["int"])(n)
  };

  if (stmtId !== NO_STATEMENT_ID) {
    metadata.qid = (0, _integer["int"])(stmtId);
  }

  return metadata;
} // constants for messages that never change


var PULL_ALL_MESSAGE = new RequestMessage(PULL_ALL, [], function () {
  return 'PULL_ALL';
});
var RESET_MESSAGE = new RequestMessage(RESET, [], function () {
  return 'RESET';
});
var COMMIT_MESSAGE = new RequestMessage(COMMIT, [], function () {
  return 'COMMIT';
});
var ROLLBACK_MESSAGE = new RequestMessage(ROLLBACK, [], function () {
  return 'ROLLBACK';
});
var GOODBYE_MESSAGE = new RequestMessage(GOODBYE, [], function () {
  return 'GOODBYE';
});

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/resolver/base-host-name-resolver.js":
/*!************************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/resolver/base-host-name-resolver.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BaseHostNameResolver = /*#__PURE__*/function () {
  function BaseHostNameResolver() {
    (0, _classCallCheck2["default"])(this, BaseHostNameResolver);
  }

  (0, _createClass2["default"])(BaseHostNameResolver, [{
    key: "resolve",
    value: function resolve() {
      throw new Error('Abstract function');
    }
    /**
     * @protected
     */

  }, {
    key: "_resolveToItself",
    value: function _resolveToItself(address) {
      return Promise.resolve([address]);
    }
  }]);
  return BaseHostNameResolver;
}();

exports["default"] = BaseHostNameResolver;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/resolver/configured-custom-resolver.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/resolver/configured-custom-resolver.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _serverAddress = _interopRequireDefault(__webpack_require__(/*! ../server-address */ "./node_modules/neo4j-driver/lib/internal/server-address.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function resolveToSelf(address) {
  return Promise.resolve([address]);
}

var ConfiguredCustomResolver = /*#__PURE__*/function () {
  function ConfiguredCustomResolver(resolverFunction) {
    (0, _classCallCheck2["default"])(this, ConfiguredCustomResolver);
    this._resolverFunction = resolverFunction || resolveToSelf;
  }

  (0, _createClass2["default"])(ConfiguredCustomResolver, [{
    key: "resolve",
    value: function resolve(seedRouter) {
      var _this = this;

      return new Promise(function (resolve) {
        return resolve(_this._resolverFunction(seedRouter.asHostPort()));
      }).then(function (resolved) {
        if (!Array.isArray(resolved)) {
          throw new TypeError('Configured resolver function should either return an array of addresses or a Promise resolved with an array of addresses.' + "Each address is '<host>:<port>'. Got: ".concat(resolved));
        }

        return resolved.map(function (r) {
          return _serverAddress["default"].fromUrl(r);
        });
      });
    }
  }]);
  return ConfiguredCustomResolver;
}();

exports["default"] = ConfiguredCustomResolver;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/retry-logic-rx.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/retry-logic-rx.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _rxjs = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");

var _logger = _interopRequireDefault(__webpack_require__(/*! ./logger */ "./node_modules/neo4j-driver/lib/internal/logger.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds

var DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds

var DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;
var DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;

var RxRetryLogic = /*#__PURE__*/function () {
  /**
   *
   * @param {Object} args
   * @param {Logger} args.logger
   */
  function RxRetryLogic() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$maxRetryTimeout = _ref.maxRetryTimeout,
        maxRetryTimeout = _ref$maxRetryTimeout === void 0 ? DEFAULT_MAX_RETRY_TIME_MS : _ref$maxRetryTimeout,
        _ref$initialDelay = _ref.initialDelay,
        initialDelay = _ref$initialDelay === void 0 ? DEFAULT_INITIAL_RETRY_DELAY_MS : _ref$initialDelay,
        _ref$delayMultiplier = _ref.delayMultiplier,
        delayMultiplier = _ref$delayMultiplier === void 0 ? DEFAULT_RETRY_DELAY_MULTIPLIER : _ref$delayMultiplier,
        _ref$delayJitter = _ref.delayJitter,
        delayJitter = _ref$delayJitter === void 0 ? DEFAULT_RETRY_DELAY_JITTER_FACTOR : _ref$delayJitter,
        _ref$logger = _ref.logger,
        logger = _ref$logger === void 0 ? null : _ref$logger;

    (0, _classCallCheck2["default"])(this, RxRetryLogic);
    this._maxRetryTimeout = valueOrDefault(maxRetryTimeout, DEFAULT_MAX_RETRY_TIME_MS);
    this._initialDelay = valueOrDefault(initialDelay, DEFAULT_INITIAL_RETRY_DELAY_MS);
    this._delayMultiplier = valueOrDefault(delayMultiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);
    this._delayJitter = valueOrDefault(delayJitter, DEFAULT_RETRY_DELAY_JITTER_FACTOR);
    this._logger = logger;
  }
  /**
   *
   * @param {Observable<Any>} work
   */


  (0, _createClass2["default"])(RxRetryLogic, [{
    key: "retry",
    value: function retry(work) {
      var _this = this;

      return work.pipe((0, _operators.retryWhen)(function (failedWork) {
        var handledExceptions = [];
        var startTime = Date.now();
        var retryCount = 1;
        var delayDuration = _this._initialDelay;
        return failedWork.pipe((0, _operators.flatMap)(function (err) {
          if (!RxRetryLogic._canRetryOn(err)) {
            return (0, _rxjs.throwError)(err);
          }

          handledExceptions.push(err);

          if (retryCount >= 2 && Date.now() - startTime >= _this._maxRetryTimeout) {
            var error = (0, _error.newError)("Failed after retried for ".concat(retryCount, " times in ").concat(_this._maxRetryTimeout, " ms. Make sure that your database is online and retry again."), _error.SERVICE_UNAVAILABLE);
            error.seenErrors = handledExceptions;
            return (0, _rxjs.throwError)(error);
          }

          var nextDelayDuration = _this._computeNextDelay(delayDuration);

          delayDuration = delayDuration * _this._delayMultiplier;
          retryCount++;

          if (_this._logger) {
            _this._logger.warn("Transaction failed and will be retried in ".concat(nextDelayDuration));
          }

          return (0, _rxjs.of)(1).pipe((0, _operators.delay)(nextDelayDuration));
        }));
      }));
    }
  }, {
    key: "_computeNextDelay",
    value: function _computeNextDelay(delay) {
      var jitter = delay * this._delayJitter;
      return delay - jitter + 2 * jitter * Math.random();
    }
  }], [{
    key: "_canRetryOn",
    value: function _canRetryOn(error) {
      return error && error.code && (error.code === _error.SERVICE_UNAVAILABLE || error.code === _error.SESSION_EXPIRED || this._isTransientError(error));
    }
  }, {
    key: "_isTransientError",
    value: function _isTransientError(error) {
      // Retries should not happen when transaction was explicitly terminated by the user.
      // Termination of transaction might result in two different error codes depending on where it was
      // terminated. These are really client errors but classification on the server is not entirely correct and
      // they are classified as transient.
      var code = error.code;

      if (code.indexOf('TransientError') >= 0) {
        if (code === 'Neo.TransientError.Transaction.Terminated' || code === 'Neo.TransientError.Transaction.LockClientStopped') {
          return false;
        }

        return true;
      }

      return false;
    }
  }]);
  return RxRetryLogic;
}();

exports["default"] = RxRetryLogic;

function valueOrDefault(value, defaultValue) {
  if (value || value === 0) {
    return value;
  }

  return defaultValue;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/round-robin-array-index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/round-robin-array-index.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var RoundRobinArrayIndex = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {number} [initialOffset=0] the initial offset for round robin.
   */
  function RoundRobinArrayIndex(initialOffset) {
    (0, _classCallCheck2["default"])(this, RoundRobinArrayIndex);
    this._offset = initialOffset || 0;
  }
  /**
   * Get next index for an array with given length.
   * @param {number} arrayLength the array length.
   * @return {number} index in the array.
   */


  (0, _createClass2["default"])(RoundRobinArrayIndex, [{
    key: "next",
    value: function next(arrayLength) {
      if (arrayLength === 0) {
        return -1;
      }

      var nextOffset = this._offset;
      this._offset += 1;

      if (this._offset === Number.MAX_SAFE_INTEGER) {
        this._offset = 0;
      }

      return nextOffset % arrayLength;
    }
  }]);
  return RoundRobinArrayIndex;
}();

exports["default"] = RoundRobinArrayIndex;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/routing-table.js":
/*!*****************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/routing-table.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _integer = __webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js");

var _driver = __webpack_require__(/*! ../driver */ "./node_modules/neo4j-driver/lib/driver.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MIN_ROUTERS = 1;

var RoutingTable = /*#__PURE__*/function () {
  function RoutingTable() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        database = _ref.database,
        routers = _ref.routers,
        readers = _ref.readers,
        writers = _ref.writers,
        expirationTime = _ref.expirationTime;

    (0, _classCallCheck2["default"])(this, RoutingTable);
    this.database = database;
    this.databaseName = database || 'default database';
    this.routers = routers || [];
    this.readers = readers || [];
    this.writers = writers || [];
    this.expirationTime = expirationTime || (0, _integer["int"])(0);
  }

  (0, _createClass2["default"])(RoutingTable, [{
    key: "forget",
    value: function forget(address) {
      // Don't remove it from the set of routers, since that might mean we lose our ability to re-discover,
      // just remove it from the set of readers and writers, so that we don't use it for actual work without
      // performing discovery first.
      this.readers = removeFromArray(this.readers, address);
      this.writers = removeFromArray(this.writers, address);
    }
  }, {
    key: "forgetRouter",
    value: function forgetRouter(address) {
      this.routers = removeFromArray(this.routers, address);
    }
  }, {
    key: "forgetWriter",
    value: function forgetWriter(address) {
      this.writers = removeFromArray(this.writers, address);
    }
    /**
     * Check if this routing table is fresh to perform the required operation.
     * @param {string} accessMode the type of operation. Allowed values are {@link READ} and {@link WRITE}.
     * @return {boolean} `true` when this table contains servers to serve the required operation, `false` otherwise.
     */

  }, {
    key: "isStaleFor",
    value: function isStaleFor(accessMode) {
      return this.expirationTime.lessThan(Date.now()) || this.routers.length < MIN_ROUTERS || accessMode === _driver.READ && this.readers.length === 0 || accessMode === _driver.WRITE && this.writers.length === 0;
    }
    /**
     * Check if this routing table is expired for specified amount of duration
     *
     * @param {Integer} duration amount of duration in milliseconds to check for expiration
     * @returns {boolean}
     */

  }, {
    key: "isExpiredFor",
    value: function isExpiredFor(duration) {
      return this.expirationTime.add(duration).lessThan(Date.now());
    }
  }, {
    key: "allServers",
    value: function allServers() {
      return [].concat((0, _toConsumableArray2["default"])(this.routers), (0, _toConsumableArray2["default"])(this.readers), (0, _toConsumableArray2["default"])(this.writers));
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'RoutingTable[' + "database=".concat(this.databaseName, ", ") + "expirationTime=".concat(this.expirationTime, ", ") + "currentTime=".concat(Date.now(), ", ") + "routers=[".concat(this.routers, "], ") + "readers=[".concat(this.readers, "], ") + "writers=[".concat(this.writers, "]]");
    }
  }]);
  return RoutingTable;
}();
/**
 * Remove all occurrences of the element in the array.
 * @param {Array} array the array to filter.
 * @param {Object} element the element to remove.
 * @return {Array} new filtered array.
 */


exports["default"] = RoutingTable;

function removeFromArray(array, element) {
  return array.filter(function (item) {
    return item.asKey() !== element.asKey();
  });
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/routing-util.js":
/*!****************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/routing-util.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _integer = _interopRequireWildcard(__webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js"));

var _serverVersion = __webpack_require__(/*! ./server-version */ "./node_modules/neo4j-driver/lib/internal/server-version.js");

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

var _session = _interopRequireDefault(__webpack_require__(/*! ../session */ "./node_modules/neo4j-driver/lib/session.js"));

var _txConfig = _interopRequireDefault(__webpack_require__(/*! ./tx-config */ "./node_modules/neo4j-driver/lib/internal/tx-config.js"));

var _serverAddress = _interopRequireDefault(__webpack_require__(/*! ./server-address */ "./node_modules/neo4j-driver/lib/internal/server-address.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var CONTEXT = 'context';
var CALL_GET_ROUTING_TABLE = "CALL dbms.cluster.routing.getRoutingTable($".concat(CONTEXT, ")");
var DATABASE = 'database';
var CALL_GET_ROUTING_TABLE_MULTI_DB = "CALL dbms.routing.getRoutingTable($".concat(CONTEXT, ", $").concat(DATABASE, ")");
var PROCEDURE_NOT_FOUND_CODE = 'Neo.ClientError.Procedure.ProcedureNotFound';
var DATABASE_NOT_FOUND_CODE = 'Neo.ClientError.Database.DatabaseNotFound';

var RoutingUtil = /*#__PURE__*/function () {
  function RoutingUtil(routingContext, initialAddress) {
    (0, _classCallCheck2["default"])(this, RoutingUtil);
    this._routingContext = routingContext; // The address that the driver is connecting to, used by routing as a fallback when routing
    // and clustering isn't configured.

    this._initialAddress = initialAddress;
  }
  /**
   * Invoke routing procedure using the given session.
   * @param {Session} session the session to use.
   * @param {string} routerAddress the URL of the router.
   * @return {Promise<Record[]>} promise resolved with records returned by the procedure call or null if
   * connection error happened.
   */


  (0, _createClass2["default"])(RoutingUtil, [{
    key: "callRoutingProcedure",
    value: function () {
      var _callRoutingProcedure = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(session, database, routerAddress) {
        var result;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return this._callAvailableRoutingProcedure(session, database);

              case 3:
                result = _context.sent;
                _context.next = 6;
                return session.close();

              case 6:
                return _context.abrupt("return", result.records);

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](0);

                if (!(_context.t0.code === DATABASE_NOT_FOUND_CODE)) {
                  _context.next = 15;
                  break;
                }

                throw _context.t0;

              case 15:
                if (!(_context.t0.code === PROCEDURE_NOT_FOUND_CODE)) {
                  _context.next = 19;
                  break;
                }

                throw (0, _error.newError)("Server at ".concat(routerAddress.asHostPort(), " can't perform routing. Make sure you are connecting to a causal cluster"), _error.SERVICE_UNAVAILABLE);

              case 19:
                return _context.abrupt("return", null);

              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 9]]);
      }));

      function callRoutingProcedure(_x, _x2, _x3) {
        return _callRoutingProcedure.apply(this, arguments);
      }

      return callRoutingProcedure;
    }()
  }, {
    key: "parseTtl",
    value: function parseTtl(record, routerAddress) {
      try {
        var now = (0, _integer["int"])(Date.now());
        var expires = (0, _integer["int"])(record.get('ttl')).multiply(1000).add(now); // if the server uses a really big expire time like Long.MAX_VALUE this may have overflowed

        if (expires.lessThan(now)) {
          return _integer["default"].MAX_VALUE;
        }

        return expires;
      } catch (error) {
        throw (0, _error.newError)("Unable to parse TTL entry from router ".concat(routerAddress, " from record:\n").concat(JSON.stringify(record), "\nError message: ").concat(error.message), _error.PROTOCOL_ERROR);
      }
    }
  }, {
    key: "parseServers",
    value: function parseServers(record, routerAddress) {
      try {
        var servers = record.get('servers');
        var routers = [];
        var readers = [];
        var writers = [];
        servers.forEach(function (server) {
          var role = server.role;
          var addresses = server.addresses;

          if (role === 'ROUTE') {
            routers = parseArray(addresses).map(function (address) {
              return _serverAddress["default"].fromUrl(address);
            });
          } else if (role === 'WRITE') {
            writers = parseArray(addresses).map(function (address) {
              return _serverAddress["default"].fromUrl(address);
            });
          } else if (role === 'READ') {
            readers = parseArray(addresses).map(function (address) {
              return _serverAddress["default"].fromUrl(address);
            });
          } else {
            throw (0, _error.newError)('Unknown server role "' + role + '"', _error.PROTOCOL_ERROR);
          }
        });
        return {
          routers: routers,
          readers: readers,
          writers: writers
        };
      } catch (error) {
        throw (0, _error.newError)("Unable to parse servers entry from router ".concat(routerAddress, " from record:\n").concat(JSON.stringify(record), "\nError message: ").concat(error.message), _error.PROTOCOL_ERROR);
      }
    }
  }, {
    key: "_callAvailableRoutingProcedure",
    value: function _callAvailableRoutingProcedure(session, database) {
      var _this = this;

      return session._run(null, null, function (connection) {
        var query;
        var params;
        var protocolVersion = connection.protocol().version;

        if (protocolVersion >= 4.0) {
          query = CALL_GET_ROUTING_TABLE_MULTI_DB;
          params = {
            context: _this._routingContext || {},
            database: database || null
          };
          params.context.address = _this._initialAddress;
        } else {
          query = CALL_GET_ROUTING_TABLE;
          params = {
            context: _this._routingContext
          };
        }

        return connection.protocol().run(query, params, {
          bookmark: session._lastBookmark,
          txConfig: _txConfig["default"].empty(),
          mode: session._mode,
          database: session._database,
          afterComplete: session._onComplete
        });
      });
    }
  }]);
  return RoutingUtil;
}();

exports["default"] = RoutingUtil;

function parseArray(addresses) {
  if (!Array.isArray(addresses)) {
    throw new TypeError('Array expected but got: ' + addresses);
  }

  return Array.from(addresses);
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/server-address.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/server-address.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _util = __webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js");

var _urlUtil = _interopRequireDefault(__webpack_require__(/*! ./url-util */ "./node_modules/neo4j-driver/lib/internal/url-util.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ServerAddress = /*#__PURE__*/function () {
  function ServerAddress(host, resolved, port, hostPort) {
    (0, _classCallCheck2["default"])(this, ServerAddress);
    this._host = (0, _util.assertString)(host, 'host');
    this._resolved = resolved ? (0, _util.assertString)(resolved, 'resolved') : null;
    this._port = (0, _util.assertNumber)(port, 'port');
    this._hostPort = hostPort;
    this._stringValue = resolved ? "".concat(hostPort, "(").concat(resolved, ")") : "".concat(hostPort);
  }

  (0, _createClass2["default"])(ServerAddress, [{
    key: "host",
    value: function host() {
      return this._host;
    }
  }, {
    key: "resolvedHost",
    value: function resolvedHost() {
      return this._resolved ? this._resolved : this._host;
    }
  }, {
    key: "port",
    value: function port() {
      return this._port;
    }
  }, {
    key: "resolveWith",
    value: function resolveWith(resolved) {
      return new ServerAddress(this._host, resolved, this._port, this._hostPort);
    }
  }, {
    key: "asHostPort",
    value: function asHostPort() {
      return this._hostPort;
    }
  }, {
    key: "asKey",
    value: function asKey() {
      return this._hostPort;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this._stringValue;
    }
  }], [{
    key: "fromUrl",
    value: function fromUrl(url) {
      var urlParsed = _urlUtil["default"].parseDatabaseUrl(url);

      return new ServerAddress(urlParsed.host, null, urlParsed.port, urlParsed.hostAndPort);
    }
  }]);
  return ServerAddress;
}();

exports["default"] = ServerAddress;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/server-version.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/server-version.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION_IN_DEV = exports.VERSION_4_0_0 = exports.VERSION_3_5_0 = exports.VERSION_3_4_0 = exports.VERSION_3_2_0 = exports.ServerVersion = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _util = __webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SERVER_VERSION_REGEX = new RegExp('^(Neo4j/)?(\\d+)\\.(\\d+)(?:\\.)?(\\d*)(\\.|-|\\+)?([0-9A-Za-z-.]*)?$');
var NEO4J_IN_DEV_VERSION_STRING = 'Neo4j/dev';

var ServerVersion = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {number} major the major version number.
   * @param {number} minor the minor version number.
   * @param {number} patch the patch version number.
   * @param {string} the original version string
   */
  function ServerVersion(major, minor, patch, originalVersionString) {
    (0, _classCallCheck2["default"])(this, ServerVersion);
    this.major = major;
    this.minor = minor;
    this.patch = patch;
    this._originalVersionString = originalVersionString;
  }
  /**
   * Fetch server version using the given driver.
   * @param {Driver} driver the driver to use.
   * @return {Promise<ServerVersion>} promise resolved with a {@link ServerVersion} object or rejected with error.
   */


  (0, _createClass2["default"])(ServerVersion, [{
    key: "compareTo",

    /**
     * Compare this version to the given one.
     * @param {ServerVersion} other the version to compare with.
     * @return {number} value 0 if this version is the same as the given one, value less then 0 when this version
     * was released earlier than the given one and value greater then 0 when this version was released after
     * than the given one.
     */
    value: function compareTo(other) {
      var result = compareInts(this.major, other.major);

      if (result === 0) {
        result = compareInts(this.minor, other.minor);

        if (result === 0) {
          result = compareInts(this.patch, other.patch);
        }
      }

      return result;
    }
  }, {
    key: "toString",
    value: function toString() {
      if (this._originalVersionString) {
        return this._originalVersionString;
      }

      return "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);
    }
  }], [{
    key: "fromDriver",
    value: function fromDriver(driver) {
      var session = driver.session();
      return session.run('RETURN 1').then(function (result) {
        return session.close().then(function () {
          return ServerVersion.fromString(result.summary.server.version);
        });
      });
    }
    /**
     * Parse given string to a {@link ServerVersion} object.
     * @param {string} versionStr the string to parse.
     * @return {ServerVersion} version for the given string.
     * @throws Error if given string can't be parsed.
     */

  }, {
    key: "fromString",
    value: function fromString(versionStr) {
      if (!versionStr) {
        return new ServerVersion(3, 0, 0);
      }

      (0, _util.assertString)(versionStr, 'Neo4j version string');

      if (versionStr.toLowerCase() === NEO4J_IN_DEV_VERSION_STRING.toLowerCase()) {
        return VERSION_IN_DEV;
      }

      var version = versionStr.match(SERVER_VERSION_REGEX);

      if (!version) {
        throw new Error("Unparsable Neo4j version: ".concat(versionStr));
      }

      var major = parseIntStrict(version[2]);
      var minor = parseIntStrict(version[3]);
      var patch = parseIntStrict(version[4] || 0);
      return new ServerVersion(major, minor, patch, versionStr);
    }
  }]);
  return ServerVersion;
}();

exports.ServerVersion = ServerVersion;

function parseIntStrict(str, name) {
  var value = parseInt(str, 10);

  if (!value && value !== 0) {
    throw new Error("Unparsable number ".concat(name, ": '").concat(str, "'"));
  }

  return value;
}

function compareInts(x, y) {
  return x < y ? -1 : x === y ? 0 : 1;
}

var VERSION_3_2_0 = ServerVersion.fromString('Neo4j/3.2.0');
exports.VERSION_3_2_0 = VERSION_3_2_0;
var VERSION_3_4_0 = ServerVersion.fromString('Neo4j/3.4.0');
exports.VERSION_3_4_0 = VERSION_3_4_0;
var VERSION_3_5_0 = ServerVersion.fromString('Neo4j/3.5.0');
exports.VERSION_3_5_0 = VERSION_3_5_0;
var VERSION_4_0_0 = ServerVersion.fromString('Neo4j/4.0.0');
exports.VERSION_4_0_0 = VERSION_4_0_0;
var maxVer = Number.MAX_SAFE_INTEGER;
var VERSION_IN_DEV = new ServerVersion(maxVer, maxVer, maxVer, NEO4J_IN_DEV_VERSION_STRING);
exports.VERSION_IN_DEV = VERSION_IN_DEV;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/stream-observers.js":
/*!********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/stream-observers.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompletedObserver = exports.FailedObserver = exports.ResetObserver = exports.LoginObserver = exports.ResultStreamObserver = exports.StreamObserver = void 0;

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _record = _interopRequireDefault(__webpack_require__(/*! ../record */ "./node_modules/neo4j-driver/lib/record.js"));

var _connection = _interopRequireDefault(__webpack_require__(/*! ./connection */ "./node_modules/neo4j-driver/lib/internal/connection.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _integer = _interopRequireDefault(__webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js"));

var _requestMessage = __webpack_require__(/*! ./request-message */ "./node_modules/neo4j-driver/lib/internal/request-message.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var StreamObserver = /*#__PURE__*/function () {
  function StreamObserver() {
    (0, _classCallCheck2["default"])(this, StreamObserver);
  }

  (0, _createClass2["default"])(StreamObserver, [{
    key: "onNext",
    value: function onNext(rawRecord) {}
  }, {
    key: "onError",
    value: function onError(error) {}
  }, {
    key: "onCompleted",
    value: function onCompleted(meta) {}
  }]);
  return StreamObserver;
}();
/**
 * Handles a RUN/PULL_ALL, or RUN/DISCARD_ALL requests, maps the responses
 * in a way that a user-provided observer can see these as a clean Stream
 * of records.
 * This class will queue up incoming messages until a user-provided observer
 * for the incoming stream is registered. Thus, we keep fields around
 * for tracking head/records/tail. These are only used if there is no
 * observer registered.
 * @access private
 */


exports.StreamObserver = StreamObserver;

var ResultStreamObserver = /*#__PURE__*/function (_StreamObserver) {
  (0, _inherits2["default"])(ResultStreamObserver, _StreamObserver);

  var _super = _createSuper(ResultStreamObserver);

  /**
   *
   * @param {Object} param
   * @param {Connection} param.connection
   * @param {boolean} param.reactive
   * @param {function(connection: Connection, stmtId: number|Integer, n: number|Integer, observer: StreamObserver)} param.moreFunction -
   * @param {function(connection: Connection, stmtId: number|Integer, observer: StreamObserver)} param.discardFunction -
   * @param {number|Integer} param.fetchSize -
   * @param {function(err: Error): Promise|void} param.beforeError -
   * @param {function(err: Error): Promise|void} param.afterError -
   * @param {function(keys: string[]): Promise|void} param.beforeKeys -
   * @param {function(keys: string[]): Promise|void} param.afterKeys -
   * @param {function(metadata: Object): Promise|void} param.beforeComplete -
   * @param {function(metadata: Object): Promise|void} param.afterComplete -
   */
  function ResultStreamObserver() {
    var _this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        connection = _ref.connection,
        _ref$reactive = _ref.reactive,
        reactive = _ref$reactive === void 0 ? false : _ref$reactive,
        moreFunction = _ref.moreFunction,
        discardFunction = _ref.discardFunction,
        _ref$fetchSize = _ref.fetchSize,
        fetchSize = _ref$fetchSize === void 0 ? _requestMessage.ALL : _ref$fetchSize,
        beforeError = _ref.beforeError,
        afterError = _ref.afterError,
        beforeKeys = _ref.beforeKeys,
        afterKeys = _ref.afterKeys,
        beforeComplete = _ref.beforeComplete,
        afterComplete = _ref.afterComplete;

    (0, _classCallCheck2["default"])(this, ResultStreamObserver);
    _this = _super.call(this);
    _this._connection = connection;
    _this._fieldKeys = null;
    _this._fieldLookup = null;
    _this._head = null;
    _this._queuedRecords = [];
    _this._tail = null;
    _this._error = null;
    _this._observers = [];
    _this._meta = {};
    _this._beforeError = beforeError;
    _this._afterError = afterError;
    _this._beforeKeys = beforeKeys;
    _this._afterKeys = afterKeys;
    _this._beforeComplete = beforeComplete;
    _this._afterComplete = afterComplete;
    _this._queryId = null;
    _this._moreFunction = moreFunction;
    _this._discardFunction = discardFunction;
    _this._discard = false;
    _this._fetchSize = fetchSize;

    _this._setState(reactive ? _states.READY : _states.READY_STREAMING);

    _this._setupAuoPull(fetchSize);

    return _this;
  }
  /**
   * Will be called on every record that comes in and transform a raw record
   * to a Object. If user-provided observer is present, pass transformed record
   * to it's onNext method, otherwise, push to record que.
   * @param {Array} rawRecord - An array with the raw record
   */


  (0, _createClass2["default"])(ResultStreamObserver, [{
    key: "onNext",
    value: function onNext(rawRecord) {
      var record = new _record["default"](this._fieldKeys, rawRecord, this._fieldLookup);

      if (this._observers.some(function (o) {
        return o.onNext;
      })) {
        this._observers.forEach(function (o) {
          if (o.onNext) {
            o.onNext(record);
          }
        });
      } else {
        this._queuedRecords.push(record);

        if (this._queuedRecords.length > this._highRecordWatermark) {
          this._autoPull = false;
        }
      }
    }
  }, {
    key: "onCompleted",
    value: function onCompleted(meta) {
      this._state.onSuccess(this, meta);
    }
    /**
     * Will be called on errors.
     * If user-provided observer is present, pass the error
     * to it's onError method, otherwise set instance variable _error.
     * @param {Object} error - An error object
     */

  }, {
    key: "onError",
    value: function onError(error) {
      this._state.onError(this, error);
    }
    /**
     * Cancel pending record stream
     */

  }, {
    key: "cancel",
    value: function cancel() {
      this._discard = true;
    }
    /**
     * Stream observer defaults to handling responses for two messages: RUN + PULL_ALL or RUN + DISCARD_ALL.
     * Response for RUN initializes query keys. Response for PULL_ALL / DISCARD_ALL exposes the result stream.
     *
     * However, some operations can be represented as a single message which receives full metadata in a single response.
     * For example, operations to begin, commit and rollback an explicit transaction use two messages in Bolt V1 but a single message in Bolt V3.
     * Messages are `RUN "BEGIN" {}` + `PULL_ALL` in Bolt V1 and `BEGIN` in Bolt V3.
     *
     * This function prepares the observer to only handle a single response message.
     */

  }, {
    key: "prepareToHandleSingleResponse",
    value: function prepareToHandleSingleResponse() {
      this._head = [];
      this._fieldKeys = [];

      this._setState(_states.STREAMING);
    }
    /**
     * Mark this observer as if it has completed with no metadata.
     */

  }, {
    key: "markCompleted",
    value: function markCompleted() {
      this._head = [];
      this._fieldKeys = [];
      this._tail = {};

      this._setState(_states.SUCCEEDED);
    }
    /**
     * Subscribe to events with provided observer.
     * @param {Object} observer - Observer object
     * @param {function(keys: String[])} observer.onKeys - Handle stream header, field keys.
     * @param {function(record: Object)} observer.onNext - Handle records, one by one.
     * @param {function(metadata: Object)} observer.onCompleted - Handle stream tail, the metadata.
     * @param {function(error: Object)} observer.onError - Handle errors, should always be provided.
     */

  }, {
    key: "subscribe",
    value: function subscribe(observer) {
      if (this._error) {
        observer.onError(this._error);
        return;
      }

      if (this._head && observer.onKeys) {
        observer.onKeys(this._head);
      }

      if (this._queuedRecords.length > 0 && observer.onNext) {
        for (var i = 0; i < this._queuedRecords.length; i++) {
          observer.onNext(this._queuedRecords[i]);

          if (this._queuedRecords.length - i - 1 <= this._lowRecordWatermark) {
            this._autoPull = true;

            if (this._state === _states.READY) {
              this._handleStreaming();
            }
          }
        }
      }

      if (this._tail && observer.onCompleted) {
        observer.onCompleted(this._tail);
      }

      this._observers.push(observer);

      if (this._state === _states.READY) {
        this._handleStreaming();
      }
    }
  }, {
    key: "_handleHasMore",
    value: function _handleHasMore(meta) {
      // We've consumed current batch and server notified us that there're more
      // records to stream. Let's invoke more or discard function based on whether
      // the user wants to discard streaming or not
      this._setState(_states.READY); // we've done streaming


      this._handleStreaming();

      delete meta.has_more;
    }
  }, {
    key: "_handlePullSuccess",
    value: function _handlePullSuccess(meta) {
      var _this2 = this;

      this._setState(_states.SUCCEEDED);

      var completionMetadata = Object.assign(this._connection ? {
        server: this._connection.server
      } : {}, this._meta, meta);
      var beforeHandlerResult = null;

      if (this._beforeComplete) {
        beforeHandlerResult = this._beforeComplete(completionMetadata);
      }

      var continuation = function continuation() {
        // End of stream
        _this2._tail = completionMetadata;

        if (_this2._observers.some(function (o) {
          return o.onCompleted;
        })) {
          _this2._observers.forEach(function (o) {
            if (o.onCompleted) {
              o.onCompleted(completionMetadata);
            }
          });
        }

        if (_this2._afterComplete) {
          _this2._afterComplete(completionMetadata);
        }
      };

      if (beforeHandlerResult) {
        Promise.resolve(beforeHandlerResult).then(function () {
          return continuation();
        });
      } else {
        continuation();
      }
    }
  }, {
    key: "_handleRunSuccess",
    value: function _handleRunSuccess(meta, afterSuccess) {
      var _this3 = this;

      if (this._fieldKeys === null) {
        // Stream header, build a name->index field lookup table
        // to be used by records. This is an optimization to make it
        // faster to look up fields in a record by name, rather than by index.
        // Since the records we get back via Bolt are just arrays of values.
        this._fieldKeys = [];
        this._fieldLookup = {};

        if (meta.fields && meta.fields.length > 0) {
          this._fieldKeys = meta.fields;

          for (var i = 0; i < meta.fields.length; i++) {
            this._fieldLookup[meta.fields[i]] = i;
          } // remove fields key from metadata object


          delete meta.fields;
        } // Extract server generated query id for use in requestMore and discard
        // functions


        if (meta.qid) {
          this._queryId = meta.qid; // remove qid from metadata object

          delete meta.qid;
        }

        this._storeMetadataForCompletion(meta);

        var beforeHandlerResult = null;

        if (this._beforeKeys) {
          beforeHandlerResult = this._beforeKeys(this._fieldKeys);
        }

        var continuation = function continuation() {
          _this3._head = _this3._fieldKeys;

          if (_this3._observers.some(function (o) {
            return o.onKeys;
          })) {
            _this3._observers.forEach(function (o) {
              if (o.onKeys) {
                o.onKeys(_this3._fieldKeys);
              }
            });
          }

          if (_this3._afterKeys) {
            _this3._afterKeys(_this3._fieldKeys);
          }

          afterSuccess();
        };

        if (beforeHandlerResult) {
          Promise.resolve(beforeHandlerResult).then(function () {
            return continuation();
          });
        } else {
          continuation();
        }
      }
    }
  }, {
    key: "_handleError",
    value: function _handleError(error) {
      var _this4 = this;

      this._setState(_states.FAILED);

      this._error = error;
      var beforeHandlerResult = null;

      if (this._beforeError) {
        beforeHandlerResult = this._beforeError(error);
      }

      var continuation = function continuation() {
        if (_this4._observers.some(function (o) {
          return o.onError;
        })) {
          _this4._observers.forEach(function (o) {
            if (o.onError) {
              o.onError(error);
            }
          });
        }

        if (_this4._afterError) {
          _this4._afterError(error);
        }
      };

      if (beforeHandlerResult) {
        Promise.resolve(beforeHandlerResult).then(function () {
          return continuation();
        });
      } else {
        continuation();
      }
    }
  }, {
    key: "_handleStreaming",
    value: function _handleStreaming() {
      if (this._head && this._observers.some(function (o) {
        return o.onNext || o.onCompleted;
      })) {
        if (this._discard) {
          this._discardFunction(this._connection, this._queryId, this);

          this._setState(_states.STREAMING);
        } else if (this._autoPull) {
          this._moreFunction(this._connection, this._queryId, this._fetchSize, this);

          this._setState(_states.STREAMING);
        }
      }
    }
  }, {
    key: "_storeMetadataForCompletion",
    value: function _storeMetadataForCompletion(meta) {
      var keys = Object.keys(meta);
      var index = keys.length;
      var key = '';

      while (index--) {
        key = keys[index];
        this._meta[key] = meta[key];
      }
    }
  }, {
    key: "_setState",
    value: function _setState(state) {
      this._state = state;
    }
  }, {
    key: "_setupAuoPull",
    value: function _setupAuoPull(fetchSize) {
      this._autoPull = true;

      if (fetchSize === _requestMessage.ALL) {
        this._lowRecordWatermark = Number.MAX_VALUE; // we shall always lower than this number to enable auto pull

        this._highRecordWatermark = Number.MAX_VALUE; // we shall never reach this number to disable auto pull
      } else {
        this._lowRecordWatermark = 0.3 * fetchSize;
        this._highRecordWatermark = 0.7 * fetchSize;
      }
    }
  }]);
  return ResultStreamObserver;
}(StreamObserver);

exports.ResultStreamObserver = ResultStreamObserver;

var LoginObserver = /*#__PURE__*/function (_StreamObserver2) {
  (0, _inherits2["default"])(LoginObserver, _StreamObserver2);

  var _super2 = _createSuper(LoginObserver);

  /**
   *
   * @param {Object} param -
   * @param {Connection} param.connection
   * @param {function(err: Error)} param.beforeError
   * @param {function(err: Error)} param.afterError
   * @param {function(metadata)} param.beforeComplete
   * @param {function(metadata)} param.afterComplete
   */
  function LoginObserver() {
    var _this5;

    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        connection = _ref2.connection,
        beforeError = _ref2.beforeError,
        afterError = _ref2.afterError,
        beforeComplete = _ref2.beforeComplete,
        afterComplete = _ref2.afterComplete;

    (0, _classCallCheck2["default"])(this, LoginObserver);
    _this5 = _super2.call(this);
    _this5._connection = connection;
    _this5._beforeError = beforeError;
    _this5._afterError = afterError;
    _this5._beforeComplete = beforeComplete;
    _this5._afterComplete = afterComplete;
    return _this5;
  }

  (0, _createClass2["default"])(LoginObserver, [{
    key: "onNext",
    value: function onNext(record) {
      this.onError((0, _error.newError)('Received RECORD when initializing ' + JSON.stringify(record)));
    }
  }, {
    key: "onError",
    value: function onError(error) {
      if (this._beforeError) {
        this._beforeError(error);
      }

      this._connection._updateCurrentObserver(); // make sure this exact observer will not be called again


      this._connection._handleFatalError(error); // initialization errors are fatal


      if (this._afterError) {
        this._afterError(error);
      }
    }
  }, {
    key: "onCompleted",
    value: function onCompleted(metadata) {
      if (this._beforeComplete) {
        this._beforeComplete(metadata);
      }

      if (metadata) {
        // read server version from the response metadata, if it is available
        var serverVersion = metadata.server;

        if (!this._connection.version) {
          this._connection.version = serverVersion;
        } // read database connection id from the response metadata, if it is available


        var dbConnectionId = metadata.connection_id;

        if (!this._connection.databaseId) {
          this._connection.databaseId = dbConnectionId;
        }
      }

      if (this._afterComplete) {
        this._afterComplete(metadata);
      }
    }
  }]);
  return LoginObserver;
}(StreamObserver);

exports.LoginObserver = LoginObserver;

var ResetObserver = /*#__PURE__*/function (_StreamObserver3) {
  (0, _inherits2["default"])(ResetObserver, _StreamObserver3);

  var _super3 = _createSuper(ResetObserver);

  /**
   *
   * @param {Object} param -
   * @param {Connection} param.connection
   * @param {function(err: Error)} param.onError
   * @param {function(metadata)} param.onComplete
   */
  function ResetObserver() {
    var _this6;

    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        connection = _ref3.connection,
        onError = _ref3.onError,
        onComplete = _ref3.onComplete;

    (0, _classCallCheck2["default"])(this, ResetObserver);
    _this6 = _super3.call(this);
    _this6._connection = connection;
    _this6._onError = onError;
    _this6._onComplete = onComplete;
    return _this6;
  }

  (0, _createClass2["default"])(ResetObserver, [{
    key: "onNext",
    value: function onNext(record) {
      this.onError((0, _error.newError)('Received RECORD when resetting: received record is: ' + JSON.stringify(record), _error.PROTOCOL_ERROR));
    }
  }, {
    key: "onError",
    value: function onError(error) {
      if (error.code === _error.PROTOCOL_ERROR) {
        this._connection._handleProtocolError(error.message);
      }

      if (this._onError) {
        this._onError(error);
      }
    }
  }, {
    key: "onCompleted",
    value: function onCompleted(metadata) {
      if (this._onComplete) {
        this._onComplete(metadata);
      }
    }
  }]);
  return ResetObserver;
}(StreamObserver);

exports.ResetObserver = ResetObserver;

var FailedObserver = /*#__PURE__*/function (_ResultStreamObserver) {
  (0, _inherits2["default"])(FailedObserver, _ResultStreamObserver);

  var _super4 = _createSuper(FailedObserver);

  function FailedObserver(_ref4) {
    var _this7;

    var error = _ref4.error,
        onError = _ref4.onError;
    (0, _classCallCheck2["default"])(this, FailedObserver);
    _this7 = _super4.call(this, {
      beforeError: onError
    });

    _this7.onError(error);

    return _this7;
  }

  return FailedObserver;
}(ResultStreamObserver);

exports.FailedObserver = FailedObserver;

var CompletedObserver = /*#__PURE__*/function (_ResultStreamObserver2) {
  (0, _inherits2["default"])(CompletedObserver, _ResultStreamObserver2);

  var _super5 = _createSuper(CompletedObserver);

  function CompletedObserver() {
    var _thisSuper, _this8;

    (0, _classCallCheck2["default"])(this, CompletedObserver);
    _this8 = _super5.call(this);
    (0, _get2["default"])((_thisSuper = (0, _assertThisInitialized2["default"])(_this8), (0, _getPrototypeOf2["default"])(CompletedObserver.prototype)), "markCompleted", _thisSuper).call(_thisSuper);
    return _this8;
  }

  return CompletedObserver;
}(ResultStreamObserver);

exports.CompletedObserver = CompletedObserver;
var _states = {
  READY_STREAMING: {
    // async start state
    onSuccess: function onSuccess(streamObserver, meta) {
      streamObserver._handleRunSuccess(meta, function () {
        streamObserver._setState(_states.STREAMING);
      } // after run succeeded, async directly move to streaming
      // state
      );
    },
    onError: function onError(streamObserver, error) {
      streamObserver._handleError(error);
    },
    name: function name() {
      return 'READY_STREAMING';
    }
  },
  READY: {
    // reactive start state
    onSuccess: function onSuccess(streamObserver, meta) {
      streamObserver._handleRunSuccess(meta, function () {
        return streamObserver._handleStreaming();
      } // after run succeeded received, reactive shall start pulling
      );
    },
    onError: function onError(streamObserver, error) {
      streamObserver._handleError(error);
    },
    name: function name() {
      return 'READY';
    }
  },
  STREAMING: {
    onSuccess: function onSuccess(streamObserver, meta) {
      if (meta.has_more) {
        streamObserver._handleHasMore(meta);
      } else {
        streamObserver._handlePullSuccess(meta);
      }
    },
    onError: function onError(streamObserver, error) {
      streamObserver._handleError(error);
    },
    name: function name() {
      return 'STREAMING';
    }
  },
  FAILED: {
    onError: function onError(error) {// more errors are ignored
    },
    name: function name() {
      return 'FAILED';
    }
  },
  SUCCEEDED: {
    name: function name() {
      return 'SUCCEEDED';
    }
  }
};

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/temporal-util.js":
/*!*****************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/temporal-util.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeSecondsForDuration = normalizeSecondsForDuration;
exports.normalizeNanosecondsForDuration = normalizeNanosecondsForDuration;
exports.localTimeToNanoOfDay = localTimeToNanoOfDay;
exports.nanoOfDayToLocalTime = nanoOfDayToLocalTime;
exports.localDateTimeToEpochSecond = localDateTimeToEpochSecond;
exports.epochSecondAndNanoToLocalDateTime = epochSecondAndNanoToLocalDateTime;
exports.dateToEpochDay = dateToEpochDay;
exports.epochDayToDate = epochDayToDate;
exports.durationToIsoString = durationToIsoString;
exports.timeToIsoString = timeToIsoString;
exports.timeZoneOffsetToIsoString = timeZoneOffsetToIsoString;
exports.dateToIsoString = dateToIsoString;
exports.totalNanoseconds = totalNanoseconds;
exports.timeZoneOffsetInSeconds = timeZoneOffsetInSeconds;
exports.assertValidYear = assertValidYear;
exports.assertValidMonth = assertValidMonth;
exports.assertValidDay = assertValidDay;
exports.assertValidHour = assertValidHour;
exports.assertValidMinute = assertValidMinute;
exports.assertValidSecond = assertValidSecond;
exports.assertValidNanosecond = assertValidNanosecond;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _integer = __webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js");

var _temporalTypes = __webpack_require__(/*! ../temporal-types */ "./node_modules/neo4j-driver/lib/temporal-types.js");

var _util = __webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js");

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
  Code in this util should be compatible with code in the database that uses JSR-310 java.time APIs.

  It is based on a library called ThreeTen (https://github.com/ThreeTen/threetenbp) which was derived
  from JSR-310 reference implementation previously hosted on GitHub. Code uses `Integer` type everywhere
  to correctly handle large integer values that are greater than `Number.MAX_SAFE_INTEGER`.

  Please consult either ThreeTen or js-joda (https://github.com/js-joda/js-joda) when working with the
  conversion functions.
 */
var ValueRange = /*#__PURE__*/function () {
  function ValueRange(min, max) {
    (0, _classCallCheck2["default"])(this, ValueRange);
    this._minNumber = min;
    this._maxNumber = max;
    this._minInteger = (0, _integer["int"])(min);
    this._maxInteger = (0, _integer["int"])(max);
  }

  (0, _createClass2["default"])(ValueRange, [{
    key: "contains",
    value: function contains(value) {
      if ((0, _integer.isInt)(value)) {
        return value.greaterThanOrEqual(this._minInteger) && value.lessThanOrEqual(this._maxInteger);
      } else {
        return value >= this._minNumber && value <= this._maxNumber;
      }
    }
  }, {
    key: "toString",
    value: function toString() {
      return "[".concat(this._minNumber, ", ").concat(this._maxNumber, "]");
    }
  }]);
  return ValueRange;
}();

var YEAR_RANGE = new ValueRange(-999999999, 999999999);
var MONTH_OF_YEAR_RANGE = new ValueRange(1, 12);
var DAY_OF_MONTH_RANGE = new ValueRange(1, 31);
var HOUR_OF_DAY_RANGE = new ValueRange(0, 23);
var MINUTE_OF_HOUR_RANGE = new ValueRange(0, 59);
var SECOND_OF_MINUTE_RANGE = new ValueRange(0, 59);
var NANOSECOND_OF_SECOND_RANGE = new ValueRange(0, 999999999);
var MINUTES_PER_HOUR = 60;
var SECONDS_PER_MINUTE = 60;
var SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
var NANOS_PER_SECOND = 1000000000;
var NANOS_PER_MILLISECOND = 1000000;
var NANOS_PER_MINUTE = NANOS_PER_SECOND * SECONDS_PER_MINUTE;
var NANOS_PER_HOUR = NANOS_PER_MINUTE * MINUTES_PER_HOUR;
var DAYS_0000_TO_1970 = 719528;
var DAYS_PER_400_YEAR_CYCLE = 146097;
var SECONDS_PER_DAY = 86400;

function normalizeSecondsForDuration(seconds, nanoseconds) {
  return (0, _integer["int"])(seconds).add(floorDiv(nanoseconds, NANOS_PER_SECOND));
}

function normalizeNanosecondsForDuration(nanoseconds) {
  return floorMod(nanoseconds, NANOS_PER_SECOND);
}
/**
 * Converts given local time into a single integer representing this same time in nanoseconds of the day.
 * @param {Integer|number|string} hour the hour of the local time to convert.
 * @param {Integer|number|string} minute the minute of the local time to convert.
 * @param {Integer|number|string} second the second of the local time to convert.
 * @param {Integer|number|string} nanosecond the nanosecond of the local time to convert.
 * @return {Integer} nanoseconds representing the given local time.
 */


function localTimeToNanoOfDay(hour, minute, second, nanosecond) {
  hour = (0, _integer["int"])(hour);
  minute = (0, _integer["int"])(minute);
  second = (0, _integer["int"])(second);
  nanosecond = (0, _integer["int"])(nanosecond);
  var totalNanos = hour.multiply(NANOS_PER_HOUR);
  totalNanos = totalNanos.add(minute.multiply(NANOS_PER_MINUTE));
  totalNanos = totalNanos.add(second.multiply(NANOS_PER_SECOND));
  return totalNanos.add(nanosecond);
}
/**
 * Converts nanoseconds of the day into local time.
 * @param {Integer|number|string} nanoOfDay the nanoseconds of the day to convert.
 * @return {LocalTime} the local time representing given nanoseconds of the day.
 */


function nanoOfDayToLocalTime(nanoOfDay) {
  nanoOfDay = (0, _integer["int"])(nanoOfDay);
  var hour = nanoOfDay.div(NANOS_PER_HOUR);
  nanoOfDay = nanoOfDay.subtract(hour.multiply(NANOS_PER_HOUR));
  var minute = nanoOfDay.div(NANOS_PER_MINUTE);
  nanoOfDay = nanoOfDay.subtract(minute.multiply(NANOS_PER_MINUTE));
  var second = nanoOfDay.div(NANOS_PER_SECOND);
  var nanosecond = nanoOfDay.subtract(second.multiply(NANOS_PER_SECOND));
  return new _temporalTypes.LocalTime(hour, minute, second, nanosecond);
}
/**
 * Converts given local date time into a single integer representing this same time in epoch seconds UTC.
 * @param {Integer|number|string} year the year of the local date-time to convert.
 * @param {Integer|number|string} month the month of the local date-time to convert.
 * @param {Integer|number|string} day the day of the local date-time to convert.
 * @param {Integer|number|string} hour the hour of the local date-time to convert.
 * @param {Integer|number|string} minute the minute of the local date-time to convert.
 * @param {Integer|number|string} second the second of the local date-time to convert.
 * @param {Integer|number|string} nanosecond the nanosecond of the local date-time to convert.
 * @return {Integer} epoch second in UTC representing the given local date time.
 */


function localDateTimeToEpochSecond(year, month, day, hour, minute, second, nanosecond) {
  var epochDay = dateToEpochDay(year, month, day);
  var localTimeSeconds = localTimeToSecondOfDay(hour, minute, second);
  return epochDay.multiply(SECONDS_PER_DAY).add(localTimeSeconds);
}
/**
 * Converts given epoch second and nanosecond adjustment into a local date time object.
 * @param {Integer|number|string} epochSecond the epoch second to use.
 * @param {Integer|number|string} nano the nanosecond to use.
 * @return {LocalDateTime} the local date time representing given epoch second and nano.
 */


function epochSecondAndNanoToLocalDateTime(epochSecond, nano) {
  var epochDay = floorDiv(epochSecond, SECONDS_PER_DAY);
  var secondsOfDay = floorMod(epochSecond, SECONDS_PER_DAY);
  var nanoOfDay = secondsOfDay.multiply(NANOS_PER_SECOND).add(nano);
  var localDate = epochDayToDate(epochDay);
  var localTime = nanoOfDayToLocalTime(nanoOfDay);
  return new _temporalTypes.LocalDateTime(localDate.year, localDate.month, localDate.day, localTime.hour, localTime.minute, localTime.second, localTime.nanosecond);
}
/**
 * Converts given local date into a single integer representing it's epoch day.
 * @param {Integer|number|string} year the year of the local date to convert.
 * @param {Integer|number|string} month the month of the local date to convert.
 * @param {Integer|number|string} day the day of the local date to convert.
 * @return {Integer} epoch day representing the given date.
 */


function dateToEpochDay(year, month, day) {
  year = (0, _integer["int"])(year);
  month = (0, _integer["int"])(month);
  day = (0, _integer["int"])(day);
  var epochDay = year.multiply(365);

  if (year.greaterThanOrEqual(0)) {
    epochDay = epochDay.add(year.add(3).div(4).subtract(year.add(99).div(100)).add(year.add(399).div(400)));
  } else {
    epochDay = epochDay.subtract(year.div(-4).subtract(year.div(-100)).add(year.div(-400)));
  }

  epochDay = epochDay.add(month.multiply(367).subtract(362).div(12));
  epochDay = epochDay.add(day.subtract(1));

  if (month.greaterThan(2)) {
    epochDay = epochDay.subtract(1);

    if (!isLeapYear(year)) {
      epochDay = epochDay.subtract(1);
    }
  }

  return epochDay.subtract(DAYS_0000_TO_1970);
}
/**
 * Converts given epoch day to a local date.
 * @param {Integer|number|string} epochDay the epoch day to convert.
 * @return {Date} the date representing the epoch day in years, months and days.
 */


function epochDayToDate(epochDay) {
  epochDay = (0, _integer["int"])(epochDay);
  var zeroDay = epochDay.add(DAYS_0000_TO_1970).subtract(60);
  var adjust = (0, _integer["int"])(0);

  if (zeroDay.lessThan(0)) {
    var adjustCycles = zeroDay.add(1).div(DAYS_PER_400_YEAR_CYCLE).subtract(1);
    adjust = adjustCycles.multiply(400);
    zeroDay = zeroDay.add(adjustCycles.multiply(-DAYS_PER_400_YEAR_CYCLE));
  }

  var year = zeroDay.multiply(400).add(591).div(DAYS_PER_400_YEAR_CYCLE);
  var dayOfYearEst = zeroDay.subtract(year.multiply(365).add(year.div(4)).subtract(year.div(100)).add(year.div(400)));

  if (dayOfYearEst.lessThan(0)) {
    year = year.subtract(1);
    dayOfYearEst = zeroDay.subtract(year.multiply(365).add(year.div(4)).subtract(year.div(100)).add(year.div(400)));
  }

  year = year.add(adjust);
  var marchDayOfYear = dayOfYearEst;
  var marchMonth = marchDayOfYear.multiply(5).add(2).div(153);
  var month = marchMonth.add(2).modulo(12).add(1);
  var day = marchDayOfYear.subtract(marchMonth.multiply(306).add(5).div(10)).add(1);
  year = year.add(marchMonth.div(10));
  return new _temporalTypes.Date(year, month, day);
}
/**
 * Format given duration to an ISO 8601 string.
 * @param {Integer|number|string} months the number of months.
 * @param {Integer|number|string} days the number of days.
 * @param {Integer|number|string} seconds the number of seconds.
 * @param {Integer|number|string} nanoseconds the number of nanoseconds.
 * @return {string} ISO string that represents given duration.
 */


function durationToIsoString(months, days, seconds, nanoseconds) {
  var monthsString = formatNumber(months);
  var daysString = formatNumber(days);
  var secondsAndNanosecondsString = formatSecondsAndNanosecondsForDuration(seconds, nanoseconds);
  return "P".concat(monthsString, "M").concat(daysString, "DT").concat(secondsAndNanosecondsString, "S");
}
/**
 * Formats given time to an ISO 8601 string.
 * @param {Integer|number|string} hour the hour value.
 * @param {Integer|number|string} minute the minute value.
 * @param {Integer|number|string} second the second value.
 * @param {Integer|number|string} nanosecond the nanosecond value.
 * @return {string} ISO string that represents given time.
 */


function timeToIsoString(hour, minute, second, nanosecond) {
  var hourString = formatNumber(hour, 2);
  var minuteString = formatNumber(minute, 2);
  var secondString = formatNumber(second, 2);
  var nanosecondString = formatNanosecond(nanosecond);
  return "".concat(hourString, ":").concat(minuteString, ":").concat(secondString).concat(nanosecondString);
}
/**
 * Formats given time zone offset in seconds to string representation like 'HH:MM', 'HH:MM:SS' or 'Z' for UTC.
 * @param {Integer|number|string} offsetSeconds the offset in seconds.
 * @return {string} ISO string that represents given offset.
 */


function timeZoneOffsetToIsoString(offsetSeconds) {
  offsetSeconds = (0, _integer["int"])(offsetSeconds);

  if (offsetSeconds.equals(0)) {
    return 'Z';
  }

  var isNegative = offsetSeconds.isNegative();

  if (isNegative) {
    offsetSeconds = offsetSeconds.multiply(-1);
  }

  var signPrefix = isNegative ? '-' : '+';
  var hours = formatNumber(offsetSeconds.div(SECONDS_PER_HOUR), 2);
  var minutes = formatNumber(offsetSeconds.div(SECONDS_PER_MINUTE).modulo(MINUTES_PER_HOUR), 2);
  var secondsValue = offsetSeconds.modulo(SECONDS_PER_MINUTE);
  var seconds = secondsValue.equals(0) ? null : formatNumber(secondsValue, 2);
  return seconds ? "".concat(signPrefix).concat(hours, ":").concat(minutes, ":").concat(seconds) : "".concat(signPrefix).concat(hours, ":").concat(minutes);
}
/**
 * Formats given date to an ISO 8601 string.
 * @param {Integer|number|string} year the date year.
 * @param {Integer|number|string} month the date month.
 * @param {Integer|number|string} day the date day.
 * @return {string} ISO string that represents given date.
 */


function dateToIsoString(year, month, day) {
  year = (0, _integer["int"])(year);
  var isNegative = year.isNegative();

  if (isNegative) {
    year = year.multiply(-1);
  }

  var yearString = formatNumber(year, 4);

  if (isNegative) {
    yearString = '-' + yearString;
  }

  var monthString = formatNumber(month, 2);
  var dayString = formatNumber(day, 2);
  return "".concat(yearString, "-").concat(monthString, "-").concat(dayString);
}
/**
 * Get the total number of nanoseconds from the milliseconds of the given standard JavaScript date and optional nanosecond part.
 * @param {global.Date} standardDate the standard JavaScript date.
 * @param {Integer|number|undefined} nanoseconds the optional number of nanoseconds.
 * @return {Integer|number} the total amount of nanoseconds.
 */


function totalNanoseconds(standardDate, nanoseconds) {
  nanoseconds = nanoseconds || 0;
  var nanosFromMillis = standardDate.getMilliseconds() * NANOS_PER_MILLISECOND;
  return (0, _integer.isInt)(nanoseconds) ? nanoseconds.add(nanosFromMillis) : nanoseconds + nanosFromMillis;
}
/**
 * Get the time zone offset in seconds from the given standard JavaScript date.
 *
 * <b>Implementation note:</b>
 * Time zone offset returned by the standard JavaScript date is the difference, in minutes, from local time to UTC.
 * So positive value means offset is behind UTC and negative value means it is ahead.
 * For Neo4j temporal types, like `Time` or `DateTime` offset is in seconds and represents difference from UTC to local time.
 * This is different from standard JavaScript dates and that's why implementation negates the returned value.
 *
 * @param {global.Date} standardDate the standard JavaScript date.
 * @return {number} the time zone offset in seconds.
 */


function timeZoneOffsetInSeconds(standardDate) {
  var offsetInMinutes = standardDate.getTimezoneOffset();

  if (offsetInMinutes === 0) {
    return 0;
  }

  return -1 * offsetInMinutes * SECONDS_PER_MINUTE;
}
/**
 * Assert that the year value is valid.
 * @param {Integer|number} year the value to check.
 * @return {Integer|number} the value of the year if it is valid. Exception is thrown otherwise.
 */


function assertValidYear(year) {
  return assertValidTemporalValue(year, YEAR_RANGE, 'Year');
}
/**
 * Assert that the month value is valid.
 * @param {Integer|number} month the value to check.
 * @return {Integer|number} the value of the month if it is valid. Exception is thrown otherwise.
 */


function assertValidMonth(month) {
  return assertValidTemporalValue(month, MONTH_OF_YEAR_RANGE, 'Month');
}
/**
 * Assert that the day value is valid.
 * @param {Integer|number} day the value to check.
 * @return {Integer|number} the value of the day if it is valid. Exception is thrown otherwise.
 */


function assertValidDay(day) {
  return assertValidTemporalValue(day, DAY_OF_MONTH_RANGE, 'Day');
}
/**
 * Assert that the hour value is valid.
 * @param {Integer|number} hour the value to check.
 * @return {Integer|number} the value of the hour if it is valid. Exception is thrown otherwise.
 */


function assertValidHour(hour) {
  return assertValidTemporalValue(hour, HOUR_OF_DAY_RANGE, 'Hour');
}
/**
 * Assert that the minute value is valid.
 * @param {Integer|number} minute the value to check.
 * @return {Integer|number} the value of the minute if it is valid. Exception is thrown otherwise.
 */


function assertValidMinute(minute) {
  return assertValidTemporalValue(minute, MINUTE_OF_HOUR_RANGE, 'Minute');
}
/**
 * Assert that the second value is valid.
 * @param {Integer|number} second the value to check.
 * @return {Integer|number} the value of the second if it is valid. Exception is thrown otherwise.
 */


function assertValidSecond(second) {
  return assertValidTemporalValue(second, SECOND_OF_MINUTE_RANGE, 'Second');
}
/**
 * Assert that the nanosecond value is valid.
 * @param {Integer|number} nanosecond the value to check.
 * @return {Integer|number} the value of the nanosecond if it is valid. Exception is thrown otherwise.
 */


function assertValidNanosecond(nanosecond) {
  return assertValidTemporalValue(nanosecond, NANOSECOND_OF_SECOND_RANGE, 'Nanosecond');
}
/**
 * Check if the given value is of expected type and is in the expected range.
 * @param {Integer|number} value the value to check.
 * @param {ValueRange} range the range.
 * @param {string} name the name of the value.
 * @return {Integer|number} the value if valid. Exception is thrown otherwise.
 */


function assertValidTemporalValue(value, range, name) {
  (0, _util.assertNumberOrInteger)(value, name);

  if (!range.contains(value)) {
    throw (0, _error.newError)("".concat(name, " is expected to be in range ").concat(range, " but was: ").concat(value));
  }

  return value;
}
/**
 * Converts given local time into a single integer representing this same time in seconds of the day. Nanoseconds are skipped.
 * @param {Integer|number|string} hour the hour of the local time.
 * @param {Integer|number|string} minute the minute of the local time.
 * @param {Integer|number|string} second the second of the local time.
 * @return {Integer} seconds representing the given local time.
 */


function localTimeToSecondOfDay(hour, minute, second) {
  hour = (0, _integer["int"])(hour);
  minute = (0, _integer["int"])(minute);
  second = (0, _integer["int"])(second);
  var totalSeconds = hour.multiply(SECONDS_PER_HOUR);
  totalSeconds = totalSeconds.add(minute.multiply(SECONDS_PER_MINUTE));
  return totalSeconds.add(second);
}
/**
 * Check if given year is a leap year. Uses algorithm described here {@link https://en.wikipedia.org/wiki/Leap_year#Algorithm}.
 * @param {Integer|number|string} year the year to check. Will be converted to {@link Integer} for all calculations.
 * @return {boolean} `true` if given year is a leap year, `false` otherwise.
 */


function isLeapYear(year) {
  year = (0, _integer["int"])(year);

  if (!year.modulo(4).equals(0)) {
    return false;
  } else if (!year.modulo(100).equals(0)) {
    return true;
  } else if (!year.modulo(400).equals(0)) {
    return false;
  } else {
    return true;
  }
}
/**
 * @param {Integer|number|string} x the divident.
 * @param {Integer|number|string} y the divisor.
 * @return {Integer} the result.
 */


function floorDiv(x, y) {
  x = (0, _integer["int"])(x);
  y = (0, _integer["int"])(y);
  var result = x.div(y);

  if (x.isPositive() !== y.isPositive() && result.multiply(y).notEquals(x)) {
    result = result.subtract(1);
  }

  return result;
}
/**
 * @param {Integer|number|string} x the divident.
 * @param {Integer|number|string} y the divisor.
 * @return {Integer} the result.
 */


function floorMod(x, y) {
  x = (0, _integer["int"])(x);
  y = (0, _integer["int"])(y);
  return x.subtract(floorDiv(x, y).multiply(y));
}
/**
 * @param {Integer|number|string} seconds the number of seconds to format.
 * @param {Integer|number|string} nanoseconds the number of nanoseconds to format.
 * @return {string} formatted value.
 */


function formatSecondsAndNanosecondsForDuration(seconds, nanoseconds) {
  seconds = (0, _integer["int"])(seconds);
  nanoseconds = (0, _integer["int"])(nanoseconds);
  var secondsString;
  var nanosecondsString;
  var secondsNegative = seconds.isNegative();
  var nanosecondsGreaterThanZero = nanoseconds.greaterThan(0);

  if (secondsNegative && nanosecondsGreaterThanZero) {
    if (seconds.equals(-1)) {
      secondsString = '-0';
    } else {
      secondsString = seconds.add(1).toString();
    }
  } else {
    secondsString = seconds.toString();
  }

  if (nanosecondsGreaterThanZero) {
    if (secondsNegative) {
      nanosecondsString = formatNanosecond(nanoseconds.negate().add(2 * NANOS_PER_SECOND).modulo(NANOS_PER_SECOND));
    } else {
      nanosecondsString = formatNanosecond(nanoseconds.add(NANOS_PER_SECOND).modulo(NANOS_PER_SECOND));
    }
  }

  return nanosecondsString ? secondsString + nanosecondsString : secondsString;
}
/**
 * @param {Integer|number|string} value the number of nanoseconds to format.
 * @return {string} formatted and possibly left-padded nanoseconds part as string.
 */


function formatNanosecond(value) {
  value = (0, _integer["int"])(value);
  return value.equals(0) ? '' : '.' + formatNumber(value, 9);
}
/**
 * @param {Integer|number|string} num the number to format.
 * @param {number} [stringLength=undefined] the string length to left-pad to.
 * @return {string} formatted and possibly left-padded number as string.
 */


function formatNumber(num) {
  var stringLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  num = (0, _integer["int"])(num);
  var isNegative = num.isNegative();

  if (isNegative) {
    num = num.negate();
  }

  var numString = num.toString();

  if (stringLength) {
    // left pad the string with zeroes
    while (numString.length < stringLength) {
      numString = '0' + numString;
    }
  }

  return isNegative ? '-' + numString : numString;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/transaction-executor.js":
/*!************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/transaction-executor.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds

var DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds

var DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;
var DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;

var TransactionExecutor = /*#__PURE__*/function () {
  function TransactionExecutor(maxRetryTimeMs, initialRetryDelayMs, multiplier, jitterFactor) {
    (0, _classCallCheck2["default"])(this, TransactionExecutor);
    this._maxRetryTimeMs = _valueOrDefault(maxRetryTimeMs, DEFAULT_MAX_RETRY_TIME_MS);
    this._initialRetryDelayMs = _valueOrDefault(initialRetryDelayMs, DEFAULT_INITIAL_RETRY_DELAY_MS);
    this._multiplier = _valueOrDefault(multiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);
    this._jitterFactor = _valueOrDefault(jitterFactor, DEFAULT_RETRY_DELAY_JITTER_FACTOR);
    this._inFlightTimeoutIds = [];

    this._verifyAfterConstruction();
  }

  (0, _createClass2["default"])(TransactionExecutor, [{
    key: "execute",
    value: function execute(transactionCreator, transactionWork) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);
      })["catch"](function (error) {
        var retryStartTimeMs = Date.now();
        var retryDelayMs = _this._initialRetryDelayMs;
        return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTimeMs, retryDelayMs);
      });
    }
  }, {
    key: "close",
    value: function close() {
      // cancel all existing timeouts to prevent further retries
      this._inFlightTimeoutIds.forEach(function (timeoutId) {
        return clearTimeout(timeoutId);
      });

      this._inFlightTimeoutIds = [];
    }
  }, {
    key: "_retryTransactionPromise",
    value: function _retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, retryDelayMs) {
      var _this2 = this;

      var elapsedTimeMs = Date.now() - retryStartTime;

      if (elapsedTimeMs > this._maxRetryTimeMs || !TransactionExecutor._canRetryOn(error)) {
        return Promise.reject(error);
      }

      return new Promise(function (resolve, reject) {
        var nextRetryTime = _this2._computeDelayWithJitter(retryDelayMs);

        var timeoutId = setTimeout(function () {
          // filter out this timeoutId when time has come and function is being executed
          _this2._inFlightTimeoutIds = _this2._inFlightTimeoutIds.filter(function (id) {
            return id !== timeoutId;
          });

          _this2._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);
        }, nextRetryTime); // add newly created timeoutId to the list of all in-flight timeouts

        _this2._inFlightTimeoutIds.push(timeoutId);
      })["catch"](function (error) {
        var nextRetryDelayMs = retryDelayMs * _this2._multiplier;
        return _this2._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, nextRetryDelayMs);
      });
    }
  }, {
    key: "_executeTransactionInsidePromise",
    value: function _executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject) {
      var _this3 = this;

      var tx;

      try {
        tx = transactionCreator();
      } catch (error) {
        // failed to create a transaction
        reject(error);
        return;
      }

      var resultPromise = this._safeExecuteTransactionWork(tx, transactionWork);

      resultPromise.then(function (result) {
        return _this3._handleTransactionWorkSuccess(result, tx, resolve, reject);
      })["catch"](function (error) {
        return _this3._handleTransactionWorkFailure(error, tx, reject);
      });
    }
  }, {
    key: "_safeExecuteTransactionWork",
    value: function _safeExecuteTransactionWork(tx, transactionWork) {
      try {
        var result = transactionWork(tx); // user defined callback is supposed to return a promise, but it might not; so to protect against an
        // incorrect API usage we wrap the returned value with a resolved promise; this is effectively a
        // validation step without type checks

        return Promise.resolve(result);
      } catch (error) {
        return Promise.reject(error);
      }
    }
  }, {
    key: "_handleTransactionWorkSuccess",
    value: function _handleTransactionWorkSuccess(result, tx, resolve, reject) {
      if (tx.isOpen()) {
        // transaction work returned resolved promise and transaction has not been committed/rolled back
        // try to commit the transaction
        tx.commit().then(function () {
          // transaction was committed, return result to the user
          resolve(result);
        })["catch"](function (error) {
          // transaction failed to commit, propagate the failure
          reject(error);
        });
      } else {
        // transaction work returned resolved promise and transaction is already committed/rolled back
        // return the result returned by given transaction work
        resolve(result);
      }
    }
  }, {
    key: "_handleTransactionWorkFailure",
    value: function _handleTransactionWorkFailure(error, tx, reject) {
      if (tx.isOpen()) {
        // transaction work failed and the transaction is still open, roll it back and propagate the failure
        tx.rollback()["catch"](function (ignore) {// ignore the rollback error
        }).then(function () {
          return reject(error);
        }); // propagate the original error we got from the transaction work
      } else {
        // transaction is already rolled back, propagate the error
        reject(error);
      }
    }
  }, {
    key: "_computeDelayWithJitter",
    value: function _computeDelayWithJitter(delayMs) {
      var jitter = delayMs * this._jitterFactor;
      var min = delayMs - jitter;
      var max = delayMs + jitter;
      return Math.random() * (max - min) + min;
    }
  }, {
    key: "_verifyAfterConstruction",
    value: function _verifyAfterConstruction() {
      if (this._maxRetryTimeMs < 0) {
        throw (0, _error.newError)('Max retry time should be >= 0: ' + this._maxRetryTimeMs);
      }

      if (this._initialRetryDelayMs < 0) {
        throw (0, _error.newError)('Initial retry delay should >= 0: ' + this._initialRetryDelayMs);
      }

      if (this._multiplier < 1.0) {
        throw (0, _error.newError)('Multiplier should be >= 1.0: ' + this._multiplier);
      }

      if (this._jitterFactor < 0 || this._jitterFactor > 1) {
        throw (0, _error.newError)('Jitter factor should be in [0.0, 1.0]: ' + this._jitterFactor);
      }
    }
  }], [{
    key: "_canRetryOn",
    value: function _canRetryOn(error) {
      return error && error instanceof _error.Neo4jError && error.code && (error.code === _error.SERVICE_UNAVAILABLE || error.code === _error.SESSION_EXPIRED || this._isTransientError(error));
    }
  }, {
    key: "_isTransientError",
    value: function _isTransientError(error) {
      // Retries should not happen when transaction was explicitly terminated by the user.
      // Termination of transaction might result in two different error codes depending on where it was
      // terminated. These are really client errors but classification on the server is not entirely correct and
      // they are classified as transient.
      var code = error.code;

      if (code.indexOf('TransientError') >= 0) {
        if (code === 'Neo.TransientError.Transaction.Terminated' || code === 'Neo.TransientError.Transaction.LockClientStopped') {
          return false;
        }

        return true;
      }

      return false;
    }
  }]);
  return TransactionExecutor;
}();

exports["default"] = TransactionExecutor;

function _valueOrDefault(value, defaultValue) {
  if (value || value === 0) {
    return value;
  }

  return defaultValue;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/tx-config.js":
/*!*************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/tx-config.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js"));

var _integer = __webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js");

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Internal holder of the transaction configuration.
 * It performs input validation and value conversion for further serialization by the Bolt protocol layer.
 * Users of the driver provide transaction configuration as regular objects `{timeout: 10, metadata: {key: 'value'}}`.
 * Driver converts such objects to {@link TxConfig} immediately and uses converted values everywhere.
 */
var TxConfig = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Object} config the raw configuration object.
   */
  function TxConfig(config) {
    (0, _classCallCheck2["default"])(this, TxConfig);
    assertValidConfig(config);
    this.timeout = extractTimeout(config);
    this.metadata = extractMetadata(config);
  }
  /**
   * Get an empty config object.
   * @return {TxConfig} an empty config.
   */


  (0, _createClass2["default"])(TxConfig, [{
    key: "isEmpty",

    /**
     * Check if this config object is empty. I.e. has no configuration values specified.
     * @return {boolean} `true` if this object is empty, `false` otherwise.
     */
    value: function isEmpty() {
      return Object.values(this).every(function (value) {
        return value == null;
      });
    }
  }], [{
    key: "empty",
    value: function empty() {
      return EMPTY_CONFIG;
    }
  }]);
  return TxConfig;
}();

exports["default"] = TxConfig;
var EMPTY_CONFIG = new TxConfig({});
/**
 * @return {Integer|null}
 */

function extractTimeout(config) {
  if (util.isObject(config) && (config.timeout || config.timeout === 0)) {
    util.assertNumberOrInteger(config.timeout, 'Transaction timeout');
    var timeout = (0, _integer["int"])(config.timeout);

    if (timeout.isZero()) {
      throw (0, _error.newError)('Transaction timeout should not be zero');
    }

    if (timeout.isNegative()) {
      throw (0, _error.newError)('Transaction timeout should not be negative');
    }

    return timeout;
  }

  return null;
}
/**
 * @return {object|null}
 */


function extractMetadata(config) {
  if (util.isObject(config) && config.metadata) {
    var metadata = config.metadata;
    util.assertObject(metadata);

    if (Object.keys(metadata).length !== 0) {
      // not an empty object
      return metadata;
    }
  }

  return null;
}

function assertValidConfig(config) {
  if (config) {
    util.assertObject(config, 'Transaction config');
  }
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/url-util.js":
/*!************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/url-util.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _uriJs = __webpack_require__(/*! uri-js */ "./node_modules/uri-js/dist/es5/uri.all.js");

var _util = __webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_BOLT_PORT = 7687;
var DEFAULT_HTTP_PORT = 7474;
var DEFAULT_HTTPS_PORT = 7473;

var Url = function Url(scheme, host, port, hostAndPort, query) {
  (0, _classCallCheck2["default"])(this, Url);

  /**
   * Nullable scheme (protocol) of the URL.
   * Example: 'bolt', 'neo4j', 'http', 'https', etc.
   * @type {string}
   */
  this.scheme = scheme;
  /**
   * Nonnull host name or IP address. IPv6 not wrapped in square brackets.
   * Example: 'neo4j.com', 'localhost', '127.0.0.1', '192.168.10.15', '::1', '2001:4860:4860::8844', etc.
   * @type {string}
   */

  this.host = host;
  /**
   * Nonnull number representing port. Default port for the given scheme is used if given URL string
   * does not contain port. Example: 7687 for bolt, 7474 for HTTP and 7473 for HTTPS.
   * @type {number}
   */

  this.port = port;
  /**
   * Nonnull host name or IP address plus port, separated by ':'. IPv6 wrapped in square brackets.
   * Example: 'neo4j.com', 'neo4j.com:7687', '127.0.0.1', '127.0.0.1:8080', '[2001:4860:4860::8844]',
   * '[2001:4860:4860::8844]:9090', etc.
   * @type {string}
   */

  this.hostAndPort = hostAndPort;
  /**
   * Nonnull object representing parsed query string key-value pairs. Duplicated keys not supported.
   * Example: '{}', '{'key1': 'value1', 'key2': 'value2'}', etc.
   * @type {Object}
   */

  this.query = query;
};

function parseDatabaseUrl(url) {
  (0, _util.assertString)(url, 'URL');
  var sanitized = sanitizeUrl(url);
  var parsedUrl = (0, _uriJs.parse)(sanitized.url);
  var scheme = sanitized.schemeMissing ? null : extractScheme(parsedUrl.scheme);
  var host = extractHost(parsedUrl.host); // no square brackets for IPv6

  var formattedHost = formatHost(host); // has square brackets for IPv6

  var port = extractPort(parsedUrl.port, scheme);
  var hostAndPort = "".concat(formattedHost, ":").concat(port);
  var query = extractQuery(parsedUrl.query, url);
  return new Url(scheme, host, port, hostAndPort, query);
}

function sanitizeUrl(url) {
  url = url.trim();

  if (url.indexOf('://') === -1) {
    // url does not contain scheme, add dummy 'none://' to make parser work correctly
    return {
      schemeMissing: true,
      url: "none://".concat(url)
    };
  }

  return {
    schemeMissing: false,
    url: url
  };
}

function extractScheme(scheme) {
  if (scheme) {
    scheme = scheme.trim();

    if (scheme.charAt(scheme.length - 1) === ':') {
      scheme = scheme.substring(0, scheme.length - 1);
    }

    return scheme;
  }

  return null;
}

function extractHost(host, url) {
  if (!host) {
    throw new Error("Unable to extract host from ".concat(url));
  }

  return host.trim();
}

function extractPort(portString, scheme) {
  var port = parseInt(portString, 10);
  return port === 0 || port ? port : defaultPortForScheme(scheme);
}

function extractQuery(queryString, url) {
  var query = trimAndSanitizeQuery(queryString);
  var context = {};

  if (query) {
    query.split('&').forEach(function (pair) {
      var keyValue = pair.split('=');

      if (keyValue.length !== 2) {
        throw new Error("Invalid parameters: '".concat(keyValue, "' in URL '").concat(url, "'."));
      }

      var key = trimAndVerifyQueryElement(keyValue[0], 'key', url);
      var value = trimAndVerifyQueryElement(keyValue[1], 'value', url);

      if (context[key]) {
        throw new Error("Duplicated query parameters with key '".concat(key, "' in URL '").concat(url, "'"));
      }

      context[key] = value;
    });
  }

  return context;
}

function trimAndSanitizeQuery(query) {
  query = (query || '').trim();

  if (query && query.charAt(0) === '?') {
    query = query.substring(1, query.length);
  }

  return query;
}

function trimAndVerifyQueryElement(element, name, url) {
  element = (element || '').trim();

  if (!element) {
    throw new Error("Illegal empty ".concat(name, " in URL query '").concat(url, "'"));
  }

  return element;
}

function escapeIPv6Address(address) {
  var startsWithSquareBracket = address.charAt(0) === '[';
  var endsWithSquareBracket = address.charAt(address.length - 1) === ']';

  if (!startsWithSquareBracket && !endsWithSquareBracket) {
    return "[".concat(address, "]");
  } else if (startsWithSquareBracket && endsWithSquareBracket) {
    return address;
  } else {
    throw new Error("Illegal IPv6 address ".concat(address));
  }
}

function formatHost(host) {
  if (!host) {
    throw new Error("Illegal host ".concat(host));
  }

  var isIPv6Address = host.indexOf(':') >= 0;
  return isIPv6Address ? escapeIPv6Address(host) : host;
}

function formatIPv4Address(address, port) {
  return "".concat(address, ":").concat(port);
}

function formatIPv6Address(address, port) {
  var escapedAddress = escapeIPv6Address(address);
  return "".concat(escapedAddress, ":").concat(port);
}

function defaultPortForScheme(scheme) {
  if (scheme === 'http') {
    return DEFAULT_HTTP_PORT;
  } else if (scheme === 'https') {
    return DEFAULT_HTTPS_PORT;
  } else {
    return DEFAULT_BOLT_PORT;
  }
}

var _default = {
  parseDatabaseUrl: parseDatabaseUrl,
  defaultPortForScheme: defaultPortForScheme,
  formatIPv4Address: formatIPv4Address,
  formatIPv6Address: formatIPv6Address
};
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/util.js":
/*!********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/util.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEmptyObjectOrNull = isEmptyObjectOrNull;
exports.isObject = isObject;
exports.isString = isString;
exports.assertObject = assertObject;
exports.assertString = assertString;
exports.assertNumber = assertNumber;
exports.assertNumberOrInteger = assertNumberOrInteger;
exports.assertValidDate = assertValidDate;
exports.validateQueryAndParameters = validateQueryAndParameters;
exports.ENCRYPTION_OFF = exports.ENCRYPTION_ON = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

var _integer = __webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ENCRYPTION_ON = 'ENCRYPTION_ON';
exports.ENCRYPTION_ON = ENCRYPTION_ON;
var ENCRYPTION_OFF = 'ENCRYPTION_OFF';
exports.ENCRYPTION_OFF = ENCRYPTION_OFF;

function isEmptyObjectOrNull(obj) {
  if (obj === null) {
    return true;
  }

  if (!isObject(obj)) {
    return false;
  }

  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      return false;
    }
  }

  return true;
}

function isObject(obj) {
  return (0, _typeof2["default"])(obj) === 'object' && !Array.isArray(obj) && obj !== null;
}
/**
 * Check and normalize given query and parameters.
 * @param {string|{text: string, parameters: object}} query the query to check.
 * @param {Object} parameters
 * @return {{query: string, params: object}} the normalized query with parameters.
 * @throws TypeError when either given query or parameters are invalid.
 */


function validateQueryAndParameters(query, parameters) {
  var validatedQuery = query;
  var params = parameters || {};

  if ((0, _typeof2["default"])(query) === 'object' && query.text) {
    validatedQuery = query.text;
    params = query.parameters || {};
  }

  assertCypherQuery(validatedQuery);
  assertQueryParameters(params);
  return {
    validatedQuery: validatedQuery,
    params: params
  };
}

function assertObject(obj, objName) {
  if (!isObject(obj)) {
    throw new TypeError(objName + ' expected to be an object but was: ' + JSON.stringify(obj));
  }

  return obj;
}

function assertString(obj, objName) {
  if (!isString(obj)) {
    throw new TypeError(objName + ' expected to be string but was: ' + JSON.stringify(obj));
  }

  return obj;
}

function assertNumber(obj, objName) {
  if (typeof obj !== 'number') {
    throw new TypeError(objName + ' expected to be a number but was: ' + JSON.stringify(obj));
  }

  return obj;
}

function assertNumberOrInteger(obj, objName) {
  if (typeof obj !== 'number' && !(0, _integer.isInt)(obj)) {
    throw new TypeError(objName + ' expected to be either a number or an Integer object but was: ' + JSON.stringify(obj));
  }

  return obj;
}

function assertValidDate(obj, objName) {
  if (Object.prototype.toString.call(obj) !== '[object Date]') {
    throw new TypeError(objName + ' expected to be a standard JavaScript Date but was: ' + JSON.stringify(obj));
  }

  if (Number.isNaN(obj.getTime())) {
    throw new TypeError(objName + ' expected to be valid JavaScript Date but its time was NaN: ' + JSON.stringify(obj));
  }

  return obj;
}

function assertCypherQuery(obj) {
  assertString(obj, 'Cypher query');

  if (obj.trim().length === 0) {
    throw new TypeError('Cypher query is expected to be a non-empty string.');
  }
}

function assertQueryParameters(obj) {
  if (!isObject(obj)) {
    // objects created with `Object.create(null)` do not have a constructor property
    var _constructor = obj.constructor ? ' ' + obj.constructor.name : '';

    throw new TypeError("Query parameters are expected to either be undefined/null or an object, given:".concat(_constructor, " ").concat(obj));
  }
}

function isString(str) {
  return Object.prototype.toString.call(str) === '[object String]';
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/record.js":
/*!*************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/record.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function generateFieldLookup(keys) {
  var lookup = {};
  keys.forEach(function (name, idx) {
    lookup[name] = idx;
  });
  return lookup;
}
/**
 * Records make up the contents of the {@link Result}, and is how you access
 * the output of a query. A simple query might yield a result stream
 * with a single record, for instance:
 *
 *     MATCH (u:User) RETURN u.name, u.age
 *
 * This returns a stream of records with two fields, named `u.name` and `u.age`,
 * each record represents one user found by the query above. You can access
 * the values of each field either by name:
 *
 *     record.get("u.name")
 *
 * Or by it's position:
 *
 *     record.get(0)
 *
 * @access public
 */


var Record = /*#__PURE__*/function () {
  /**
   * Create a new record object.
   * @constructor
   * @protected
   * @param {string[]} keys An array of field keys, in the order the fields appear in the record
   * @param {Array} fields An array of field values
   * @param {Object} fieldLookup An object of fieldName -> value index, used to map
   *                            field names to values. If this is null, one will be
   *                            generated.
   */
  function Record(keys, fields) {
    var fieldLookup = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    (0, _classCallCheck2["default"])(this, Record);

    /**
     * Field keys, in the order the fields appear in the record.
     * @type {string[]}
     */
    this.keys = keys;
    /**
     * Number of fields
     * @type {Number}
     */

    this.length = keys.length;
    this._fields = fields;
    this._fieldLookup = fieldLookup || generateFieldLookup(keys);
  }
  /**
   * Run the given function for each field in this record. The function
   * will get three arguments - the value, the key and this record, in that
   * order.
   *
   * @param {function(value: Object, key: string, record: Record)} visitor the function to apply to each field.
   */


  (0, _createClass2["default"])(Record, [{
    key: "forEach",
    value: function forEach(visitor) {
      var _iterator = _createForOfIteratorHelper(this.entries()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = (0, _slicedToArray2["default"])(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];

          visitor(value, key, this);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Run the given function for each field in this record. The function
     * will get three arguments - the value, the key and this record, in that
     * order.
     *
     * @param {function(value: Object, key: string, record: Record)} visitor the function to apply on each field
     * and return a value that is saved to the returned Array.
     *
     * @returns {Array}
     */

  }, {
    key: "map",
    value: function map(visitor) {
      var resultArray = [];

      var _iterator2 = _createForOfIteratorHelper(this.entries()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = (0, _slicedToArray2["default"])(_step2.value, 2),
              key = _step2$value[0],
              value = _step2$value[1];

          resultArray.push(visitor(value, key, this));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return resultArray;
    }
    /**
     * Iterate over results. Each iteration will yield an array
     * of exactly two items - the key, and the value (in order).
     *
     * @generator
     * @returns {IterableIterator<Array>}
     */

  }, {
    key: "entries",
    value: /*#__PURE__*/_regenerator["default"].mark(function entries() {
      var i;
      return _regenerator["default"].wrap(function entries$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              i = 0;

            case 1:
              if (!(i < this.keys.length)) {
                _context.next = 7;
                break;
              }

              _context.next = 4;
              return [this.keys[i], this._fields[i]];

            case 4:
              i++;
              _context.next = 1;
              break;

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, entries, this);
    })
    /**
     * Iterate over values.
     *
     * @generator
     * @returns {IterableIterator<Object>}
     */

  }, {
    key: "values",
    value: /*#__PURE__*/_regenerator["default"].mark(function values() {
      var i;
      return _regenerator["default"].wrap(function values$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              i = 0;

            case 1:
              if (!(i < this.keys.length)) {
                _context2.next = 7;
                break;
              }

              _context2.next = 4;
              return this._fields[i];

            case 4:
              i++;
              _context2.next = 1;
              break;

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, values, this);
    })
    /**
     * Iterate over values. Delegates to {@link Record#values}
     *
     * @generator
     * @returns {IterableIterator<Object>}
     */

  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regenerator["default"].mark(function value() {
      return _regenerator["default"].wrap(function value$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.delegateYield(this.values(), "t0", 1);

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, value, this);
    })
    /**
     * Generates an object out of the current Record
     *
     * @returns {Object}
     */

  }, {
    key: "toObject",
    value: function toObject() {
      var object = {};

      var _iterator3 = _createForOfIteratorHelper(this.entries()),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _step3$value = (0, _slicedToArray2["default"])(_step3.value, 2),
              key = _step3$value[0],
              _value = _step3$value[1];

          object[key] = _value;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return object;
    }
    /**
     * Get a value from this record, either by index or by field key.
     *
     * @param {string|Number} key Field key, or the index of the field.
     * @returns {*}
     */

  }, {
    key: "get",
    value: function get(key) {
      var index;

      if (!(typeof key === 'number')) {
        index = this._fieldLookup[key];

        if (index === undefined) {
          throw (0, _error.newError)("This record has no field with key '" + key + "', available key are: [" + this.keys + '].');
        }
      } else {
        index = key;
      }

      if (index > this._fields.length - 1 || index < 0) {
        throw (0, _error.newError)("This record has no field with index '" + index + "'. Remember that indexes start at `0`, " + 'and make sure your query returns records in the shape you meant it to.');
      }

      return this._fields[index];
    }
    /**
     * Check if a value from this record, either by index or by field key, exists.
     *
     * @param {string|Number} key Field key, or the index of the field.
     * @returns {boolean}
     */

  }, {
    key: "has",
    value: function has(key) {
      // if key is a number, we check if it is in the _fields array
      if (typeof key === 'number') {
        return key >= 0 && key < this._fields.length;
      } // if it's not a number, we check _fieldLookup dictionary directly


      return this._fieldLookup[key] !== undefined;
    }
  }]);
  return Record;
}();

var _default = Record;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/result-rx.js":
/*!****************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/result-rx.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

var _resultSummary = _interopRequireDefault(__webpack_require__(/*! ./result-summary */ "./node_modules/neo4j-driver/lib/result-summary.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");

var _record = _interopRequireDefault(__webpack_require__(/*! ./record */ "./node_modules/neo4j-driver/lib/record.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var States = {
  READY: 0,
  STREAMING: 1,
  COMPLETED: 2
};
/**
 * The reactive result interface.
 */

var RxResult = /*#__PURE__*/function () {
  /**
   * @constructor
   * @protected
   * @param {Observable<Result>} result - An observable of single Result instance to relay requests.
   */
  function RxResult(result) {
    (0, _classCallCheck2["default"])(this, RxResult);
    var replayedResult = result.pipe((0, _operators.publishReplay)(1), (0, _operators.refCount)());
    this._result = replayedResult;
    this._keys = replayedResult.pipe((0, _operators.flatMap)(function (r) {
      return (0, _rxjs.from)(r.keys());
    }), (0, _operators.publishReplay)(1), (0, _operators.refCount)());
    this._records = new _rxjs.Subject();
    this._summary = new _rxjs.ReplaySubject();
    this._state = States.READY;
  }
  /**
   * Returns an observable that exposes a single item containing field names
   * returned by the executing query.
   *
   * Errors raised by actual query execution can surface on the returned
   * observable stream.
   *
   * @public
   * @returns {Observable<string[]>} - An observable stream (with exactly one element) of field names.
   */


  (0, _createClass2["default"])(RxResult, [{
    key: "keys",
    value: function keys() {
      return this._keys;
    }
    /**
     * Returns an observable that exposes each record returned by the executing query.
     *
     * Errors raised during the streaming phase can surface on the returned observable stream.
     *
     * @public
     * @returns {Observable<Record>} - An observable stream of records.
     */

  }, {
    key: "records",
    value: function records() {
      var _this = this;

      return this._result.pipe((0, _operators.flatMap)(function (result) {
        return new _rxjs.Observable(function (recordsObserver) {
          return _this._startStreaming({
            result: result,
            recordsObserver: recordsObserver
          });
        });
      }));
    }
    /**
     * Returns an observable that exposes a single item of {@link ResultSummary} that is generated by
     * the server after the streaming of the executing query is completed.
     *
     * *Subscribing to this stream before subscribing to records() stream causes the results to be discarded on the server.*
     *
     * @public
     * @returns {Observable<ResultSummary>} - An observable stream (with exactly one element) of result summary.
     */

  }, {
    key: "consume",
    value: function consume() {
      var _this2 = this;

      return this._result.pipe((0, _operators.flatMap)(function (result) {
        return new _rxjs.Observable(function (summaryObserver) {
          return _this2._startStreaming({
            result: result,
            summaryObserver: summaryObserver
          });
        });
      }));
    }
  }, {
    key: "_startStreaming",
    value: function _startStreaming() {
      var _this3 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          result = _ref.result,
          _ref$recordsObserver = _ref.recordsObserver,
          recordsObserver = _ref$recordsObserver === void 0 ? null : _ref$recordsObserver,
          _ref$summaryObserver = _ref.summaryObserver,
          summaryObserver = _ref$summaryObserver === void 0 ? null : _ref$summaryObserver;

      var subscriptions = [];

      if (summaryObserver) {
        subscriptions.push(this._summary.subscribe(summaryObserver));
      }

      if (this._state < States.STREAMING) {
        this._state = States.STREAMING;

        if (recordsObserver) {
          subscriptions.push(this._records.subscribe(recordsObserver));
        }

        subscriptions.push({
          unsubscribe: function unsubscribe() {
            if (result._cancel) {
              result._cancel();
            }
          }
        });

        if (this._records.observers.length === 0) {
          result._cancel();
        }

        result.subscribe({
          onNext: function onNext(record) {
            _this3._records.next(record);
          },
          onCompleted: function onCompleted(summary) {
            _this3._records.complete();

            _this3._summary.next(summary);

            _this3._summary.complete();

            _this3._state = States.COMPLETED;
          },
          onError: function onError(err) {
            _this3._records.error(err);

            _this3._summary.error(err);

            _this3._state = States.COMPLETED;
          }
        });
      } else if (recordsObserver) {
        recordsObserver.error((0, _error.newError)('Streaming has already started/consumed with a previous records or summary subscription.'));
      }

      return function () {
        subscriptions.forEach(function (s) {
          return s.unsubscribe();
        });
      };
    }
  }]);
  return RxResult;
}();

exports["default"] = RxResult;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/result-summary.js":
/*!*********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/result-summary.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.queryType = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _integer = __webpack_require__(/*! ./integer */ "./node_modules/neo4j-driver/lib/integer.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A ResultSummary instance contains structured metadata for a {@link Result}.
 * @access public
 */
var ResultSummary = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {string} query - The query this summary is for
   * @param {Object} parameters - Parameters for the query
   * @param {Object} metadata - Query metadata
   * @param {number} protocolVersion - Bolt protocol version
   */
  function ResultSummary(query, parameters, metadata, protocolVersion) {
    (0, _classCallCheck2["default"])(this, ResultSummary);

    /**
     * The query and parameters this summary is for.
     * @type {{text: string, parameters: Object}}
     * @public
     */
    this.query = {
      text: query,
      parameters: parameters
    };
    /**
     * The type of query executed. Can be "r" for read-only query, "rw" for read-write query,
     * "w" for write-only query and "s" for schema-write query.
     * String constants are available in {@link queryType} object.
     * @type {string}
     * @public
     */

    this.queryType = metadata.type;
    /**
     * Counters for operations the query triggered.
     * @type {QueryStatistics}
     * @public
     */

    this.counters = new QueryStatistics(metadata.stats || {}); // for backwards compatibility, remove in future version

    /**
     * Use {@link ResultSummary.counters} instead.
     * @type {QueryStatistics}
     * @deprecated
     */

    this.updateStatistics = this.counters;
    /**
     * This describes how the database will execute the query.
     * Query plan for the executed query if available, otherwise undefined.
     * Will only be populated for queries that start with "EXPLAIN".
     * @type {Plan}
     * @public
     */

    this.plan = metadata.plan || metadata.profile ? new Plan(metadata.plan || metadata.profile) : false;
    /**
     * This describes how the database did execute your query. This will contain detailed information about what
     * each step of the plan did. Profiled query plan for the executed query if available, otherwise undefined.
     * Will only be populated for queries that start with "PROFILE".
     * @type {ProfiledPlan}
     * @public
     */

    this.profile = metadata.profile ? new ProfiledPlan(metadata.profile) : false;
    /**
     * An array of notifications that might arise when executing the query. Notifications can be warnings about
     * problematic queries or other valuable information that can be presented in a client. Unlike failures
     * or errors, notifications do not affect the execution of a query.
     * @type {Array<Notification>}
     * @public
     */

    this.notifications = this._buildNotifications(metadata.notifications);
    /**
     * The basic information of the server where the result is obtained from.
     * @type {ServerInfo}
     * @public
     */

    this.server = new ServerInfo(metadata.server, protocolVersion);
    /**
     * The time it took the server to consume the result.
     * @type {number}
     * @public
     */

    this.resultConsumedAfter = metadata.result_consumed_after;
    /**
     * The time it took the server to make the result available for consumption in milliseconds.
     * @type {number}
     * @public
     */

    this.resultAvailableAfter = metadata.result_available_after;
    /**
     * The database name where this summary is obtained from.
     * @type {{name: string}}
     * @public
     */

    this.database = {
      name: metadata.db || null
    };
  }

  (0, _createClass2["default"])(ResultSummary, [{
    key: "_buildNotifications",
    value: function _buildNotifications(notifications) {
      if (!notifications) {
        return [];
      }

      return notifications.map(function (n) {
        return new Notification(n);
      });
    }
    /**
     * Check if the result summary has a plan
     * @return {boolean}
     */

  }, {
    key: "hasPlan",
    value: function hasPlan() {
      return this.plan instanceof Plan;
    }
    /**
     * Check if the result summary has a profile
     * @return {boolean}
     */

  }, {
    key: "hasProfile",
    value: function hasProfile() {
      return this.profile instanceof ProfiledPlan;
    }
  }]);
  return ResultSummary;
}();
/**
 * Class for execution plan received by prepending Cypher with EXPLAIN.
 * @access public
 */


var Plan =
/**
 * Create a Plan instance
 * @constructor
 * @param {Object} plan - Object with plan data
 */
function Plan(plan) {
  (0, _classCallCheck2["default"])(this, Plan);
  this.operatorType = plan.operatorType;
  this.identifiers = plan.identifiers;
  this.arguments = plan.args;
  this.children = plan.children ? plan.children.map(function (child) {
    return new Plan(child);
  }) : [];
};
/**
 * Class for execution plan received by prepending Cypher with PROFILE.
 * @access public
 */


var ProfiledPlan = /*#__PURE__*/function () {
  /**
   * Create a ProfiledPlan instance
   * @constructor
   * @param {Object} profile - Object with profile data
   */
  function ProfiledPlan(profile) {
    (0, _classCallCheck2["default"])(this, ProfiledPlan);
    this.operatorType = profile.operatorType;
    this.identifiers = profile.identifiers;
    this.arguments = profile.args;
    this.dbHits = valueOrDefault('dbHits', profile);
    this.rows = valueOrDefault('rows', profile);
    this.pageCacheMisses = valueOrDefault('pageCacheMisses', profile);
    this.pageCacheHits = valueOrDefault('pageCacheHits', profile);
    this.pageCacheHitRatio = valueOrDefault('pageCacheHitRatio', profile);
    this.time = valueOrDefault('time', profile);
    this.children = profile.children ? profile.children.map(function (child) {
      return new ProfiledPlan(child);
    }) : [];
  }

  (0, _createClass2["default"])(ProfiledPlan, [{
    key: "hasPageCacheStats",
    value: function hasPageCacheStats() {
      return this.pageCacheMisses > 0 || this.pageCacheHits > 0 || this.pageCacheHitRatio > 0;
    }
  }]);
  return ProfiledPlan;
}();
/**
 * Get statistical information for a {@link Result}.
 * @access public
 */


var QueryStatistics = /*#__PURE__*/function () {
  /**
   * Structurize the statistics
   * @constructor
   * @param {Object} statistics - Result statistics
   */
  function QueryStatistics(statistics) {
    var _this = this;

    (0, _classCallCheck2["default"])(this, QueryStatistics);
    this._stats = {
      nodesCreated: 0,
      nodesDeleted: 0,
      relationshipsCreated: 0,
      relationshipsDeleted: 0,
      propertiesSet: 0,
      labelsAdded: 0,
      labelsRemoved: 0,
      indexesAdded: 0,
      indexesRemoved: 0,
      constraintsAdded: 0,
      constraintsRemoved: 0
    };
    this._systemUpdates = 0;
    Object.keys(statistics).forEach(function (index) {
      // To camelCase
      var camelCaseIndex = index.replace(/(-\w)/g, function (m) {
        return m[1].toUpperCase();
      });

      if (camelCaseIndex in _this._stats) {
        _this._stats[camelCaseIndex] = intValue(statistics[index]);
      } else if (camelCaseIndex === 'systemUpdates') {
        _this._systemUpdates = intValue(statistics[index]);
      }
    });
    this._stats = Object.freeze(this._stats);
  }
  /**
   * Did the database get updated?
   * @return {boolean}
   */


  (0, _createClass2["default"])(QueryStatistics, [{
    key: "containsUpdates",
    value: function containsUpdates() {
      var _this2 = this;

      return Object.keys(this._stats).reduce(function (last, current) {
        return last + _this2._stats[current];
      }, 0) > 0;
    }
    /**
     * Returns the query statistics updates in a dictionary.
     * @returns {*}
     */

  }, {
    key: "updates",
    value: function updates() {
      return this._stats;
    }
    /**
     * Return true if the system database get updated, otherwise false
     * @returns {boolean} - If the system database get updated or not.
     */

  }, {
    key: "containsSystemUpdates",
    value: function containsSystemUpdates() {
      return this._systemUpdates > 0;
    }
    /**
     * @returns {number} - Number of system updates
     */

  }, {
    key: "systemUpdates",
    value: function systemUpdates() {
      return this._systemUpdates;
    }
  }]);
  return QueryStatistics;
}();
/**
 * Class for Cypher notifications
 * @access public
 */


var Notification = /*#__PURE__*/function () {
  /**
   * Create a Notification instance
   * @constructor
   * @param {Object} notification - Object with notification data
   */
  function Notification(notification) {
    (0, _classCallCheck2["default"])(this, Notification);
    this.code = notification.code;
    this.title = notification.title;
    this.description = notification.description;
    this.severity = notification.severity;
    this.position = Notification._constructPosition(notification.position);
  }

  (0, _createClass2["default"])(Notification, null, [{
    key: "_constructPosition",
    value: function _constructPosition(pos) {
      if (!pos) {
        return {};
      }

      return {
        offset: intValue(pos.offset),
        line: intValue(pos.line),
        column: intValue(pos.column)
      };
    }
  }]);
  return Notification;
}();
/**
 * Class for exposing server info from a result.
 * @access public
 */


var ServerInfo =
/**
 * Create a ServerInfo instance
 * @constructor
 * @param {Object} serverMeta - Object with serverMeta data
 * @param {number} protocolVersion - Bolt protocol version
 */
function ServerInfo(serverMeta, protocolVersion) {
  (0, _classCallCheck2["default"])(this, ServerInfo);

  if (serverMeta) {
    this.address = serverMeta.address;
    this.version = serverMeta.version;
  }

  this.protocolVersion = protocolVersion;
};

function intValue(value) {
  return (0, _integer.isInt)(value) ? value.toInt() : value;
}

function valueOrDefault(key, values) {
  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  if (key in values) {
    var value = values[key];
    return (0, _integer.isInt)(value) ? value.toInt() : value;
  } else {
    return defaultValue;
  }
}
/**
 * The constants for query types
 * @type {{SCHEMA_WRITE: string, WRITE_ONLY: string, READ_ONLY: string, READ_WRITE: string}}
 */


var queryType = {
  READ_ONLY: 'r',
  READ_WRITE: 'rw',
  WRITE_ONLY: 'w',
  SCHEMA_WRITE: 's'
};
exports.queryType = queryType;
var _default = ResultSummary;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/result.js":
/*!*************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/result.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _resultSummary = _interopRequireDefault(__webpack_require__(/*! ./result-summary */ "./node_modules/neo4j-driver/lib/result-summary.js"));

var _connectionHolder = __webpack_require__(/*! ./internal/connection-holder */ "./node_modules/neo4j-driver/lib/internal/connection-holder.js");

var _streamObservers = __webpack_require__(/*! ./internal/stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_ON_ERROR = function DEFAULT_ON_ERROR(error) {
  console.log('Uncaught error when processing result: ' + error);
};

var DEFAULT_ON_COMPLETED = function DEFAULT_ON_COMPLETED(summary) {};

var DEFAULT_METADATA_SUPPLIER = function DEFAULT_METADATA_SUPPLIER(metadata) {};
/**
 * A stream of {@link Record} representing the result of a query.
 * Can be consumed eagerly as {@link Promise} resolved with array of records and {@link ResultSummary}
 * summary, or rejected with error that contains {@link string} code and {@link string} message.
 * Alternatively can be consumed lazily using {@link Result#subscribe} function.
 * @access public
 */


var Result = /*#__PURE__*/function () {
  /**
   * Inject the observer to be used.
   * @constructor
   * @access private
   * @param {Promise<ResultStreamObserver>} streamObserverPromise
   * @param {mixed} query - Cypher query to execute
   * @param {Object} parameters - Map with parameters to use in query
   * @param {ConnectionHolder} connectionHolder - to be notified when result is either fully consumed or error happened.
   */
  function Result(streamObserverPromise, query, parameters, connectionHolder) {
    (0, _classCallCheck2["default"])(this, Result);
    this._stack = captureStacktrace();
    this._streamObserverPromise = streamObserverPromise;
    this._p = null;
    this._query = query;
    this._parameters = parameters || {};
    this._connectionHolder = connectionHolder || _connectionHolder.EMPTY_CONNECTION_HOLDER;
  }
  /**
   * Returns a promise for the field keys.
   *
   * *Should not be combined with {@link Result#subscribe} function.*
   *
   * @public
   * @returns {Promise<string[]>} - Field keys, in the order they will appear in records.
   }
   */


  (0, _createClass2["default"])(Result, [{
    key: "keys",
    value: function keys() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        _this._streamObserverPromise.then(function (observer) {
          return observer.subscribe({
            onKeys: function onKeys(keys) {
              return resolve(keys);
            },
            onError: function onError(err) {
              return reject(err);
            }
          });
        });
      });
    }
    /**
     * Returns a promise for the result summary.
     *
     * *Should not be combined with {@link Result#subscribe} function.*
     *
     * @public
     * @returns {Promise<ResultSummary>} - Result summary.
     *
     */

  }, {
    key: "summary",
    value: function summary() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2._streamObserverPromise.then(function (o) {
          o.cancel();
          o.subscribe({
            onCompleted: function onCompleted(metadata) {
              return resolve(metadata);
            },
            onError: function onError(err) {
              return reject(err);
            }
          });
        });
      });
    }
    /**
     * Create and return new Promise
     *
     * @private
     * @return {Promise} new Promise.
     */

  }, {
    key: "_getOrCreatePromise",
    value: function _getOrCreatePromise() {
      var _this3 = this;

      if (!this._p) {
        this._p = new Promise(function (resolve, reject) {
          var records = [];
          var observer = {
            onNext: function onNext(record) {
              records.push(record);
            },
            onCompleted: function onCompleted(summary) {
              resolve({
                records: records,
                summary: summary
              });
            },
            onError: function onError(error) {
              reject(error);
            }
          };

          _this3.subscribe(observer);
        });
      }

      return this._p;
    }
    /**
     * Waits for all results and calls the passed in function with the results.
     *
     * *Should not be combined with {@link Result#subscribe} function.*
     *
     * @param {function(result: {records:Array<Record>, summary: ResultSummary})} onFulfilled - function to be called
     * when finished.
     * @param {function(error: {message:string, code:string})} onRejected - function to be called upon errors.
     * @return {Promise} promise.
     */

  }, {
    key: "then",
    value: function then(onFulfilled, onRejected) {
      return this._getOrCreatePromise().then(onFulfilled, onRejected);
    }
    /**
     * Catch errors when using promises.
     *
     * *Should not be combined with {@link Result#subscribe} function.*
     *
     * @param {function(error: Neo4jError)} onRejected - Function to be called upon errors.
     * @return {Promise} promise.
     */

  }, {
    key: "catch",
    value: function _catch(onRejected) {
      return this._getOrCreatePromise()["catch"](onRejected);
    }
    /**
     * Stream records to observer as they come in, this is a more efficient method
     * of handling the results, and allows you to handle arbitrarily large results.
     *
     * @param {Object} observer - Observer object
     * @param {function(keys: string[])} observer.onKeys - handle stream head, the field keys.
     * @param {function(record: Record)} observer.onNext - handle records, one by one.
     * @param {function(summary: ResultSummary)} observer.onCompleted - handle stream tail, the result summary.
     * @param {function(error: {message:string, code:string})} observer.onError - handle errors.
     * @return
     */

  }, {
    key: "subscribe",
    value: function subscribe(observer) {
      var _this4 = this;

      var onCompletedOriginal = observer.onCompleted || DEFAULT_ON_COMPLETED;

      var onCompletedWrapper = function onCompletedWrapper(metadata) {
        var connectionHolder = _this4._connectionHolder;
        var query = _this4._query;
        var parameters = _this4._parameters;

        function release(protocolVersion) {
          // notify connection holder that the used connection is not needed any more because result has
          // been fully consumed; call the original onCompleted callback after that
          connectionHolder.releaseConnection().then(function () {
            onCompletedOriginal.call(observer, new _resultSummary["default"](query, parameters, metadata, protocolVersion));
          });
        }

        connectionHolder.getConnection().then( // onFulfilled:
        function (connection) {
          release(connection ? connection.protocol().version : undefined);
        }, // onRejected:
        function (_) {
          release();
        });
      };

      observer.onCompleted = onCompletedWrapper;
      var onErrorOriginal = observer.onError || DEFAULT_ON_ERROR;

      var onErrorWrapper = function onErrorWrapper(error) {
        // notify connection holder that the used connection is not needed any more because error happened
        // and result can't bee consumed any further; call the original onError callback after that
        _this4._connectionHolder.releaseConnection().then(function () {
          replaceStacktrace(error, _this4._stack);
          onErrorOriginal.call(observer, error);
        });
      };

      observer.onError = onErrorWrapper;

      this._streamObserverPromise.then(function (o) {
        return o.subscribe(observer);
      });
    }
    /**
     * Signals the stream observer that the future records should be discarded on the server.
     *
     * @protected
     * @since 4.0.0
     */

  }, {
    key: "_cancel",
    value: function _cancel() {
      this._streamObserverPromise.then(function (o) {
        return o.cancel();
      });
    }
  }]);
  return Result;
}();

function captureStacktrace() {
  var error = new Error('');

  if (error.stack) {
    return error.stack.replace(/^Error(\n\r)*/, ''); // we don't need the 'Error\n' part, if only it exists
  }

  return null;
}

function replaceStacktrace(error, newStack) {
  if (newStack) {
    // Error.prototype.toString() concatenates error.name and error.message nicely
    // then we add the rest of the stack trace
    error.stack = error.toString() + '\n' + newStack;
  }
}

var _default = Result;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/routing-driver.js":
/*!*********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/routing-driver.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _driver = __webpack_require__(/*! ./driver */ "./node_modules/neo4j-driver/lib/driver.js");

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

var _connectionProviderRouting = _interopRequireDefault(__webpack_require__(/*! ./internal/connection-provider-routing */ "./node_modules/neo4j-driver/lib/internal/connection-provider-routing.js"));

var _leastConnectedLoadBalancingStrategy = _interopRequireDefault(__webpack_require__(/*! ./internal/least-connected-load-balancing-strategy */ "./node_modules/neo4j-driver/lib/internal/least-connected-load-balancing-strategy.js"));

var _connectionErrorHandler = _interopRequireDefault(__webpack_require__(/*! ./internal/connection-error-handler */ "./node_modules/neo4j-driver/lib/internal/connection-error-handler.js"));

var _configuredCustomResolver = _interopRequireDefault(__webpack_require__(/*! ./internal/resolver/configured-custom-resolver */ "./node_modules/neo4j-driver/lib/internal/resolver/configured-custom-resolver.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * A driver that supports routing in a causal cluster.
 * @private
 */
var RoutingDriver = /*#__PURE__*/function (_Driver) {
  (0, _inherits2["default"])(RoutingDriver, _Driver);

  var _super = _createSuper(RoutingDriver);

  function RoutingDriver(address, routingContext, userAgent) {
    var _this;

    var token = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var config = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    (0, _classCallCheck2["default"])(this, RoutingDriver);
    _this = _super.call(this, address, userAgent, token, validateConfig(config));
    _this._routingContext = routingContext;
    return _this;
  }

  (0, _createClass2["default"])(RoutingDriver, [{
    key: "_afterConstruction",
    value: function _afterConstruction() {
      this._log.info("Routing driver ".concat(this._id, " created for server address ").concat(this._address));
    }
  }, {
    key: "_createConnectionProvider",
    value: function _createConnectionProvider(address, userAgent, authToken) {
      return new _connectionProviderRouting["default"]({
        id: this._id,
        address: address,
        routingContext: this._routingContext,
        hostNameResolver: createHostNameResolver(this._config),
        config: this._config,
        log: this._log,
        userAgent: userAgent,
        authToken: authToken
      });
    }
  }, {
    key: "_supportsRouting",
    value: function _supportsRouting() {
      return true;
    }
  }]);
  return RoutingDriver;
}(_driver.Driver);
/**
 * @private
 * @returns {ConfiguredCustomResolver} new custom resolver that wraps the passed-in resolver function.
 *              If resolved function is not specified, it defaults to an identity resolver.
 */


function createHostNameResolver(config) {
  return new _configuredCustomResolver["default"](config.resolver);
}
/**
 * @private
 * @returns {Object} the given config.
 */


function validateConfig(config) {
  var resolver = config.resolver;

  if (resolver && typeof resolver !== 'function') {
    throw new TypeError("Configured resolver should be a function. Got: ".concat(resolver));
  }

  return config;
}

var _default = RoutingDriver;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/session-rx.js":
/*!*****************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/session-rx.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");

var _resultRx = _interopRequireDefault(__webpack_require__(/*! ./result-rx */ "./node_modules/neo4j-driver/lib/result-rx.js"));

var _session = _interopRequireDefault(__webpack_require__(/*! ./session */ "./node_modules/neo4j-driver/lib/session.js"));

var _transactionRx = _interopRequireDefault(__webpack_require__(/*! ./transaction-rx */ "./node_modules/neo4j-driver/lib/transaction-rx.js"));

var _constants = __webpack_require__(/*! ./internal/constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

var _txConfig = _interopRequireDefault(__webpack_require__(/*! ./internal/tx-config */ "./node_modules/neo4j-driver/lib/internal/tx-config.js"));

var _retryLogicRx = _interopRequireDefault(__webpack_require__(/*! ./internal/retry-logic-rx */ "./node_modules/neo4j-driver/lib/internal/retry-logic-rx.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A Reactive session, which provides the same functionality as {@link Session} but through a Reactive API.
 */
var RxSession = /*#__PURE__*/function () {
  /**
   * Constructs a reactive session with given default session instance and provided driver configuration.
   *
   * @protected
   * @param {Object} param - Object parameter
   * @param {Session} param.session - The underlying session instance to relay requests
   */
  function RxSession() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        session = _ref.session,
        config = _ref.config;

    (0, _classCallCheck2["default"])(this, RxSession);
    this._session = session;
    this._retryLogic = _createRetryLogic(config);
  }
  /**
   * Creates a reactive result that will execute the  query with the provided parameters and the provided
   * transaction configuration that applies to the underlying auto-commit transaction.
   *
   * @public
   * @param {string} query - Query to be executed.
   * @param {Object} parameters - Parameter values to use in query execution.
   * @param {TransactionConfig} transactionConfig - Configuration for the new auto-commit transaction.
   * @returns {RxResult} - A reactive result
   */


  (0, _createClass2["default"])(RxSession, [{
    key: "run",
    value: function run(query, parameters, transactionConfig) {
      var _this = this;

      return new _resultRx["default"](new _rxjs.Observable(function (observer) {
        try {
          observer.next(_this._session.run(query, parameters, transactionConfig));
          observer.complete();
        } catch (err) {
          observer.error(err);
        }

        return function () {};
      }));
    }
    /**
     * Starts a new explicit transaction with the provided transaction configuration.
     *
     * @public
     * @param {TransactionConfig} transactionConfig - Configuration for the new transaction.
     * @returns {Observable<RxTransaction>} - A reactive stream that will generate at most **one** RxTransaction instance.
     */

  }, {
    key: "beginTransaction",
    value: function beginTransaction(transactionConfig) {
      return this._beginTransaction(this._session._mode, transactionConfig);
    }
    /**
     * Executes the provided unit of work in a {@link READ} reactive transaction which is created with the provided
     * transaction configuration.
     * @public
     * @param {function(txc: RxTransaction): Observable} work - A unit of work to be executed.
     * @param {TransactionConfig} transactionConfig - Configuration for the enclosing transaction created by the driver.
     * @returns {Observable} - A reactive stream returned by the unit of work.
     */

  }, {
    key: "readTransaction",
    value: function readTransaction(work, transactionConfig) {
      return this._runTransaction(_constants.ACCESS_MODE_READ, work, transactionConfig);
    }
    /**
     * Executes the provided unit of work in a {@link WRITE} reactive transaction which is created with the provided
     * transaction configuration.
     * @public
     * @param {function(txc: RxTransaction): Observable} work - A unit of work to be executed.
     * @param {TransactionConfig} transactionConfig - Configuration for the enclosing transaction created by the driver.
     * @returns {Observable} - A reactive stream returned by the unit of work.
     */

  }, {
    key: "writeTransaction",
    value: function writeTransaction(work, transactionConfig) {
      return this._runTransaction(_constants.ACCESS_MODE_WRITE, work, transactionConfig);
    }
    /**
     * Closes this reactive session.
     *
     * @public
     * @returns {Observable} - An empty reactive stream
     */

  }, {
    key: "close",
    value: function close() {
      var _this2 = this;

      return new _rxjs.Observable(function (observer) {
        _this2._session.close().then(function () {
          observer.complete();
        })["catch"](function (err) {
          return observer.error(err);
        });
      });
    }
    /**
     * Returns the bookmark received following the last successfully completed query, which is executed
     * either in an {@link RxTransaction} obtained from this session instance or directly through one of
     * the {@link RxSession#run} method of this session instance.
     *
     * If no bookmark was received or if this transaction was rolled back, the bookmark value will not be
     * changed.
     *
     * @public
     * @returns {string}
     */

  }, {
    key: "lastBookmark",
    value: function lastBookmark() {
      return this._session.lastBookmark();
    }
    /**
     * @private
     */

  }, {
    key: "_beginTransaction",
    value: function _beginTransaction(accessMode, transactionConfig) {
      var _this3 = this;

      var txConfig = _txConfig["default"].empty();

      if (transactionConfig) {
        txConfig = new _txConfig["default"](transactionConfig);
      }

      return new _rxjs.Observable(function (observer) {
        try {
          observer.next(new _transactionRx["default"](_this3._session._beginTransaction(accessMode, txConfig)));
          observer.complete();
        } catch (err) {
          observer.error(err);
        }

        return function () {};
      });
    }
    /**
     * @private
     */

  }, {
    key: "_runTransaction",
    value: function _runTransaction(accessMode, work, transactionConfig) {
      var txConfig = _txConfig["default"].empty();

      if (transactionConfig) {
        txConfig = new _txConfig["default"](transactionConfig);
      }

      return this._retryLogic.retry(this._beginTransaction(accessMode, transactionConfig).pipe((0, _operators.flatMap)(function (txc) {
        return (0, _rxjs.defer)(function () {
          try {
            return work(txc);
          } catch (err) {
            return (0, _rxjs.throwError)(err);
          }
        }).pipe((0, _operators.catchError)(function (err) {
          return txc.rollback().pipe((0, _operators.concat)((0, _rxjs.throwError)(err)));
        }), (0, _operators.concat)(txc.commit()));
      })));
    }
  }]);
  return RxSession;
}();

exports["default"] = RxSession;

function _createRetryLogic(config) {
  var maxRetryTimeout = config && config.maxTransactionRetryTime ? config.maxTransactionRetryTime : null;
  return new _retryLogicRx["default"]({
    maxRetryTimeout: maxRetryTimeout
  });
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/session.js":
/*!**************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/session.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _streamObservers = __webpack_require__(/*! ./internal/stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

var _result = _interopRequireDefault(__webpack_require__(/*! ./result */ "./node_modules/neo4j-driver/lib/result.js"));

var _transaction = _interopRequireDefault(__webpack_require__(/*! ./transaction */ "./node_modules/neo4j-driver/lib/transaction.js"));

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

var _util = __webpack_require__(/*! ./internal/util */ "./node_modules/neo4j-driver/lib/internal/util.js");

var _connectionHolder = _interopRequireDefault(__webpack_require__(/*! ./internal/connection-holder */ "./node_modules/neo4j-driver/lib/internal/connection-holder.js"));

var _driver = _interopRequireDefault(__webpack_require__(/*! ./driver */ "./node_modules/neo4j-driver/lib/driver.js"));

var _constants = __webpack_require__(/*! ./internal/constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

var _transactionExecutor = _interopRequireDefault(__webpack_require__(/*! ./internal/transaction-executor */ "./node_modules/neo4j-driver/lib/internal/transaction-executor.js"));

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./internal/bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

var _txConfig = _interopRequireDefault(__webpack_require__(/*! ./internal/tx-config */ "./node_modules/neo4j-driver/lib/internal/tx-config.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A Session instance is used for handling the connection and
 * sending queries through the connection.
 * In a single session, multiple queries will be executed serially.
 * In order to execute parallel queries, multiple sessions are required.
 * @access public
 */
var Session = /*#__PURE__*/function () {
  /**
   * @constructor
   * @protected
   * @param {Object} args
   * @param {string} args.mode the default access mode for this session.
   * @param {ConnectionProvider} args.connectionProvider - The connection provider to acquire connections from.
   * @param {Bookmark} args.bookmark - The initial bookmark for this session.
   * @param {string} args.database the database name
   * @param {Object} args.config={} - This driver configuration.
   * @param {boolean} args.reactive - Whether this session should create reactive streams
   * @param {number} args.fetchSize - Defines how many records is pulled in each pulling batch
   */
  function Session(_ref) {
    var mode = _ref.mode,
        connectionProvider = _ref.connectionProvider,
        bookmark = _ref.bookmark,
        database = _ref.database,
        config = _ref.config,
        reactive = _ref.reactive,
        fetchSize = _ref.fetchSize;
    (0, _classCallCheck2["default"])(this, Session);
    this._mode = mode;
    this._database = database;
    this._reactive = reactive;
    this._fetchSize = fetchSize;
    this._readConnectionHolder = new _connectionHolder["default"]({
      mode: _constants.ACCESS_MODE_READ,
      database: database,
      bookmark: bookmark,
      connectionProvider: connectionProvider
    });
    this._writeConnectionHolder = new _connectionHolder["default"]({
      mode: _constants.ACCESS_MODE_WRITE,
      database: database,
      bookmark: bookmark,
      connectionProvider: connectionProvider
    });
    this._open = true;
    this._hasTx = false;
    this._lastBookmark = bookmark;
    this._transactionExecutor = _createTransactionExecutor(config);
    this._onComplete = this._onCompleteCallback.bind(this);
  }
  /**
   * Run Cypher query
   * Could be called with a query object i.e.: `{text: "MATCH ...", prameters: {param: 1}}`
   * or with the query and parameters as separate arguments.
   *
   * @public
   * @param {mixed} query - Cypher query to execute
   * @param {Object} parameters - Map with parameters to use in query
   * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.
   * @return {Result} New Result.
   */


  (0, _createClass2["default"])(Session, [{
    key: "run",
    value: function run(query, parameters, transactionConfig) {
      var _this = this;

      var _validateQueryAndPara = (0, _util.validateQueryAndParameters)(query, parameters),
          validatedQuery = _validateQueryAndPara.validatedQuery,
          params = _validateQueryAndPara.params;

      var autoCommitTxConfig = transactionConfig ? new _txConfig["default"](transactionConfig) : _txConfig["default"].empty();
      return this._run(validatedQuery, params, function (connection) {
        _this._assertSessionIsOpen();

        return connection.protocol().run(validatedQuery, params, {
          bookmark: _this._lastBookmark,
          txConfig: autoCommitTxConfig,
          mode: _this._mode,
          database: _this._database,
          afterComplete: _this._onComplete,
          reactive: _this._reactive,
          fetchSize: _this._fetchSize
        });
      });
    }
  }, {
    key: "_run",
    value: function _run(query, parameters, customRunner) {
      var connectionHolder = this._connectionHolderWithMode(this._mode);

      var observerPromise;

      if (!this._open) {
        observerPromise = Promise.resolve(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot run query in a closed session.')
        }));
      } else if (!this._hasTx && connectionHolder.initializeConnection()) {
        observerPromise = connectionHolder.getConnection().then(function (connection) {
          return customRunner(connection);
        })["catch"](function (error) {
          return Promise.resolve(new _streamObservers.FailedObserver({
            error: error
          }));
        });
      } else {
        observerPromise = Promise.resolve(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Queries cannot be run directly on a ' + 'session with an open transaction; either run from within the ' + 'transaction or use a different session.')
        }));
      }

      return new _result["default"](observerPromise, query, parameters, connectionHolder);
    }
    /**
     * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you
     * want to run multiple concurrent transactions, you should use multiple concurrent sessions.
     *
     * While a transaction is open the session cannot be used to run queries outside the transaction.
     *
     * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.
     * @returns {Transaction} New Transaction.
     */

  }, {
    key: "beginTransaction",
    value: function beginTransaction(transactionConfig) {
      // this function needs to support bookmarks parameter for backwards compatibility
      // parameter was of type {string|string[]} and represented either a single or multiple bookmarks
      // that's why we need to check parameter type and decide how to interpret the value
      var arg = transactionConfig;

      var txConfig = _txConfig["default"].empty();

      if (arg) {
        txConfig = new _txConfig["default"](arg);
      }

      return this._beginTransaction(this._mode, txConfig);
    }
  }, {
    key: "_beginTransaction",
    value: function _beginTransaction(accessMode, txConfig) {
      if (!this._open) {
        throw (0, _error.newError)('Cannot begin a transaction on a closed session.');
      }

      if (this._hasTx) {
        throw (0, _error.newError)('You cannot begin a transaction on a session with an open transaction; ' + 'either run from within the transaction or use a different session.');
      }

      var mode = _driver["default"]._validateSessionMode(accessMode);

      var connectionHolder = this._connectionHolderWithMode(mode);

      connectionHolder.initializeConnection();
      this._hasTx = true;
      var tx = new _transaction["default"]({
        connectionHolder: connectionHolder,
        onClose: this._transactionClosed.bind(this),
        onBookmark: this._updateBookmark.bind(this),
        onConnection: this._assertSessionIsOpen.bind(this),
        reactive: this._reactive,
        fetchSize: this._fetchSize
      });

      tx._begin(this._lastBookmark, txConfig);

      return tx;
    }
  }, {
    key: "_assertSessionIsOpen",
    value: function _assertSessionIsOpen() {
      if (!this._open) {
        throw (0, _error.newError)('You cannot run more transactions on a closed session.');
      }
    }
  }, {
    key: "_transactionClosed",
    value: function _transactionClosed() {
      this._hasTx = false;
    }
    /**
     * Return the bookmark received following the last completed {@link Transaction}.
     *
     * @return {string[]} A reference to a previous transaction.
     */

  }, {
    key: "lastBookmark",
    value: function lastBookmark() {
      return this._lastBookmark.values();
    }
    /**
     * Execute given unit of work in a {@link READ} transaction.
     *
     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.
     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial
     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's
     * `maxTransactionRetryTime` property in milliseconds.
     *
     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against
     * a given {@link Transaction}.
     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.
     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given
     * function or commit fails.
     */

  }, {
    key: "readTransaction",
    value: function readTransaction(transactionWork, transactionConfig) {
      var config = new _txConfig["default"](transactionConfig);
      return this._runTransaction(_constants.ACCESS_MODE_READ, config, transactionWork);
    }
    /**
     * Execute given unit of work in a {@link WRITE} transaction.
     *
     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.
     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial
     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's
     * `maxTransactionRetryTime` property in milliseconds.
     *
     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against
     * a given {@link Transaction}.
     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.
     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given
     * function or commit fails.
     */

  }, {
    key: "writeTransaction",
    value: function writeTransaction(transactionWork, transactionConfig) {
      var config = new _txConfig["default"](transactionConfig);
      return this._runTransaction(_constants.ACCESS_MODE_WRITE, config, transactionWork);
    }
  }, {
    key: "_runTransaction",
    value: function _runTransaction(accessMode, transactionConfig, transactionWork) {
      var _this2 = this;

      return this._transactionExecutor.execute(function () {
        return _this2._beginTransaction(accessMode, transactionConfig);
      }, transactionWork);
    }
    /**
     * Update value of the last bookmark.
     * @param {Bookmark} newBookmark - The new bookmark.
     */

  }, {
    key: "_updateBookmark",
    value: function _updateBookmark(newBookmark) {
      if (newBookmark && !newBookmark.isEmpty()) {
        this._lastBookmark = newBookmark;
      }
    }
    /**
     * Close this session.
     * @return {Promise}
     */

  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._open) {
                  _context.next = 7;
                  break;
                }

                this._open = false;

                this._transactionExecutor.close();

                _context.next = 5;
                return this._readConnectionHolder.close();

              case 5:
                _context.next = 7;
                return this._writeConnectionHolder.close();

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "_connectionHolderWithMode",
    value: function _connectionHolderWithMode(mode) {
      if (mode === _constants.ACCESS_MODE_READ) {
        return this._readConnectionHolder;
      } else if (mode === _constants.ACCESS_MODE_WRITE) {
        return this._writeConnectionHolder;
      } else {
        throw (0, _error.newError)('Unknown access mode: ' + mode);
      }
    }
  }, {
    key: "_onCompleteCallback",
    value: function _onCompleteCallback(meta) {
      this._updateBookmark(new _bookmark["default"](meta.bookmark));
    }
  }]);
  return Session;
}();

function _createTransactionExecutor(config) {
  var maxRetryTimeMs = config && config.maxTransactionRetryTime ? config.maxTransactionRetryTime : null;
  return new _transactionExecutor["default"](maxRetryTimeMs);
}

var _default = Session;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/spatial-types.js":
/*!********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/spatial-types.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPoint = isPoint;
exports.Point = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _util = __webpack_require__(/*! ./internal/util */ "./node_modules/neo4j-driver/lib/internal/util.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var POINT_IDENTIFIER_PROPERTY = '__isPoint__';
/**
 * Represents a single two or three-dimensional point in a particular coordinate reference system.
 * Created `Point` objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */

var Point = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Integer|number} srid - The coordinate reference system identifier.
   * @param {number} x - The `x` coordinate of the point.
   * @param {number} y - The `y` coordinate of the point.
   * @param {number} [z=undefined] - The `z` coordinate of the point or `undefined` if point has 2 dimensions.
   */
  function Point(srid, x, y, z) {
    (0, _classCallCheck2["default"])(this, Point);

    /**
     * The coordinate reference system identifier.
     * @type {Integer|number}
     */
    this.srid = (0, _util.assertNumberOrInteger)(srid, 'SRID');
    /**
     * The `x` coordinate of the point.
     * @type {number}
     */

    this.x = (0, _util.assertNumber)(x, 'X coordinate');
    /**
     * The `y` coordinate of the point.
     * @type {number}
     */

    this.y = (0, _util.assertNumber)(y, 'Y coordinate');
    /**
     * The `z` coordinate of the point or `undefined` if point is 2-dimensional.
     * @type {number}
     */

    this.z = z === null || z === undefined ? z : (0, _util.assertNumber)(z, 'Z coordinate');
    Object.freeze(this);
  }
  /**
   * @ignore
   */


  (0, _createClass2["default"])(Point, [{
    key: "toString",
    value: function toString() {
      return this.z || this.z === 0 ? "Point{srid=".concat(formatAsFloat(this.srid), ", x=").concat(formatAsFloat(this.x), ", y=").concat(formatAsFloat(this.y), ", z=").concat(formatAsFloat(this.z), "}") : "Point{srid=".concat(formatAsFloat(this.srid), ", x=").concat(formatAsFloat(this.x), ", y=").concat(formatAsFloat(this.y), "}");
    }
  }]);
  return Point;
}();

exports.Point = Point;

function formatAsFloat(number) {
  return Number.isInteger(number) ? number + '.0' : number.toString();
}

Object.defineProperty(Point.prototype, POINT_IDENTIFIER_PROPERTY, {
  value: true,
  enumerable: false,
  configurable: false,
  writable: false
});
/**
 * Test if given object is an instance of {@link Point} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Point}, `false` otherwise.
 */

function isPoint(obj) {
  return (obj && obj[POINT_IDENTIFIER_PROPERTY]) === true;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/temporal-types.js":
/*!*********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/temporal-types.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDuration = isDuration;
exports.isLocalTime = isLocalTime;
exports.isTime = isTime;
exports.isDate = isDate;
exports.isLocalDateTime = isLocalDateTime;
exports.isDateTime = isDateTime;
exports.DateTime = exports.LocalDateTime = exports.Date = exports.Time = exports.LocalTime = exports.Duration = void 0;

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var util = _interopRequireWildcard(__webpack_require__(/*! ./internal/temporal-util */ "./node_modules/neo4j-driver/lib/internal/temporal-util.js"));

var _util = __webpack_require__(/*! ./internal/util */ "./node_modules/neo4j-driver/lib/internal/util.js");

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var IDENTIFIER_PROPERTY_ATTRIBUTES = {
  value: true,
  enumerable: false,
  configurable: false,
  writable: false
};
var DURATION_IDENTIFIER_PROPERTY = '__isDuration__';
var LOCAL_TIME_IDENTIFIER_PROPERTY = '__isLocalTime__';
var TIME_IDENTIFIER_PROPERTY = '__isTime__';
var DATE_IDENTIFIER_PROPERTY = '__isDate__';
var LOCAL_DATE_TIME_IDENTIFIER_PROPERTY = '__isLocalDateTime__';
var DATE_TIME_IDENTIFIER_PROPERTY = '__isDateTime__';
/**
 * Represents an ISO 8601 duration. Contains both date-based values (years, months, days) and time-based values (seconds, nanoseconds).
 * Created `Duration` objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */

var Duration = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Integer|number} months - The number of months for the new duration.
   * @param {Integer|number} days - The number of days for the new duration.
   * @param {Integer|number} seconds - The number of seconds for the new duration.
   * @param {Integer|number} nanoseconds - The number of nanoseconds for the new duration.
   */
  function Duration(months, days, seconds, nanoseconds) {
    (0, _classCallCheck2["default"])(this, Duration);

    /**
     * The number of months.
     * @type {Integer|number}
     */
    this.months = (0, _util.assertNumberOrInteger)(months, 'Months');
    /**
     * The number of days.
     * @type {Integer|number}
     */

    this.days = (0, _util.assertNumberOrInteger)(days, 'Days');
    (0, _util.assertNumberOrInteger)(seconds, 'Seconds');
    (0, _util.assertNumberOrInteger)(nanoseconds, 'Nanoseconds');
    /**
     * The number of seconds.
     * @type {Integer|number}
     */

    this.seconds = util.normalizeSecondsForDuration(seconds, nanoseconds);
    /**
     * The number of nanoseconds.
     * @type {Integer|number}
     */

    this.nanoseconds = util.normalizeNanosecondsForDuration(nanoseconds);
    Object.freeze(this);
  }
  /**
   * @ignore
   */


  (0, _createClass2["default"])(Duration, [{
    key: "toString",
    value: function toString() {
      return util.durationToIsoString(this.months, this.days, this.seconds, this.nanoseconds);
    }
  }]);
  return Duration;
}();

exports.Duration = Duration;
Object.defineProperty(Duration.prototype, DURATION_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Duration} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Duration}, `false` otherwise.
 */

function isDuration(obj) {
  return hasIdentifierProperty(obj, DURATION_IDENTIFIER_PROPERTY);
}
/**
 * Represents an instant capturing the time of day, but not the date, nor the timezone.
 * Created {@link LocalTime} objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */


var LocalTime = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Integer|number} hour - The hour for the new local time.
   * @param {Integer|number} minute - The minute for the new local time.
   * @param {Integer|number} second - The second for the new local time.
   * @param {Integer|number} nanosecond - The nanosecond for the new local time.
   */
  function LocalTime(hour, minute, second, nanosecond) {
    (0, _classCallCheck2["default"])(this, LocalTime);

    /**
     * The hour.
     * @type {Integer|number}
     */
    this.hour = util.assertValidHour(hour);
    /**
     * The minute.
     * @type {Integer|number}
     */

    this.minute = util.assertValidMinute(minute);
    /**
     * The second.
     * @type {Integer|number}
     */

    this.second = util.assertValidSecond(second);
    /**
     * The nanosecond.
     * @type {Integer|number}
     */

    this.nanosecond = util.assertValidNanosecond(nanosecond);
    Object.freeze(this);
  }
  /**
   * Create a {@link LocalTime} object from the given standard JavaScript `Date` and optional nanoseconds.
   * Year, month, day and time zone offset components of the given date are ignored.
   * @param {global.Date} standardDate - The standard JavaScript date to convert.
   * @param {Integer|number|undefined} nanosecond - The optional amount of nanoseconds.
   * @return {LocalTime} New LocalTime.
   */


  (0, _createClass2["default"])(LocalTime, [{
    key: "toString",

    /**
     * @ignore
     */
    value: function toString() {
      return util.timeToIsoString(this.hour, this.minute, this.second, this.nanosecond);
    }
  }], [{
    key: "fromStandardDate",
    value: function fromStandardDate(standardDate, nanosecond) {
      verifyStandardDateAndNanos(standardDate, nanosecond);
      return new LocalTime(standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), util.totalNanoseconds(standardDate, nanosecond));
    }
  }]);
  return LocalTime;
}();

exports.LocalTime = LocalTime;
Object.defineProperty(LocalTime.prototype, LOCAL_TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link LocalTime} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link LocalTime}, `false` otherwise.
 */

function isLocalTime(obj) {
  return hasIdentifierProperty(obj, LOCAL_TIME_IDENTIFIER_PROPERTY);
}
/**
 * Represents an instant capturing the time of day, and the timezone offset in seconds, but not the date.
 * Created {@link Time} objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */


var Time = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Integer|number} hour - The hour for the new local time.
   * @param {Integer|number} minute - The minute for the new local time.
   * @param {Integer|number} second - The second for the new local time.
   * @param {Integer|number} nanosecond - The nanosecond for the new local time.
   * @param {Integer|number} timeZoneOffsetSeconds - The time zone offset in seconds. Value represents the difference, in seconds, from UTC to local time.
   * This is different from standard JavaScript `Date.getTimezoneOffset()` which is the difference, in minutes, from local time to UTC.
   */
  function Time(hour, minute, second, nanosecond, timeZoneOffsetSeconds) {
    (0, _classCallCheck2["default"])(this, Time);

    /**
     * The hour.
     * @type {Integer|number}
     */
    this.hour = util.assertValidHour(hour);
    /**
     * The minute.
     * @type {Integer|number}
     */

    this.minute = util.assertValidMinute(minute);
    /**
     * The second.
     * @type {Integer|number}
     */

    this.second = util.assertValidSecond(second);
    /**
     * The nanosecond.
     * @type {Integer|number}
     */

    this.nanosecond = util.assertValidNanosecond(nanosecond);
    /**
     * The time zone offset in seconds.
     * @type {Integer|number}
     */

    this.timeZoneOffsetSeconds = (0, _util.assertNumberOrInteger)(timeZoneOffsetSeconds, 'Time zone offset in seconds');
    Object.freeze(this);
  }
  /**
   * Create a {@link Time} object from the given standard JavaScript `Date` and optional nanoseconds.
   * Year, month and day components of the given date are ignored.
   * @param {global.Date} standardDate - The standard JavaScript date to convert.
   * @param {Integer|number|undefined} nanosecond - The optional amount of nanoseconds.
   * @return {Time} New Time.
   */


  (0, _createClass2["default"])(Time, [{
    key: "toString",

    /**
     * @ignore
     */
    value: function toString() {
      return util.timeToIsoString(this.hour, this.minute, this.second, this.nanosecond) + util.timeZoneOffsetToIsoString(this.timeZoneOffsetSeconds);
    }
  }], [{
    key: "fromStandardDate",
    value: function fromStandardDate(standardDate, nanosecond) {
      verifyStandardDateAndNanos(standardDate, nanosecond);
      return new Time(standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), util.totalNanoseconds(standardDate, nanosecond), util.timeZoneOffsetInSeconds(standardDate));
    }
  }]);
  return Time;
}();

exports.Time = Time;
Object.defineProperty(Time.prototype, TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Time} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Time}, `false` otherwise.
 */

function isTime(obj) {
  return hasIdentifierProperty(obj, TIME_IDENTIFIER_PROPERTY);
}
/**
 * Represents an instant capturing the date, but not the time, nor the timezone.
 * Created {@link Date} objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */


var Date = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Integer|number} year - The year for the new local date.
   * @param {Integer|number} month - The month for the new local date.
   * @param {Integer|number} day - The day for the new local date.
   */
  function Date(year, month, day) {
    (0, _classCallCheck2["default"])(this, Date);

    /**
     * The year.
     * @type {Integer|number}
     */
    this.year = util.assertValidYear(year);
    /**
     * The month.
     * @type {Integer|number}
     */

    this.month = util.assertValidMonth(month);
    /**
     * The day.
     * @type {Integer|number}
     */

    this.day = util.assertValidDay(day);
    Object.freeze(this);
  }
  /**
   * Create a {@link Date} object from the given standard JavaScript `Date`.
   * Hour, minute, second, millisecond and time zone offset components of the given date are ignored.
   * @param {global.Date} standardDate - The standard JavaScript date to convert.
   * @return {Date} New Date.
   */


  (0, _createClass2["default"])(Date, [{
    key: "toString",

    /**
     * @ignore
     */
    value: function toString() {
      return util.dateToIsoString(this.year, this.month, this.day);
    }
  }], [{
    key: "fromStandardDate",
    value: function fromStandardDate(standardDate) {
      verifyStandardDateAndNanos(standardDate, null);
      return new Date(standardDate.getFullYear(), standardDate.getMonth() + 1, standardDate.getDate());
    }
  }]);
  return Date;
}();

exports.Date = Date;
Object.defineProperty(Date.prototype, DATE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Date} class.
 * @param {Object} obj - The object to test.
 * @return {boolean} `true` if given object is a {@link Date}, `false` otherwise.
 */

function isDate(obj) {
  return hasIdentifierProperty(obj, DATE_IDENTIFIER_PROPERTY);
}
/**
 * Represents an instant capturing the date and the time, but not the timezone.
 * Created {@link LocalDateTime} objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */


var LocalDateTime = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Integer|number} year - The year for the new local date.
   * @param {Integer|number} month - The month for the new local date.
   * @param {Integer|number} day - The day for the new local date.
   * @param {Integer|number} hour - The hour for the new local time.
   * @param {Integer|number} minute - The minute for the new local time.
   * @param {Integer|number} second - The second for the new local time.
   * @param {Integer|number} nanosecond - The nanosecond for the new local time.
   */
  function LocalDateTime(year, month, day, hour, minute, second, nanosecond) {
    (0, _classCallCheck2["default"])(this, LocalDateTime);

    /**
     * The year.
     * @type {Integer|number}
     */
    this.year = util.assertValidYear(year);
    /**
     * The month.
     * @type {Integer|number}
     */

    this.month = util.assertValidMonth(month);
    /**
     * The day.
     * @type {Integer|number}
     */

    this.day = util.assertValidDay(day);
    /**
     * The hour.
     * @type {Integer|number}
     */

    this.hour = util.assertValidHour(hour);
    /**
     * The minute.
     * @type {Integer|number}
     */

    this.minute = util.assertValidMinute(minute);
    /**
     * The second.
     * @type {Integer|number}
     */

    this.second = util.assertValidSecond(second);
    /**
     * The nanosecond.
     * @type {Integer|number}
     */

    this.nanosecond = util.assertValidNanosecond(nanosecond);
    Object.freeze(this);
  }
  /**
   * Create a {@link LocalDateTime} object from the given standard JavaScript `Date` and optional nanoseconds.
   * Time zone offset component of the given date is ignored.
   * @param {global.Date} standardDate - The standard JavaScript date to convert.
   * @param {Integer|number|undefined} nanosecond - The optional amount of nanoseconds.
   * @return {LocalDateTime} New LocalDateTime.
   */


  (0, _createClass2["default"])(LocalDateTime, [{
    key: "toString",

    /**
     * @ignore
     */
    value: function toString() {
      return localDateTimeToString(this.year, this.month, this.day, this.hour, this.minute, this.second, this.nanosecond);
    }
  }], [{
    key: "fromStandardDate",
    value: function fromStandardDate(standardDate, nanosecond) {
      verifyStandardDateAndNanos(standardDate, nanosecond);
      return new LocalDateTime(standardDate.getFullYear(), standardDate.getMonth() + 1, standardDate.getDate(), standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), util.totalNanoseconds(standardDate, nanosecond));
    }
  }]);
  return LocalDateTime;
}();

exports.LocalDateTime = LocalDateTime;
Object.defineProperty(LocalDateTime.prototype, LOCAL_DATE_TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link LocalDateTime} class.
 * @param {Object} obj - The object to test.
 * @return {boolean} `true` if given object is a {@link LocalDateTime}, `false` otherwise.
 */

function isLocalDateTime(obj) {
  return hasIdentifierProperty(obj, LOCAL_DATE_TIME_IDENTIFIER_PROPERTY);
}
/**
 * Represents an instant capturing the date, the time and the timezone identifier.
 * Created {@ DateTime} objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */


var DateTime = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Integer|number} year - The year for the new date-time.
   * @param {Integer|number} month - The month for the new date-time.
   * @param {Integer|number} day - The day for the new date-time.
   * @param {Integer|number} hour - The hour for the new date-time.
   * @param {Integer|number} minute - The minute for the new date-time.
   * @param {Integer|number} second - The second for the new date-time.
   * @param {Integer|number} nanosecond - The nanosecond for the new date-time.
   * @param {Integer|number} timeZoneOffsetSeconds - The time zone offset in seconds. Either this argument or `timeZoneId` should be defined.
   * Value represents the difference, in seconds, from UTC to local time.
   * This is different from standard JavaScript `Date.getTimezoneOffset()` which is the difference, in minutes, from local time to UTC.
   * @param {string|null} timeZoneId - The time zone id for the new date-time. Either this argument or `timeZoneOffsetSeconds` should be defined.
   */
  function DateTime(year, month, day, hour, minute, second, nanosecond, timeZoneOffsetSeconds, timeZoneId) {
    (0, _classCallCheck2["default"])(this, DateTime);

    /**
     * The year.
     * @type {Integer|number}
     */
    this.year = util.assertValidYear(year);
    /**
     * The month.
     * @type {Integer|number}
     */

    this.month = util.assertValidMonth(month);
    /**
     * The day.
     * @type {Integer|number}
     */

    this.day = util.assertValidDay(day);
    /**
     * The hour.
     * @type {Integer|number}
     */

    this.hour = util.assertValidHour(hour);
    /**
     * The minute.
     * @type {Integer|number}
     */

    this.minute = util.assertValidMinute(minute);
    /**
     * The second.
     * @type {Integer|number}
     */

    this.second = util.assertValidSecond(second);
    /**
     * The nanosecond.
     * @type {Integer|number}
     */

    this.nanosecond = util.assertValidNanosecond(nanosecond);

    var _verifyTimeZoneArgume = verifyTimeZoneArguments(timeZoneOffsetSeconds, timeZoneId),
        _verifyTimeZoneArgume2 = (0, _slicedToArray2["default"])(_verifyTimeZoneArgume, 2),
        offset = _verifyTimeZoneArgume2[0],
        id = _verifyTimeZoneArgume2[1];
    /**
     * The time zone offset in seconds.
     *
     * *Either this or {@link timeZoneId} is defined.*
     *
     * @type {Integer|number}
     */


    this.timeZoneOffsetSeconds = offset;
    /**
     * The time zone id.
     *
     * *Either this or {@link timeZoneOffsetSeconds} is defined.*
     *
     * @type {string}
     */

    this.timeZoneId = id;
    Object.freeze(this);
  }
  /**
   * Create a {@link DateTime} object from the given standard JavaScript `Date` and optional nanoseconds.
   * @param {global.Date} standardDate - The standard JavaScript date to convert.
   * @param {Integer|number|undefined} nanosecond - The optional amount of nanoseconds.
   * @return {DateTime} New DateTime.
   */


  (0, _createClass2["default"])(DateTime, [{
    key: "toString",

    /**
     * @ignore
     */
    value: function toString() {
      var localDateTimeStr = localDateTimeToString(this.year, this.month, this.day, this.hour, this.minute, this.second, this.nanosecond);
      var timeZoneStr = this.timeZoneId ? "[".concat(this.timeZoneId, "]") : util.timeZoneOffsetToIsoString(this.timeZoneOffsetSeconds);
      return localDateTimeStr + timeZoneStr;
    }
  }], [{
    key: "fromStandardDate",
    value: function fromStandardDate(standardDate, nanosecond) {
      verifyStandardDateAndNanos(standardDate, nanosecond);
      return new DateTime(standardDate.getFullYear(), standardDate.getMonth() + 1, standardDate.getDate(), standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), util.totalNanoseconds(standardDate, nanosecond), util.timeZoneOffsetInSeconds(standardDate), null
      /* no time zone id */
      );
    }
  }]);
  return DateTime;
}();

exports.DateTime = DateTime;
Object.defineProperty(DateTime.prototype, DATE_TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link DateTime} class.
 * @param {Object} obj - The object to test.
 * @return {boolean} `true` if given object is a {@link DateTime}, `false` otherwise.
 */

function isDateTime(obj) {
  return hasIdentifierProperty(obj, DATE_TIME_IDENTIFIER_PROPERTY);
}

function hasIdentifierProperty(obj, property) {
  return (obj && obj[property]) === true;
}

function localDateTimeToString(year, month, day, hour, minute, second, nanosecond) {
  return util.dateToIsoString(year, month, day) + 'T' + util.timeToIsoString(hour, minute, second, nanosecond);
}

function verifyTimeZoneArguments(timeZoneOffsetSeconds, timeZoneId) {
  var offsetDefined = timeZoneOffsetSeconds || timeZoneOffsetSeconds === 0;
  var idDefined = timeZoneId && timeZoneId !== '';

  if (offsetDefined && !idDefined) {
    (0, _util.assertNumberOrInteger)(timeZoneOffsetSeconds, 'Time zone offset in seconds');
    return [timeZoneOffsetSeconds, null];
  } else if (!offsetDefined && idDefined) {
    (0, _util.assertString)(timeZoneId, 'Time zone ID');
    return [null, timeZoneId];
  } else if (offsetDefined && idDefined) {
    throw (0, _error.newError)("Unable to create DateTime with both time zone offset and id. Please specify either of them. Given offset: ".concat(timeZoneOffsetSeconds, " and id: ").concat(timeZoneId));
  } else {
    throw (0, _error.newError)("Unable to create DateTime without either time zone offset or id. Please specify either of them. Given offset: ".concat(timeZoneOffsetSeconds, " and id: ").concat(timeZoneId));
  }
}

function verifyStandardDateAndNanos(standardDate, nanosecond) {
  (0, _util.assertValidDate)(standardDate, 'Standard date');

  if (nanosecond !== null && nanosecond !== undefined) {
    (0, _util.assertNumberOrInteger)(nanosecond, 'Nanosecond');
  }
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/transaction-rx.js":
/*!*********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/transaction-rx.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");

var _resultRx = _interopRequireDefault(__webpack_require__(/*! ./result-rx */ "./node_modules/neo4j-driver/lib/result-rx.js"));

var _transaction = _interopRequireDefault(__webpack_require__(/*! ./transaction */ "./node_modules/neo4j-driver/lib/transaction.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A reactive transaction, which provides the same functionality as {@link Transaction} but through a Reactive API.
 */
var RxTransaction = /*#__PURE__*/function () {
  /**
   * @constructor
   * @protected
   * @param {Transaction} txc - The underlying transaction instance to relay requests
   */
  function RxTransaction(txc) {
    (0, _classCallCheck2["default"])(this, RxTransaction);
    this._txc = txc;
  }
  /**
   * Creates a reactive result that will execute the query in this transaction, with the provided parameters.
   *
   * @public
   * @param {string} query - Query to be executed.
   * @param {Object} parameters - Parameter values to use in query execution.
   * @returns {RxResult} - A reactive result
   */


  (0, _createClass2["default"])(RxTransaction, [{
    key: "run",
    value: function run(query, parameters) {
      var _this = this;

      return new _resultRx["default"](new _rxjs.Observable(function (observer) {
        try {
          observer.next(_this._txc.run(query, parameters));
          observer.complete();
        } catch (err) {
          observer.error(err);
        }

        return function () {};
      }));
    }
    /**
     *  Commits the transaction.
     *
     * @public
     * @returns {Observable} - An empty observable
     */

  }, {
    key: "commit",
    value: function commit() {
      var _this2 = this;

      return new _rxjs.Observable(function (observer) {
        _this2._txc.commit().then(function () {
          observer.complete();
        })["catch"](function (err) {
          return observer.error(err);
        });
      });
    }
    /**
     *  Rolls back the transaction.
     *
     * @public
     * @returns {Observable} - An empty observable
     */

  }, {
    key: "rollback",
    value: function rollback() {
      var _this3 = this;

      return new _rxjs.Observable(function (observer) {
        _this3._txc.rollback().then(function () {
          observer.complete();
        })["catch"](function (err) {
          return observer.error(err);
        });
      });
    }
  }]);
  return RxTransaction;
}();

exports["default"] = RxTransaction;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/transaction.js":
/*!******************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/transaction.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _result = _interopRequireDefault(__webpack_require__(/*! ./result */ "./node_modules/neo4j-driver/lib/result.js"));

var _util = __webpack_require__(/*! ./internal/util */ "./node_modules/neo4j-driver/lib/internal/util.js");

var _connectionHolder = _interopRequireWildcard(__webpack_require__(/*! ./internal/connection-holder */ "./node_modules/neo4j-driver/lib/internal/connection-holder.js"));

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./internal/bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

var _txConfig = _interopRequireDefault(__webpack_require__(/*! ./internal/tx-config */ "./node_modules/neo4j-driver/lib/internal/tx-config.js"));

var _streamObservers = __webpack_require__(/*! ./internal/stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Represents a transaction in the Neo4j database.
 *
 * @access public
 */
var Transaction = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {ConnectionHolder} connectionHolder - the connection holder to get connection from.
   * @param {function()} onClose - Function to be called when transaction is committed or rolled back.
   * @param {function(bookmark: Bookmark)} onBookmark callback invoked when new bookmark is produced.
   * * @param {function()} onConnection - Function to be called when a connection is obtained to ensure the conneciton
   * is not yet released.
   * @param {boolean} reactive whether this transaction generates reactive streams
   * @param {number} fetchSize - the record fetch size in each pulling batch.
   */
  function Transaction(_ref) {
    var connectionHolder = _ref.connectionHolder,
        onClose = _ref.onClose,
        onBookmark = _ref.onBookmark,
        onConnection = _ref.onConnection,
        reactive = _ref.reactive,
        fetchSize = _ref.fetchSize;
    (0, _classCallCheck2["default"])(this, Transaction);
    this._connectionHolder = connectionHolder;
    this._reactive = reactive;
    this._state = _states.ACTIVE;
    this._onClose = onClose;
    this._onBookmark = onBookmark;
    this._onConnection = onConnection;
    this._onError = this._onErrorCallback.bind(this);
    this._onComplete = this._onCompleteCallback.bind(this);
    this._fetchSize = fetchSize;
    this._results = [];
  }

  (0, _createClass2["default"])(Transaction, [{
    key: "_begin",
    value: function _begin(bookmark, txConfig) {
      var _this = this;

      this._connectionHolder.getConnection().then(function (conn) {
        _this._onConnection();

        return conn.protocol().beginTransaction({
          bookmark: bookmark,
          txConfig: txConfig,
          mode: _this._connectionHolder.mode(),
          database: _this._connectionHolder.database(),
          beforeError: _this._onError,
          afterComplete: _this._onComplete
        });
      })["catch"](function (error) {
        return _this._onError(error);
      });
    }
    /**
     * Run Cypher query
     * Could be called with a query object i.e.: `{text: "MATCH ...", parameters: {param: 1}}`
     * or with the query and parameters as separate arguments.
     * @param {mixed} query - Cypher query to execute
     * @param {Object} parameters - Map with parameters to use in query
     * @return {Result} New Result
     */

  }, {
    key: "run",
    value: function run(query, parameters) {
      var _validateQueryAndPara = (0, _util.validateQueryAndParameters)(query, parameters),
          validatedQuery = _validateQueryAndPara.validatedQuery,
          params = _validateQueryAndPara.params;

      var result = this._state.run(validatedQuery, params, {
        connectionHolder: this._connectionHolder,
        onError: this._onError,
        onComplete: this._onComplete,
        onConnection: this._onConnection,
        reactive: this._reactive,
        fetchSize: this._fetchSize
      });

      this._results.push(result);

      return result;
    }
    /**
     * Commits the transaction and returns the result.
     *
     * After committing the transaction can no longer be used.
     *
     * @returns {Promise<void>} An empty promise if committed successfully or error if any error happened during commit.
     */

  }, {
    key: "commit",
    value: function commit() {
      var committed = this._state.commit({
        connectionHolder: this._connectionHolder,
        onError: this._onError,
        onComplete: this._onComplete,
        onConnection: this._onConnection,
        pendingResults: this._results
      });

      this._state = committed.state; // clean up

      this._onClose();

      return new Promise(function (resolve, reject) {
        committed.result.subscribe({
          onCompleted: function onCompleted() {
            return resolve();
          },
          onError: function onError(error) {
            return reject(error);
          }
        });
      });
    }
    /**
     * Rollbacks the transaction.
     *
     * After rolling back, the transaction can no longer be used.
     *
     * @returns {Promise<void>} An empty promise if rolled back successfully or error if any error happened during
     * rollback.
     */

  }, {
    key: "rollback",
    value: function rollback() {
      var rolledback = this._state.rollback({
        connectionHolder: this._connectionHolder,
        onError: this._onError,
        onComplete: this._onComplete,
        onConnection: this._onConnection,
        pendingResults: this._results
      });

      this._state = rolledback.state; // clean up

      this._onClose();

      return new Promise(function (resolve, reject) {
        rolledback.result.subscribe({
          onCompleted: function onCompleted() {
            return resolve();
          },
          onError: function onError(error) {
            return reject(error);
          }
        });
      });
    }
    /**
     * Check if this transaction is active, which means commit and rollback did not happen.
     * @return {boolean} `true` when not committed and not rolled back, `false` otherwise.
     */

  }, {
    key: "isOpen",
    value: function isOpen() {
      return this._state === _states.ACTIVE;
    }
  }, {
    key: "_onErrorCallback",
    value: function _onErrorCallback(err) {
      // error will be "acknowledged" by sending a RESET message
      // database will then forget about this transaction and cleanup all corresponding resources
      // it is thus safe to move this transaction to a FAILED state and disallow any further interactions with it
      this._state = _states.FAILED;

      this._onClose(); // release connection back to the pool


      return this._connectionHolder.releaseConnection();
    }
  }, {
    key: "_onCompleteCallback",
    value: function _onCompleteCallback(meta) {
      this._onBookmark(new _bookmark["default"](meta.bookmark));
    }
  }]);
  return Transaction;
}();

var _states = {
  // The transaction is running with no explicit success or failure marked
  ACTIVE: {
    commit: function commit(_ref2) {
      var connectionHolder = _ref2.connectionHolder,
          onError = _ref2.onError,
          onComplete = _ref2.onComplete,
          onConnection = _ref2.onConnection,
          pendingResults = _ref2.pendingResults;
      return {
        result: finishTransaction(true, connectionHolder, onError, onComplete, onConnection, pendingResults),
        state: _states.SUCCEEDED
      };
    },
    rollback: function rollback(_ref3) {
      var connectionHolder = _ref3.connectionHolder,
          onError = _ref3.onError,
          onComplete = _ref3.onComplete,
          onConnection = _ref3.onConnection,
          pendingResults = _ref3.pendingResults;
      return {
        result: finishTransaction(false, connectionHolder, onError, onComplete, onConnection, pendingResults),
        state: _states.ROLLED_BACK
      };
    },
    run: function run(query, parameters, _ref4) {
      var connectionHolder = _ref4.connectionHolder,
          onError = _ref4.onError,
          onComplete = _ref4.onComplete,
          onConnection = _ref4.onConnection,
          reactive = _ref4.reactive,
          fetchSize = _ref4.fetchSize;
      // RUN in explicit transaction can't contain bookmarks and transaction configuration
      // No need to include mode and database name as it shall be inclued in begin
      var observerPromise = connectionHolder.getConnection().then(function (conn) {
        onConnection();
        return conn.protocol().run(query, parameters, {
          bookmark: _bookmark["default"].empty(),
          txConfig: _txConfig["default"].empty(),
          beforeError: onError,
          afterComplete: onComplete,
          reactive: reactive,
          fetchSize: fetchSize
        });
      })["catch"](function (error) {
        return new _streamObservers.FailedObserver({
          error: error,
          onError: onError
        });
      });
      return newCompletedResult(observerPromise, query, parameters);
    }
  },
  // An error has occurred, transaction can no longer be used and no more messages will
  // be sent for this transaction.
  FAILED: {
    commit: function commit(_ref5) {
      var connectionHolder = _ref5.connectionHolder,
          onError = _ref5.onError,
          onComplete = _ref5.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot commit this transaction, because it has been rolled back either because of an error or explicit termination.'),
          onError: onError
        }), 'COMMIT', {}),
        state: _states.FAILED
      };
    },
    rollback: function rollback(_ref6) {
      var connectionHolder = _ref6.connectionHolder,
          onError = _ref6.onError,
          onComplete = _ref6.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.CompletedObserver(), 'ROLLBACK', {}),
        state: _states.FAILED
      };
    },
    run: function run(query, parameters, _ref7) {
      var connectionHolder = _ref7.connectionHolder,
          onError = _ref7.onError,
          onComplete = _ref7.onComplete;
      return newCompletedResult(new _streamObservers.FailedObserver({
        error: (0, _error.newError)('Cannot run query in this transaction, because it has been rolled back either because of an error or explicit termination.'),
        onError: onError
      }), query, parameters);
    }
  },
  // This transaction has successfully committed
  SUCCEEDED: {
    commit: function commit(_ref8) {
      var connectionHolder = _ref8.connectionHolder,
          onError = _ref8.onError,
          onComplete = _ref8.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot commit this transaction, because it has already been committed.'),
          onError: onError
        }), 'COMMIT', {}),
        state: _states.SUCCEEDED
      };
    },
    rollback: function rollback(_ref9) {
      var connectionHolder = _ref9.connectionHolder,
          onError = _ref9.onError,
          onComplete = _ref9.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot rollback this transaction, because it has already been committed.'),
          onError: onError
        }), 'ROLLBACK', {}),
        state: _states.SUCCEEDED
      };
    },
    run: function run(query, parameters, _ref10) {
      var connectionHolder = _ref10.connectionHolder,
          onError = _ref10.onError,
          onComplete = _ref10.onComplete;
      return newCompletedResult(new _streamObservers.FailedObserver({
        error: (0, _error.newError)('Cannot run query in this transaction, because it has already been committed.'),
        onError: onError
      }), query, parameters);
    }
  },
  // This transaction has been rolled back
  ROLLED_BACK: {
    commit: function commit(_ref11) {
      var connectionHolder = _ref11.connectionHolder,
          onError = _ref11.onError,
          onComplete = _ref11.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot commit this transaction, because it has already been rolled back.'),
          onError: onError
        }), 'COMMIT', {}),
        state: _states.ROLLED_BACK
      };
    },
    rollback: function rollback(_ref12) {
      var connectionHolder = _ref12.connectionHolder,
          onError = _ref12.onError,
          onComplete = _ref12.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot rollback this transaction, because it has already been rolled back.')
        }), 'ROLLBACK', {}),
        state: _states.ROLLED_BACK
      };
    },
    run: function run(query, parameters, _ref13) {
      var connectionHolder = _ref13.connectionHolder,
          onError = _ref13.onError,
          onComplete = _ref13.onComplete;
      return newCompletedResult(new _streamObservers.FailedObserver({
        error: (0, _error.newError)('Cannot run query in this transaction, because it has already been rolled back.'),
        onError: onError
      }), query, parameters);
    }
  }
};
/**
 *
 * @param {boolean} commit
 * @param {ConnectionHolder} connectionHolder
 * @param {function(err:Error): any} onError
 * @param {function(metadata:object): any} onComplete
 * @param {function() : any} onConnection
 * @param {list<Result>>}pendingResults all run results in this transaction
 */

function finishTransaction(commit, connectionHolder, onError, onComplete, onConnection, pendingResults) {
  var observerPromise = connectionHolder.getConnection().then(function (connection) {
    onConnection();
    pendingResults.forEach(function (r) {
      return r._cancel();
    });
    return Promise.all(pendingResults).then(function (results) {
      if (commit) {
        return connection.protocol().commitTransaction({
          beforeError: onError,
          afterComplete: onComplete
        });
      } else {
        return connection.protocol().rollbackTransaction({
          beforeError: onError,
          afterComplete: onComplete
        });
      }
    });
  })["catch"](function (error) {
    return new _streamObservers.FailedObserver({
      error: error,
      onError: onError
    });
  }); // for commit & rollback we need result that uses real connection holder and notifies it when
  // connection is not needed and can be safely released to the pool

  return new _result["default"](observerPromise, commit ? 'COMMIT' : 'ROLLBACK', {}, connectionHolder);
}
/**
 * Creates a {@link Result} with empty connection holder.
 * For cases when result represents an intermediate or failed action, does not require any metadata and does not
 * need to influence real connection holder to release connections.
 * @param {ResultStreamObserver} observer - an observer for the created result.
 * @param {string} query - the cypher query that produced the result.
 * @param {Object} parameters - the parameters for cypher query that produced the result.
 * @return {Result} new result.
 * @private
 */


function newCompletedResult(observerPromise, query, parameters) {
  return new _result["default"](Promise.resolve(observerPromise), query, parameters, _connectionHolder.EMPTY_CONNECTION_HOLDER);
}

var _default = Transaction;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/version.js":
/*!**************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/version.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// DO NOT CHANGE THE VERSION BELOW HERE
// This is set by the build system at release time, using
//   gulp set --version <releaseversion>
//
// This is set up this way to keep the version in the code in
// sync with the npm package version, and to allow the build
// system to control version names at packaging time.
var _default = '0.0.0-dev';
exports["default"] = _default;

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9kcml2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvZXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvZ3JhcGgtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9ib2x0LXByb3RvY29sLXV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvYm9sdC1wcm90b2NvbC12MS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9ib2x0LXByb3RvY29sLXYyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL2JvbHQtcHJvdG9jb2wtdjMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvYm9sdC1wcm90b2NvbC12NHgwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL2JvbHQtcHJvdG9jb2wtdjR4MS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9ib29rbWFyay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9icm93c2VyL2Jyb3dzZXItYnVmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL2Jyb3dzZXIvYnJvd3Nlci1jaGFubmVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL2Jyb3dzZXIvYnJvd3Nlci1ob3N0LW5hbWUtcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvYnJvd3Nlci9icm93c2VyLXV0ZjguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvYnJvd3Nlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9idWYvYmFzZS1idWYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvYnVmL2NvbWJpbmVkLWJ1Zi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9jaGFubmVsLWNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9jaHVua2luZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9jb25uZWN0aW9uLWNoYW5uZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvY29ubmVjdGlvbi1kZWxlZ2F0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9jb25uZWN0aW9uLWVycm9yLWhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvY29ubmVjdGlvbi1ob2xkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvY29ubmVjdGlvbi1wcm92aWRlci1kaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvY29ubmVjdGlvbi1wcm92aWRlci1wb29sZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvY29ubmVjdGlvbi1wcm92aWRlci1yb3V0aW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL2Nvbm5lY3Rpb24tcHJvdmlkZXItc2luZ2xlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL2Nvbm5lY3Rpb24tcHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvY29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9jb25uZWN0aXZpdHktdmVyaWZpZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL2xlYXN0LWNvbm5lY3RlZC1sb2FkLWJhbGFuY2luZy1zdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9sb2FkLWJhbGFuY2luZy1zdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9sb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvcGFja3N0cmVhbS12MS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9wYWNrc3RyZWFtLXYyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL3Bvb2wtY29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL3Bvb2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvcHJvdG9jb2wtaGFuZHNoYWtlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9yZWRpc2NvdmVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9yZXF1ZXN0LW1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvcmVzb2x2ZXIvYmFzZS1ob3N0LW5hbWUtcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvcmVzb2x2ZXIvY29uZmlndXJlZC1jdXN0b20tcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvcmV0cnktbG9naWMtcnguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvcm91bmQtcm9iaW4tYXJyYXktaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvcm91dGluZy10YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9yb3V0aW5nLXV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvc2VydmVyLWFkZHJlc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvc2VydmVyLXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvc3RyZWFtLW9ic2VydmVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC90ZW1wb3JhbC11dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL3RyYW5zYWN0aW9uLWV4ZWN1dG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL3R4LWNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC91cmwtdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL3JlY29yZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9yZXN1bHQtcnguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvcmVzdWx0LXN1bW1hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvcmVzdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL3JvdXRpbmctZHJpdmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL3Nlc3Npb24tcnguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvc2Vzc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9zcGF0aWFsLXR5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL3RlbXBvcmFsLXR5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL3RyYW5zYWN0aW9uLXJ4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL3RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL3ZlcnNpb24uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLG9IQUE4Qzs7QUFFbkY7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSw4Q0FBOEMsbUJBQU8sQ0FBQyxzR0FBdUM7O0FBRTdGLDJDQUEyQyxtQkFBTyxDQUFDLGdHQUFvQzs7QUFFdkYsYUFBYSxtQkFBTyxDQUFDLHlEQUFTOztBQUU5QixpREFBaUQsbUJBQU8sQ0FBQyx1R0FBZ0M7O0FBRXpGLHVDQUF1QyxtQkFBTyxDQUFDLGlGQUFxQjs7QUFFcEUsdURBQXVELG1CQUFPLENBQUMscUhBQXVDOztBQUV0RyxtREFBbUQsbUJBQU8sQ0FBQywyR0FBa0M7O0FBRTdGLGlCQUFpQixtQkFBTyxDQUFDLG1GQUFzQjs7QUFFL0MscUNBQXFDLG1CQUFPLENBQUMsNkVBQW1COztBQUVoRSxrQkFBa0IsbUJBQU8sQ0FBQyx1RkFBd0I7O0FBRWxELHNDQUFzQyxtQkFBTyxDQUFDLDZEQUFXOztBQUV6RCx3Q0FBd0MsbUJBQU8sQ0FBQyxtRUFBYzs7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QUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxpQkFBaUIsU0FBUztBQUMxQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxpQkFBaUIsU0FBUztBQUMxQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQ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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FB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Q0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7O0FBR2pDO0FBQ0E7O0FBRUEsc0RBQXNEOzs7QUFHdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7O0FBR0EsaUVBQWlFO0FBQ2pFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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R0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FB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ZXIuY2h1bmtoYXNoLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZXhwb3J0cy5XUklURSA9IGV4cG9ydHMuUkVBRCA9IGV4cG9ydHMuRHJpdmVyID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5cbnZhciBfY29ubmVjdGlvblByb3ZpZGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC9jb25uZWN0aW9uLXByb3ZpZGVyXCIpKTtcblxudmFyIF9ib29rbWFyayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW50ZXJuYWwvYm9va21hcmtcIikpO1xuXG52YXIgX2Nvbm5lY3Rpb25Qcm92aWRlckRpcmVjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW50ZXJuYWwvY29ubmVjdGlvbi1wcm92aWRlci1kaXJlY3RcIikpO1xuXG52YXIgX2Nvbm5lY3Rpdml0eVZlcmlmaWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC9jb25uZWN0aXZpdHktdmVyaWZpZXJcIikpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2NvbnN0YW50c1wiKTtcblxudmFyIF9sb2dnZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL2xvZ2dlclwiKSk7XG5cbnZhciBfcG9vbENvbmZpZyA9IHJlcXVpcmUoXCIuL2ludGVybmFsL3Bvb2wtY29uZmlnXCIpO1xuXG52YXIgX3Nlc3Npb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Nlc3Npb25cIikpO1xuXG52YXIgX3Nlc3Npb25SeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2Vzc2lvbi1yeFwiKSk7XG5cbnZhciBfcmVxdWVzdE1lc3NhZ2UgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9yZXF1ZXN0LW1lc3NhZ2VcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL2ludGVybmFsL3V0aWxcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIERFRkFVTFRfTUFYX0NPTk5FQ1RJT05fTElGRVRJTUUgPSA2MCAqIDYwICogMTAwMDsgLy8gMSBob3VyXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgcmVjb3JkIGZldGNoIHNpemUuIFRoaXMgaXMgdXNlZCBpbiBCb2x0IFY0IHByb3RvY29sIHRvIHB1bGwgcXVlcnkgZXhlY3V0aW9uIHJlc3VsdCBpbiBiYXRjaGVzLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuXG52YXIgREVGQVVMVF9GRVRDSF9TSVpFID0gMTAwMDtcbi8qKlxuICogQ29uc3RhbnQgdGhhdCByZXByZXNlbnRzIHJlYWQgc2Vzc2lvbiBhY2Nlc3MgbW9kZS5cbiAqIFNob3VsZCBiZSB1c2VkIGxpa2UgdGhpczogYGRyaXZlci5zZXNzaW9uKHsgZGVmYXVsdEFjY2Vzc01vZGU6IG5lbzRqLnNlc3Npb24uUkVBRCB9KWAuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5cbnZhciBSRUFEID0gX2NvbnN0YW50cy5BQ0NFU1NfTU9ERV9SRUFEO1xuLyoqXG4gKiBDb25zdGFudCB0aGF0IHJlcHJlc2VudHMgd3JpdGUgc2Vzc2lvbiBhY2Nlc3MgbW9kZS5cbiAqIFNob3VsZCBiZSB1c2VkIGxpa2UgdGhpczogYGRyaXZlci5zZXNzaW9uKHsgZGVmYXVsdEFjY2Vzc01vZGU6IG5lbzRqLnNlc3Npb24uV1JJVEUgfSlgLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuXG5leHBvcnRzLlJFQUQgPSBSRUFEO1xudmFyIFdSSVRFID0gX2NvbnN0YW50cy5BQ0NFU1NfTU9ERV9XUklURTtcbmV4cG9ydHMuV1JJVEUgPSBXUklURTtcbnZhciBpZEdlbmVyYXRvciA9IDA7XG4vKipcbiAqIEEgZHJpdmVyIG1haW50YWlucyBvbmUgb3IgbW9yZSB7QGxpbmsgU2Vzc2lvbn1zIHdpdGggYSByZW1vdGVcbiAqIE5lbzRqIGluc3RhbmNlLiBUaHJvdWdoIHRoZSB7QGxpbmsgU2Vzc2lvbn1zIHlvdSBjYW4gc2VuZCBxdWVyaWVzXG4gKiBhbmQgcmV0cmlldmUgcmVzdWx0cyBmcm9tIHRoZSBkYXRhYmFzZS5cbiAqXG4gKiBEcml2ZXJzIGFyZSByZWFzb25hYmx5IGV4cGVuc2l2ZSB0byBjcmVhdGUgLSB5b3Ugc2hvdWxkIHN0cml2ZSB0byBrZWVwIG9uZVxuICogZHJpdmVyIGluc3RhbmNlIGFyb3VuZCBwZXIgTmVvNGogSW5zdGFuY2UgeW91IGNvbm5lY3QgdG8uXG4gKlxuICogQGFjY2VzcyBwdWJsaWNcbiAqL1xuXG52YXIgRHJpdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFlvdSBzaG91bGQgbm90IGJlIGNhbGxpbmcgdGhpcyBkaXJlY3RseSwgaW5zdGVhZCB1c2Uge0BsaW5rIGRyaXZlcn0uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7U2VydmVyQWRkcmVzc30gYWRkcmVzc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlckFnZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdXRoVG9rZW5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKi9cbiAgZnVuY3Rpb24gRHJpdmVyKGFkZHJlc3MsIHVzZXJBZ2VudCkge1xuICAgIHZhciBhdXRoVG9rZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBjb25maWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgRHJpdmVyKTtcbiAgICBzYW5pdGl6ZUNvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX2lkID0gaWRHZW5lcmF0b3IrKztcbiAgICB0aGlzLl9hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aGlzLl91c2VyQWdlbnQgPSB1c2VyQWdlbnQ7XG4gICAgdGhpcy5fYXV0aFRva2VuID0gYXV0aFRva2VuO1xuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLl9sb2cgPSBfbG9nZ2VyW1wiZGVmYXVsdFwiXS5jcmVhdGUoY29uZmlnKTtcbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGNvbm5lY3Rpb24gcHJvdmlkZXIuIEluaXRpYWxpemVkIGxhemlseSBieSB7QGxpbmsgX2dldE9yQ3JlYXRlQ29ubmVjdGlvblByb3ZpZGVyfS5cbiAgICAgKiBAdHlwZSB7Q29ubmVjdGlvblByb3ZpZGVyfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cblxuICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm92aWRlciA9IG51bGw7XG5cbiAgICB0aGlzLl9hZnRlckNvbnN0cnVjdGlvbigpO1xuICB9XG4gIC8qKlxuICAgKiBWZXJpZmllcyBjb25uZWN0aXZpdHkgb2YgdGhpcyBkcml2ZXIgYnkgdHJ5aW5nIHRvIG9wZW4gYSBjb25uZWN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGRyaXZlciBvcHRpb25zLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSAtIFRoZSBvYmplY3QgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbS5kYXRhYmFzZSAtIFRoZSB0YXJnZXQgZGF0YWJhc2UgdG8gdmVyaWZ5IGNvbm5lY3Rpdml0eSBmb3IuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggc2VydmVyIGluZm8gb3IgcmVqZWN0ZWQgd2l0aCBlcnJvci5cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKERyaXZlciwgW3tcbiAgICBrZXk6IFwidmVyaWZ5Q29ubmVjdGl2aXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZlcmlmeUNvbm5lY3Rpdml0eSgpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBfcmVmJGRhdGFiYXNlID0gX3JlZi5kYXRhYmFzZSxcbiAgICAgICAgICBkYXRhYmFzZSA9IF9yZWYkZGF0YWJhc2UgPT09IHZvaWQgMCA/ICcnIDogX3JlZiRkYXRhYmFzZTtcblxuICAgICAgdmFyIGNvbm5lY3Rpb25Qcm92aWRlciA9IHRoaXMuX2dldE9yQ3JlYXRlQ29ubmVjdGlvblByb3ZpZGVyKCk7XG5cbiAgICAgIHZhciBjb25uZWN0aXZpdHlWZXJpZmllciA9IG5ldyBfY29ubmVjdGl2aXR5VmVyaWZpZXJbXCJkZWZhdWx0XCJdKGNvbm5lY3Rpb25Qcm92aWRlcik7XG4gICAgICByZXR1cm4gY29ubmVjdGl2aXR5VmVyaWZpZXIudmVyaWZ5KHtcbiAgICAgICAgZGF0YWJhc2U6IGRhdGFiYXNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgbXVsdGkgZGF0YWJhc2UgY2FwYWJpbGl0aWVzIGJhc2VkIG9uIHRoZSBwcm90b2NvbFxuICAgICAqIHZlcnNpb24gbmVnb3RpYXRlZCB2aWEgaGFuZHNoYWtlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gY2FsbCBfYWx3YXlzXyBjYXVzZXMgYSByb3VuZC10cmlwIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gcHJvbWlzZSByZXNvbHZlZCB3aXRoIGEgYm9vbGVhbiBvciByZWplY3RlZCB3aXRoIGVycm9yLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3VwcG9ydHNNdWx0aURiXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1cHBvcnRzTXVsdGlEYigpIHtcbiAgICAgIHZhciBjb25uZWN0aW9uUHJvdmlkZXIgPSB0aGlzLl9nZXRPckNyZWF0ZUNvbm5lY3Rpb25Qcm92aWRlcigpO1xuXG4gICAgICByZXR1cm4gY29ubmVjdGlvblByb3ZpZGVyLnN1cHBvcnRzTXVsdGlEYigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHNlcnZlciBzdXBwb3J0cyB0cmFuc2FjdGlvbiBjb25maWcgY2FwYWJpbGl0aWVzIGJhc2VkIG9uIHRoZSBwcm90b2NvbFxuICAgICAqIHZlcnNpb24gbmVnb3RpYXRlZCB2aWEgaGFuZHNoYWtlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gY2FsbCBfYWx3YXlzXyBjYXVzZXMgYSByb3VuZC10cmlwIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gcHJvbWlzZSByZXNvbHZlZCB3aXRoIGEgYm9vbGVhbiBvciByZWplY3RlZCB3aXRoIGVycm9yLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3VwcG9ydHNUcmFuc2FjdGlvbkNvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdXBwb3J0c1RyYW5zYWN0aW9uQ29uZmlnKCkge1xuICAgICAgdmFyIGNvbm5lY3Rpb25Qcm92aWRlciA9IHRoaXMuX2dldE9yQ3JlYXRlQ29ubmVjdGlvblByb3ZpZGVyKCk7XG5cbiAgICAgIHJldHVybiBjb25uZWN0aW9uUHJvdmlkZXIuc3VwcG9ydHNUcmFuc2FjdGlvbkNvbmZpZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3VwcG9ydHNSb3V0aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdXBwb3J0c1JvdXRpbmcoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYm9vbGVhbiB0byBpbmRpY2F0ZSBpZiBkcml2ZXIgaGFzIGJlZW4gY29uZmlndXJlZCB3aXRoIGVuY3J5cHRpb24gZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pc0VuY3J5cHRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNFbmNyeXB0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uZmlnLmVuY3J5cHRlZCA9PT0gX3V0aWwuRU5DUllQVElPTl9PTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uZmlndXJlZCB0cnVzdCBzdHJhdGVneSB0aGF0IHRoZSBkcml2ZXIgaGFzIGJlZW4gY29uZmlndXJlZCB3aXRoLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtUcnVzdFN0cmF0ZWd5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFRydXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUcnVzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25maWcudHJ1c3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjcXVpcmUgYSBzZXNzaW9uIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIGRhdGFiYXNlLiBUaGUgc2Vzc2lvbiB3aWxsXG4gICAgICogYm9ycm93IGNvbm5lY3Rpb25zIGZyb20gdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbiBwb29sIGFzIHJlcXVpcmVkIGFuZFxuICAgICAqIHNob3VsZCBiZSBjb25zaWRlcmVkIGxpZ2h0d2VpZ2h0IGFuZCBkaXNwb3NhYmxlLlxuICAgICAqXG4gICAgICogVGhpcyBjb21lcyB3aXRoIHNvbWUgcmVzcG9uc2liaWxpdHkgLSBtYWtlIHN1cmUgeW91IGFsd2F5cyBjYWxsXG4gICAgICoge0BsaW5rIGNsb3NlfSB3aGVuIHlvdSBhcmUgZG9uZSB1c2luZyBhIHNlc3Npb24sIGFuZCBsaWtld2lzZSxcbiAgICAgKiBtYWtlIHN1cmUgeW91IGRvbid0IGNsb3NlIHlvdXIgc2Vzc2lvbiBiZWZvcmUgeW91IGFyZSBkb25lIHVzaW5nIGl0LiBPbmNlXG4gICAgICogaXQgaXMgY2xvc2VkLCB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uIHdpbGwgYmUgcmVsZWFzZWQgdG8gdGhlIGNvbm5lY3Rpb25cbiAgICAgKiBwb29sIGFuZCBtYWRlIGF2YWlsYWJsZSBmb3Igb3RoZXJzIHRvIHVzZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gLSBUaGUgb2JqZWN0IHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbS5kZWZhdWx0QWNjZXNzTW9kZT1XUklURSAtIFRoZSBhY2Nlc3MgbW9kZSBvZiB0aGlzIHNlc3Npb24sIGFsbG93ZWQgdmFsdWVzIGFyZSB7QGxpbmsgUkVBRH0gYW5kIHtAbGluayBXUklURX0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhcmFtLmJvb2ttYXJrcyAtIFRoZSBpbml0aWFsIHJlZmVyZW5jZSBvciByZWZlcmVuY2VzIHRvIHNvbWUgcHJldmlvdXNcbiAgICAgKiB0cmFuc2FjdGlvbnMuIFZhbHVlIGlzIG9wdGlvbmFsIGFuZCBhYnNlbmNlIGluZGljYXRlcyB0aGF0IHRoYXQgdGhlIGJvb2ttYXJrcyBkbyBub3QgZXhpc3Qgb3IgYXJlIHVua25vd24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtLmZldGNoU2l6ZSAtIFRoZSByZWNvcmQgZmV0Y2ggc2l6ZSBvZiBlYWNoIGJhdGNoIG9mIHRoaXMgc2Vzc2lvbi5cbiAgICAgKiBVc2Uge0BsaW5rIEFMTH0gdG8gYWx3YXlzIHB1bGwgYWxsIHJlY29yZHMgaW4gb25lIGJhdGNoLiBUaGlzIHdpbGwgb3ZlcnJpZGUgdGhlIGNvbmZpZyB2YWx1ZSBzZXQgb24gZHJpdmVyIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0uZGF0YWJhc2UgLSBUaGUgZGF0YWJhc2UgdGhpcyBzZXNzaW9uIHdpbGwgb3BlcmF0ZSBvbi5cbiAgICAgKiBAcmV0dXJuIHtTZXNzaW9ufSBuZXcgc2Vzc2lvbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlc3Npb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Vzc2lvbigpIHtcbiAgICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgX3JlZjIkZGVmYXVsdEFjY2Vzc01vID0gX3JlZjIuZGVmYXVsdEFjY2Vzc01vZGUsXG4gICAgICAgICAgZGVmYXVsdEFjY2Vzc01vZGUgPSBfcmVmMiRkZWZhdWx0QWNjZXNzTW8gPT09IHZvaWQgMCA/IFdSSVRFIDogX3JlZjIkZGVmYXVsdEFjY2Vzc01vLFxuICAgICAgICAgIGJvb2ttYXJrT3JCb29rbWFya3MgPSBfcmVmMi5ib29rbWFya3MsXG4gICAgICAgICAgX3JlZjIkZGF0YWJhc2UgPSBfcmVmMi5kYXRhYmFzZSxcbiAgICAgICAgICBkYXRhYmFzZSA9IF9yZWYyJGRhdGFiYXNlID09PSB2b2lkIDAgPyAnJyA6IF9yZWYyJGRhdGFiYXNlLFxuICAgICAgICAgIGZldGNoU2l6ZSA9IF9yZWYyLmZldGNoU2l6ZTtcblxuICAgICAgcmV0dXJuIHRoaXMuX25ld1Nlc3Npb24oe1xuICAgICAgICBkZWZhdWx0QWNjZXNzTW9kZTogZGVmYXVsdEFjY2Vzc01vZGUsXG4gICAgICAgIGJvb2ttYXJrT3JCb29rbWFya3M6IGJvb2ttYXJrT3JCb29rbWFya3MsXG4gICAgICAgIGRhdGFiYXNlOiBkYXRhYmFzZSxcbiAgICAgICAgcmVhY3RpdmU6IGZhbHNlLFxuICAgICAgICBmZXRjaFNpemU6IHZhbGlkYXRlRmV0Y2hTaXplVmFsdWUoZmV0Y2hTaXplLCB0aGlzLl9jb25maWcuZmV0Y2hTaXplKVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjcXVpcmUgYSByZWFjdGl2ZSBzZXNzaW9uIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIGRhdGFiYXNlLiBUaGUgc2Vzc2lvbiB3aWxsXG4gICAgICogYm9ycm93IGNvbm5lY3Rpb25zIGZyb20gdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbiBwb29sIGFzIHJlcXVpcmVkIGFuZFxuICAgICAqIHNob3VsZCBiZSBjb25zaWRlcmVkIGxpZ2h0d2VpZ2h0IGFuZCBkaXNwb3NhYmxlLlxuICAgICAqXG4gICAgICogVGhpcyBjb21lcyB3aXRoIHNvbWUgcmVzcG9uc2liaWxpdHkgLSBtYWtlIHN1cmUgeW91IGFsd2F5cyBjYWxsXG4gICAgICoge0BsaW5rIGNsb3NlfSB3aGVuIHlvdSBhcmUgZG9uZSB1c2luZyBhIHNlc3Npb24sIGFuZCBsaWtld2lzZSxcbiAgICAgKiBtYWtlIHN1cmUgeW91IGRvbid0IGNsb3NlIHlvdXIgc2Vzc2lvbiBiZWZvcmUgeW91IGFyZSBkb25lIHVzaW5nIGl0LiBPbmNlXG4gICAgICogaXQgaXMgY2xvc2VkLCB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uIHdpbGwgYmUgcmVsZWFzZWQgdG8gdGhlIGNvbm5lY3Rpb25cbiAgICAgKiBwb29sIGFuZCBtYWRlIGF2YWlsYWJsZSBmb3Igb3RoZXJzIHRvIHVzZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0uZGVmYXVsdEFjY2Vzc01vZGU9V1JJVEUgLSBUaGUgYWNjZXNzIG1vZGUgb2YgdGhpcyBzZXNzaW9uLCBhbGxvd2VkIHZhbHVlcyBhcmUge0BsaW5rIFJFQUR9IGFuZCB7QGxpbmsgV1JJVEV9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXJhbS5ib29rbWFya3MgLSBUaGUgaW5pdGlhbCByZWZlcmVuY2Ugb3IgcmVmZXJlbmNlcyB0byBzb21lIHByZXZpb3VzIHRyYW5zYWN0aW9ucy4gVmFsdWUgaXMgb3B0aW9uYWwgYW5kXG4gICAgICogYWJzZW5jZSBpbmRpY2F0ZXMgdGhhdCB0aGUgYm9va21hcmtzIGRvIG5vdCBleGlzdCBvciBhcmUgdW5rbm93bi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0uZGF0YWJhc2UgLSBUaGUgZGF0YWJhc2UgdGhpcyBzZXNzaW9uIHdpbGwgb3BlcmF0ZSBvbi5cbiAgICAgKiBAcmV0dXJucyB7UnhTZXNzaW9ufSBuZXcgcmVhY3RpdmUgc2Vzc2lvbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJ4U2Vzc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByeFNlc3Npb24oKSB7XG4gICAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIF9yZWYzJGRlZmF1bHRBY2Nlc3NNbyA9IF9yZWYzLmRlZmF1bHRBY2Nlc3NNb2RlLFxuICAgICAgICAgIGRlZmF1bHRBY2Nlc3NNb2RlID0gX3JlZjMkZGVmYXVsdEFjY2Vzc01vID09PSB2b2lkIDAgPyBXUklURSA6IF9yZWYzJGRlZmF1bHRBY2Nlc3NNbyxcbiAgICAgICAgICBib29rbWFya3MgPSBfcmVmMy5ib29rbWFya3MsXG4gICAgICAgICAgX3JlZjMkZGF0YWJhc2UgPSBfcmVmMy5kYXRhYmFzZSxcbiAgICAgICAgICBkYXRhYmFzZSA9IF9yZWYzJGRhdGFiYXNlID09PSB2b2lkIDAgPyAnJyA6IF9yZWYzJGRhdGFiYXNlLFxuICAgICAgICAgIGZldGNoU2l6ZSA9IF9yZWYzLmZldGNoU2l6ZTtcblxuICAgICAgcmV0dXJuIG5ldyBfc2Vzc2lvblJ4W1wiZGVmYXVsdFwiXSh7XG4gICAgICAgIHNlc3Npb246IHRoaXMuX25ld1Nlc3Npb24oe1xuICAgICAgICAgIGRlZmF1bHRBY2Nlc3NNb2RlOiBkZWZhdWx0QWNjZXNzTW9kZSxcbiAgICAgICAgICBib29rbWFya3M6IGJvb2ttYXJrcyxcbiAgICAgICAgICBkYXRhYmFzZTogZGF0YWJhc2UsXG4gICAgICAgICAgcmVhY3RpdmU6IHRydWUsXG4gICAgICAgICAgZmV0Y2hTaXplOiB2YWxpZGF0ZUZldGNoU2l6ZVZhbHVlKGZldGNoU2l6ZSwgdGhpcy5fY29uZmlnLmZldGNoU2l6ZSlcbiAgICAgICAgfSksXG4gICAgICAgIGNvbmZpZzogdGhpcy5fY29uZmlnXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgYWxsIG9wZW4gc2Vzc2lvbnMgYW5kIG90aGVyIGFzc29jaWF0ZWQgcmVzb3VyY2VzLiBZb3Ugc2hvdWxkXG4gICAgICogbWFrZSBzdXJlIHRvIHVzZSB0aGlzIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBkcml2ZXIgaW5zdGFuY2UuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IHByb21pc2UgcmVzb2x2ZWQgd2hlbiB0aGUgZHJpdmVyIGlzIGNsb3NlZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgdGhpcy5fbG9nLmluZm8oXCJEcml2ZXIgXCIuY29uY2F0KHRoaXMuX2lkLCBcIiBjbG9zaW5nXCIpKTtcblxuICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25Qcm92aWRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblByb3ZpZGVyLmNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FmdGVyQ29uc3RydWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZnRlckNvbnN0cnVjdGlvbigpIHtcbiAgICAgIHRoaXMuX2xvZy5pbmZvKFwiRGlyZWN0IGRyaXZlciBcIi5jb25jYXQodGhpcy5faWQsIFwiIGNyZWF0ZWQgZm9yIHNlcnZlciBhZGRyZXNzIFwiKS5jb25jYXQodGhpcy5fYWRkcmVzcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQ29ubmVjdGlvblByb3ZpZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVDb25uZWN0aW9uUHJvdmlkZXIoYWRkcmVzcywgdXNlckFnZW50LCBhdXRoVG9rZW4pIHtcbiAgICAgIHJldHVybiBuZXcgX2Nvbm5lY3Rpb25Qcm92aWRlckRpcmVjdFtcImRlZmF1bHRcIl0oe1xuICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgIGNvbmZpZzogdGhpcy5fY29uZmlnLFxuICAgICAgICBsb2c6IHRoaXMuX2xvZyxcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgdXNlckFnZW50OiB1c2VyQWdlbnQsXG4gICAgICAgIGF1dGhUb2tlbjogYXV0aFRva2VuXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX25ld1Nlc3Npb25cIixcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXdTZXNzaW9uKF9yZWY0KSB7XG4gICAgICB2YXIgZGVmYXVsdEFjY2Vzc01vZGUgPSBfcmVmNC5kZWZhdWx0QWNjZXNzTW9kZSxcbiAgICAgICAgICBib29rbWFya09yQm9va21hcmtzID0gX3JlZjQuYm9va21hcmtPckJvb2ttYXJrcyxcbiAgICAgICAgICBkYXRhYmFzZSA9IF9yZWY0LmRhdGFiYXNlLFxuICAgICAgICAgIHJlYWN0aXZlID0gX3JlZjQucmVhY3RpdmUsXG4gICAgICAgICAgZmV0Y2hTaXplID0gX3JlZjQuZmV0Y2hTaXplO1xuXG4gICAgICB2YXIgc2Vzc2lvbk1vZGUgPSBEcml2ZXIuX3ZhbGlkYXRlU2Vzc2lvbk1vZGUoZGVmYXVsdEFjY2Vzc01vZGUpO1xuXG4gICAgICB2YXIgY29ubmVjdGlvblByb3ZpZGVyID0gdGhpcy5fZ2V0T3JDcmVhdGVDb25uZWN0aW9uUHJvdmlkZXIoKTtcblxuICAgICAgdmFyIGJvb2ttYXJrID0gYm9va21hcmtPckJvb2ttYXJrcyA/IG5ldyBfYm9va21hcmtbXCJkZWZhdWx0XCJdKGJvb2ttYXJrT3JCb29rbWFya3MpIDogX2Jvb2ttYXJrW1wiZGVmYXVsdFwiXS5lbXB0eSgpO1xuICAgICAgcmV0dXJuIG5ldyBfc2Vzc2lvbltcImRlZmF1bHRcIl0oe1xuICAgICAgICBtb2RlOiBzZXNzaW9uTW9kZSxcbiAgICAgICAgZGF0YWJhc2U6IGRhdGFiYXNlLFxuICAgICAgICBjb25uZWN0aW9uUHJvdmlkZXI6IGNvbm5lY3Rpb25Qcm92aWRlcixcbiAgICAgICAgYm9va21hcms6IGJvb2ttYXJrLFxuICAgICAgICBjb25maWc6IHRoaXMuX2NvbmZpZyxcbiAgICAgICAgcmVhY3RpdmU6IHJlYWN0aXZlLFxuICAgICAgICBmZXRjaFNpemU6IGZldGNoU2l6ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0T3JDcmVhdGVDb25uZWN0aW9uUHJvdmlkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE9yQ3JlYXRlQ29ubmVjdGlvblByb3ZpZGVyKCkge1xuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0aW9uUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblByb3ZpZGVyID0gdGhpcy5fY3JlYXRlQ29ubmVjdGlvblByb3ZpZGVyKHRoaXMuX2FkZHJlc3MsIHRoaXMuX3VzZXJBZ2VudCwgdGhpcy5fYXV0aFRva2VuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25Qcm92aWRlcjtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJfdmFsaWRhdGVTZXNzaW9uTW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdmFsaWRhdGVTZXNzaW9uTW9kZShyYXdNb2RlKSB7XG4gICAgICB2YXIgbW9kZSA9IHJhd01vZGUgfHwgV1JJVEU7XG5cbiAgICAgIGlmIChtb2RlICE9PSBfY29uc3RhbnRzLkFDQ0VTU19NT0RFX1JFQUQgJiYgbW9kZSAhPT0gX2NvbnN0YW50cy5BQ0NFU1NfTU9ERV9XUklURSkge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnSWxsZWdhbCBzZXNzaW9uIG1vZGUgJyArIG1vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW9kZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERyaXZlcjtcbn0oKTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5cbmV4cG9ydHMuRHJpdmVyID0gRHJpdmVyO1xuXG5mdW5jdGlvbiBzYW5pdGl6ZUNvbmZpZyhjb25maWcpIHtcbiAgY29uZmlnLm1heENvbm5lY3Rpb25MaWZldGltZSA9IHNhbml0aXplSW50VmFsdWUoY29uZmlnLm1heENvbm5lY3Rpb25MaWZldGltZSwgREVGQVVMVF9NQVhfQ09OTkVDVElPTl9MSUZFVElNRSk7XG4gIGNvbmZpZy5tYXhDb25uZWN0aW9uUG9vbFNpemUgPSBzYW5pdGl6ZUludFZhbHVlKGNvbmZpZy5tYXhDb25uZWN0aW9uUG9vbFNpemUsIF9wb29sQ29uZmlnLkRFRkFVTFRfTUFYX1NJWkUpO1xuICBjb25maWcuY29ubmVjdGlvbkFjcXVpc2l0aW9uVGltZW91dCA9IHNhbml0aXplSW50VmFsdWUoY29uZmlnLmNvbm5lY3Rpb25BY3F1aXNpdGlvblRpbWVvdXQsIF9wb29sQ29uZmlnLkRFRkFVTFRfQUNRVUlTSVRJT05fVElNRU9VVCk7XG4gIGNvbmZpZy5mZXRjaFNpemUgPSB2YWxpZGF0ZUZldGNoU2l6ZVZhbHVlKGNvbmZpZy5mZXRjaFNpemUsIERFRkFVTFRfRkVUQ0hfU0laRSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzYW5pdGl6ZUludFZhbHVlKHJhd1ZhbHVlLCBkZWZhdWx0V2hlbkFic2VudCkge1xuICB2YXIgc2FuaXRpemVkVmFsdWUgPSBwYXJzZUludChyYXdWYWx1ZSwgMTApO1xuXG4gIGlmIChzYW5pdGl6ZWRWYWx1ZSA+IDAgfHwgc2FuaXRpemVkVmFsdWUgPT09IDApIHtcbiAgICByZXR1cm4gc2FuaXRpemVkVmFsdWU7XG4gIH0gZWxzZSBpZiAoc2FuaXRpemVkVmFsdWUgPCAwKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZWZhdWx0V2hlbkFic2VudDtcbiAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGZXRjaFNpemVWYWx1ZShyYXdWYWx1ZSwgZGVmYXVsdFdoZW5BYnNlbnQpIHtcbiAgdmFyIGZldGNoU2l6ZSA9IHBhcnNlSW50KHJhd1ZhbHVlLCAxMCk7XG5cbiAgaWYgKGZldGNoU2l6ZSA+IDAgfHwgZmV0Y2hTaXplID09PSBfcmVxdWVzdE1lc3NhZ2UuQUxMKSB7XG4gICAgcmV0dXJuIGZldGNoU2l6ZTtcbiAgfSBlbHNlIGlmIChmZXRjaFNpemUgPT09IDAgfHwgZmV0Y2hTaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZldGNoIHNpemUgY2FuIG9ubHkgYmUgYSBwb3NpdGl2ZSB2YWx1ZSBvciAtMSBmb3IgQUxMLiBIb3dldmVyIGZldGNoU2l6ZSA9ICcgKyBmZXRjaFNpemUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZWZhdWx0V2hlbkFic2VudDtcbiAgfVxufVxuXG52YXIgX2RlZmF1bHQgPSBEcml2ZXI7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubmV3RXJyb3IgPSBuZXdFcnJvcjtcbmV4cG9ydHMuUFJPVE9DT0xfRVJST1IgPSBleHBvcnRzLlNFU1NJT05fRVhQSVJFRCA9IGV4cG9ydHMuU0VSVklDRV9VTkFWQUlMQUJMRSA9IGV4cG9ydHMuTmVvNGpFcnJvciA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfd3JhcE5hdGl2ZVN1cGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvd3JhcE5hdGl2ZVN1cGVyXCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBBIGNvbW1vbiBwbGFjZSBmb3IgY29uc3RydWN0aW5nIGVycm9yIG9iamVjdHMsIHRvIGtlZXAgdGhlbVxuLy8gdW5pZm9ybSBhY3Jvc3MgdGhlIGRyaXZlciBzdXJmYWNlLlxuXG4vKipcbiAqIEVycm9yIGNvZGUgcmVwcmVzZW50aW5nIGNvbXBsZXRlIGxvc3Mgb2Ygc2VydmljZS4gVXNlZCBieSB7QGxpbmsgTmVvNGpFcnJvciNjb2RlfS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciBTRVJWSUNFX1VOQVZBSUxBQkxFID0gJ1NlcnZpY2VVbmF2YWlsYWJsZSc7XG4vKipcbiAqIEVycm9yIGNvZGUgcmVwcmVzZW50aW5nIHRyYW5zaWVudCBsb3NzIG9mIHNlcnZpY2UuIFVzZWQgYnkge0BsaW5rIE5lbzRqRXJyb3IjY29kZX0uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5cbmV4cG9ydHMuU0VSVklDRV9VTkFWQUlMQUJMRSA9IFNFUlZJQ0VfVU5BVkFJTEFCTEU7XG52YXIgU0VTU0lPTl9FWFBJUkVEID0gJ1Nlc3Npb25FeHBpcmVkJztcbi8qKlxuICogRXJyb3IgY29kZSByZXByZXNlbnRpbmcgc2VyaWFsaXphdGlvbi9kZXNlcmlhbGl6YXRpb24gaXNzdWUgaW4gdGhlIEJvbHQgcHJvdG9jb2wuIFVzZWQgYnkge0BsaW5rIE5lbzRqRXJyb3IjY29kZX0uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5cbmV4cG9ydHMuU0VTU0lPTl9FWFBJUkVEID0gU0VTU0lPTl9FWFBJUkVEO1xudmFyIFBST1RPQ09MX0VSUk9SID0gJ1Byb3RvY29sRXJyb3InO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZXJyb3IgZnJvbSBhIG1lc3NhZ2UgYW5kIGVycm9yIGNvZGVcbiAqIEBwYXJhbSBtZXNzYWdlIHRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0gY29kZSB0aGUgZXJyb3IgY29kZVxuICogQHJldHVybiB7TmVvNGpFcnJvcn0gYW4ge0BsaW5rIE5lbzRqRXJyb3J9XG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuUFJPVE9DT0xfRVJST1IgPSBQUk9UT0NPTF9FUlJPUjtcblxuZnVuY3Rpb24gbmV3RXJyb3IobWVzc2FnZSkge1xuICB2YXIgY29kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ04vQSc7XG4gIC8vIFRPRE86IElkZWEgaXMgdGhhdCB3ZSBjYW4gY2hlY2sgdGhlIGNvZGUgaGVyZSBhbmQgdGhyb3cgc3ViLWNsYXNzZXNcbiAgLy8gb2YgTmVvNGpFcnJvciBhcyBhcHByb3ByaWF0ZVxuICByZXR1cm4gbmV3IE5lbzRqRXJyb3IobWVzc2FnZSwgY29kZSk7XG59XG4vKipcbiAqIENsYXNzIGZvciBhbGwgZXJyb3JzIHRocm93bi9yZXR1cm5lZCBieSB0aGUgZHJpdmVyLlxuICovXG5cblxudmFyIE5lbzRqRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKE5lbzRqRXJyb3IsIF9FcnJvcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihOZW80akVycm9yKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIC0gT3B0aW9uYWwgZXJyb3IgY29kZS4gV2lsbCBiZSBwb3B1bGF0ZWQgd2hlbiBlcnJvciBvcmlnaW5hdGVzIGluIHRoZSBkYXRhYmFzZS5cbiAgICovXG4gIGZ1bmN0aW9uIE5lbzRqRXJyb3IobWVzc2FnZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBjb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnTi9BJztcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIE5lbzRqRXJyb3IpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgLyoqXG4gICAgICogVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gICAgX3RoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgZXJyb3IgY29kZS4gV2lsbCBiZSBwb3B1bGF0ZWQgd2hlbiBlcnJvciBvcmlnaW5hdGVzIGluIHRoZSBkYXRhYmFzZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGVycm9yLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgICBfdGhpcy5uYW1lID0gJ05lbzRqRXJyb3InO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBOZW80akVycm9yO1xufSggLyojX19QVVJFX18qLygwLCBfd3JhcE5hdGl2ZVN1cGVyMltcImRlZmF1bHRcIl0pKEVycm9yKSk7XG5cbmV4cG9ydHMuTmVvNGpFcnJvciA9IE5lbzRqRXJyb3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc05vZGUgPSBpc05vZGU7XG5leHBvcnRzLmlzUmVsYXRpb25zaGlwID0gaXNSZWxhdGlvbnNoaXA7XG5leHBvcnRzLmlzVW5ib3VuZFJlbGF0aW9uc2hpcCA9IGlzVW5ib3VuZFJlbGF0aW9uc2hpcDtcbmV4cG9ydHMuaXNQYXRoID0gaXNQYXRoO1xuZXhwb3J0cy5pc1BhdGhTZWdtZW50ID0gaXNQYXRoU2VnbWVudDtcbmV4cG9ydHMuUGF0aFNlZ21lbnQgPSBleHBvcnRzLlBhdGggPSBleHBvcnRzLlVuYm91bmRSZWxhdGlvbnNoaXAgPSBleHBvcnRzLlJlbGF0aW9uc2hpcCA9IGV4cG9ydHMuTm9kZSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgSURFTlRJRklFUl9QUk9QRVJUWV9BVFRSSUJVVEVTID0ge1xuICB2YWx1ZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZVxufTtcbnZhciBOT0RFX0lERU5USUZJRVJfUFJPUEVSVFkgPSAnX19pc05vZGVfXyc7XG52YXIgUkVMQVRJT05TSElQX0lERU5USUZJRVJfUFJPUEVSVFkgPSAnX19pc1JlbGF0aW9uc2hpcF9fJztcbnZhciBVTkJPVU5EX1JFTEFUSU9OU0hJUF9JREVOVElGSUVSX1BST1BFUlRZID0gJ19faXNVbmJvdW5kUmVsYXRpb25zaGlwX18nO1xudmFyIFBBVEhfSURFTlRJRklFUl9QUk9QRVJUWSA9ICdfX2lzUGF0aF9fJztcbnZhciBQQVRIX1NFR01FTlRfSURFTlRJRklFUl9QUk9QRVJUWSA9ICdfX2lzUGF0aFNlZ21lbnRfXyc7XG5cbmZ1bmN0aW9uIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIHByb3BlcnR5KSB7XG4gIHJldHVybiAob2JqICYmIG9ialtwcm9wZXJ0eV0pID09PSB0cnVlO1xufVxuLyoqXG4gKiBDbGFzcyBmb3IgTm9kZSBUeXBlLlxuICovXG5cblxudmFyIE5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBpZGVudGl0eSAtIFVuaXF1ZSBpZGVudGl0eVxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGxhYmVscyAtIEFycmF5IGZvciBhbGwgbGFiZWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gTWFwIHdpdGggbm9kZSBwcm9wZXJ0aWVzXG4gICAqL1xuICBmdW5jdGlvbiBOb2RlKGlkZW50aXR5LCBsYWJlbHMsIHByb3BlcnRpZXMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIE5vZGUpO1xuXG4gICAgLyoqXG4gICAgICogSWRlbnRpdHkgb2YgdGhlIG5vZGUuXG4gICAgICogQHR5cGUge0ludGVnZXJ9XG4gICAgICovXG4gICAgdGhpcy5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIC8qKlxuICAgICAqIExhYmVscyBvZiB0aGUgbm9kZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICovXG5cbiAgICB0aGlzLmxhYmVscyA9IGxhYmVscztcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIHRoZSBub2RlLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICB9XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShOb2RlLCBbe1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBzID0gJygnICsgdGhpcy5pZGVudGl0eTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzICs9ICc6JyArIHRoaXMubGFiZWxzW2ldO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMucHJvcGVydGllcyk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcyArPSAnIHsnO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBrZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGlmIChfaSA+IDApIHMgKz0gJywnO1xuICAgICAgICAgIHMgKz0ga2V5c1tfaV0gKyAnOicgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnByb3BlcnRpZXNba2V5c1tfaV1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMgKz0gJ30nO1xuICAgICAgfVxuXG4gICAgICBzICs9ICcpJztcbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTm9kZTtcbn0oKTtcblxuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSwgTk9ERV9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgTm9kZX0gY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBvYmplY3QgaXMgYSB7QGxpbmsgTm9kZX0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzTm9kZShvYmopIHtcbiAgcmV0dXJuIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIE5PREVfSURFTlRJRklFUl9QUk9QRVJUWSk7XG59XG4vKipcbiAqIENsYXNzIGZvciBSZWxhdGlvbnNoaXAgVHlwZS5cbiAqL1xuXG5cbnZhciBSZWxhdGlvbnNoaXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBpZGVudGl0eSAtIFVuaXF1ZSBpZGVudGl0eVxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IHN0YXJ0IC0gSWRlbnRpdHkgb2Ygc3RhcnQgTm9kZVxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IGVuZCAtIElkZW50aXR5IG9mIGVuZCBOb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gUmVsYXRpb25zaGlwIHR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBNYXAgd2l0aCByZWxhdGlvbnNoaXAgcHJvcGVydGllc1xuICAgKi9cbiAgZnVuY3Rpb24gUmVsYXRpb25zaGlwKGlkZW50aXR5LCBzdGFydCwgZW5kLCB0eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBSZWxhdGlvbnNoaXApO1xuXG4gICAgLyoqXG4gICAgICogSWRlbnRpdHkgb2YgdGhlIHJlbGF0aW9uc2hpcC5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgLyoqXG4gICAgICogSWRlbnRpdHkgb2YgdGhlIHN0YXJ0IG5vZGUuXG4gICAgICogQHR5cGUge0ludGVnZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgLyoqXG4gICAgICogSWRlbnRpdHkgb2YgdGhlIGVuZCBub2RlLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfVxuICAgICAqL1xuXG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgLyoqXG4gICAgICogVHlwZSBvZiB0aGUgcmVsYXRpb25zaGlwLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgdGhlIHJlbGF0aW9uc2hpcC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgfVxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUmVsYXRpb25zaGlwLCBbe1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBzID0gJygnICsgdGhpcy5zdGFydCArICcpLVs6JyArIHRoaXMudHlwZTtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5wcm9wZXJ0aWVzKTtcblxuICAgICAgaWYgKGtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzICs9ICcgeyc7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSBzICs9ICcsJztcbiAgICAgICAgICBzICs9IGtleXNbaV0gKyAnOicgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnByb3BlcnRpZXNba2V5c1tpXV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcyArPSAnfSc7XG4gICAgICB9XG5cbiAgICAgIHMgKz0gJ10tPignICsgdGhpcy5lbmQgKyAnKSc7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlbGF0aW9uc2hpcDtcbn0oKTtcblxuZXhwb3J0cy5SZWxhdGlvbnNoaXAgPSBSZWxhdGlvbnNoaXA7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVsYXRpb25zaGlwLnByb3RvdHlwZSwgUkVMQVRJT05TSElQX0lERU5USUZJRVJfUFJPUEVSVFksIElERU5USUZJRVJfUFJPUEVSVFlfQVRUUklCVVRFUyk7XG4vKipcbiAqIFRlc3QgaWYgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIHtAbGluayBSZWxhdGlvbnNoaXB9IGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgZ2l2ZW4gb2JqZWN0IGlzIGEge0BsaW5rIFJlbGF0aW9uc2hpcH0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzUmVsYXRpb25zaGlwKG9iaikge1xuICByZXR1cm4gaGFzSWRlbnRpZmllclByb3BlcnR5KG9iaiwgUkVMQVRJT05TSElQX0lERU5USUZJRVJfUFJPUEVSVFkpO1xufVxuLyoqXG4gKiBDbGFzcyBmb3IgVW5ib3VuZFJlbGF0aW9uc2hpcCBUeXBlLlxuICogQGFjY2VzcyBwcml2YXRlXG4gKi9cblxuXG52YXIgVW5ib3VuZFJlbGF0aW9uc2hpcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IGlkZW50aXR5IC0gVW5pcXVlIGlkZW50aXR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gUmVsYXRpb25zaGlwIHR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBNYXAgd2l0aCByZWxhdGlvbnNoaXAgcHJvcGVydGllc1xuICAgKi9cbiAgZnVuY3Rpb24gVW5ib3VuZFJlbGF0aW9uc2hpcChpZGVudGl0eSwgdHlwZSwgcHJvcGVydGllcykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgVW5ib3VuZFJlbGF0aW9uc2hpcCk7XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGl0eSBvZiB0aGUgcmVsYXRpb25zaGlwLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfVxuICAgICAqL1xuICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIHRoZSByZWxhdGlvbnNoaXAuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiB0aGUgcmVsYXRpb25zaGlwLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kIHJlbGF0aW9uc2hpcFxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gc3RhcnQgLSBJZGVudGl0eSBvZiBzdGFydCBub2RlXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gZW5kIC0gSWRlbnRpdHkgb2YgZW5kIG5vZGVcbiAgICogQHJldHVybiB7UmVsYXRpb25zaGlwfSAtIENyZWF0ZWQgcmVsYXRpb25zaGlwXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShVbmJvdW5kUmVsYXRpb25zaGlwLCBbe1xuICAgIGtleTogXCJiaW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmQoc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIG5ldyBSZWxhdGlvbnNoaXAodGhpcy5pZGVudGl0eSwgc3RhcnQsIGVuZCwgdGhpcy50eXBlLCB0aGlzLnByb3BlcnRpZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBzID0gJy1bOicgKyB0aGlzLnR5cGU7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMucHJvcGVydGllcyk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcyArPSAnIHsnO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChpID4gMCkgcyArPSAnLCc7XG4gICAgICAgICAgcyArPSBrZXlzW2ldICsgJzonICsgSlNPTi5zdHJpbmdpZnkodGhpcy5wcm9wZXJ0aWVzW2tleXNbaV1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMgKz0gJ30nO1xuICAgICAgfVxuXG4gICAgICBzICs9ICddLT4nO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBVbmJvdW5kUmVsYXRpb25zaGlwO1xufSgpO1xuXG5leHBvcnRzLlVuYm91bmRSZWxhdGlvbnNoaXAgPSBVbmJvdW5kUmVsYXRpb25zaGlwO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVuYm91bmRSZWxhdGlvbnNoaXAucHJvdG90eXBlLCBVTkJPVU5EX1JFTEFUSU9OU0hJUF9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgVW5ib3VuZFJlbGF0aW9uc2hpcH0gY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBvYmplY3QgaXMgYSB7QGxpbmsgVW5ib3VuZFJlbGF0aW9uc2hpcH0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzVW5ib3VuZFJlbGF0aW9uc2hpcChvYmopIHtcbiAgcmV0dXJuIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIFVOQk9VTlRfUkVMQVRJT05TSElQX0lERU5USUZJRVJfUFJPUEVSVFkpO1xufVxuLyoqXG4gKiBDbGFzcyBmb3IgUGF0aFNlZ21lbnQgVHlwZS5cbiAqL1xuXG5cbnZhciBQYXRoU2VnbWVudCA9XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtOb2RlfSBzdGFydCAtIHN0YXJ0IG5vZGVcbiAqIEBwYXJhbSB7UmVsYXRpb25zaGlwfSByZWwgLSByZWxhdGlvbnNoaXAgdGhhdCBjb25uZWN0cyBzdGFydCBhbmQgZW5kIG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gZW5kIC0gZW5kIG5vZGVcbiAqL1xuZnVuY3Rpb24gUGF0aFNlZ21lbnQoc3RhcnQsIHJlbCwgZW5kKSB7XG4gICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUGF0aFNlZ21lbnQpO1xuXG4gIC8qKlxuICAgKiBTdGFydCBub2RlLlxuICAgKiBAdHlwZSB7Tm9kZX1cbiAgICovXG4gIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgLyoqXG4gICAqIFJlbGF0aW9uc2hpcC5cbiAgICogQHR5cGUge1JlbGF0aW9uc2hpcH1cbiAgICovXG5cbiAgdGhpcy5yZWxhdGlvbnNoaXAgPSByZWw7XG4gIC8qKlxuICAgKiBFbmQgbm9kZS5cbiAgICogQHR5cGUge05vZGV9XG4gICAqL1xuXG4gIHRoaXMuZW5kID0gZW5kO1xufTtcblxuZXhwb3J0cy5QYXRoU2VnbWVudCA9IFBhdGhTZWdtZW50O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhdGhTZWdtZW50LnByb3RvdHlwZSwgUEFUSF9TRUdNRU5UX0lERU5USUZJRVJfUFJPUEVSVFksIElERU5USUZJRVJfUFJPUEVSVFlfQVRUUklCVVRFUyk7XG4vKipcbiAqIFRlc3QgaWYgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIHtAbGluayBQYXRoU2VnbWVudH0gY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBvYmplY3QgaXMgYSB7QGxpbmsgUGF0aFNlZ21lbnR9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc1BhdGhTZWdtZW50KG9iaikge1xuICByZXR1cm4gaGFzSWRlbnRpZmllclByb3BlcnR5KG9iaiwgUEFUSF9TRUdNRU5UX0lERU5USUZJRVJfUFJPUEVSVFkpO1xufVxuLyoqXG4gKiBDbGFzcyBmb3IgUGF0aCBUeXBlLlxuICovXG5cblxudmFyIFBhdGggPVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7Tm9kZX0gc3RhcnQgIC0gc3RhcnQgbm9kZVxuICogQHBhcmFtIHtOb2RlfSBlbmQgLSBlbmQgbm9kZVxuICogQHBhcmFtIHtBcnJheTxQYXRoU2VnbWVudD59IHNlZ21lbnRzIC0gQXJyYXkgb2YgU2VnbWVudHNcbiAqL1xuZnVuY3Rpb24gUGF0aChzdGFydCwgZW5kLCBzZWdtZW50cykge1xuICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFBhdGgpO1xuXG4gIC8qKlxuICAgKiBTdGFydCBub2RlLlxuICAgKiBAdHlwZSB7Tm9kZX1cbiAgICovXG4gIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgLyoqXG4gICAqIEVuZCBub2RlLlxuICAgKiBAdHlwZSB7Tm9kZX1cbiAgICovXG5cbiAgdGhpcy5lbmQgPSBlbmQ7XG4gIC8qKlxuICAgKiBTZWdtZW50cy5cbiAgICogQHR5cGUge0FycmF5PFBhdGhTZWdtZW50Pn1cbiAgICovXG5cbiAgdGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzO1xuICAvKipcbiAgICogTGVuZ3RoIG9mIHRoZSBzZWdtZW50cy5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG5cbiAgdGhpcy5sZW5ndGggPSBzZWdtZW50cy5sZW5ndGg7XG59O1xuXG5leHBvcnRzLlBhdGggPSBQYXRoO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhdGgucHJvdG90eXBlLCBQQVRIX0lERU5USUZJRVJfUFJPUEVSVFksIElERU5USUZJRVJfUFJPUEVSVFlfQVRUUklCVVRFUyk7XG4vKipcbiAqIFRlc3QgaWYgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIHtAbGluayBQYXRofSBjbGFzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIG9iamVjdCBpcyBhIHtAbGluayBQYXRofSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNQYXRoKG9iaikge1xuICByZXR1cm4gaGFzSWRlbnRpZmllclByb3BlcnR5KG9iaiwgUEFUSF9JREVOVElGSUVSX1BST1BFUlRZKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRyaXZlciA9IGRyaXZlcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImludFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZWdlcltcImludFwiXTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0ludFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZWdlci5pc0ludDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOZW80akVycm9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9lcnJvci5OZW80akVycm9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUG9pbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NwYXRpYWxUeXBlcy5pc1BvaW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzRGF0ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdGVtcG9yYWxUeXBlcy5pc0RhdGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNEYXRlVGltZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdGVtcG9yYWxUeXBlcy5pc0RhdGVUaW1lO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzRHVyYXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3RlbXBvcmFsVHlwZXMuaXNEdXJhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0xvY2FsRGF0ZVRpbWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3RlbXBvcmFsVHlwZXMuaXNMb2NhbERhdGVUaW1lO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzTG9jYWxUaW1lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90ZW1wb3JhbFR5cGVzLmlzTG9jYWxUaW1lO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVGltZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdGVtcG9yYWxUeXBlcy5pc1RpbWU7XG4gIH1cbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBleHBvcnRzLnRlbXBvcmFsID0gZXhwb3J0cy5zcGF0aWFsID0gZXhwb3J0cy5lcnJvciA9IGV4cG9ydHMuc2Vzc2lvbiA9IGV4cG9ydHMudHlwZXMgPSBleHBvcnRzLmxvZ2dpbmcgPSBleHBvcnRzLmF1dGggPSBleHBvcnRzLmludGVnZXIgPSB2b2lkIDA7XG5cbnZhciBfaW50ZWdlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2ludGVnZXJcIikpO1xuXG52YXIgX2dyYXBoVHlwZXMgPSByZXF1aXJlKFwiLi9ncmFwaC10eXBlc1wiKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuXG52YXIgX3Jlc3VsdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVzdWx0XCIpKTtcblxudmFyIF9yZXN1bHRTdW1tYXJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZXN1bHQtc3VtbWFyeVwiKSk7XG5cbnZhciBfcmVjb3JkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZWNvcmRcIikpO1xuXG52YXIgX2RyaXZlciA9IHJlcXVpcmUoXCIuL2RyaXZlclwiKTtcblxudmFyIF9yb3V0aW5nRHJpdmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yb3V0aW5nLWRyaXZlclwiKSk7XG5cbnZhciBfdmVyc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmVyc2lvblwiKSk7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL2ludGVybmFsL3V0aWxcIik7XG5cbnZhciBfdXJsVXRpbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW50ZXJuYWwvdXJsLXV0aWxcIikpO1xuXG52YXIgX3NwYXRpYWxUeXBlcyA9IHJlcXVpcmUoXCIuL3NwYXRpYWwtdHlwZXNcIik7XG5cbnZhciBfdGVtcG9yYWxUeXBlcyA9IHJlcXVpcmUoXCIuL3RlbXBvcmFsLXR5cGVzXCIpO1xuXG52YXIgX3NlcnZlckFkZHJlc3MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL3NlcnZlci1hZGRyZXNzXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQ29uc3RydWN0IGEgbmV3IE5lbzRqIERyaXZlci4gVGhpcyBpcyB5b3VyIG1haW4gZW50cnkgcG9pbnQgZm9yIHRoaXNcbiAqIGxpYnJhcnkuXG4gKlxuICogIyMgQ29uZmlndXJhdGlvblxuICpcbiAqIFRoaXMgZnVuY3Rpb24gb3B0aW9uYWxseSB0YWtlcyBhIGNvbmZpZ3VyYXRpb24gYXJndW1lbnQuIEF2YWlsYWJsZSBjb25maWd1cmF0aW9uXG4gKiBvcHRpb25zIGFyZSBhcyBmb2xsb3dzOlxuICpcbiAqICAgICB7XG4gKiAgICAgICAvLyBFbmNyeXB0aW9uIGxldmVsOiBFTkNSWVBUSU9OX09OIG9yIEVOQ1JZUFRJT05fT0ZGLlxuICogICAgICAgZW5jcnlwdGVkOiBFTkNSWVBUSU9OX09OfEVOQ1JZUFRJT05fT0ZGXG4gKlxuICogICAgICAgLy8gVHJ1c3Qgc3RyYXRlZ3kgdG8gdXNlIGlmIGVuY3J5cHRpb24gaXMgZW5hYmxlZC4gVGhlcmUgaXMgbm8gbW9kZSB0byBkaXNhYmxlXG4gKiAgICAgICAvLyB0cnVzdCBvdGhlciB0aGFuIGRpc2FibGluZyBlbmNyeXB0aW9uIGFsdG9nZXRoZXIuIFRoZSByZWFzb24gZm9yXG4gKiAgICAgICAvLyB0aGlzIGlzIHRoYXQgaWYgeW91IGRvbid0IGtub3cgd2hvIHlvdSBhcmUgdGFsa2luZyB0bywgaXQgaXMgZWFzeSBmb3IgYW5cbiAqICAgICAgIC8vIGF0dGFja2VyIHRvIGhpamFjayB5b3VyIGVuY3J5cHRlZCBjb25uZWN0aW9uLCByZW5kZXJpbmcgZW5jcnlwdGlvbiBwb2ludGxlc3MuXG4gKiAgICAgICAvL1xuICogICAgICAgLy8gVFJVU1RfU1lTVEVNX0NBX1NJR05FRF9DRVJUSUZJQ0FURVMgaXMgdGhlIGRlZmF1bHQgY2hvaWNlLiBGb3IgTm9kZUpTIGVudmlyb25tZW50cywgdGhpc1xuICogICAgICAgLy8gbWVhbnMgdGhhdCB5b3UgdHJ1c3Qgd2hhdGV2ZXIgY2VydGlmaWNhdGVzIGFyZSBpbiB0aGUgZGVmYXVsdCB0cnVzdGVkIGNlcnRpZmljYXRlXG4gKiAgICAgICAvLyBzdG9yZSBvZiB0aGUgdW5kZXJseWluZyBzeXN0ZW0uIEZvciBCcm93c2VyIGVudmlyb25tZW50cywgdGhlIHRydXN0ZWQgY2VydGlmaWNhdGVcbiAqICAgICAgIC8vIHN0b3JlIGlzIHVzdWFsbHkgbWFuYWdlZCBieSB0aGUgYnJvd3Nlci4gUmVmZXIgdG8geW91ciBzeXN0ZW0gb3IgYnJvd3NlciBkb2N1bWVudGF0aW9uXG4gKiAgICAgICAvLyBpZiB5b3Ugd2FudCB0byBleHBsaWNpdGx5IGFkZCBhIGNlcnRpZmljYXRlIGFzIHRydXN0ZWQuXG4gKiAgICAgICAvL1xuICogICAgICAgLy8gVFJVU1RfQ1VTVE9NX0NBX1NJR05FRF9DRVJUSUZJQ0FURVMgaXMgYW5vdGhlciBvcHRpb24gZm9yIHRydXN0IHZlcmlmaWNhdGlvbiAtXG4gKiAgICAgICAvLyB3aGVuZXZlciB3ZSBlc3RhYmxpc2ggYW4gZW5jcnlwdGVkIGNvbm5lY3Rpb24sIHdlIGVuc3VyZSB0aGUgaG9zdCBpcyB1c2luZ1xuICogICAgICAgLy8gYW4gZW5jcnlwdGlvbiBjZXJ0aWZpY2F0ZSB0aGF0IGlzIGluLCBvciBpcyBzaWduZWQgYnksIGEgY2VydGlmaWNhdGUgZ2l2ZW5cbiAqICAgICAgIC8vIGFzIHRydXN0ZWQgdGhyb3VnaCBjb25maWd1cmF0aW9uLiBUaGlzIG9wdGlvbiBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgTm9kZUpTIGVudmlyb25tZW50cy5cbiAqICAgICAgIC8vXG4gKiAgICAgICAvLyBUUlVTVF9BTExfQ0VSVElGSUNBVEVTIG1lYW5zIHRoYXQgeW91IHRydXN0IGV2ZXJ5dGhpbmcgd2l0aG91dCBhbnkgdmVyaWZpY2F0aW9uc1xuICogICAgICAgLy8gc3RlcHMgY2FycmllZCBvdXQuICBUaGlzIG9wdGlvbiBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgTm9kZUpTIGVudmlyb25tZW50cyBhbmQgc2hvdWxkIG5vdFxuICogICAgICAgLy8gYmUgdXNlZCBvbiBwcm9kdWN0aW9uIHN5c3RlbXMuXG4gKiAgICAgICB0cnVzdDogXCJUUlVTVF9TWVNURU1fQ0FfU0lHTkVEX0NFUlRJRklDQVRFU1wiIHwgXCJUUlVTVF9DVVNUT01fQ0FfU0lHTkVEX0NFUlRJRklDQVRFU1wiIHxcbiAqICAgICAgIFwiVFJVU1RfQUxMX0NFUlRJRklDQVRFU1wiLFxuICpcbiAqICAgICAgIC8vIExpc3Qgb2Ygb25lIG9yIG1vcmUgcGF0aHMgdG8gdHJ1c3RlZCBlbmNyeXB0aW9uIGNlcnRpZmljYXRlcy4gVGhpcyBvbmx5XG4gKiAgICAgICAvLyB3b3JrcyBpbiB0aGUgTm9kZUpTIGJ1bmRsZSwgYW5kIG9ubHkgbWF0dGVycyBpZiB5b3UgdXNlIFwiVFJVU1RfQ1VTVE9NX0NBX1NJR05FRF9DRVJUSUZJQ0FURVNcIi5cbiAqICAgICAgIC8vIFRoZSBjZXJ0aWZpY2F0ZSBmaWxlcyBzaG91bGQgYmUgaW4gcmVndWxhciBYLjUwOSBQRU0gZm9ybWF0LlxuICogICAgICAgLy8gRm9yIGluc3RhbmNlLCBbJy4vdHJ1c3RlZC5wZW0nXVxuICogICAgICAgdHJ1c3RlZENlcnRpZmljYXRlczogW10sXG4gKlxuICogICAgICAgLy8gVGhlIG1heGltdW0gdG90YWwgbnVtYmVyIG9mIGNvbm5lY3Rpb25zIGFsbG93ZWQgdG8gYmUgbWFuYWdlZCBieSB0aGUgY29ubmVjdGlvbiBwb29sLCBwZXIgaG9zdC5cbiAqICAgICAgIC8vIFRoaXMgaW5jbHVkZXMgYm90aCBpbi11c2UgYW5kIGlkbGUgY29ubmVjdGlvbnMuIE5vIG1heGltdW0gY29ubmVjdGlvbiBwb29sIHNpemUgaXMgaW1wb3NlZFxuICogICAgICAgLy8gYnkgZGVmYXVsdC5cbiAqICAgICAgIG1heENvbm5lY3Rpb25Qb29sU2l6ZTogMTAwLFxuICpcbiAqICAgICAgIC8vIFRoZSBtYXhpbXVtIGFsbG93ZWQgbGlmZXRpbWUgZm9yIGEgcG9vbGVkIGNvbm5lY3Rpb24gaW4gbWlsbGlzZWNvbmRzLiBQb29sZWQgY29ubmVjdGlvbnMgb2xkZXIgdGhhbiB0aGlzXG4gKiAgICAgICAvLyB0aHJlc2hvbGQgd2lsbCBiZSBjbG9zZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgcG9vbC4gU3VjaCBkaXNjYXJkaW5nIGhhcHBlbnMgZHVyaW5nIGNvbm5lY3Rpb24gYWNxdWlzaXRpb25cbiAqICAgICAgIC8vIHNvIHRoYXQgbmV3IHNlc3Npb24gaXMgbmV2ZXIgYmFja2VkIGJ5IGFuIG9sZCBjb25uZWN0aW9uLiBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGEgbG93IHZhbHVlIHdpbGwgY2F1c2VcbiAqICAgICAgIC8vIGEgaGlnaCBjb25uZWN0aW9uIGNodXJuIGFuZCBtaWdodCByZXN1bHQgaW4gYSBwZXJmb3JtYW5jZSBoaXQuIEl0IGlzIHJlY29tbWVuZGVkIHRvIHNldCBtYXhpbXVtIGxpZmV0aW1lXG4gKiAgICAgICAvLyB0byBhIHNsaWdodGx5IHNtYWxsZXIgdmFsdWUgdGhhbiB0aGUgb25lIGNvbmZpZ3VyZWQgaW4gbmV0d29yayBlcXVpcG1lbnQgKGxvYWQgYmFsYW5jZXIsIHByb3h5LCBmaXJld2FsbCxcbiAqICAgICAgIC8vIGV0Yy4gY2FuIGFsc28gbGltaXQgbWF4aW11bSBjb25uZWN0aW9uIGxpZmV0aW1lKS4gTm8gbWF4aW11bSBsaWZldGltZSBsaW1pdCBpcyBpbXBvc2VkIGJ5IGRlZmF1bHQuIFplcm9cbiAqICAgICAgIC8vIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgcmVzdWx0IGluIGxpZmV0aW1lIG5vdCBiZWluZyBjaGVja2VkLlxuICogICAgICAgbWF4Q29ubmVjdGlvbkxpZmV0aW1lOiA2MCAqIDYwICogMTAwMCwgLy8gMSBob3VyXG4gKlxuICogICAgICAgLy8gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gd2FpdCB0byBhY3F1aXJlIGEgY29ubmVjdGlvbiBmcm9tIHRoZSBwb29sICh0byBlaXRoZXIgY3JlYXRlIGEgbmV3XG4gKiAgICAgICAvLyBjb25uZWN0aW9uIG9yIGJvcnJvdyBhbiBleGlzdGluZyBvbmUuXG4gKiAgICAgICBjb25uZWN0aW9uQWNxdWlzaXRpb25UaW1lb3V0OiA2MDAwMCwgLy8gMSBtaW51dGVcbiAqXG4gKiAgICAgICAvLyBTcGVjaWZ5IHRoZSBtYXhpbXVtIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRyYW5zYWN0aW9ucyBhcmUgYWxsb3dlZCB0byByZXRyeSB2aWFcbiAqICAgICAgIC8vIGBTZXNzaW9uI3JlYWRUcmFuc2FjdGlvbigpYCBhbmQgYFNlc3Npb24jd3JpdGVUcmFuc2FjdGlvbigpYCBmdW5jdGlvbnMuXG4gKiAgICAgICAvLyBUaGVzZSBmdW5jdGlvbnMgd2lsbCByZXRyeSB0aGUgZ2l2ZW4gdW5pdCBvZiB3b3JrIG9uIGBTZXJ2aWNlVW5hdmFpbGFibGVgLCBgU2Vzc2lvbkV4cGlyZWRgIGFuZCB0cmFuc2llbnRcbiAqICAgICAgIC8vIGVycm9ycyB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmYgdXNpbmcgaW5pdGlhbCBkZWxheSBvZiAxIHNlY29uZC5cbiAqICAgICAgIC8vIERlZmF1bHQgdmFsdWUgaXMgMzAwMDAgd2hpY2ggaXMgMzAgc2Vjb25kcy5cbiAqICAgICAgIG1heFRyYW5zYWN0aW9uUmV0cnlUaW1lOiAzMDAwMCwgLy8gMzAgc2Vjb25kc1xuICpcbiAqICAgICAgIC8vIFNwZWNpZnkgc29ja2V0IGNvbm5lY3Rpb24gdGltZW91dCBpbiBtaWxsaXNlY29uZHMuIE51bWVyaWMgdmFsdWVzIGFyZSBleHBlY3RlZC4gTmVnYXRpdmUgYW5kIHplcm8gdmFsdWVzXG4gKiAgICAgICAvLyByZXN1bHQgaW4gbm8gdGltZW91dCBiZWluZyBhcHBsaWVkLiBDb25uZWN0aW9uIGVzdGFibGlzaG1lbnQgd2lsbCBiZSB0aGVuIGJvdW5kIGJ5IHRoZSB0aW1lb3V0IGNvbmZpZ3VyZWRcbiAqICAgICAgIC8vIG9uIHRoZSBvcGVyYXRpbmcgc3lzdGVtIGxldmVsLiBEZWZhdWx0IHZhbHVlIGlzIDMwMDAwLCB3aGljaCBpcyAzMCBzZWNvbmRzLlxuICogICAgICAgY29ubmVjdGlvblRpbWVvdXQ6IDMwMDAwLCAvLyAzMCBzZWNvbmRzXG4gKlxuICogICAgICAgLy8gTWFrZSB0aGlzIGRyaXZlciBhbHdheXMgcmV0dXJuIG5hdGl2ZSBKYXZhU2NyaXB0IG51bWJlcnMgZm9yIGludGVnZXIgdmFsdWVzLCBpbnN0ZWFkIG9mIHRoZVxuICogICAgICAgLy8gZGVkaWNhdGVkIHtAbGluayBJbnRlZ2VyfSBjbGFzcy4gVmFsdWVzIHRoYXQgZG8gbm90IGZpdCBpbiBuYXRpdmUgbnVtYmVyIGJpdCByYW5nZSB3aWxsIGJlIHJlcHJlc2VudGVkIGFzXG4gKiAgICAgICAvLyBgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZYCBvciBgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZYC5cbiAqICAgICAgIC8vICoqV2FybmluZzoqKiBSZXN1bHRTdW1tYXJ5IEl0IGlzIG5vdCBhbHdheXMgc2FmZSB0byBlbmFibGUgdGhpcyBzZXR0aW5nIHdoZW4gSmF2YVNjcmlwdCBhcHBsaWNhdGlvbnMgYXJlIG5vdCB0aGUgb25seSBvbmVzXG4gKiAgICAgICAvLyBpbnRlcmFjdGluZyB3aXRoIHRoZSBkYXRhYmFzZS4gU3RvcmVkIG51bWJlcnMgbWlnaHQgaW4gc3VjaCBjYXNlIGJlIG5vdCByZXByZXNlbnRhYmxlIGJ5IG5hdGl2ZVxuICogICAgICAgLy8ge0BsaW5rIE51bWJlcn0gdHlwZSBhbmQgdGh1cyBkcml2ZXIgd2lsbCByZXR1cm4gbG9zc3kgdmFsdWVzLiBUaGlzIG1pZ2h0IGFsc28gaGFwcGVuIHdoZW4gZGF0YSB3YXNcbiAqICAgICAgIC8vIGluaXRpYWxseSBpbXBvcnRlZCB1c2luZyBuZW80aiBpbXBvcnQgdG9vbCBhbmQgY29udGFpbmVkIG51bWJlcnMgbGFyZ2VyIHRoYW5cbiAqICAgICAgIC8vIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuIERyaXZlciB3aWxsIHRoZW4gcmV0dXJuIHBvc2l0aXZlIGluZmluaXR5LCB3aGljaCBpcyBsb3NzeS5cbiAqICAgICAgIC8vIERlZmF1bHQgdmFsdWUgZm9yIHRoaXMgb3B0aW9uIGlzIGBmYWxzZWAgYmVjYXVzZSBuYXRpdmUgSmF2YVNjcmlwdCBudW1iZXJzIG1pZ2h0IHJlc3VsdFxuICogICAgICAgLy8gaW4gbG9zcyBvZiBwcmVjaXNpb24gaW4gdGhlIGdlbmVyYWwgY2FzZS5cbiAqICAgICAgIGRpc2FibGVMb3NzbGVzc0ludGVnZXJzOiBmYWxzZSxcbiAqXG4gKiAgICAgICAvLyBTcGVjaWZ5IHRoZSBsb2dnaW5nIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBkcml2ZXIuIE9iamVjdCBzaG91bGQgaGF2ZSB0d28gcHJvcGVydGllcyBgbGV2ZWxgIGFuZCBgbG9nZ2VyYC5cbiAqICAgICAgIC8vXG4gKiAgICAgICAvLyBQcm9wZXJ0eSBgbGV2ZWxgIHJlcHJlc2VudHMgdGhlIGxvZ2dpbmcgbGV2ZWwgd2hpY2ggc2hvdWxkIGJlIG9uZSBvZjogJ2Vycm9yJywgJ3dhcm4nLCAnaW5mbycgb3IgJ2RlYnVnJy4gVGhpcyBwcm9wZXJ0eSBpcyBvcHRpb25hbCBhbmRcbiAqICAgICAgIC8vIGl0cyBkZWZhdWx0IHZhbHVlIGlzICdpbmZvJy4gTGV2ZWxzIGhhdmUgcHJpb3JpdGllczogJ2Vycm9yJzogMCwgJ3dhcm4nOiAxLCAnaW5mbyc6IDIsICdkZWJ1Zyc6IDMuIEVuYWJsaW5nIGEgY2VydGFpbiBsZXZlbCBhbHNvIGVuYWJsZXMgYWxsXG4gKiAgICAgICAvLyBsZXZlbHMgd2l0aCBsb3dlciBwcmlvcml0eS4gRm9yIGV4YW1wbGU6ICdlcnJvcicsICd3YXJuJyBhbmQgJ2luZm8nIHdpbGwgYmUgbG9nZ2VkIHdoZW4gJ2luZm8nIGxldmVsIGlzIGNvbmZpZ3VyZWQuXG4gKiAgICAgICAvL1xuICogICAgICAgLy8gUHJvcGVydHkgYGxvZ2dlcmAgcmVwcmVzZW50cyB0aGUgbG9nZ2luZyBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGludm9rZWQgZm9yIGV2ZXJ5IGxvZyBjYWxsIHdpdGggYW4gYWNjZXB0YWJsZSBsZXZlbC4gVGhlIGZ1bmN0aW9uIHNob3VsZFxuICogICAgICAgLy8gdGFrZSB0d28gc3RyaW5nIGFyZ3VtZW50cyBgbGV2ZWxgIGFuZCBgbWVzc2FnZWAuIFRoZSBmdW5jdGlvbiBzaG91bGQgbm90IGV4ZWN1dGUgYW55IGJsb2NraW5nIG9yIGxvbmctcnVubmluZyBvcGVyYXRpb25zXG4gKiAgICAgICAvLyBiZWNhdXNlIGl0IGlzIG9mdGVuIGV4ZWN1dGVkIG9uIGEgaG90IHBhdGguXG4gKiAgICAgICAvL1xuICogICAgICAgLy8gTm8gbG9nZ2luZyBpcyBkb25lIGJ5IGRlZmF1bHQuIFNlZSBgbmVvNGoubG9nZ2luZ2Agb2JqZWN0IHRoYXQgY29udGFpbnMgcHJlZGVmaW5lZCBsb2dnaW5nIGltcGxlbWVudGF0aW9ucy5cbiAqICAgICAgIGxvZ2dpbmc6IHtcbiAqICAgICAgICAgbGV2ZWw6ICdpbmZvJyxcbiAqICAgICAgICAgbG9nZ2VyOiAobGV2ZWwsIG1lc3NhZ2UpID0+IGNvbnNvbGUubG9nKGxldmVsICsgJyAnICsgbWVzc2FnZSlcbiAqICAgICAgIH0sXG4gKlxuICogICAgICAgLy8gU3BlY2lmeSBhIGN1c3RvbSBzZXJ2ZXIgYWRkcmVzcyByZXNvbHZlciBmdW5jdGlvbiB1c2VkIGJ5IHRoZSByb3V0aW5nIGRyaXZlciB0byByZXNvbHZlIHRoZSBpbml0aWFsIGFkZHJlc3MgdXNlZCB0byBjcmVhdGUgdGhlIGRyaXZlci5cbiAqICAgICAgIC8vIFN1Y2ggcmVzb2x1dGlvbiBoYXBwZW5zOlxuICogICAgICAgLy8gICogZHVyaW5nIHRoZSB2ZXJ5IGZpcnN0IHJlZGlzY292ZXJ5IHdoZW4gZHJpdmVyIGlzIGNyZWF0ZWRcbiAqICAgICAgIC8vICAqIHdoZW4gYWxsIHRoZSBrbm93biByb3V0ZXJzIGZyb20gdGhlIGN1cnJlbnQgcm91dGluZyB0YWJsZSBoYXZlIGZhaWxlZCBhbmQgZHJpdmVyIG5lZWRzIHRvIGZhbGxiYWNrIHRvIHRoZSBpbml0aWFsIGFkZHJlc3NcbiAqICAgICAgIC8vXG4gKiAgICAgICAvLyBJbiBOb2RlSlMgZW52aXJvbm1lbnQgZHJpdmVyIGRlZmF1bHRzIHRvIHBlcmZvcm1pbmcgYSBETlMgcmVzb2x1dGlvbiBvZiB0aGUgaW5pdGlhbCBhZGRyZXNzIHVzaW5nICdkbnMnIG1vZHVsZS5cbiAqICAgICAgIC8vIEluIGJyb3dzZXIgZW52aXJvbm1lbnQgZHJpdmVyIHVzZXMgdGhlIGluaXRpYWwgYWRkcmVzcyBhcy1pcy5cbiAqICAgICAgIC8vIFZhbHVlIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50IC0gdGhlIGluaXRpYWwgYWRkcmVzcy4gSXQgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBuZXcgYWRkcmVzc2VzLlxuICogICAgICAgLy8gQWRkcmVzcyBpcyBhIHN0cmluZyBvZiBzaGFwZSAnPGhvc3Q+Ojxwb3J0PicuIFByb3ZpZGVkIGZ1bmN0aW9uIGNhbiByZXR1cm4gZWl0aGVyIGEgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGFuIGFycmF5IG9mIGFkZHJlc3Nlc1xuICogICAgICAgLy8gb3IgYXJyYXkgb2YgYWRkcmVzc2VzIGRpcmVjdGx5LlxuICogICAgICAgcmVzb2x2ZXI6IGZ1bmN0aW9uKGFkZHJlc3MpIHtcbiAqICAgICAgICAgcmV0dXJuIFsnMTI3LjAuMC4xOjg4ODgnLCAnZmFsbGJhY2suZGIuY29tOjc2ODcnXTtcbiAqICAgICAgIH0sXG4gKlxuICogICAgICAvLyBPcHRpb25hbGx5IG92ZXJyaWRlIHRoZSBkZWZhdWx0IHVzZXIgYWdlbnQgbmFtZS5cbiAqICAgICAgIHVzZXJBZ2VudDogVVNFUl9BR0VOVFxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgZm9yIHRoZSBOZW80aiBkYXRhYmFzZSwgZm9yIGluc3RhbmNlIFwibmVvNGo6Ly9sb2NhbGhvc3RcIiBhbmQvb3IgXCJib2x0Oi8vbG9jYWxob3N0XCJcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxzdHJpbmc+fSBhdXRoVG9rZW4gQXV0aGVudGljYXRpb24gY3JlZGVudGlhbHMuIFNlZSB7QGxpbmsgYXV0aH0gZm9yIGhlbHBlcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0LiBTZWUgdGhlIGNvbmZpZ3VyYXRpb24gc2VjdGlvbiBhYm92ZSBmb3IgZGV0YWlscy5cbiAqIEByZXR1cm5zIHtEcml2ZXJ9XG4gKi9cbmZ1bmN0aW9uIGRyaXZlcih1cmwsIGF1dGhUb2tlbikge1xuICB2YXIgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgKDAsIF91dGlsLmFzc2VydFN0cmluZykodXJsLCAnQm9sdCBVUkwnKTtcblxuICB2YXIgcGFyc2VkVXJsID0gX3VybFV0aWxbXCJkZWZhdWx0XCJdLnBhcnNlRGF0YWJhc2VVcmwodXJsKTsgLy8gRGV0ZXJtaW5lIGVudHJ5cHRpb24vdHJ1c3Qgb3B0aW9ucyBmcm9tIHRoZSBVUkwuXG5cblxuICB2YXIgcm91dGluZyA9IGZhbHNlO1xuICB2YXIgZW5jcnlwdGVkID0gZmFsc2U7XG4gIHZhciB0cnVzdDtcblxuICBzd2l0Y2ggKHBhcnNlZFVybC5zY2hlbWUpIHtcbiAgICBjYXNlICdib2x0JzpcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm9sdCtzJzpcbiAgICAgIGVuY3J5cHRlZCA9IHRydWU7XG4gICAgICB0cnVzdCA9ICdUUlVTVF9TWVNURU1fQ0FfU0lHTkVEX0NFUlRJRklDQVRFUyc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JvbHQrc3NjJzpcbiAgICAgIGVuY3J5cHRlZCA9IHRydWU7XG4gICAgICB0cnVzdCA9ICdUUlVTVF9BTExfQ0VSVElGSUNBVEVTJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbmVvNGonOlxuICAgICAgcm91dGluZyA9IHRydWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ25lbzRqK3MnOlxuICAgICAgZW5jcnlwdGVkID0gdHJ1ZTtcbiAgICAgIHRydXN0ID0gJ1RSVVNUX1NZU1RFTV9DQV9TSUdORURfQ0VSVElGSUNBVEVTJztcbiAgICAgIHJvdXRpbmcgPSB0cnVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICduZW80aitzc2MnOlxuICAgICAgZW5jcnlwdGVkID0gdHJ1ZTtcbiAgICAgIHRydXN0ID0gJ1RSVVNUX0FMTF9DRVJUSUZJQ0FURVMnO1xuICAgICAgcm91dGluZyA9IHRydWU7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHNjaGVtZTogXCIuY29uY2F0KHBhcnNlZFVybC5zY2hlbWUpKTtcbiAgfSAvLyBFbmNyeXB0aW9uIGVuYWJsZWQgb24gVVJMLCBwcm9wYWdhdGUgdHJ1c3QgdG8gdGhlIGNvbmZpZy5cblxuXG4gIGlmIChlbmNyeXB0ZWQpIHtcbiAgICAvLyBDaGVjayBmb3IgY29uZmlndXJhdGlvbiBjb25mbGljdCBiZXR3ZWVuIFVSTCBhbmQgY29uZmlnLlxuICAgIGlmICgnZW5jcnlwdGVkJyBpbiBjb25maWcgfHwgJ3RydXN0JyBpbiBjb25maWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbi90cnVzdCBjYW4gb25seSBiZSBjb25maWd1cmVkIGVpdGhlciB0aHJvdWdoIFVSTCBvciBjb25maWcsIG5vdCBib3RoJyk7XG4gICAgfVxuXG4gICAgY29uZmlnLmVuY3J5cHRlZCA9IF91dGlsLkVOQ1JZUFRJT05fT047XG4gICAgY29uZmlnLnRydXN0ID0gdHJ1c3Q7XG4gIH0gLy8gU2FuaXRpemUgYXV0aG9yaXR5IHRva2VuLiBOaWNlciBlcnJvciBmcm9tIHNlcnZlciB3aGVuIGEgc2NoZW1lIGlzIHNldC5cblxuXG4gIGF1dGhUb2tlbiA9IGF1dGhUb2tlbiB8fCB7fTtcbiAgYXV0aFRva2VuLnNjaGVtZSA9IGF1dGhUb2tlbi5zY2hlbWUgfHwgJ25vbmUnOyAvLyBVc2UgZGVmYXVsdCB1c2VyIGFnZW50IG9yIHVzZXIgYWdlbnQgc3BlY2lmaWVkIGJ5IHVzZXIuXG5cbiAgY29uZmlnLnVzZXJBZ2VudCA9IGNvbmZpZy51c2VyQWdlbnQgfHwgVVNFUl9BR0VOVDtcblxuICBpZiAocm91dGluZykge1xuICAgIHJldHVybiBuZXcgX3JvdXRpbmdEcml2ZXJbXCJkZWZhdWx0XCJdKF9zZXJ2ZXJBZGRyZXNzW1wiZGVmYXVsdFwiXS5mcm9tVXJsKHBhcnNlZFVybC5ob3N0QW5kUG9ydCksIHBhcnNlZFVybC5xdWVyeSwgY29uZmlnLnVzZXJBZ2VudCwgYXV0aFRva2VuLCBjb25maWcpO1xuICB9IGVsc2Uge1xuICAgIGlmICghKDAsIF91dGlsLmlzRW1wdHlPYmplY3RPck51bGwpKHBhcnNlZFVybC5xdWVyeSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlcnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBub25lIHJvdXRlZCBzY2hlbWUuIEdpdmVuIFVSTDogJ1wiLmNvbmNhdCh1cmwsIFwiJ1wiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBfZHJpdmVyLkRyaXZlcihfc2VydmVyQWRkcmVzc1tcImRlZmF1bHRcIl0uZnJvbVVybChwYXJzZWRVcmwuaG9zdEFuZFBvcnQpLCBjb25maWcudXNlckFnZW50LCBhdXRoVG9rZW4sIGNvbmZpZyk7XG4gIH1cbn1cbi8qKlxuICogQHByb3BlcnR5IHtmdW5jdGlvbih1c2VybmFtZTogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nLCByZWFsbTogP3N0cmluZyl9IGJhc2ljIHRoZSBmdW5jdGlvbiB0byBjcmVhdGUgYVxuICogYmFzaWMgYXV0aGVudGljYXRpb24gdG9rZW4uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJhc2U2NEVuY29kZWRUaWNrZXQ6IHN0cmluZyl9IGtlcmJlcm9zIHRoZSBmdW5jdGlvbiB0byBjcmVhdGUgYSBLZXJiZXJvcyBhdXRoZW50aWNhdGlvbiB0b2tlbi5cbiAqIEFjY2VwdHMgYSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50IC0gYmFzZTY0IGVuY29kZWQgS2VyYmVyb3MgdGlja2V0LlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihwcmluY2lwYWw6IHN0cmluZywgY3JlZGVudGlhbHM6IHN0cmluZywgcmVhbG06IHN0cmluZywgc2NoZW1lOiBzdHJpbmcsIHBhcmFtZXRlcnM6ID9vYmplY3QpfSBjdXN0b21cbiAqIHRoZSBmdW5jdGlvbiB0byBjcmVhdGUgYSBjdXN0b20gYXV0aGVudGljYXRpb24gdG9rZW4uXG4gKi9cblxuXG52YXIgYXV0aCA9IHtcbiAgYmFzaWM6IGZ1bmN0aW9uIGJhc2ljKHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICAgIHZhciByZWFsbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHJlYWxtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6ICdiYXNpYycsXG4gICAgICAgIHByaW5jaXBhbDogdXNlcm5hbWUsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBwYXNzd29yZCxcbiAgICAgICAgcmVhbG06IHJlYWxtXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6ICdiYXNpYycsXG4gICAgICAgIHByaW5jaXBhbDogdXNlcm5hbWUsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBwYXNzd29yZFxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIGtlcmJlcm9zOiBmdW5jdGlvbiBrZXJiZXJvcyhiYXNlNjRFbmNvZGVkVGlja2V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtZTogJ2tlcmJlcm9zJyxcbiAgICAgIHByaW5jaXBhbDogJycsXG4gICAgICAvLyBUaGlzIGVtcHR5IHN0cmluZyBpcyByZXF1aXJlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICBjcmVkZW50aWFsczogYmFzZTY0RW5jb2RlZFRpY2tldFxuICAgIH07XG4gIH0sXG4gIGN1c3RvbTogZnVuY3Rpb24gY3VzdG9tKHByaW5jaXBhbCwgY3JlZGVudGlhbHMsIHJlYWxtLCBzY2hlbWUpIHtcbiAgICB2YXIgcGFyYW1ldGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHBhcmFtZXRlcnMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogc2NoZW1lLFxuICAgICAgICBwcmluY2lwYWw6IHByaW5jaXBhbCxcbiAgICAgICAgY3JlZGVudGlhbHM6IGNyZWRlbnRpYWxzLFxuICAgICAgICByZWFsbTogcmVhbG0sXG4gICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnNcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogc2NoZW1lLFxuICAgICAgICBwcmluY2lwYWw6IHByaW5jaXBhbCxcbiAgICAgICAgY3JlZGVudGlhbHM6IGNyZWRlbnRpYWxzLFxuICAgICAgICByZWFsbTogcmVhbG1cbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuZXhwb3J0cy5hdXRoID0gYXV0aDtcbnZhciBVU0VSX0FHRU5UID0gJ25lbzRqLWphdmFzY3JpcHQvJyArIF92ZXJzaW9uW1wiZGVmYXVsdFwiXTtcbi8qKlxuICogT2JqZWN0IGNvbnRhaW5pbmcgcHJlZGVmaW5lZCBsb2dnaW5nIGNvbmZpZ3VyYXRpb25zLiBUaGVzZSBhcmUgZXhwZWN0ZWQgdG8gYmUgdXNlZCBhcyB2YWx1ZXMgb2YgdGhlIGRyaXZlciBjb25maWcncyBgbG9nZ2luZ2AgcHJvcGVydHkuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGxldmVsOiA/c3RyaW5nKTogb2JqZWN0fSBjb25zb2xlIHRoZSBmdW5jdGlvbiB0byBjcmVhdGUgYSBsb2dnaW5nIGNvbmZpZyB0aGF0IHByaW50cyBhbGwgbWVzc2FnZXMgdG8gYGNvbnNvbGUubG9nYCB3aXRoXG4gKiB0aW1lc3RhbXAsIGxldmVsIGFuZCBtZXNzYWdlLiBJdCB0YWtlcyBhbiBvcHRpb25hbCBgbGV2ZWxgIHBhcmFtZXRlciB3aGljaCByZXByZXNlbnRzIHRoZSBtYXhpbXVtIGxvZyBsZXZlbCB0byBiZSBsb2dnZWQuIERlZmF1bHQgdmFsdWUgaXMgJ2luZm8nLlxuICovXG5cbnZhciBsb2dnaW5nID0ge1xuICBjb25zb2xlOiBmdW5jdGlvbiAoX2NvbnNvbGUpIHtcbiAgICBmdW5jdGlvbiBjb25zb2xlKF94KSB7XG4gICAgICByZXR1cm4gX2NvbnNvbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9jb25zb2xlLnRvU3RyaW5nKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBjb25zb2xlO1xuICB9KGZ1bmN0aW9uIChsZXZlbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICBsb2dnZXI6IGZ1bmN0aW9uIGxvZ2dlcihsZXZlbCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gY29uc29sZS5sb2coXCJcIi5jb25jYXQoZ2xvYmFsLkRhdGUubm93KCksIFwiIFwiKS5jb25jYXQobGV2ZWwudG9VcHBlckNhc2UoKSwgXCIgXCIpLmNvbmNhdChtZXNzYWdlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSlcbn07XG4vKipcbiAqIE9iamVjdCBjb250YWluaW5nIGNvbnN0cnVjdG9ycyBmb3IgYWxsIG5lbzRqIHR5cGVzLlxuICovXG5cbmV4cG9ydHMubG9nZ2luZyA9IGxvZ2dpbmc7XG52YXIgdHlwZXMgPSB7XG4gIE5vZGU6IF9ncmFwaFR5cGVzLk5vZGUsXG4gIFJlbGF0aW9uc2hpcDogX2dyYXBoVHlwZXMuUmVsYXRpb25zaGlwLFxuICBVbmJvdW5kUmVsYXRpb25zaGlwOiBfZ3JhcGhUeXBlcy5VbmJvdW5kUmVsYXRpb25zaGlwLFxuICBQYXRoU2VnbWVudDogX2dyYXBoVHlwZXMuUGF0aFNlZ21lbnQsXG4gIFBhdGg6IF9ncmFwaFR5cGVzLlBhdGgsXG4gIFJlc3VsdDogX3Jlc3VsdFtcImRlZmF1bHRcIl0sXG4gIFJlc3VsdFN1bW1hcnk6IF9yZXN1bHRTdW1tYXJ5W1wiZGVmYXVsdFwiXSxcbiAgUmVjb3JkOiBfcmVjb3JkW1wiZGVmYXVsdFwiXSxcbiAgUG9pbnQ6IF9zcGF0aWFsVHlwZXMuUG9pbnQsXG4gIERhdGU6IF90ZW1wb3JhbFR5cGVzLkRhdGUsXG4gIERhdGVUaW1lOiBfdGVtcG9yYWxUeXBlcy5EYXRlVGltZSxcbiAgRHVyYXRpb246IF90ZW1wb3JhbFR5cGVzLkR1cmF0aW9uLFxuICBMb2NhbERhdGVUaW1lOiBfdGVtcG9yYWxUeXBlcy5Mb2NhbERhdGVUaW1lLFxuICBMb2NhbFRpbWU6IF90ZW1wb3JhbFR5cGVzLkxvY2FsVGltZSxcbiAgVGltZTogX3RlbXBvcmFsVHlwZXMuVGltZSxcbiAgSW50ZWdlcjogX2ludGVnZXJbXCJkZWZhdWx0XCJdXG59O1xuLyoqXG4gKiBPYmplY3QgY29udGFpbmluZyBzdHJpbmcgY29uc3RhbnRzIHJlcHJlc2VudGluZyBzZXNzaW9uIGFjY2VzcyBtb2Rlcy5cbiAqL1xuXG5leHBvcnRzLnR5cGVzID0gdHlwZXM7XG52YXIgc2Vzc2lvbiA9IHtcbiAgUkVBRDogX2RyaXZlci5SRUFELFxuICBXUklURTogX2RyaXZlci5XUklURVxufTtcbi8qKlxuICogT2JqZWN0IGNvbnRhaW5pbmcgc3RyaW5nIGNvbnN0YW50cyByZXByZXNlbnRpbmcgcHJlZGVmaW5lZCB7QGxpbmsgTmVvNGpFcnJvcn0gY29kZXMuXG4gKi9cblxuZXhwb3J0cy5zZXNzaW9uID0gc2Vzc2lvbjtcbnZhciBlcnJvciA9IHtcbiAgU0VSVklDRV9VTkFWQUlMQUJMRTogX2Vycm9yLlNFUlZJQ0VfVU5BVkFJTEFCTEUsXG4gIFNFU1NJT05fRVhQSVJFRDogX2Vycm9yLlNFU1NJT05fRVhQSVJFRCxcbiAgUFJPVE9DT0xfRVJST1I6IF9lcnJvci5QUk9UT0NPTF9FUlJPUlxufTtcbi8qKlxuICogT2JqZWN0IGNvbnRhaW5pbmcgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB7QGxpbmsgSW50ZWdlcn0gb2JqZWN0cy5cbiAqL1xuXG5leHBvcnRzLmVycm9yID0gZXJyb3I7XG52YXIgaW50ZWdlciA9IHtcbiAgdG9OdW1iZXI6IF9pbnRlZ2VyLnRvTnVtYmVyLFxuICB0b1N0cmluZzogX2ludGVnZXIudG9TdHJpbmcsXG4gIGluU2FmZVJhbmdlOiBfaW50ZWdlci5pblNhZmVSYW5nZVxufTtcbi8qKlxuICogT2JqZWN0IGNvbnRhaW5pbmcgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCBzcGF0aWFsIHR5cGVzLCBsaWtlIHtAbGluayBQb2ludH0uXG4gKi9cblxuZXhwb3J0cy5pbnRlZ2VyID0gaW50ZWdlcjtcbnZhciBzcGF0aWFsID0ge1xuICBpc1BvaW50OiBfc3BhdGlhbFR5cGVzLmlzUG9pbnRcbn07XG4vKipcbiAqIE9iamVjdCBjb250YWluaW5nIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGVtcG9yYWwgdHlwZXMsIGxpa2Uge0BsaW5rIFRpbWV9IG9yIHtAbGluayBEdXJhdGlvbn0uXG4gKi9cblxuZXhwb3J0cy5zcGF0aWFsID0gc3BhdGlhbDtcbnZhciB0ZW1wb3JhbCA9IHtcbiAgaXNEdXJhdGlvbjogX3RlbXBvcmFsVHlwZXMuaXNEdXJhdGlvbixcbiAgaXNMb2NhbFRpbWU6IF90ZW1wb3JhbFR5cGVzLmlzTG9jYWxUaW1lLFxuICBpc1RpbWU6IF90ZW1wb3JhbFR5cGVzLmlzVGltZSxcbiAgaXNEYXRlOiBfdGVtcG9yYWxUeXBlcy5pc0RhdGUsXG4gIGlzTG9jYWxEYXRlVGltZTogX3RlbXBvcmFsVHlwZXMuaXNMb2NhbERhdGVUaW1lLFxuICBpc0RhdGVUaW1lOiBfdGVtcG9yYWxUeXBlcy5pc0RhdGVUaW1lXG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudGVtcG9yYWwgPSB0ZW1wb3JhbDtcbnZhciBmb3JFeHBvcnQgPSB7XG4gIGRyaXZlcjogZHJpdmVyLFxuICBcImludFwiOiBfaW50ZWdlcltcImludFwiXSxcbiAgaXNJbnQ6IF9pbnRlZ2VyLmlzSW50LFxuICBpc1BvaW50OiBfc3BhdGlhbFR5cGVzLmlzUG9pbnQsXG4gIGlzRHVyYXRpb246IF90ZW1wb3JhbFR5cGVzLmlzRHVyYXRpb24sXG4gIGlzTG9jYWxUaW1lOiBfdGVtcG9yYWxUeXBlcy5pc0xvY2FsVGltZSxcbiAgaXNUaW1lOiBfdGVtcG9yYWxUeXBlcy5pc1RpbWUsXG4gIGlzRGF0ZTogX3RlbXBvcmFsVHlwZXMuaXNEYXRlLFxuICBpc0xvY2FsRGF0ZVRpbWU6IF90ZW1wb3JhbFR5cGVzLmlzTG9jYWxEYXRlVGltZSxcbiAgaXNEYXRlVGltZTogX3RlbXBvcmFsVHlwZXMuaXNEYXRlVGltZSxcbiAgaW50ZWdlcjogaW50ZWdlcixcbiAgTmVvNGpFcnJvcjogX2Vycm9yLk5lbzRqRXJyb3IsXG4gIGF1dGg6IGF1dGgsXG4gIGxvZ2dpbmc6IGxvZ2dpbmcsXG4gIHR5cGVzOiB0eXBlcyxcbiAgc2Vzc2lvbjogc2Vzc2lvbixcbiAgZXJyb3I6IGVycm9yLFxuICBzcGF0aWFsOiBzcGF0aWFsLFxuICB0ZW1wb3JhbDogdGVtcG9yYWxcbn07XG52YXIgX2RlZmF1bHQgPSBmb3JFeHBvcnQ7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZXhwb3J0cy50b1N0cmluZyA9IGV4cG9ydHMudG9OdW1iZXIgPSBleHBvcnRzLmluU2FmZVJhbmdlID0gZXhwb3J0cy5pc0ludCA9IGV4cG9ydHNbXCJpbnRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyA2NC1iaXQgSW50ZWdlciBsaWJyYXJ5LCBvcmlnaW5hbGx5IGZyb20gTG9uZy5qcyBieSBkY29kZUlPXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9Mb25nLmpzXG4vLyBMaWNlbnNlIEFwYWNoZSAyXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIsIGdpdmVuIGl0cyBsb3cgYW5kIGhpZ2ggMzIgYml0IHZhbHVlcyBhcyAqc2lnbmVkKiBpbnRlZ2Vycy5cbiAqIFNlZSBleHBvcnRlZCBmdW5jdGlvbnMgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIG9wZXJhdGluZyBpbnRlZ2Vycy5cbiAqIFVzZSBgaW50KClgIGZ1bmN0aW9uIHRvIGNyZWF0ZSBuZXcgaW50ZWdlcnMsIGBpc0ludCgpYCB0byBjaGVjayBpZiBnaXZlbiBvYmplY3QgaXMgaW50ZWdlcixcbiAqIGBpblNhZmVSYW5nZSgpYCB0byBjaGVjayBpZiBpdCBpcyBzYWZlIHRvIGNvbnZlcnQgZ2l2ZW4gdmFsdWUgdG8gbmF0aXZlIG51bWJlcixcbiAqIGB0b051bWJlcigpYCBhbmQgYHRvU3RyaW5nKClgIHRvIGNvbnZlcnQgZ2l2ZW4gaW50ZWdlciB0byBudW1iZXIgb3Igc3RyaW5nIHJlc3BlY3RpdmVseS5cbiAqIEBhY2Nlc3MgcHVibGljXG4gKiBAZXhwb3J0cyBJbnRlZ2VyXG4gKiBAY2xhc3MgQSBJbnRlZ2VyIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSW50ZWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEludGVnZXIobG93LCBoaWdoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBJbnRlZ2VyKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICB0aGlzLmxvdyA9IGxvdyB8IDA7XG4gICAgLyoqXG4gICAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xuICB9IC8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhbiBJbnRlZ2VyIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxuICAvLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxuICAvLyBKYXZhU2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcbiAgLy8gbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYgYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxuICAvLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhU2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xuICAvLyBvciBjaGFuZ2UgaW4gc2lnbi5cbiAgLy9cbiAgLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxuICAvLyBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cbiAgLy8gTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXG4gIC8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcbiAgLy8gYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xuICAvLyBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXG4gIC8vXG4gIC8vIENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKlxuICAvLyBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShJbnRlZ2VyLCBbe1xuICAgIGtleTogXCJpblNhZmVSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpblNhZmVSYW5nZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdyZWF0ZXJUaGFuT3JFcXVhbChJbnRlZ2VyLk1JTl9TQUZFX1ZBTFVFKSAmJiB0aGlzLmxlc3NUaGFuT3JFcXVhbChJbnRlZ2VyLk1BWF9TQUZFX1ZBTFVFKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIEludGVnZXIgdG8gYW4gZXhhY3QgamF2YXNjcmlwdCBOdW1iZXIsIGFzc3VtaW5nIGl0IGlzIGEgMzIgYml0IGludGVnZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b0ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0ludCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIEludGVnZXIgdG8gYSB0aGUgbmVhcmVzdCBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZhbHVlIChkb3VibGUsIDUzIGJpdCBtYW50aXNzYSkuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b051bWJlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b051bWJlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBJbnRlZ2VyIHRvIG5hdGl2ZSBudW1iZXIgb3IgLUluZmluaXR5LytJbmZpbml0eSB3aGVuIGl0IGRvZXMgbm90IGZpdC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvTnVtYmVyT3JJbmZpbml0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b051bWJlck9ySW5maW5pdHkoKSB7XG4gICAgICBpZiAodGhpcy5sZXNzVGhhbihJbnRlZ2VyLk1JTl9TQUZFX1ZBTFVFKSkge1xuICAgICAgICByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmdyZWF0ZXJUaGFuKEludGVnZXIuTUFYX1NBRkVfVkFMVUUpKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy50b051bWJlcigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgSW50ZWdlciB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBSYWRpeCAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcmFkaXhgIGlzIG91dCBvZiByYW5nZVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XG4gICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuXG4gICAgICBpZiAocmFkaXggPCAyIHx8IHJhZGl4ID4gMzYpIHtcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXggb3V0IG9mIHJhbmdlOiAnICsgcmFkaXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICByZXR1cm4gJzAnO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVtO1xuXG4gICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgaWYgKHRoaXMuZXF1YWxzKEludGVnZXIuTUlOX1ZBTFVFKSkge1xuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBJbnRlZ2VyIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXG4gICAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxuICAgICAgICAgIHZhciByYWRpeEludGVnZXIgPSBJbnRlZ2VyLmZyb21OdW1iZXIocmFkaXgpO1xuICAgICAgICAgIHZhciBkaXYgPSB0aGlzLmRpdihyYWRpeEludGVnZXIpO1xuICAgICAgICAgIHJlbSA9IGRpdi5tdWx0aXBseShyYWRpeEludGVnZXIpLnN1YnRyYWN0KHRoaXMpO1xuICAgICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtLnRvSW50KCkudG9TdHJpbmcocmFkaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZ2F0ZSgpLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXG4gICAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cblxuXG4gICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gSW50ZWdlci5mcm9tTnVtYmVyKE1hdGgucG93KHJhZGl4LCA2KSk7XG4gICAgICByZW0gPSB0aGlzO1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpO1xuICAgICAgICB2YXIgaW50dmFsID0gcmVtLnN1YnRyYWN0KHJlbURpdi5tdWx0aXBseShyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwO1xuICAgICAgICB2YXIgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgcmVtID0gcmVtRGl2O1xuXG4gICAgICAgIGlmIChyZW0uaXNaZXJvKCkpIHtcbiAgICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9ICcnICsgZGlnaXRzICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRIaWdoQml0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcbiAgICAgIHJldHVybiB0aGlzLmhpZ2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG93Qml0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMubG93O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEludGVnZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXROdW1CaXRzQWJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7XG4gICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKEludGVnZXIuTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWdhdGUoKS5nZXROdW1CaXRzQWJzKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT09IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcblxuICAgICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKSB7XG4gICAgICAgIGlmICgodmFsICYgMSA8PCBiaXQpICE9PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuaGlnaCAhPT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBJbnRlZ2VyJ3MgdmFsdWUgZXF1YWxzIHplcm8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNaZXJvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzWmVybygpIHtcbiAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgSW50ZWdlcidzIHZhbHVlIGlzIG5lZ2F0aXZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzTmVnYXRpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhpZ2ggPCAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIEludGVnZXIncyB2YWx1ZSBpcyBwb3NpdGl2ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc1Bvc2l0aXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUG9zaXRpdmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaWdoID49IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgSW50ZWdlcidzIHZhbHVlIGlzIG9kZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc09kZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc09kZCgpIHtcbiAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBJbnRlZ2VyJ3MgdmFsdWUgaXMgZXZlbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0V2ZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFdmVuKCkge1xuICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIEludGVnZXIncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlcXVhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgICBpZiAoIUludGVnZXIuaXNJbnRlZ2VyKG90aGVyKSkge1xuICAgICAgICBvdGhlciA9IEludGVnZXIuZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIEludGVnZXIncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLlxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJub3RFcXVhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7XG4gICAgICByZXR1cm4gIXRoaXMuZXF1YWxzKFxuICAgICAgLyogdmFsaWRhdGVzICovXG4gICAgICBvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgSW50ZWdlcidzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxlc3NUaGFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlc3NUaGFuKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wYXJlKFxuICAgICAgLyogdmFsaWRhdGVzICovXG4gICAgICBvdGhlcikgPCAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIEludGVnZXIncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsZXNzVGhhbk9yRXF1YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wYXJlKFxuICAgICAgLyogdmFsaWRhdGVzICovXG4gICAgICBvdGhlcikgPD0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBJbnRlZ2VyJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JlYXRlclRoYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUoXG4gICAgICAvKiB2YWxpZGF0ZXMgKi9cbiAgICAgIG90aGVyKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgSW50ZWdlcidzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdyZWF0ZXJUaGFuT3JFcXVhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUoXG4gICAgICAvKiB2YWxpZGF0ZXMgKi9cbiAgICAgIG90aGVyKSA+PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0aGlzIEludGVnZXIncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxuICAgICAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb21wYXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgIGlmICghSW50ZWdlci5pc0ludGVnZXIob3RoZXIpKSB7XG4gICAgICAgIG90aGVyID0gSW50ZWdlci5mcm9tVmFsdWUob3RoZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5lcXVhbHMob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpO1xuICAgICAgdmFyIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpO1xuXG4gICAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IC8vIEF0IHRoaXMgcG9pbnQgdGhlIHNpZ24gYml0cyBhcmUgdGhlIHNhbWVcblxuXG4gICAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdChvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOZWdhdGVzIHRoaXMgSW50ZWdlcidzIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHshSW50ZWdlcn0gTmVnYXRlZCBJbnRlZ2VyXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmVnYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcbiAgICAgIGlmICh0aGlzLmVxdWFscyhJbnRlZ2VyLk1JTl9WQUxVRSkpIHtcbiAgICAgICAgcmV0dXJuIEludGVnZXIuTUlOX1ZBTFVFO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoSW50ZWdlci5PTkUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBJbnRlZ2VyLlxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ30gYWRkZW5kIEFkZGVuZFxuICAgICAqIEByZXR1cm5zIHshSW50ZWdlcn0gU3VtXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChhZGRlbmQpIHtcbiAgICAgIGlmICghSW50ZWdlci5pc0ludGVnZXIoYWRkZW5kKSkge1xuICAgICAgICBhZGRlbmQgPSBJbnRlZ2VyLmZyb21WYWx1ZShhZGRlbmQpO1xuICAgICAgfSAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cblxuXG4gICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcbiAgICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweGZmZmY7XG4gICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xuICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhmZmZmO1xuICAgICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcbiAgICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDB4ZmZmZjtcbiAgICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcbiAgICAgIHZhciBiMDAgPSBhZGRlbmQubG93ICYgMHhmZmZmO1xuICAgICAgdmFyIGM0OCA9IDA7XG4gICAgICB2YXIgYzMyID0gMDtcbiAgICAgIHZhciBjMTYgPSAwO1xuICAgICAgdmFyIGMwMCA9IDA7XG4gICAgICBjMDAgKz0gYTAwICsgYjAwO1xuICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgICBjMDAgJj0gMHhmZmZmO1xuICAgICAgYzE2ICs9IGExNiArIGIxNjtcbiAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgICAgYzE2ICY9IDB4ZmZmZjtcbiAgICAgIGMzMiArPSBhMzIgKyBiMzI7XG4gICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgIGMzMiAmPSAweGZmZmY7XG4gICAgICBjNDggKz0gYTQ4ICsgYjQ4O1xuICAgICAgYzQ4ICY9IDB4ZmZmZjtcbiAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIEludGVnZXIuXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9IERpZmZlcmVuY2VcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdWJ0cmFjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7XG4gICAgICBpZiAoIUludGVnZXIuaXNJbnRlZ2VyKHN1YnRyYWhlbmQpKSB7XG4gICAgICAgIHN1YnRyYWhlbmQgPSBJbnRlZ2VyLmZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnYXRlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZWdlci5cbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxuICAgICAqIEByZXR1cm5zIHshSW50ZWdlcn0gUHJvZHVjdFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm11bHRpcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgIHJldHVybiBJbnRlZ2VyLlpFUk87XG4gICAgICB9XG5cbiAgICAgIGlmICghSW50ZWdlci5pc0ludGVnZXIobXVsdGlwbGllcikpIHtcbiAgICAgICAgbXVsdGlwbGllciA9IEludGVnZXIuZnJvbVZhbHVlKG11bHRpcGxpZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSkge1xuICAgICAgICByZXR1cm4gSW50ZWdlci5aRVJPO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5lcXVhbHMoSW50ZWdlci5NSU5fVkFMVUUpKSB7XG4gICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBJbnRlZ2VyLk1JTl9WQUxVRSA6IEludGVnZXIuWkVSTztcbiAgICAgIH1cblxuICAgICAgaWYgKG11bHRpcGxpZXIuZXF1YWxzKEludGVnZXIuTUlOX1ZBTFVFKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gSW50ZWdlci5NSU5fVkFMVUUgOiBJbnRlZ2VyLlpFUk87XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGUoKS5tdWx0aXBseShtdWx0aXBsaWVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGUoKS5tdWx0aXBseShtdWx0aXBsaWVyKS5uZWdhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShtdWx0aXBsaWVyLm5lZ2F0ZSgpKS5uZWdhdGUoKTtcbiAgICAgIH0gLy8gSWYgYm90aCBsb25ncyBhcmUgc21hbGwsIHVzZSBmbG9hdCBtdWx0aXBsaWNhdGlvblxuXG5cbiAgICAgIGlmICh0aGlzLmxlc3NUaGFuKFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubGVzc1RoYW4oVFdPX1BXUl8yNCkpIHtcbiAgICAgICAgcmV0dXJuIEludGVnZXIuZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCkpO1xuICAgICAgfSAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cbiAgICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXG5cblxuICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhmZmZmO1xuICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4ZmZmZjtcbiAgICAgIHZhciBiNDggPSBtdWx0aXBsaWVyLmhpZ2ggPj4+IDE2O1xuICAgICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4ZmZmZjtcbiAgICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XG4gICAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiAweGZmZmY7XG4gICAgICB2YXIgYzQ4ID0gMDtcbiAgICAgIHZhciBjMzIgPSAwO1xuICAgICAgdmFyIGMxNiA9IDA7XG4gICAgICB2YXIgYzAwID0gMDtcbiAgICAgIGMwMCArPSBhMDAgKiBiMDA7XG4gICAgICBjMTYgKz0gYzAwID4+PiAxNjtcbiAgICAgIGMwMCAmPSAweGZmZmY7XG4gICAgICBjMTYgKz0gYTE2ICogYjAwO1xuICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gICAgICBjMTYgJj0gMHhmZmZmO1xuICAgICAgYzE2ICs9IGEwMCAqIGIxNjtcbiAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgICAgYzE2ICY9IDB4ZmZmZjtcbiAgICAgIGMzMiArPSBhMzIgKiBiMDA7XG4gICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgIGMzMiAmPSAweGZmZmY7XG4gICAgICBjMzIgKz0gYTE2ICogYjE2O1xuICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICBjMzIgJj0gMHhmZmZmO1xuICAgICAgYzMyICs9IGEwMCAqIGIzMjtcbiAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XG4gICAgICBjNDggJj0gMHhmZmZmO1xuICAgICAgcmV0dXJuIEludGVnZXIuZnJvbUJpdHMoYzE2IDw8IDE2IHwgYzAwLCBjNDggPDwgMTYgfCBjMzIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgSW50ZWdlciBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9IFF1b3RpZW50XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGl2XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpdihkaXZpc29yKSB7XG4gICAgICBpZiAoIUludGVnZXIuaXNJbnRlZ2VyKGRpdmlzb3IpKSB7XG4gICAgICAgIGRpdmlzb3IgPSBJbnRlZ2VyLmZyb21WYWx1ZShkaXZpc29yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgcmV0dXJuIEludGVnZXIuWkVSTztcbiAgICAgIH1cblxuICAgICAgdmFyIGFwcHJveCwgcmVtLCByZXM7XG5cbiAgICAgIGlmICh0aGlzLmVxdWFscyhJbnRlZ2VyLk1JTl9WQUxVRSkpIHtcbiAgICAgICAgaWYgKGRpdmlzb3IuZXF1YWxzKEludGVnZXIuT05FKSB8fCBkaXZpc29yLmVxdWFscyhJbnRlZ2VyLk5FR19PTkUpKSB7XG4gICAgICAgICAgcmV0dXJuIEludGVnZXIuTUlOX1ZBTFVFO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpdmlzb3IuZXF1YWxzKEludGVnZXIuTUlOX1ZBTFVFKSkge1xuICAgICAgICAgIHJldHVybiBJbnRlZ2VyLk9ORTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHxvdGhlcnwgPj0gMiwgc28gfHRoaXMvb3RoZXJ8IDwgfE1JTl9WQUxVRXwuXG4gICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaGlmdFJpZ2h0KDEpO1xuICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGlmdExlZnQoMSk7XG5cbiAgICAgICAgICBpZiAoYXBwcm94LmVxdWFscyhJbnRlZ2VyLlpFUk8pKSB7XG4gICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBJbnRlZ2VyLk9ORSA6IEludGVnZXIuTkVHX09ORTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtID0gdGhpcy5zdWJ0cmFjdChkaXZpc29yLm11bHRpcGx5KGFwcHJveCkpO1xuICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXF1YWxzKEludGVnZXIuTUlOX1ZBTFVFKSkge1xuICAgICAgICByZXR1cm4gSW50ZWdlci5aRVJPO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCkuZGl2KGRpdmlzb3IubmVnYXRlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCkuZGl2KGRpdmlzb3IpLm5lZ2F0ZSgpO1xuICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWdhdGUoKSkubmVnYXRlKCk7XG4gICAgICB9IC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXG4gICAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXG4gICAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XG4gICAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXG4gICAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cblxuXG4gICAgICByZXMgPSBJbnRlZ2VyLlpFUk87XG4gICAgICByZW0gPSB0aGlzO1xuXG4gICAgICB3aGlsZSAocmVtLmdyZWF0ZXJUaGFuT3JFcXVhbChkaXZpc29yKSkge1xuICAgICAgICAvLyBBcHByb3hpbWF0ZSB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uLiBUaGlzIG1heSBiZSBhIGxpdHRsZSBncmVhdGVyIG9yXG4gICAgICAgIC8vIHNtYWxsZXIgdGhhbiB0aGUgYWN0dWFsIHZhbHVlLlxuICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7IC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcbiAgICAgICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxuXG4gICAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMik7XG4gICAgICAgIHZhciBkZWx0YSA9IGxvZzIgPD0gNDggPyAxIDogTWF0aC5wb3coMiwgbG9nMiAtIDQ4KTsgLy8gRGVjcmVhc2UgdGhlIGFwcHJveGltYXRpb24gdW50aWwgaXQgaXMgc21hbGxlciB0aGFuIHRoZSByZW1haW5kZXIuICBOb3RlXG4gICAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxuXG4gICAgICAgIHZhciBhcHByb3hSZXMgPSBJbnRlZ2VyLmZyb21OdW1iZXIoYXBwcm94KTtcbiAgICAgICAgdmFyIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWx0aXBseShkaXZpc29yKTtcblxuICAgICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3JlYXRlclRoYW4ocmVtKSkge1xuICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcbiAgICAgICAgICBhcHByb3hSZXMgPSBJbnRlZ2VyLmZyb21OdW1iZXIoYXBwcm94KTtcbiAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsdGlwbHkoZGl2aXNvcik7XG4gICAgICAgIH0gLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXG4gICAgICAgIC8vIGluZmluaXRlIHJlY3Vyc2lvbiBzaW5jZSB3ZSB3b3VsZCBtYWtlIG5vIHByb2dyZXNzLlxuXG5cbiAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSkge1xuICAgICAgICAgIGFwcHJveFJlcyA9IEludGVnZXIuT05FO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xuICAgICAgICByZW0gPSByZW0uc3VidHJhY3QoYXBwcm94UmVtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIEludGVnZXIgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9IFJlbWFpbmRlclxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1vZHVsb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikge1xuICAgICAgaWYgKCFJbnRlZ2VyLmlzSW50ZWdlcihkaXZpc29yKSkge1xuICAgICAgICBkaXZpc29yID0gSW50ZWdlci5mcm9tVmFsdWUoZGl2aXNvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KHRoaXMuZGl2KGRpdmlzb3IpLm11bHRpcGx5KGRpdmlzb3IpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBOT1Qgb2YgdGhpcyBJbnRlZ2VyLlxuICAgICAqIEByZXR1cm5zIHshSW50ZWdlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJub3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm90KCkge1xuICAgICAgcmV0dXJuIEludGVnZXIuZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBJbnRlZ2VyIGFuZCB0aGUgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgSW50ZWdlclxuICAgICAqIEByZXR1cm5zIHshSW50ZWdlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5kKG90aGVyKSB7XG4gICAgICBpZiAoIUludGVnZXIuaXNJbnRlZ2VyKG90aGVyKSkge1xuICAgICAgICBvdGhlciA9IEludGVnZXIuZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEludGVnZXIuZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE9SIG9mIHRoaXMgSW50ZWdlciBhbmQgdGhlIHNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIEludGVnZXJcbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3Iob3RoZXIpIHtcbiAgICAgIGlmICghSW50ZWdlci5pc0ludGVnZXIob3RoZXIpKSB7XG4gICAgICAgIG90aGVyID0gSW50ZWdlci5mcm9tVmFsdWUob3RoZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gSW50ZWdlci5mcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgWE9SIG9mIHRoaXMgSW50ZWdlciBhbmQgdGhlIGdpdmVuIG9uZS5cbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIEludGVnZXJcbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwieG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHhvcihvdGhlcikge1xuICAgICAgaWYgKCFJbnRlZ2VyLmlzSW50ZWdlcihvdGhlcikpIHtcbiAgICAgICAgb3RoZXIgPSBJbnRlZ2VyLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIEludGVnZXIgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcnwhSW50ZWdlcn0gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgICAqIEByZXR1cm5zIHshSW50ZWdlcn0gU2hpZnRlZCBJbnRlZ2VyXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRMZWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0TGVmdChudW1CaXRzKSB7XG4gICAgICBpZiAoSW50ZWdlci5pc0ludGVnZXIobnVtQml0cykpIHtcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA8IDMyKSB7XG4gICAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsIHRoaXMuaGlnaCA8PCBudW1CaXRzIHwgdGhpcy5sb3cgPj4+IDMyIC0gbnVtQml0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSW50ZWdlci5mcm9tQml0cygwLCB0aGlzLmxvdyA8PCBudW1CaXRzIC0gMzIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgSW50ZWdlciB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcnwhSW50ZWdlcn0gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgICAqIEByZXR1cm5zIHshSW50ZWdlcn0gU2hpZnRlZCBJbnRlZ2VyXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRSaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdFJpZ2h0KG51bUJpdHMpIHtcbiAgICAgIGlmIChJbnRlZ2VyLmlzSW50ZWdlcihudW1CaXRzKSkge1xuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICAgICAgcmV0dXJuIEludGVnZXIuZnJvbUJpdHModGhpcy5sb3cgPj4+IG51bUJpdHMgfCB0aGlzLmhpZ2ggPDwgMzIgLSBudW1CaXRzLCB0aGlzLmhpZ2ggPj4gbnVtQml0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSW50ZWdlci5mcm9tQml0cyh0aGlzLmhpZ2ggPj4gbnVtQml0cyAtIDMyLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBJbnRlZ2VyO1xufSgpO1xuLyoqXG4gKiBBbiBpbmRpY2F0b3IgdXNlZCB0byByZWxpYWJseSBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgSW50ZWdlciBvciBub3QuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBjb25zdFxuICogQGV4cG9zZVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkludGVnZXIuX19pc0ludGVnZXJfXyA9IHRydWU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW50ZWdlci5wcm90b3R5cGUsICdfX2lzSW50ZWdlcl9fJywge1xuICB2YWx1ZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn0pO1xuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIEludGVnZXIuXG4gKiBAYWNjZXNzIHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAZXhwb3NlXG4gKi9cblxuSW50ZWdlci5pc0ludGVnZXIgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiAob2JqICYmIG9iai5fX2lzSW50ZWdlcl9fKSA9PT0gdHJ1ZTtcbn07XG4vKipcbiAqIEEgY2FjaGUgb2YgdGhlIEludGVnZXIgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxuICogQHR5cGUgeyFPYmplY3R9XG4gKiBAaW5uZXJcbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgSU5UX0NBQ0hFID0ge307XG4vKipcbiAqIFJldHVybnMgYSBJbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gMzIgYml0IGludGVnZXIgdmFsdWUuXG4gKiBAYWNjZXNzIHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzIgYml0IGludGVnZXIgaW4gcXVlc3Rpb25cbiAqIEByZXR1cm5zIHshSW50ZWdlcn0gVGhlIGNvcnJlc3BvbmRpbmcgSW50ZWdlciB2YWx1ZVxuICogQGV4cG9zZVxuICovXG5cbkludGVnZXIuZnJvbUludCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgb2JqLCBjYWNoZWRPYmo7XG4gIHZhbHVlID0gdmFsdWUgfCAwO1xuXG4gIGlmICh2YWx1ZSA+PSAtMTI4ICYmIHZhbHVlIDwgMTI4KSB7XG4gICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcblxuICAgIGlmIChjYWNoZWRPYmopIHtcbiAgICAgIHJldHVybiBjYWNoZWRPYmo7XG4gICAgfVxuICB9XG5cbiAgb2JqID0gbmV3IEludGVnZXIodmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xuXG4gIGlmICh2YWx1ZSA+PSAtMTI4ICYmIHZhbHVlIDwgMTI4KSB7XG4gICAgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgSW50ZWdlciByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZhbHVlLCBwcm92aWRlZCB0aGF0IGl0IGlzIGEgZmluaXRlIG51bWJlci4gT3RoZXJ3aXNlLCB6ZXJvIGlzIHJldHVybmVkLlxuICogQGFjY2VzcyBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBpbiBxdWVzdGlvblxuICogQHJldHVybnMgeyFJbnRlZ2VyfSBUaGUgY29ycmVzcG9uZGluZyBJbnRlZ2VyIHZhbHVlXG4gKiBAZXhwb3NlXG4gKi9cblxuXG5JbnRlZ2VyLmZyb21OdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIEludGVnZXIuWkVSTztcbiAgfVxuXG4gIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpIHtcbiAgICByZXR1cm4gSW50ZWdlci5NSU5fVkFMVUU7XG4gIH1cblxuICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKSB7XG4gICAgcmV0dXJuIEludGVnZXIuTUFYX1ZBTFVFO1xuICB9XG5cbiAgaWYgKHZhbHVlIDwgMCkge1xuICAgIHJldHVybiBJbnRlZ2VyLmZyb21OdW1iZXIoLXZhbHVlKS5uZWdhdGUoKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgSW50ZWdlcih2YWx1ZSAlIFRXT19QV1JfMzJfREJMIHwgMCwgdmFsdWUgLyBUV09fUFdSXzMyX0RCTCB8IDApO1xufTtcbi8qKlxuICogUmV0dXJucyBhIEludGVnZXIgcmVwcmVzZW50aW5nIHRoZSA2NCBiaXQgaW50ZWdlciB0aGF0IGNvbWVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxvdyBhbmQgaGlnaCBiaXRzLiBFYWNoIGlzXG4gKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHMgVGhlIGxvdyAzMiBiaXRzXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xuICogQHJldHVybnMgeyFJbnRlZ2VyfSBUaGUgY29ycmVzcG9uZGluZyBJbnRlZ2VyIHZhbHVlXG4gKiBAZXhwb3NlXG4gKi9cblxuXG5JbnRlZ2VyLmZyb21CaXRzID0gZnVuY3Rpb24gKGxvd0JpdHMsIGhpZ2hCaXRzKSB7XG4gIHJldHVybiBuZXcgSW50ZWdlcihsb3dCaXRzLCBoaWdoQml0cyk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgSW50ZWdlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gKiBAYWNjZXNzIHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIEludGVnZXJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggVGhlIHJhZGl4IGluIHdoaWNoIHRoZSB0ZXh0IGlzIHdyaXR0ZW4gKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICogQHJldHVybnMgeyFJbnRlZ2VyfSBUaGUgY29ycmVzcG9uZGluZyBJbnRlZ2VyIHZhbHVlXG4gKiBAZXhwb3NlXG4gKi9cblxuXG5JbnRlZ2VyLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyLCByYWRpeCkge1xuICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdudW1iZXIgZm9ybWF0IGVycm9yOiBlbXB0eSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmIChzdHIgPT09ICdOYU4nIHx8IHN0ciA9PT0gJ0luZmluaXR5JyB8fCBzdHIgPT09ICcrSW5maW5pdHknIHx8IHN0ciA9PT0gJy1JbmZpbml0eScpIHtcbiAgICByZXR1cm4gSW50ZWdlci5aRVJPO1xuICB9XG5cbiAgcmFkaXggPSByYWRpeCB8fCAxMDtcblxuICBpZiAocmFkaXggPCAyIHx8IHJhZGl4ID4gMzYpIHtcbiAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgncmFkaXggb3V0IG9mIHJhbmdlOiAnICsgcmFkaXgpO1xuICB9XG5cbiAgdmFyIHA7XG5cbiAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKSB7XG4gICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ251bWJlciBmb3JtYXQgZXJyb3I6IGludGVyaW9yIFwiLVwiIGNoYXJhY3RlcjogJyArIHN0cik7XG4gIH0gZWxzZSBpZiAocCA9PT0gMCkge1xuICAgIHJldHVybiBJbnRlZ2VyLmZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgcmFkaXgpLm5lZ2F0ZSgpO1xuICB9IC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cbiAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXG5cblxuICB2YXIgcmFkaXhUb1Bvd2VyID0gSW50ZWdlci5mcm9tTnVtYmVyKE1hdGgucG93KHJhZGl4LCA4KSk7XG4gIHZhciByZXN1bHQgPSBJbnRlZ2VyLlpFUk87XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcbiAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKTtcbiAgICB2YXIgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xuXG4gICAgaWYgKHNpemUgPCA4KSB7XG4gICAgICB2YXIgcG93ZXIgPSBJbnRlZ2VyLmZyb21OdW1iZXIoTWF0aC5wb3cocmFkaXgsIHNpemUpKTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWx0aXBseShwb3dlcikuYWRkKEludGVnZXIuZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQubXVsdGlwbHkocmFkaXhUb1Bvd2VyKTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoSW50ZWdlci5mcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBJbnRlZ2VyLlxuICogQGFjY2VzcyBwcml2YXRlXG4gKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyfX0gdmFsIFZhbHVlXG4gKiBAcmV0dXJucyB7IUludGVnZXJ9XG4gKiBAZXhwb3NlXG4gKi9cblxuXG5JbnRlZ2VyLmZyb21WYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgaWYgKHZhbFxuICAvKiBpcyBjb21wYXRpYmxlICovXG4gIGluc3RhbmNlb2YgSW50ZWdlcikge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gSW50ZWdlci5mcm9tTnVtYmVyKHZhbCk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gSW50ZWdlci5mcm9tU3RyaW5nKHZhbCk7XG4gIH0gLy8gVGhyb3dzIGZvciBub24tb2JqZWN0cywgY29udmVydHMgbm9uLWluc3RhbmNlb2YgSW50ZWdlcjpcblxuXG4gIHJldHVybiBuZXcgSW50ZWdlcih2YWwubG93LCB2YWwuaGlnaCk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgbnVtYmVyLlxuICogQGFjY2VzcyBwcml2YXRlXG4gKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyfX0gdmFsIFZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICogQGV4cG9zZVxuICovXG5cblxuSW50ZWdlci50b051bWJlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIEludGVnZXIuZnJvbVZhbHVlKHZhbCkudG9OdW1iZXIoKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBzdHJpbmcuXG4gKiBAYWNjZXNzIHByaXZhdGVcbiAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXJ9fSB2YWwgVmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpeCBvcHRpb25hbCByYWRpeCBmb3Igc3RyaW5nIGNvbnZlcnNpb24sIGRlZmF1bHRzIHRvIDEwXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogQGV4cG9zZVxuICovXG5cblxuSW50ZWdlci50b1N0cmluZyA9IGZ1bmN0aW9uICh2YWwsIHJhZGl4KSB7XG4gIHJldHVybiBJbnRlZ2VyLmZyb21WYWx1ZSh2YWwpLnRvU3RyaW5nKHJhZGl4KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgaW4gdGhlIHNhZmUgcmFuZ2UgaW4gb3JkZXIgdG8gYmUgY29udmVydGVkIHRvIGEgbmF0aXZlIG51bWJlclxuICogQGFjY2VzcyBwcml2YXRlXG4gKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyfX0gdmFsIFZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXggb3B0aW9uYWwgcmFkaXggZm9yIHN0cmluZyBjb252ZXJzaW9uLCBkZWZhdWx0cyB0byAxMFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAZXhwb3NlXG4gKi9cblxuXG5JbnRlZ2VyLmluU2FmZVJhbmdlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gSW50ZWdlci5mcm9tVmFsdWUodmFsKS5pblNhZmVSYW5nZSgpO1xufTtcbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjtcbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqIEBpbm5lclxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKiBAaW5uZXJcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDtcbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcbi8qKlxuICogQHR5cGUgeyFJbnRlZ2VyfVxuICogQGNvbnN0XG4gKiBAaW5uZXJcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIFRXT19QV1JfMjQgPSBJbnRlZ2VyLmZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xuLyoqXG4gKiBTaWduZWQgemVyby5cbiAqIEB0eXBlIHshSW50ZWdlcn1cbiAqIEBleHBvc2VcbiAqL1xuXG5JbnRlZ2VyLlpFUk8gPSBJbnRlZ2VyLmZyb21JbnQoMCk7XG4vKipcbiAqIFNpZ25lZCBvbmUuXG4gKiBAdHlwZSB7IUludGVnZXJ9XG4gKiBAZXhwb3NlXG4gKi9cblxuSW50ZWdlci5PTkUgPSBJbnRlZ2VyLmZyb21JbnQoMSk7XG4vKipcbiAqIFNpZ25lZCBuZWdhdGl2ZSBvbmUuXG4gKiBAdHlwZSB7IUludGVnZXJ9XG4gKiBAZXhwb3NlXG4gKi9cblxuSW50ZWdlci5ORUdfT05FID0gSW50ZWdlci5mcm9tSW50KC0xKTtcbi8qKlxuICogTWF4aW11bSBzaWduZWQgdmFsdWUuXG4gKiBAdHlwZSB7IUludGVnZXJ9XG4gKiBAZXhwb3NlXG4gKi9cblxuSW50ZWdlci5NQVhfVkFMVUUgPSBJbnRlZ2VyLmZyb21CaXRzKDB4ZmZmZmZmZmYgfCAwLCAweDdmZmZmZmZmIHwgMCwgZmFsc2UpO1xuLyoqXG4gKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cbiAqIEB0eXBlIHshSW50ZWdlcn1cbiAqIEBleHBvc2VcbiAqL1xuXG5JbnRlZ2VyLk1JTl9WQUxVRSA9IEludGVnZXIuZnJvbUJpdHMoMCwgMHg4MDAwMDAwMCB8IDAsIGZhbHNlKTtcbi8qKlxuICogTWluaW11bSBzYWZlIHZhbHVlLlxuICogQHR5cGUgeyFJbnRlZ2VyfVxuICogQGV4cG9zZVxuICovXG5cbkludGVnZXIuTUlOX1NBRkVfVkFMVUUgPSBJbnRlZ2VyLmZyb21CaXRzKDB4MSB8IDAsIDB4ZmZmZmZmZmZmZmUwMDAwMCB8IDApO1xuLyoqXG4gKiBNYXhpbXVtIHNhZmUgdmFsdWUuXG4gKiBAdHlwZSB7IUludGVnZXJ9XG4gKiBAZXhwb3NlXG4gKi9cblxuSW50ZWdlci5NQVhfU0FGRV9WQUxVRSA9IEludGVnZXIuZnJvbUJpdHMoMHhmZmZmZmZmZiB8IDAsIDB4MWZmZmZmIHwgMCk7XG4vKipcbiAqIENhc3QgdmFsdWUgdG8gSW50ZWdlciB0eXBlLlxuICogQGFjY2VzcyBwdWJsaWNcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHVzZS5cbiAqIEByZXR1cm4ge0ludGVnZXJ9IC0gQW4gb2JqZWN0IG9mIHR5cGUgSW50ZWdlci5cbiAqL1xuXG52YXIgX2ludCA9IEludGVnZXIuZnJvbVZhbHVlO1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhcmlhYmxlIGlzIG9mIEludGVnZXIgdHlwZS5cbiAqIEBhY2Nlc3MgcHVibGljXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAtIFRoZSB2YXJpYWJsZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gSXMgaXQgb2YgdGhlIEludGVnZXIgdHlwZT9cbiAqL1xuXG5leHBvcnRzW1wiaW50XCJdID0gX2ludDtcbnZhciBpc0ludCA9IEludGVnZXIuaXNJbnRlZ2VyO1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhcmlhYmxlIGNhbiBiZSBzYWZlbHkgY29udmVydGVkIHRvIGEgbnVtYmVyXG4gKiBAYWNjZXNzIHB1YmxpY1xuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgLSBUaGUgdmFyaWFibGUgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBpdCBpcyBzYWZlIHRvIGNhbGwgdG9OdW1iZXIgb24gdmFyaWFibGUgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cblxuZXhwb3J0cy5pc0ludCA9IGlzSW50O1xudmFyIGluU2FmZVJhbmdlID0gSW50ZWdlci5pblNhZmVSYW5nZTtcbi8qKlxuICogQ29udmVydHMgYSB2YXJpYWJsZSB0byBhIG51bWJlclxuICogQGFjY2VzcyBwdWJsaWNcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIC0gVGhlIHZhcmlhYmxlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge251bWJlcn0gLSB0aGUgdmFyaWFibGUgYXMgYSBudW1iZXJcbiAqL1xuXG5leHBvcnRzLmluU2FmZVJhbmdlID0gaW5TYWZlUmFuZ2U7XG52YXIgdG9OdW1iZXIgPSBJbnRlZ2VyLnRvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgaW50ZWdlciB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvblxuICogQGFjY2VzcyBwdWJsaWNcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIC0gVGhlIHZhcmlhYmxlIHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpeCAtIHJhZGl4IHRvIHVzZSBpbiBzdHJpbmcgY29udmVyc2lvbiwgZGVmYXVsdHMgdG8gMTBcbiAqIEByZXR1cm4ge3N0cmluZ30gLSByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnRlZ2VyXG4gKi9cblxuZXhwb3J0cy50b051bWJlciA9IHRvTnVtYmVyO1xudmFyIHRvU3RyaW5nID0gSW50ZWdlci50b1N0cmluZztcbmV4cG9ydHMudG9TdHJpbmcgPSB0b1N0cmluZztcbnZhciBfZGVmYXVsdCA9IEludGVnZXI7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hc3NlcnREYXRhYmFzZUlzRW1wdHkgPSBhc3NlcnREYXRhYmFzZUlzRW1wdHk7XG5leHBvcnRzLmFzc2VydFR4Q29uZmlnSXNFbXB0eSA9IGFzc2VydFR4Q29uZmlnSXNFbXB0eTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuLi9lcnJvclwiKTtcblxudmFyIF9zdHJlYW1PYnNlcnZlcnMgPSByZXF1aXJlKFwiLi9zdHJlYW0tb2JzZXJ2ZXJzXCIpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1R4Q29uZmlnfSB0eENvbmZpZyB0aGUgYXV0by1jb21taXQgdHJhbnNhY3Rpb24gY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvbiB0aGUgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSB7UmVzdWx0U3RyZWFtT2JzZXJ2ZXJ9IG9ic2VydmVyIHRoZSByZXNwb25zZSBvYnNlcnZlci5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VHhDb25maWdJc0VtcHR5KHR4Q29uZmlnLCBjb25uZWN0aW9uLCBvYnNlcnZlcikge1xuICBpZiAodHhDb25maWcgJiYgIXR4Q29uZmlnLmlzRW1wdHkoKSkge1xuICAgIHZhciBlcnJvciA9ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdEcml2ZXIgaXMgY29ubmVjdGVkIHRvIHRoZSBkYXRhYmFzZSB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdHJhbnNhY3Rpb24gY29uZmlndXJhdGlvbi4gJyArICdQbGVhc2UgdXBncmFkZSB0byBuZW80aiAzLjUuMCBvciBsYXRlciBpbiBvcmRlciB0byB1c2UgdGhpcyBmdW5jdGlvbmFsaXR5Jyk7IC8vIHVuc3VwcG9ydGVkIEFQSSB3YXMgdXNlZCwgY29uc2lkZXIgdGhpcyBhIGZhdGFsIGVycm9yIGZvciB0aGUgY3VycmVudCBjb25uZWN0aW9uXG5cbiAgICBjb25uZWN0aW9uLl9oYW5kbGVGYXRhbEVycm9yKGVycm9yKTtcblxuICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgcGFzc2VkLWluIGRhdGFiYXNlIG5hbWUgaXMgZW1wdHkuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2VcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0RGF0YWJhc2VJc0VtcHR5KGRhdGFiYXNlLCBjb25uZWN0aW9uLCBvYnNlcnZlcikge1xuICBpZiAoZGF0YWJhc2UpIHtcbiAgICB2YXIgZXJyb3IgPSAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnRHJpdmVyIGlzIGNvbm5lY3RlZCB0byB0aGUgZGF0YWJhc2UgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IG11bHRpcGxlIGRhdGFiYXNlcy4gJyArICdQbGVhc2UgdXBncmFkZSB0byBuZW80aiA0LjAuMCBvciBsYXRlciBpbiBvcmRlciB0byB1c2UgdGhpcyBmdW5jdGlvbmFsaXR5Jyk7IC8vIHVuc3VwcG9ydGVkIEFQSSB3YXMgdXNlZCwgY29uc2lkZXIgdGhpcyBhIGZhdGFsIGVycm9yIGZvciB0aGUgY3VycmVudCBjb25uZWN0aW9uXG5cbiAgICBjb25uZWN0aW9uLl9oYW5kbGVGYXRhbEVycm9yKGVycm9yKTtcblxuICAgIG9ic2VydmVyLm9uRXJyb3IoZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfYm9sdFByb3RvY29sVXRpbCA9IHJlcXVpcmUoXCIuL2JvbHQtcHJvdG9jb2wtdXRpbFwiKTtcblxudmFyIF9ib29rbWFyayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYm9va21hcmtcIikpO1xuXG52YXIgX2NodW5raW5nID0gcmVxdWlyZShcIi4vY2h1bmtpbmdcIik7XG5cbnZhciBfY29ubmVjdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29ubmVjdGlvblwiKSk7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXG52YXIgdjEgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9wYWNrc3RyZWFtLXYxXCIpKTtcblxudmFyIF9yZXF1ZXN0TWVzc2FnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVxdWVzdC1tZXNzYWdlXCIpKTtcblxudmFyIF9zdHJlYW1PYnNlcnZlcnMgPSByZXF1aXJlKFwiLi9zdHJlYW0tb2JzZXJ2ZXJzXCIpO1xuXG52YXIgX3R4Q29uZmlnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi90eC1jb25maWdcIikpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBCb2x0UHJvdG9jb2wgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvbiB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtDaHVua2VyfSBjaHVua2VyIHRoZSBjaHVua2VyLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVMb3NzbGVzc0ludGVnZXJzIGlmIHRoaXMgY29ubmVjdGlvbiBzaG91bGQgY29udmVydCBhbGwgcmVjZWl2ZWQgaW50ZWdlcnMgdG8gbmF0aXZlIEpTIG51bWJlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBCb2x0UHJvdG9jb2woY29ubmVjdGlvbiwgY2h1bmtlciwgZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIEJvbHRQcm90b2NvbCk7XG4gICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5fcGFja2VyID0gdGhpcy5fY3JlYXRlUGFja2VyKGNodW5rZXIpO1xuICAgIHRoaXMuX3VucGFja2VyID0gdGhpcy5fY3JlYXRlVW5wYWNrZXIoZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1lcmljYWwgdmVyc2lvbiBpZGVudGlmaWVyIGZvciB0aGlzIHByb3RvY29sXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShCb2x0UHJvdG9jb2wsIFt7XG4gICAga2V5OiBcInBhY2tlclwiLFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwYWNrZXIuXG4gICAgICogQHJldHVybiB7UGFja2VyfSB0aGUgcHJvdG9jb2wncyBwYWNrZXIuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhY2tlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWNrZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdW5wYWNrZXIuXG4gICAgICogQHJldHVybiB7VW5wYWNrZXJ9IHRoZSBwcm90b2NvbCdzIHVucGFja2VyLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5wYWNrZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5wYWNrZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdW5wYWNrZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBtZXRhZGF0YSByZWNlaXZlZCBpbiBTVUNDRVNTIG1lc3NhZ2UgYmVmb3JlIGl0IGlzIHBhc3NlZCB0byB0aGUgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YWRhdGEgdGhlIHJlY2VpdmVkIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdHJhbnNmb3JtZWQgbWV0YWRhdGEuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2Zvcm1NZXRhZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1NZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGluaXRpYWxpemF0aW9uIGFuZCBhdXRoZW50aWNhdGlvbiBvZiB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbS51c2VyQWdlbnQgdGhlIHVzZXIgYWdlbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtLmF1dGhUb2tlbiB0aGUgYXV0aGVudGljYXRpb24gdG9rZW4uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IEVycm9yKX0gcGFyYW0ub25FcnJvciB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gcGFyYW0ub25Db21wbGV0ZSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIG9uIGNvbXBsZXRpb24uXG4gICAgICogQHJldHVybnMge1N0cmVhbU9ic2VydmVyfSB0aGUgc3RyZWFtIG9ic2VydmVyIHRoYXQgbW9uaXRvcnMgdGhlIGNvcnJlc3BvbmRpbmcgc2VydmVyIHJlc3BvbnNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIHVzZXJBZ2VudCA9IF9yZWYudXNlckFnZW50LFxuICAgICAgICAgIGF1dGhUb2tlbiA9IF9yZWYuYXV0aFRva2VuLFxuICAgICAgICAgIG9uRXJyb3IgPSBfcmVmLm9uRXJyb3IsXG4gICAgICAgICAgb25Db21wbGV0ZSA9IF9yZWYub25Db21wbGV0ZTtcblxuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IF9zdHJlYW1PYnNlcnZlcnMuTG9naW5PYnNlcnZlcih7XG4gICAgICAgIGNvbm5lY3Rpb246IHRoaXMuX2Nvbm5lY3Rpb24sXG4gICAgICAgIGFmdGVyRXJyb3I6IG9uRXJyb3IsXG4gICAgICAgIGFmdGVyQ29tcGxldGU6IG9uQ29tcGxldGVcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLndyaXRlKF9yZXF1ZXN0TWVzc2FnZVtcImRlZmF1bHRcIl0uaW5pdCh1c2VyQWdlbnQsIGF1dGhUb2tlbiksIG9ic2VydmVyLCB0cnVlKTtcblxuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIHByb3RvY29sIHJlbGF0ZWQgb3BlcmF0aW9ucyBmb3IgY2xvc2luZyB0aGlzIGNvbm5lY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByZXBhcmVUb0Nsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcmVUb0Nsb3NlKCkge30gLy8gbm8gbmVlZCB0byBub3RpZnkgdGhlIGRhdGFiYXNlIGluIHRoaXMgcHJvdG9jb2wgdmVyc2lvblxuXG4gICAgLyoqXG4gICAgICogQmVnaW4gYW4gZXhwbGljaXQgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gICAgICogQHBhcmFtIHtCb29rbWFya30gcGFyYW0uYm9va21hcmsgdGhlIGJvb2ttYXJrLlxuICAgICAqIEBwYXJhbSB7VHhDb25maWd9IHBhcmFtLnR4Q29uZmlnIHRoZSBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbS5kYXRhYmFzZSB0aGUgdGFyZ2V0IGRhdGFiYXNlIG5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtLm1vZGUgdGhlIGFjY2VzcyBtb2RlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBFcnJvcil9IHBhcmFtLmJlZm9yZUVycm9yIHRoZSBjYWxsYmFjayB0byBpbnZva2UgYmVmb3JlIGhhbmRsaW5nIHRoZSBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycjogRXJyb3IpfSBwYXJhbS5hZnRlckVycm9yIHRoZSBjYWxsYmFjayB0byBpbnZva2UgYWZ0ZXIgaGFuZGxpbmcgdGhlIGVycm9yLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gcGFyYW0uYmVmb3JlQ29tcGxldGUgdGhlIGNhbGxiYWNrIHRvIGludm9rZSBiZWZvcmUgaGFuZGxpbmcgdGhlIGNvbXBsZXRpb24uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBwYXJhbS5hZnRlckNvbXBsZXRlIHRoZSBjYWxsYmFjayB0byBpbnZva2UgYWZ0ZXIgaGFuZGxpbmcgdGhlIGNvbXBsZXRpb24uXG4gICAgICogQHJldHVybnMge1N0cmVhbU9ic2VydmVyfSB0aGUgc3RyZWFtIG9ic2VydmVyIHRoYXQgbW9uaXRvcnMgdGhlIGNvcnJlc3BvbmRpbmcgc2VydmVyIHJlc3BvbnNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYmVnaW5UcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWdpblRyYW5zYWN0aW9uKCkge1xuICAgICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBib29rbWFyayA9IF9yZWYyLmJvb2ttYXJrLFxuICAgICAgICAgIHR4Q29uZmlnID0gX3JlZjIudHhDb25maWcsXG4gICAgICAgICAgZGF0YWJhc2UgPSBfcmVmMi5kYXRhYmFzZSxcbiAgICAgICAgICBtb2RlID0gX3JlZjIubW9kZSxcbiAgICAgICAgICBiZWZvcmVFcnJvciA9IF9yZWYyLmJlZm9yZUVycm9yLFxuICAgICAgICAgIGFmdGVyRXJyb3IgPSBfcmVmMi5hZnRlckVycm9yLFxuICAgICAgICAgIGJlZm9yZUNvbXBsZXRlID0gX3JlZjIuYmVmb3JlQ29tcGxldGUsXG4gICAgICAgICAgYWZ0ZXJDb21wbGV0ZSA9IF9yZWYyLmFmdGVyQ29tcGxldGU7XG5cbiAgICAgIHJldHVybiB0aGlzLnJ1bignQkVHSU4nLCBib29rbWFyayA/IGJvb2ttYXJrLmFzQmVnaW5UcmFuc2FjdGlvblBhcmFtZXRlcnMoKSA6IHt9LCB7XG4gICAgICAgIGJvb2ttYXJrOiBib29rbWFyayxcbiAgICAgICAgdHhDb25maWc6IHR4Q29uZmlnLFxuICAgICAgICBkYXRhYmFzZTogZGF0YWJhc2UsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIGJlZm9yZUVycm9yOiBiZWZvcmVFcnJvcixcbiAgICAgICAgYWZ0ZXJFcnJvcjogYWZ0ZXJFcnJvcixcbiAgICAgICAgYmVmb3JlQ29tcGxldGU6IGJlZm9yZUNvbXBsZXRlLFxuICAgICAgICBhZnRlckNvbXBsZXRlOiBhZnRlckNvbXBsZXRlLFxuICAgICAgICBmbHVzaDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21taXQgdGhlIGV4cGxpY2l0IHRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBFcnJvcil9IHBhcmFtLmJlZm9yZUVycm9yIHRoZSBjYWxsYmFjayB0byBpbnZva2UgYmVmb3JlIGhhbmRsaW5nIHRoZSBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycjogRXJyb3IpfSBwYXJhbS5hZnRlckVycm9yIHRoZSBjYWxsYmFjayB0byBpbnZva2UgYWZ0ZXIgaGFuZGxpbmcgdGhlIGVycm9yLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gcGFyYW0uYmVmb3JlQ29tcGxldGUgdGhlIGNhbGxiYWNrIHRvIGludm9rZSBiZWZvcmUgaGFuZGxpbmcgdGhlIGNvbXBsZXRpb24uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBwYXJhbS5hZnRlckNvbXBsZXRlIHRoZSBjYWxsYmFjayB0byBpbnZva2UgYWZ0ZXIgaGFuZGxpbmcgdGhlIGNvbXBsZXRpb24uXG4gICAgICogQHJldHVybnMge1N0cmVhbU9ic2VydmVyfSB0aGUgc3RyZWFtIG9ic2VydmVyIHRoYXQgbW9uaXRvcnMgdGhlIGNvcnJlc3BvbmRpbmcgc2VydmVyIHJlc3BvbnNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tbWl0VHJhbnNhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tbWl0VHJhbnNhY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIGJlZm9yZUVycm9yID0gX3JlZjMuYmVmb3JlRXJyb3IsXG4gICAgICAgICAgYWZ0ZXJFcnJvciA9IF9yZWYzLmFmdGVyRXJyb3IsXG4gICAgICAgICAgYmVmb3JlQ29tcGxldGUgPSBfcmVmMy5iZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgICBhZnRlckNvbXBsZXRlID0gX3JlZjMuYWZ0ZXJDb21wbGV0ZTtcblxuICAgICAgLy8gV1JJVEUgYWNjZXNzIG1vZGUgaXMgdXNlZCBhcyBhIHBsYWNlIGhvbGRlciBoZXJlLCBpdCBoYXNcbiAgICAgIC8vIG5vIGVmZmVjdCBvbiBiZWhhdmlvdXIgZm9yIEJvbHQgVjEgJiBWMlxuICAgICAgcmV0dXJuIHRoaXMucnVuKCdDT01NSVQnLCB7fSwge1xuICAgICAgICBib29rbWFyazogX2Jvb2ttYXJrW1wiZGVmYXVsdFwiXS5lbXB0eSgpLFxuICAgICAgICB0eENvbmZpZzogX3R4Q29uZmlnW1wiZGVmYXVsdFwiXS5lbXB0eSgpLFxuICAgICAgICBtb2RlOiBfY29uc3RhbnRzLkFDQ0VTU19NT0RFX1dSSVRFLFxuICAgICAgICBiZWZvcmVFcnJvcjogYmVmb3JlRXJyb3IsXG4gICAgICAgIGFmdGVyRXJyb3I6IGFmdGVyRXJyb3IsXG4gICAgICAgIGJlZm9yZUNvbXBsZXRlOiBiZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgYWZ0ZXJDb21wbGV0ZTogYWZ0ZXJDb21wbGV0ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvbGxiYWNrIHRoZSBleHBsaWNpdCB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycjogRXJyb3IpfSBwYXJhbS5iZWZvcmVFcnJvciB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIGJlZm9yZSBoYW5kbGluZyB0aGUgZXJyb3IuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IEVycm9yKX0gcGFyYW0uYWZ0ZXJFcnJvciB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIGhhbmRsaW5nIHRoZSBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IHBhcmFtLmJlZm9yZUNvbXBsZXRlIHRoZSBjYWxsYmFjayB0byBpbnZva2UgYmVmb3JlIGhhbmRsaW5nIHRoZSBjb21wbGV0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gcGFyYW0uYWZ0ZXJDb21wbGV0ZSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIGhhbmRsaW5nIHRoZSBjb21wbGV0aW9uLlxuICAgICAqIEByZXR1cm5zIHtTdHJlYW1PYnNlcnZlcn0gdGhlIHN0cmVhbSBvYnNlcnZlciB0aGF0IG1vbml0b3JzIHRoZSBjb3JyZXNwb25kaW5nIHNlcnZlciByZXNwb25zZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJvbGxiYWNrVHJhbnNhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm9sbGJhY2tUcmFuc2FjdGlvbigpIHtcbiAgICAgIHZhciBfcmVmNCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgYmVmb3JlRXJyb3IgPSBfcmVmNC5iZWZvcmVFcnJvcixcbiAgICAgICAgICBhZnRlckVycm9yID0gX3JlZjQuYWZ0ZXJFcnJvcixcbiAgICAgICAgICBiZWZvcmVDb21wbGV0ZSA9IF9yZWY0LmJlZm9yZUNvbXBsZXRlLFxuICAgICAgICAgIGFmdGVyQ29tcGxldGUgPSBfcmVmNC5hZnRlckNvbXBsZXRlO1xuXG4gICAgICAvLyBXUklURSBhY2Nlc3MgbW9kZSBpcyB1c2VkIGFzIGEgcGxhY2UgaG9sZGVyIGhlcmUsIGl0IGhhc1xuICAgICAgLy8gbm8gZWZmZWN0IG9uIGJlaGF2aW91ciBmb3IgQm9sdCBWMSAmIFYyXG4gICAgICByZXR1cm4gdGhpcy5ydW4oJ1JPTExCQUNLJywge30sIHtcbiAgICAgICAgYm9va21hcms6IF9ib29rbWFya1tcImRlZmF1bHRcIl0uZW1wdHkoKSxcbiAgICAgICAgdHhDb25maWc6IF90eENvbmZpZ1tcImRlZmF1bHRcIl0uZW1wdHkoKSxcbiAgICAgICAgbW9kZTogX2NvbnN0YW50cy5BQ0NFU1NfTU9ERV9XUklURSxcbiAgICAgICAgYmVmb3JlRXJyb3I6IGJlZm9yZUVycm9yLFxuICAgICAgICBhZnRlckVycm9yOiBhZnRlckVycm9yLFxuICAgICAgICBiZWZvcmVDb21wbGV0ZTogYmVmb3JlQ29tcGxldGUsXG4gICAgICAgIGFmdGVyQ29tcGxldGU6IGFmdGVyQ29tcGxldGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgQ3lwaGVyIHF1ZXJ5IHRocm91Z2ggdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgdGhlIGN5cGhlciBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyB0aGUgcXVlcnkgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cbiAgICAgKiBAcGFyYW0ge0Jvb2ttYXJrfSBwYXJhbS5ib29rbWFyayB0aGUgYm9va21hcmsuXG4gICAgICogQHBhcmFtIHtUeENvbmZpZ30gcGFyYW0udHhDb25maWcgdGhlIHRyYW5zYWN0aW9uIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtLmRhdGFiYXNlIHRoZSB0YXJnZXQgZGF0YWJhc2UgbmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0ubW9kZSB0aGUgYWNjZXNzIG1vZGUuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihrZXlzOiBzdHJpbmdbXSl9IHBhcmFtLmJlZm9yZUtleXMgdGhlIGNhbGxiYWNrIHRvIGludm9rZSBiZWZvcmUgaGFuZGxpbmcgdGhlIGtleXMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihrZXlzOiBzdHJpbmdbXSl9IHBhcmFtLmFmdGVyS2V5cyB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIGhhbmRsaW5nIHRoZSBrZXlzLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBFcnJvcil9IHBhcmFtLmJlZm9yZUVycm9yIHRoZSBjYWxsYmFjayB0byBpbnZva2UgYmVmb3JlIGhhbmRsaW5nIHRoZSBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycjogRXJyb3IpfSBwYXJhbS5hZnRlckVycm9yIHRoZSBjYWxsYmFjayB0byBpbnZva2UgYWZ0ZXIgaGFuZGxpbmcgdGhlIGVycm9yLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gcGFyYW0uYmVmb3JlQ29tcGxldGUgdGhlIGNhbGxiYWNrIHRvIGludm9rZSBiZWZvcmUgaGFuZGxpbmcgdGhlIGNvbXBsZXRpb24uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBwYXJhbS5hZnRlckNvbXBsZXRlIHRoZSBjYWxsYmFjayB0byBpbnZva2UgYWZ0ZXIgaGFuZGxpbmcgdGhlIGNvbXBsZXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbS5mbHVzaCB3aGV0aGVyIHRvIGZsdXNoIHRoZSBidWZmZXJlZCBtZXNzYWdlcy5cbiAgICAgKiBAcmV0dXJucyB7U3RyZWFtT2JzZXJ2ZXJ9IHRoZSBzdHJlYW0gb2JzZXJ2ZXIgdGhhdCBtb25pdG9ycyB0aGUgY29ycmVzcG9uZGluZyBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJydW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuKHF1ZXJ5LCBwYXJhbWV0ZXJzKSB7XG4gICAgICB2YXIgX3JlZjUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgICAgIGJvb2ttYXJrID0gX3JlZjUuYm9va21hcmssXG4gICAgICAgICAgdHhDb25maWcgPSBfcmVmNS50eENvbmZpZyxcbiAgICAgICAgICBkYXRhYmFzZSA9IF9yZWY1LmRhdGFiYXNlLFxuICAgICAgICAgIG1vZGUgPSBfcmVmNS5tb2RlLFxuICAgICAgICAgIGJlZm9yZUtleXMgPSBfcmVmNS5iZWZvcmVLZXlzLFxuICAgICAgICAgIGFmdGVyS2V5cyA9IF9yZWY1LmFmdGVyS2V5cyxcbiAgICAgICAgICBiZWZvcmVFcnJvciA9IF9yZWY1LmJlZm9yZUVycm9yLFxuICAgICAgICAgIGFmdGVyRXJyb3IgPSBfcmVmNS5hZnRlckVycm9yLFxuICAgICAgICAgIGJlZm9yZUNvbXBsZXRlID0gX3JlZjUuYmVmb3JlQ29tcGxldGUsXG4gICAgICAgICAgYWZ0ZXJDb21wbGV0ZSA9IF9yZWY1LmFmdGVyQ29tcGxldGUsXG4gICAgICAgICAgX3JlZjUkZmx1c2ggPSBfcmVmNS5mbHVzaCxcbiAgICAgICAgICBmbHVzaCA9IF9yZWY1JGZsdXNoID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjUkZmx1c2g7XG5cbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBfc3RyZWFtT2JzZXJ2ZXJzLlJlc3VsdFN0cmVhbU9ic2VydmVyKHtcbiAgICAgICAgY29ubmVjdGlvbjogdGhpcy5fY29ubmVjdGlvbixcbiAgICAgICAgYmVmb3JlS2V5czogYmVmb3JlS2V5cyxcbiAgICAgICAgYWZ0ZXJLZXlzOiBhZnRlcktleXMsXG4gICAgICAgIGJlZm9yZUVycm9yOiBiZWZvcmVFcnJvcixcbiAgICAgICAgYWZ0ZXJFcnJvcjogYWZ0ZXJFcnJvcixcbiAgICAgICAgYmVmb3JlQ29tcGxldGU6IGJlZm9yZUNvbXBsZXRlLFxuICAgICAgICBhZnRlckNvbXBsZXRlOiBhZnRlckNvbXBsZXRlXG4gICAgICB9KTsgLy8gYm9va21hcmsgYW5kIG1vZGUgYXJlIGlnbm9yZWQgaW4gdGhpcyB2ZXJzaW9uIG9mIHRoZSBwcm90b2NvbFxuXG4gICAgICAoMCwgX2JvbHRQcm90b2NvbFV0aWwuYXNzZXJ0VHhDb25maWdJc0VtcHR5KSh0eENvbmZpZywgdGhpcy5fY29ubmVjdGlvbiwgb2JzZXJ2ZXIpOyAvLyBwYXNzaW5nIGluIGEgZGF0YWJhc2UgbmFtZSBvbiB0aGlzIHByb3RvY29sIHZlcnNpb24gdGhyb3dzIGFuIGVycm9yXG5cbiAgICAgICgwLCBfYm9sdFByb3RvY29sVXRpbC5hc3NlcnREYXRhYmFzZUlzRW1wdHkpKGRhdGFiYXNlLCB0aGlzLl9jb25uZWN0aW9uLCBvYnNlcnZlcik7XG5cbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24ud3JpdGUoX3JlcXVlc3RNZXNzYWdlW1wiZGVmYXVsdFwiXS5ydW4ocXVlcnksIHBhcmFtZXRlcnMpLCBvYnNlcnZlciwgZmFsc2UpO1xuXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLndyaXRlKF9yZXF1ZXN0TWVzc2FnZVtcImRlZmF1bHRcIl0ucHVsbEFsbCgpLCBvYnNlcnZlciwgZmx1c2gpO1xuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBSRVNFVCB0aHJvdWdoIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IEVycm9yKX0gcGFyYW0ub25FcnJvciB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gcGFyYW0ub25Db21wbGV0ZSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIG9uIGNvbXBsZXRpb24uXG4gICAgICogQHJldHVybnMge1N0cmVhbU9ic2VydmVyfSB0aGUgc3RyZWFtIG9ic2VydmVyIHRoYXQgbW9uaXRvcnMgdGhlIGNvcnJlc3BvbmRpbmcgc2VydmVyIHJlc3BvbnNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB2YXIgX3JlZjYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIG9uRXJyb3IgPSBfcmVmNi5vbkVycm9yLFxuICAgICAgICAgIG9uQ29tcGxldGUgPSBfcmVmNi5vbkNvbXBsZXRlO1xuXG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgX3N0cmVhbU9ic2VydmVycy5SZXNldE9ic2VydmVyKHtcbiAgICAgICAgY29ubmVjdGlvbjogdGhpcy5fY29ubmVjdGlvbixcbiAgICAgICAgb25FcnJvcjogb25FcnJvcixcbiAgICAgICAgb25Db21wbGV0ZTogb25Db21wbGV0ZVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24ud3JpdGUoX3JlcXVlc3RNZXNzYWdlW1wiZGVmYXVsdFwiXS5yZXNldCgpLCBvYnNlcnZlciwgdHJ1ZSk7XG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVBhY2tlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlUGFja2VyKGNodW5rZXIpIHtcbiAgICAgIHJldHVybiBuZXcgdjEuUGFja2VyKGNodW5rZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlVW5wYWNrZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVVucGFja2VyKGRpc2FibGVMb3NzbGVzc0ludGVnZXJzKSB7XG4gICAgICByZXR1cm4gbmV3IHYxLlVucGFja2VyKGRpc2FibGVMb3NzbGVzc0ludGVnZXJzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmVyc2lvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jb25zdGFudHMuQk9MVF9QUk9UT0NPTF9WMTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJvbHRQcm90b2NvbDtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBCb2x0UHJvdG9jb2w7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2JvbHRQcm90b2NvbFYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2JvbHQtcHJvdG9jb2wtdjFcIikpO1xuXG52YXIgdjIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9wYWNrc3RyZWFtLXYyXCIpKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yW1wiZGVmYXVsdFwiXSkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBCb2x0UHJvdG9jb2wgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Cb2x0UHJvdG9jb2xWKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoQm9sdFByb3RvY29sLCBfQm9sdFByb3RvY29sVik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihCb2x0UHJvdG9jb2wpO1xuXG4gIGZ1bmN0aW9uIEJvbHRQcm90b2NvbCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIEJvbHRQcm90b2NvbCk7XG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShCb2x0UHJvdG9jb2wsIFt7XG4gICAga2V5OiBcIl9jcmVhdGVQYWNrZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVBhY2tlcihjaHVua2VyKSB7XG4gICAgICByZXR1cm4gbmV3IHYyLlBhY2tlcihjaHVua2VyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVVucGFja2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVVbnBhY2tlcihkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycykge1xuICAgICAgcmV0dXJuIG5ldyB2Mi5VbnBhY2tlcihkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZlcnNpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29uc3RhbnRzLkJPTFRfUFJPVE9DT0xfVjI7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb2x0UHJvdG9jb2w7XG59KF9ib2x0UHJvdG9jb2xWW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQm9sdFByb3RvY29sOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9ib2x0UHJvdG9jb2xWID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ib2x0LXByb3RvY29sLXYyXCIpKTtcblxudmFyIF9yZXF1ZXN0TWVzc2FnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVxdWVzdC1tZXNzYWdlXCIpKTtcblxudmFyIF9ib2x0UHJvdG9jb2xVdGlsID0gcmVxdWlyZShcIi4vYm9sdC1wcm90b2NvbC11dGlsXCIpO1xuXG52YXIgX3N0cmVhbU9ic2VydmVycyA9IHJlcXVpcmUoXCIuL3N0cmVhbS1vYnNlcnZlcnNcIik7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgbm9PcE9ic2VydmVyID0gbmV3IF9zdHJlYW1PYnNlcnZlcnMuU3RyZWFtT2JzZXJ2ZXIoKTtcblxudmFyIEJvbHRQcm90b2NvbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0JvbHRQcm90b2NvbFYpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShCb2x0UHJvdG9jb2wsIF9Cb2x0UHJvdG9jb2xWKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEJvbHRQcm90b2NvbCk7XG5cbiAgZnVuY3Rpb24gQm9sdFByb3RvY29sKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgQm9sdFByb3RvY29sKTtcbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKEJvbHRQcm90b2NvbCwgW3tcbiAgICBrZXk6IFwidHJhbnNmb3JtTWV0YWRhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgIGlmICgndF9maXJzdCcgaW4gbWV0YWRhdGEpIHtcbiAgICAgICAgLy8gQm9sdCBWMyB1c2VzIHNob3J0ZXIga2V5ICd0X2ZpcnN0JyB0byByZXByZXNlbnQgJ3Jlc3VsdF9hdmFpbGFibGVfYWZ0ZXInXG4gICAgICAgIC8vIGFkanVzdCB0aGUga2V5IHRvIGJlIHRoZSBzYW1lIGFzIGluIEJvbHQgVjEgc28gdGhhdCBSZXN1bHRTdW1tYXJ5IGNhbiByZXRyaWV2ZSB0aGUgdmFsdWVcbiAgICAgICAgbWV0YWRhdGEucmVzdWx0X2F2YWlsYWJsZV9hZnRlciA9IG1ldGFkYXRhLnRfZmlyc3Q7XG4gICAgICAgIGRlbGV0ZSBtZXRhZGF0YS50X2ZpcnN0O1xuICAgICAgfVxuXG4gICAgICBpZiAoJ3RfbGFzdCcgaW4gbWV0YWRhdGEpIHtcbiAgICAgICAgLy8gQm9sdCBWMyB1c2VzIHNob3J0ZXIga2V5ICd0X2xhc3QnIHRvIHJlcHJlc2VudCAncmVzdWx0X2NvbnN1bWVkX2FmdGVyJ1xuICAgICAgICAvLyBhZGp1c3QgdGhlIGtleSB0byBiZSB0aGUgc2FtZSBhcyBpbiBCb2x0IFYxIHNvIHRoYXQgUmVzdWx0U3VtbWFyeSBjYW4gcmV0cmlldmUgdGhlIHZhbHVlXG4gICAgICAgIG1ldGFkYXRhLnJlc3VsdF9jb25zdW1lZF9hZnRlciA9IG1ldGFkYXRhLnRfbGFzdDtcbiAgICAgICAgZGVsZXRlIG1ldGFkYXRhLnRfbGFzdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgdXNlckFnZW50ID0gX3JlZi51c2VyQWdlbnQsXG4gICAgICAgICAgYXV0aFRva2VuID0gX3JlZi5hdXRoVG9rZW4sXG4gICAgICAgICAgb25FcnJvciA9IF9yZWYub25FcnJvcixcbiAgICAgICAgICBvbkNvbXBsZXRlID0gX3JlZi5vbkNvbXBsZXRlO1xuXG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgX3N0cmVhbU9ic2VydmVycy5Mb2dpbk9ic2VydmVyKHtcbiAgICAgICAgY29ubmVjdGlvbjogdGhpcy5fY29ubmVjdGlvbixcbiAgICAgICAgYWZ0ZXJFcnJvcjogb25FcnJvcixcbiAgICAgICAgYWZ0ZXJDb21wbGV0ZTogb25Db21wbGV0ZVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24ud3JpdGUoX3JlcXVlc3RNZXNzYWdlW1wiZGVmYXVsdFwiXS5oZWxsbyh1c2VyQWdlbnQsIGF1dGhUb2tlbiksIG9ic2VydmVyLCB0cnVlKTtcblxuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmVwYXJlVG9DbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwYXJlVG9DbG9zZSgpIHtcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24ud3JpdGUoX3JlcXVlc3RNZXNzYWdlW1wiZGVmYXVsdFwiXS5nb29kYnllKCksIG5vT3BPYnNlcnZlciwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJlZ2luVHJhbnNhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVnaW5UcmFuc2FjdGlvbigpIHtcbiAgICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgYm9va21hcmsgPSBfcmVmMi5ib29rbWFyayxcbiAgICAgICAgICB0eENvbmZpZyA9IF9yZWYyLnR4Q29uZmlnLFxuICAgICAgICAgIGRhdGFiYXNlID0gX3JlZjIuZGF0YWJhc2UsXG4gICAgICAgICAgbW9kZSA9IF9yZWYyLm1vZGUsXG4gICAgICAgICAgYmVmb3JlRXJyb3IgPSBfcmVmMi5iZWZvcmVFcnJvcixcbiAgICAgICAgICBhZnRlckVycm9yID0gX3JlZjIuYWZ0ZXJFcnJvcixcbiAgICAgICAgICBiZWZvcmVDb21wbGV0ZSA9IF9yZWYyLmJlZm9yZUNvbXBsZXRlLFxuICAgICAgICAgIGFmdGVyQ29tcGxldGUgPSBfcmVmMi5hZnRlckNvbXBsZXRlO1xuXG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgX3N0cmVhbU9ic2VydmVycy5SZXN1bHRTdHJlYW1PYnNlcnZlcih7XG4gICAgICAgIGNvbm5lY3Rpb246IHRoaXMuX2Nvbm5lY3Rpb24sXG4gICAgICAgIGJlZm9yZUVycm9yOiBiZWZvcmVFcnJvcixcbiAgICAgICAgYWZ0ZXJFcnJvcjogYWZ0ZXJFcnJvcixcbiAgICAgICAgYmVmb3JlQ29tcGxldGU6IGJlZm9yZUNvbXBsZXRlLFxuICAgICAgICBhZnRlckNvbXBsZXRlOiBhZnRlckNvbXBsZXRlXG4gICAgICB9KTtcbiAgICAgIG9ic2VydmVyLnByZXBhcmVUb0hhbmRsZVNpbmdsZVJlc3BvbnNlKCk7IC8vIHBhc3NpbmcgaW4gYSBkYXRhYmFzZSBuYW1lIG9uIHRoaXMgcHJvdG9jb2wgdmVyc2lvbiB0aHJvd3MgYW4gZXJyb3JcblxuICAgICAgKDAsIF9ib2x0UHJvdG9jb2xVdGlsLmFzc2VydERhdGFiYXNlSXNFbXB0eSkoZGF0YWJhc2UsIHRoaXMuX2Nvbm5lY3Rpb24sIG9ic2VydmVyKTtcblxuICAgICAgdGhpcy5fY29ubmVjdGlvbi53cml0ZShfcmVxdWVzdE1lc3NhZ2VbXCJkZWZhdWx0XCJdLmJlZ2luKHtcbiAgICAgICAgYm9va21hcms6IGJvb2ttYXJrLFxuICAgICAgICB0eENvbmZpZzogdHhDb25maWcsXG4gICAgICAgIG1vZGU6IG1vZGVcbiAgICAgIH0pLCBvYnNlcnZlciwgdHJ1ZSk7XG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tbWl0VHJhbnNhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tbWl0VHJhbnNhY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIGJlZm9yZUVycm9yID0gX3JlZjMuYmVmb3JlRXJyb3IsXG4gICAgICAgICAgYWZ0ZXJFcnJvciA9IF9yZWYzLmFmdGVyRXJyb3IsXG4gICAgICAgICAgYmVmb3JlQ29tcGxldGUgPSBfcmVmMy5iZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgICBhZnRlckNvbXBsZXRlID0gX3JlZjMuYWZ0ZXJDb21wbGV0ZTtcblxuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IF9zdHJlYW1PYnNlcnZlcnMuUmVzdWx0U3RyZWFtT2JzZXJ2ZXIoe1xuICAgICAgICBjb25uZWN0aW9uOiB0aGlzLl9jb25uZWN0aW9uLFxuICAgICAgICBiZWZvcmVFcnJvcjogYmVmb3JlRXJyb3IsXG4gICAgICAgIGFmdGVyRXJyb3I6IGFmdGVyRXJyb3IsXG4gICAgICAgIGJlZm9yZUNvbXBsZXRlOiBiZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgYWZ0ZXJDb21wbGV0ZTogYWZ0ZXJDb21wbGV0ZVxuICAgICAgfSk7XG4gICAgICBvYnNlcnZlci5wcmVwYXJlVG9IYW5kbGVTaW5nbGVSZXNwb25zZSgpO1xuXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLndyaXRlKF9yZXF1ZXN0TWVzc2FnZVtcImRlZmF1bHRcIl0uY29tbWl0KCksIG9ic2VydmVyLCB0cnVlKTtcblxuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb2xsYmFja1RyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvbGxiYWNrVHJhbnNhY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIGJlZm9yZUVycm9yID0gX3JlZjQuYmVmb3JlRXJyb3IsXG4gICAgICAgICAgYWZ0ZXJFcnJvciA9IF9yZWY0LmFmdGVyRXJyb3IsXG4gICAgICAgICAgYmVmb3JlQ29tcGxldGUgPSBfcmVmNC5iZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgICBhZnRlckNvbXBsZXRlID0gX3JlZjQuYWZ0ZXJDb21wbGV0ZTtcblxuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IF9zdHJlYW1PYnNlcnZlcnMuUmVzdWx0U3RyZWFtT2JzZXJ2ZXIoe1xuICAgICAgICBjb25uZWN0aW9uOiB0aGlzLl9jb25uZWN0aW9uLFxuICAgICAgICBiZWZvcmVFcnJvcjogYmVmb3JlRXJyb3IsXG4gICAgICAgIGFmdGVyRXJyb3I6IGFmdGVyRXJyb3IsXG4gICAgICAgIGJlZm9yZUNvbXBsZXRlOiBiZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgYWZ0ZXJDb21wbGV0ZTogYWZ0ZXJDb21wbGV0ZVxuICAgICAgfSk7XG4gICAgICBvYnNlcnZlci5wcmVwYXJlVG9IYW5kbGVTaW5nbGVSZXNwb25zZSgpO1xuXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLndyaXRlKF9yZXF1ZXN0TWVzc2FnZVtcImRlZmF1bHRcIl0ucm9sbGJhY2soKSwgb2JzZXJ2ZXIsIHRydWUpO1xuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJ1blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW4ocXVlcnksIHBhcmFtZXRlcnMpIHtcbiAgICAgIHZhciBfcmVmNSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICAgICAgYm9va21hcmsgPSBfcmVmNS5ib29rbWFyayxcbiAgICAgICAgICB0eENvbmZpZyA9IF9yZWY1LnR4Q29uZmlnLFxuICAgICAgICAgIGRhdGFiYXNlID0gX3JlZjUuZGF0YWJhc2UsXG4gICAgICAgICAgbW9kZSA9IF9yZWY1Lm1vZGUsXG4gICAgICAgICAgYmVmb3JlS2V5cyA9IF9yZWY1LmJlZm9yZUtleXMsXG4gICAgICAgICAgYWZ0ZXJLZXlzID0gX3JlZjUuYWZ0ZXJLZXlzLFxuICAgICAgICAgIGJlZm9yZUVycm9yID0gX3JlZjUuYmVmb3JlRXJyb3IsXG4gICAgICAgICAgYWZ0ZXJFcnJvciA9IF9yZWY1LmFmdGVyRXJyb3IsXG4gICAgICAgICAgYmVmb3JlQ29tcGxldGUgPSBfcmVmNS5iZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgICBhZnRlckNvbXBsZXRlID0gX3JlZjUuYWZ0ZXJDb21wbGV0ZSxcbiAgICAgICAgICBfcmVmNSRmbHVzaCA9IF9yZWY1LmZsdXNoLFxuICAgICAgICAgIGZsdXNoID0gX3JlZjUkZmx1c2ggPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmNSRmbHVzaDtcblxuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IF9zdHJlYW1PYnNlcnZlcnMuUmVzdWx0U3RyZWFtT2JzZXJ2ZXIoe1xuICAgICAgICBjb25uZWN0aW9uOiB0aGlzLl9jb25uZWN0aW9uLFxuICAgICAgICBiZWZvcmVLZXlzOiBiZWZvcmVLZXlzLFxuICAgICAgICBhZnRlcktleXM6IGFmdGVyS2V5cyxcbiAgICAgICAgYmVmb3JlRXJyb3I6IGJlZm9yZUVycm9yLFxuICAgICAgICBhZnRlckVycm9yOiBhZnRlckVycm9yLFxuICAgICAgICBiZWZvcmVDb21wbGV0ZTogYmVmb3JlQ29tcGxldGUsXG4gICAgICAgIGFmdGVyQ29tcGxldGU6IGFmdGVyQ29tcGxldGVcbiAgICAgIH0pOyAvLyBwYXNzaW5nIGluIGEgZGF0YWJhc2UgbmFtZSBvbiB0aGlzIHByb3RvY29sIHZlcnNpb24gdGhyb3dzIGFuIGVycm9yXG5cbiAgICAgICgwLCBfYm9sdFByb3RvY29sVXRpbC5hc3NlcnREYXRhYmFzZUlzRW1wdHkpKGRhdGFiYXNlLCB0aGlzLl9jb25uZWN0aW9uLCBvYnNlcnZlcik7XG5cbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24ud3JpdGUoX3JlcXVlc3RNZXNzYWdlW1wiZGVmYXVsdFwiXS5ydW5XaXRoTWV0YWRhdGEocXVlcnksIHBhcmFtZXRlcnMsIHtcbiAgICAgICAgYm9va21hcms6IGJvb2ttYXJrLFxuICAgICAgICB0eENvbmZpZzogdHhDb25maWcsXG4gICAgICAgIG1vZGU6IG1vZGVcbiAgICAgIH0pLCBvYnNlcnZlciwgZmFsc2UpO1xuXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLndyaXRlKF9yZXF1ZXN0TWVzc2FnZVtcImRlZmF1bHRcIl0ucHVsbEFsbCgpLCBvYnNlcnZlciwgZmx1c2gpO1xuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZlcnNpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29uc3RhbnRzLkJPTFRfUFJPVE9DT0xfVjM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb2x0UHJvdG9jb2w7XG59KF9ib2x0UHJvdG9jb2xWW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQm9sdFByb3RvY29sOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkXCIpO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9ib2x0UHJvdG9jb2xWID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ib2x0LXByb3RvY29sLXYzXCIpKTtcblxudmFyIF9yZXF1ZXN0TWVzc2FnZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3JlcXVlc3QtbWVzc2FnZVwiKSk7XG5cbnZhciBfc3RyZWFtT2JzZXJ2ZXJzID0gcmVxdWlyZShcIi4vc3RyZWFtLW9ic2VydmVyc1wiKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yW1wiZGVmYXVsdFwiXSkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBCb2x0UHJvdG9jb2wgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Cb2x0UHJvdG9jb2xWKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoQm9sdFByb3RvY29sLCBfQm9sdFByb3RvY29sVik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihCb2x0UHJvdG9jb2wpO1xuXG4gIGZ1bmN0aW9uIEJvbHRQcm90b2NvbCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIEJvbHRQcm90b2NvbCk7XG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShCb2x0UHJvdG9jb2wsIFt7XG4gICAga2V5OiBcImJlZ2luVHJhbnNhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVnaW5UcmFuc2FjdGlvbigpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBib29rbWFyayA9IF9yZWYuYm9va21hcmssXG4gICAgICAgICAgdHhDb25maWcgPSBfcmVmLnR4Q29uZmlnLFxuICAgICAgICAgIGRhdGFiYXNlID0gX3JlZi5kYXRhYmFzZSxcbiAgICAgICAgICBtb2RlID0gX3JlZi5tb2RlLFxuICAgICAgICAgIGJlZm9yZUVycm9yID0gX3JlZi5iZWZvcmVFcnJvcixcbiAgICAgICAgICBhZnRlckVycm9yID0gX3JlZi5hZnRlckVycm9yLFxuICAgICAgICAgIGJlZm9yZUNvbXBsZXRlID0gX3JlZi5iZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgICBhZnRlckNvbXBsZXRlID0gX3JlZi5hZnRlckNvbXBsZXRlO1xuXG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgX3N0cmVhbU9ic2VydmVycy5SZXN1bHRTdHJlYW1PYnNlcnZlcih7XG4gICAgICAgIGNvbm5lY3Rpb246IHRoaXMuX2Nvbm5lY3Rpb24sXG4gICAgICAgIGJlZm9yZUVycm9yOiBiZWZvcmVFcnJvcixcbiAgICAgICAgYWZ0ZXJFcnJvcjogYWZ0ZXJFcnJvcixcbiAgICAgICAgYmVmb3JlQ29tcGxldGU6IGJlZm9yZUNvbXBsZXRlLFxuICAgICAgICBhZnRlckNvbXBsZXRlOiBhZnRlckNvbXBsZXRlXG4gICAgICB9KTtcbiAgICAgIG9ic2VydmVyLnByZXBhcmVUb0hhbmRsZVNpbmdsZVJlc3BvbnNlKCk7XG5cbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24ud3JpdGUoX3JlcXVlc3RNZXNzYWdlW1wiZGVmYXVsdFwiXS5iZWdpbih7XG4gICAgICAgIGJvb2ttYXJrOiBib29rbWFyayxcbiAgICAgICAgdHhDb25maWc6IHR4Q29uZmlnLFxuICAgICAgICBkYXRhYmFzZTogZGF0YWJhc2UsXG4gICAgICAgIG1vZGU6IG1vZGVcbiAgICAgIH0pLCBvYnNlcnZlciwgdHJ1ZSk7XG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicnVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bihxdWVyeSwgcGFyYW1ldGVycykge1xuICAgICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgICAgICBib29rbWFyayA9IF9yZWYyLmJvb2ttYXJrLFxuICAgICAgICAgIHR4Q29uZmlnID0gX3JlZjIudHhDb25maWcsXG4gICAgICAgICAgZGF0YWJhc2UgPSBfcmVmMi5kYXRhYmFzZSxcbiAgICAgICAgICBtb2RlID0gX3JlZjIubW9kZSxcbiAgICAgICAgICBiZWZvcmVLZXlzID0gX3JlZjIuYmVmb3JlS2V5cyxcbiAgICAgICAgICBhZnRlcktleXMgPSBfcmVmMi5hZnRlcktleXMsXG4gICAgICAgICAgYmVmb3JlRXJyb3IgPSBfcmVmMi5iZWZvcmVFcnJvcixcbiAgICAgICAgICBhZnRlckVycm9yID0gX3JlZjIuYWZ0ZXJFcnJvcixcbiAgICAgICAgICBiZWZvcmVDb21wbGV0ZSA9IF9yZWYyLmJlZm9yZUNvbXBsZXRlLFxuICAgICAgICAgIGFmdGVyQ29tcGxldGUgPSBfcmVmMi5hZnRlckNvbXBsZXRlLFxuICAgICAgICAgIF9yZWYyJGZsdXNoID0gX3JlZjIuZmx1c2gsXG4gICAgICAgICAgZmx1c2ggPSBfcmVmMiRmbHVzaCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYyJGZsdXNoLFxuICAgICAgICAgIF9yZWYyJHJlYWN0aXZlID0gX3JlZjIucmVhY3RpdmUsXG4gICAgICAgICAgcmVhY3RpdmUgPSBfcmVmMiRyZWFjdGl2ZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiRyZWFjdGl2ZSxcbiAgICAgICAgICBfcmVmMiRmZXRjaFNpemUgPSBfcmVmMi5mZXRjaFNpemUsXG4gICAgICAgICAgZmV0Y2hTaXplID0gX3JlZjIkZmV0Y2hTaXplID09PSB2b2lkIDAgPyBfcmVxdWVzdE1lc3NhZ2UuQUxMIDogX3JlZjIkZmV0Y2hTaXplO1xuXG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgX3N0cmVhbU9ic2VydmVycy5SZXN1bHRTdHJlYW1PYnNlcnZlcih7XG4gICAgICAgIGNvbm5lY3Rpb246IHRoaXMuX2Nvbm5lY3Rpb24sXG4gICAgICAgIHJlYWN0aXZlOiByZWFjdGl2ZSxcbiAgICAgICAgZmV0Y2hTaXplOiBmZXRjaFNpemUsXG4gICAgICAgIG1vcmVGdW5jdGlvbjogdGhpcy5fcmVxdWVzdE1vcmUsXG4gICAgICAgIGRpc2NhcmRGdW5jdGlvbjogdGhpcy5fcmVxdWVzdERpc2NhcmQsXG4gICAgICAgIGJlZm9yZUtleXM6IGJlZm9yZUtleXMsXG4gICAgICAgIGFmdGVyS2V5czogYWZ0ZXJLZXlzLFxuICAgICAgICBiZWZvcmVFcnJvcjogYmVmb3JlRXJyb3IsXG4gICAgICAgIGFmdGVyRXJyb3I6IGFmdGVyRXJyb3IsXG4gICAgICAgIGJlZm9yZUNvbXBsZXRlOiBiZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgYWZ0ZXJDb21wbGV0ZTogYWZ0ZXJDb21wbGV0ZVxuICAgICAgfSk7XG4gICAgICB2YXIgZmx1c2hSdW4gPSByZWFjdGl2ZTtcblxuICAgICAgdGhpcy5fY29ubmVjdGlvbi53cml0ZShfcmVxdWVzdE1lc3NhZ2VbXCJkZWZhdWx0XCJdLnJ1bldpdGhNZXRhZGF0YShxdWVyeSwgcGFyYW1ldGVycywge1xuICAgICAgICBib29rbWFyazogYm9va21hcmssXG4gICAgICAgIHR4Q29uZmlnOiB0eENvbmZpZyxcbiAgICAgICAgZGF0YWJhc2U6IGRhdGFiYXNlLFxuICAgICAgICBtb2RlOiBtb2RlXG4gICAgICB9KSwgb2JzZXJ2ZXIsIGZsdXNoUnVuICYmIGZsdXNoKTtcblxuICAgICAgaWYgKCFyZWFjdGl2ZSkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uLndyaXRlKF9yZXF1ZXN0TWVzc2FnZVtcImRlZmF1bHRcIl0ucHVsbCh7XG4gICAgICAgICAgbjogZmV0Y2hTaXplXG4gICAgICAgIH0pLCBvYnNlcnZlciwgZmx1c2gpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZXF1ZXN0TW9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVxdWVzdE1vcmUoY29ubmVjdGlvbiwgc3RtdElkLCBuLCBvYnNlcnZlcikge1xuICAgICAgY29ubmVjdGlvbi53cml0ZShfcmVxdWVzdE1lc3NhZ2VbXCJkZWZhdWx0XCJdLnB1bGwoe1xuICAgICAgICBzdG10SWQ6IHN0bXRJZCxcbiAgICAgICAgbjogblxuICAgICAgfSksIG9ic2VydmVyLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlcXVlc3REaXNjYXJkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXF1ZXN0RGlzY2FyZChjb25uZWN0aW9uLCBzdG10SWQsIG9ic2VydmVyKSB7XG4gICAgICBjb25uZWN0aW9uLndyaXRlKF9yZXF1ZXN0TWVzc2FnZVtcImRlZmF1bHRcIl0uZGlzY2FyZCh7XG4gICAgICAgIHN0bXRJZDogc3RtdElkXG4gICAgICB9KSwgb2JzZXJ2ZXIsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbm9PcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbm9PcCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwidmVyc2lvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jb25zdGFudHMuQk9MVF9QUk9UT0NPTF9WNF8wO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQm9sdFByb3RvY29sO1xufShfYm9sdFByb3RvY29sVltcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEJvbHRQcm90b2NvbDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZFwiKTtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfYm9sdFByb3RvY29sVjR4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ib2x0LXByb3RvY29sLXY0eDBcIikpO1xuXG52YXIgX3JlcXVlc3RNZXNzYWdlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vcmVxdWVzdC1tZXNzYWdlXCIpKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5cbnZhciBfc3RyZWFtT2JzZXJ2ZXJzID0gcmVxdWlyZShcIi4vc3RyZWFtLW9ic2VydmVyc1wiKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIEJvbHRQcm90b2NvbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0JvbHRQcm90b2NvbFYpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShCb2x0UHJvdG9jb2wsIF9Cb2x0UHJvdG9jb2xWKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEJvbHRQcm90b2NvbCk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb24gdGhlIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7Q2h1bmtlcn0gY2h1bmtlciB0aGUgY2h1bmtlci5cbiAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlTG9zc2xlc3NJbnRlZ2VycyBpZiB0aGlzIGNvbm5lY3Rpb24gc2hvdWxkIGNvbnZlcnQgYWxsIHJlY2VpdmVkIGludGVnZXJzIHRvIG5hdGl2ZSBKUyBudW1iZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VydmVyc2lkZVJvdXRpbmdcbiAgICovXG4gIGZ1bmN0aW9uIEJvbHRQcm90b2NvbChjb25uZWN0aW9uLCBjaHVua2VyLCBkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycywgc2VydmVyc2lkZVJvdXRpbmcpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIEJvbHRQcm90b2NvbCk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25uZWN0aW9uLCBjaHVua2VyLCBkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycyk7XG4gICAgX3RoaXMuX3NlcnZlcnNpZGVSb3V0aW5nID0gc2VydmVyc2lkZVJvdXRpbmc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShCb2x0UHJvdG9jb2wsIFt7XG4gICAga2V5OiBcImluaXRpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICB1c2VyQWdlbnQgPSBfcmVmLnVzZXJBZ2VudCxcbiAgICAgICAgICBhdXRoVG9rZW4gPSBfcmVmLmF1dGhUb2tlbixcbiAgICAgICAgICBvbkVycm9yID0gX3JlZi5vbkVycm9yLFxuICAgICAgICAgIG9uQ29tcGxldGUgPSBfcmVmLm9uQ29tcGxldGU7XG5cbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBfc3RyZWFtT2JzZXJ2ZXJzLkxvZ2luT2JzZXJ2ZXIoe1xuICAgICAgICBjb25uZWN0aW9uOiB0aGlzLl9jb25uZWN0aW9uLFxuICAgICAgICBhZnRlckVycm9yOiBvbkVycm9yLFxuICAgICAgICBhZnRlckNvbXBsZXRlOiBvbkNvbXBsZXRlXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fY29ubmVjdGlvbi53cml0ZShfcmVxdWVzdE1lc3NhZ2VbXCJkZWZhdWx0XCJdLmhlbGxvKHVzZXJBZ2VudCwgYXV0aFRva2VuLCB0aGlzLl9zZXJ2ZXJzaWRlUm91dGluZyksIG9ic2VydmVyLCB0cnVlKTtcblxuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2ZXJzaW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2NvbnN0YW50cy5CT0xUX1BST1RPQ09MX1Y0XzE7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb2x0UHJvdG9jb2w7XG59KF9ib2x0UHJvdG9jb2xWNHhbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBCb2x0UHJvdG9jb2w7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciB1dGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdXRpbFwiKSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEJPT0tNQVJLU19LRVkgPSAnYm9va21hcmtzJztcblxudmFyIEJvb2ttYXJrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdmFsdWVzIHNpbmdsZSBib29rbWFyayBhcyBzdHJpbmcgb3IgbXVsdGlwbGUgYm9va21hcmtzIGFzIGEgc3RyaW5nIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gQm9va21hcmsodmFsdWVzKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBCb29rbWFyayk7XG4gICAgdGhpcy5fdmFsdWVzID0gYXNTdHJpbmdBcnJheSh2YWx1ZXMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShCb29rbWFyaywgW3tcbiAgICBrZXk6IFwiaXNFbXB0eVwiLFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIGJvb2ttYXJrIGlzIG1lYW5pbmdmdWwgYW5kIGNhbiBiZSBzZW5kIHRvIHRoZSBkYXRhYmFzZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSByZXR1cm5zIGB0cnVlYCBib29rbWFyayBoYXMgYSB2YWx1ZSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWVzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBib29rbWFyayB2YWx1ZXMgYXMgYW4gYXJyYXkuXG4gICAgICogQHJldHVybiB7c3RyaW5nW119IGFsbCB2YWx1ZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoaXMgYm9va21hcmsgYXMgYW4gb2JqZWN0IGZvciBiZWdpbiB0cmFuc2FjdGlvbiBjYWxsLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIHZhbHVlIG9mIHRoaXMgYm9va21hcmsgYXMgb2JqZWN0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXNCZWdpblRyYW5zYWN0aW9uUGFyYW1ldGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc0JlZ2luVHJhbnNhY3Rpb25QYXJhbWV0ZXJzKCkge1xuICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH0gLy8gRHJpdmVyIHNlbmRzIHtib29rbWFyazogXCJtYXhcIiwgYm9va21hcmtzOiBbXCJvbmVcIiwgXCJ0d29cIiwgXCJtYXhcIl19IGluc3RlYWQgb2Ygc2ltcGxlXG4gICAgICAvLyB7Ym9va21hcmtzOiBbXCJvbmVcIiwgXCJ0d29cIiwgXCJtYXhcIl19IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zLiBPbGQgc2VydmVycyBjYW4gb25seSBhY2NlcHQgc2luZ2xlXG4gICAgICAvLyBib29rbWFyayB0aGF0IGlzIHdoeSBkcml2ZXIgaGFzIHRvIHBhcnNlIGFuZCBjb21wYXJlIGdpdmVuIGxpc3Qgb2YgYm9va21hcmtzLiBUaGlzIGZ1bmN0aW9uYWxpdHkgd2lsbFxuICAgICAgLy8gZXZlbnR1YWxseSBiZSByZW1vdmVkLlxuXG5cbiAgICAgIHJldHVybiAoMCwgX2RlZmluZVByb3BlcnR5MltcImRlZmF1bHRcIl0pKHt9LCBCT09LTUFSS1NfS0VZLCB0aGlzLl92YWx1ZXMpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImVtcHR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtcHR5KCkge1xuICAgICAgcmV0dXJuIEVNUFRZX0JPT0tNQVJLO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQm9va21hcms7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQm9va21hcms7XG52YXIgRU1QVFlfQk9PS01BUksgPSBuZXcgQm9va21hcmsobnVsbCk7XG4vKipcbiAqIENvbnZlcnRzIGdpdmVuIHZhbHVlIHRvIGFuIGFycmF5LlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW118QXJyYXl9IFt2YWx1ZT11bmRlZmluZWRdIGFyZ3VtZW50IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX0gdmFsdWUgY29udmVydGVkIHRvIGFuIGFycmF5LlxuICovXG5cbmZ1bmN0aW9uIGFzU3RyaW5nQXJyYXkodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiBbdmFsdWVdO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBmbGF0dGVuZWRWYWx1ZSA9IGZsYXR0ZW5BcnJheSh2YWx1ZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZsYXR0ZW5lZFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGZsYXR0ZW5lZFZhbHVlW2ldOyAvLyBpZiBpdCBpcyB1bmRlZmluZWQgb3IgbnVsbCwgaWdub3JlIGl0XG5cbiAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIXV0aWwuaXNTdHJpbmcoZWxlbWVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQm9va21hcmsgdmFsdWUgc2hvdWxkIGJlIGEgc3RyaW5nLCBnaXZlbjogJ1wiLmNvbmNhdChlbGVtZW50LCBcIidcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJCb29rbWFyayBzaG91bGQgZWl0aGVyIGJlIGEgc3RyaW5nIG9yIGEgc3RyaW5nIGFycmF5LCBnaXZlbjogJ1wiLmNvbmNhdCh2YWx1ZSwgXCInXCIpKTtcbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgZmxhdHRlbnMgYW4gYXJyYXkgc28gdGhhdCB0aGUgcmVzdWx0IGJlY29tZXMgYSBzaW5nbGUgYXJyYXlcbiAqIG9mIHZhbHVlcywgd2hpY2ggZG9lcyBub3QgaW5jbHVkZSBhbnkgc3ViLWFycmF5c1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlXG4gKi9cblxuXG5mdW5jdGlvbiBmbGF0dGVuQXJyYXkodmFsdWVzKSB7XG4gIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChkZXN0LCB2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGRlc3QuY29uY2F0KGZsYXR0ZW5BcnJheSh2YWx1ZSkpIDogZGVzdC5jb25jYXQodmFsdWUpO1xuICB9LCBbXSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2Jhc2VCdWYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9idWYvYmFzZS1idWZcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgSGVhcEJ1ZmZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VCdWZmZXIpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShIZWFwQnVmZmVyLCBfQmFzZUJ1ZmZlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihIZWFwQnVmZmVyKTtcblxuICBmdW5jdGlvbiBIZWFwQnVmZmVyKGFyZykge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgSGVhcEJ1ZmZlcik7XG4gICAgdmFyIGJ1ZmZlciA9IGFyZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gYXJnIDogbmV3IEFycmF5QnVmZmVyKGFyZyk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgX3RoaXMuX2J1ZmZlciA9IGJ1ZmZlcjtcbiAgICBfdGhpcy5fdmlldyA9IG5ldyBEYXRhVmlldyhfdGhpcy5fYnVmZmVyKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKEhlYXBCdWZmZXIsIFt7XG4gICAga2V5OiBcInB1dFVJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1dFVJbnQ4KHBvc2l0aW9uLCB2YWwpIHtcbiAgICAgIHRoaXMuX3ZpZXcuc2V0VWludDgocG9zaXRpb24sIHZhbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFVJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVJbnQ4KHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlldy5nZXRVaW50OChwb3NpdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1dEludDhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0SW50OChwb3NpdGlvbiwgdmFsKSB7XG4gICAgICB0aGlzLl92aWV3LnNldEludDgocG9zaXRpb24sIHZhbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEludDhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW50OChwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcuZ2V0SW50OChwb3NpdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZsb2F0NjRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmxvYXQ2NChwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcuZ2V0RmxvYXQ2NChwb3NpdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1dEZsb2F0NjRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0RmxvYXQ2NChwb3NpdGlvbiwgdmFsKSB7XG4gICAgICB0aGlzLl92aWV3LnNldEZsb2F0NjQocG9zaXRpb24sIHZhbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNsaWNlKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLl9idWZmZXIuc2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIZWFwQnVmZmVyKHRoaXMuX2J1ZmZlci5zbGljZShzdGFydCwgc3RhcnQgKyBsZW5ndGgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNvbWUgcGxhdGZvcm1zIChlZy4gcGhhbnRvbWpzKSBkb24ndCBzdXBwb3J0IHNsaWNlLCBzbyBmYWxsIGJhY2sgdG8gYSBjb3B5XG4gICAgICAgIC8vIFdlIGRvIHRoaXMgcmF0aGVyIHRoYW4gcmV0dXJuIGEgU2xpY2VCdWZmZXIsIGJlY2F1c2Ugc2xpY2VCdWZmZXIgY2Fubm90XG4gICAgICAgIC8vIGJlIHBhc3NlZCB0byBuYXRpdmUgbmV0d29yayB3cml0ZSBvcHMgZXRjIC0gd2UgbmVlZCBBcnJheUJ1ZmZlciBmb3IgdGhhdFxuICAgICAgICB2YXIgY29weSA9IG5ldyBIZWFwQnVmZmVyKGxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvcHkucHV0VUludDgoaSwgdGhpcy5nZXRVSW50OChpICsgc3RhcnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpYyB0byBIZWFwQnVmZmVyLCB0aGlzIGdldHMgYSBEYXRhVmlldyBmcm9tIHRoZVxuICAgICAqIGN1cnJlbnQgcG9zaXRpb24gYW5kIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFZpZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZFZpZXcobGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KHRoaXMuX2J1ZmZlciwgdGhpcy5fdXBkYXRlUG9zKGxlbmd0aCksIGxlbmd0aCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBIZWFwQnVmZmVyO1xufShfYmFzZUJ1ZltcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEhlYXBCdWZmZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfYnJvd3NlckJ1ZiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYnJvd3Nlci1idWZcIikpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBKdXN0IHRvIGJlIHN1cmUgdGhhdCB0aGVzZSB2YWx1ZXMgYXJlIHdpdGggdXMgZXZlbiBhZnRlciBXZWJTb2NrZXQgaXMgaW5qZWN0ZWRcbi8vIGZvciB0ZXN0cy5cbnZhciBXU19DT05ORUNUSU5HID0gMDtcbnZhciBXU19PUEVOID0gMTtcbnZhciBXU19DTE9TSU5HID0gMjtcbnZhciBXU19DTE9TRUQgPSAzO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgV2ViU29ja2V0Q2hhbm5lbCB0byBiZSB1c2VkIGluIHdlYiBicm93c2Vycy5cbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICovXG5cbnZhciBXZWJTb2NrZXRDaGFubmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBuZXcgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtDaGFubmVsQ29uZmlnfSBjb25maWcgLSBjb25maWd1cmF0aW9uIGZvciB0aGlzIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogc3RyaW5nfSBwcm90b2NvbFN1cHBsaWVyIC0gZnVuY3Rpb24gdGhhdCBkZXRlY3RzIHByb3RvY29sIG9mIHRoZSB3ZWIgcGFnZS4gU2hvdWxkIG9ubHkgYmUgdXNlZCBpbiB0ZXN0cy5cbiAgICovXG4gIGZ1bmN0aW9uIFdlYlNvY2tldENoYW5uZWwoY29uZmlnKSB7XG4gICAgdmFyIHByb3RvY29sU3VwcGxpZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGRldGVjdFdlYlBhZ2VQcm90b2NvbDtcbiAgICB2YXIgc29ja2V0RmFjdG9yeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgcmV0dXJuIG5ldyBXZWJTb2NrZXQodXJsKTtcbiAgICB9O1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgV2ViU29ja2V0Q2hhbm5lbCk7XG4gICAgdGhpcy5fb3BlbiA9IHRydWU7XG4gICAgdGhpcy5fcGVuZGluZyA9IFtdO1xuICAgIHRoaXMuX2Vycm9yID0gbnVsbDtcbiAgICB0aGlzLl9oYW5kbGVDb25uZWN0aW9uRXJyb3IgPSB0aGlzLl9oYW5kbGVDb25uZWN0aW9uRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG5cbiAgICB2YXIgX2RldGVybWluZVdlYlNvY2tldFNjID0gZGV0ZXJtaW5lV2ViU29ja2V0U2NoZW1lKGNvbmZpZywgcHJvdG9jb2xTdXBwbGllciksXG4gICAgICAgIHNjaGVtZSA9IF9kZXRlcm1pbmVXZWJTb2NrZXRTYy5zY2hlbWUsXG4gICAgICAgIGVycm9yID0gX2RldGVybWluZVdlYlNvY2tldFNjLmVycm9yO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3dzID0gY3JlYXRlV2ViU29ja2V0KHNjaGVtZSwgY29uZmlnLmFkZHJlc3MsIHNvY2tldEZhY3RvcnkpO1xuICAgIHRoaXMuX3dzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHZhciBzZWxmID0gdGhpczsgLy8gQWxsIGNvbm5lY3Rpb24gZXJyb3JzIGFyZSBub3Qgc2VudCB0byB0aGUgZXJyb3IgaGFuZGxlclxuICAgIC8vIHdlIG11c3QgYWxzbyBjaGVjayBmb3IgZGlydHkgY2xvc2UgY2FsbHNcblxuICAgIHRoaXMuX3dzLm9uY2xvc2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUgJiYgIWUud2FzQ2xlYW4pIHtcbiAgICAgICAgc2VsZi5faGFuZGxlQ29ubmVjdGlvbkVycm9yKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX3dzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIENvbm5lY3RlZCEgQ2FuY2VsIHRoZSBjb25uZWN0aW9uIHRpbWVvdXRcbiAgICAgIHNlbGYuX2NsZWFyQ29ubmVjdGlvblRpbWVvdXQoKTsgLy8gRHJhaW4gYWxsIHBlbmRpbmcgbWVzc2FnZXNcblxuXG4gICAgICB2YXIgcGVuZGluZyA9IHNlbGYuX3BlbmRpbmc7XG4gICAgICBzZWxmLl9wZW5kaW5nID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYud3JpdGUocGVuZGluZ1tpXSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX3dzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKHNlbGYub25tZXNzYWdlKSB7XG4gICAgICAgIHZhciBiID0gbmV3IF9icm93c2VyQnVmW1wiZGVmYXVsdFwiXShldmVudC5kYXRhKTtcbiAgICAgICAgc2VsZi5vbm1lc3NhZ2UoYik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX3dzLm9uZXJyb3IgPSB0aGlzLl9oYW5kbGVDb25uZWN0aW9uRXJyb3I7XG4gICAgdGhpcy5fY29ubmVjdGlvblRpbWVvdXRGaXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25UaW1lb3V0SWQgPSB0aGlzLl9zZXR1cENvbm5lY3Rpb25UaW1lb3V0KCk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFdlYlNvY2tldENoYW5uZWwsIFt7XG4gICAga2V5OiBcIl9oYW5kbGVDb25uZWN0aW9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNvbm5lY3Rpb25FcnJvcigpIHtcbiAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9uVGltZW91dEZpcmVkKSB7XG4gICAgICAgIC8vIHRpbWVvdXQgZmlyZWQgLSBub3QgY29ubmVjdGVkIHdpdGhpbiBjb25maWd1cmVkIHRpbWVcbiAgICAgICAgdGhpcy5fZXJyb3IgPSAoMCwgX2Vycm9yLm5ld0Vycm9yKShcIkZhaWxlZCB0byBlc3RhYmxpc2ggY29ubmVjdGlvbiBpbiBcIi5jb25jYXQodGhpcy5fY29uZmlnLmNvbm5lY3Rpb25UaW1lb3V0LCBcIm1zXCIpLCB0aGlzLl9jb25maWcuY29ubmVjdGlvbkVycm9yQ29kZSk7XG5cbiAgICAgICAgaWYgKHRoaXMub25lcnJvcikge1xuICAgICAgICAgIHRoaXMub25lcnJvcih0aGlzLl9lcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG9uZXJyb3IgdHJpZ2dlcnMgb24gd2Vic29ja2V0IGNsb3NlIGFzIHdlbGwuLiBkb24ndCBnZXQgbWUgc3RhcnRlZC5cblxuXG4gICAgICBpZiAodGhpcy5fb3Blbikge1xuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI1Nzc5ODMxL2hvdy10by1jYXRjaC13ZWJzb2NrZXQtY29ubmVjdGlvbi10by13cy14eHhubi1mYWlsZWQtY29ubmVjdGlvbi1jbG9zZWQtYmVcbiAgICAgICAgdGhpcy5fZXJyb3IgPSAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnV2ViU29ja2V0IGNvbm5lY3Rpb24gZmFpbHVyZS4gRHVlIHRvIHNlY3VyaXR5ICcgKyAnY29uc3RyYWludHMgaW4geW91ciB3ZWIgYnJvd3NlciwgdGhlIHJlYXNvbiBmb3IgdGhlIGZhaWx1cmUgaXMgbm90IGF2YWlsYWJsZSAnICsgJ3RvIHRoaXMgTmVvNGogRHJpdmVyLiBQbGVhc2UgdXNlIHlvdXIgYnJvd3NlcnMgZGV2ZWxvcG1lbnQgY29uc29sZSB0byBkZXRlcm1pbmUgJyArICd0aGUgcm9vdCBjYXVzZSBvZiB0aGUgZmFpbHVyZS4gQ29tbW9uIHJlYXNvbnMgaW5jbHVkZSB0aGUgZGF0YWJhc2UgYmVpbmcgJyArICd1bmF2YWlsYWJsZSwgdXNpbmcgdGhlIHdyb25nIGNvbm5lY3Rpb24gVVJMIG9yIHRlbXBvcmFyeSBuZXR3b3JrIHByb2JsZW1zLiAnICsgJ0lmIHlvdSBoYXZlIGVuYWJsZWQgZW5jcnlwdGlvbiwgZW5zdXJlIHlvdXIgYnJvd3NlciBpcyBjb25maWd1cmVkIHRvIHRydXN0IHRoZSAnICsgJ2NlcnRpZmljYXRlIE5lbzRqIGlzIGNvbmZpZ3VyZWQgdG8gdXNlLiBXZWJTb2NrZXQgYHJlYWR5U3RhdGVgIGlzOiAnICsgdGhpcy5fd3MucmVhZHlTdGF0ZSwgdGhpcy5fY29uZmlnLmNvbm5lY3Rpb25FcnJvckNvZGUpO1xuXG4gICAgICAgIGlmICh0aGlzLm9uZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLm9uZXJyb3IodGhpcy5fZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIHRoZSBwYXNzZWQgaW4gYnVmZmVyIHRvIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0ge0hlYXBCdWZmZXJ9IGJ1ZmZlciAtIEJ1ZmZlciB0byB3cml0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGUoYnVmZmVyKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHBlbmRpbmcgcXVldWUsIHB1c2ggdGhpcyBvbiB0aGF0IHF1ZXVlLiBUaGlzIG1lYW5zXG4gICAgICAvLyB3ZSBhcmUgbm90IHlldCBjb25uZWN0ZWQsIHNvIHdlIHF1ZXVlIHRoaW5ncyBsb2NhbGx5LlxuICAgICAgaWYgKHRoaXMuX3BlbmRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZy5wdXNoKGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIF9icm93c2VyQnVmW1wiZGVmYXVsdFwiXSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuX3dzLnNlbmQoYnVmZmVyLl9idWZmZXIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGlmICh0aGlzLl93cy5yZWFkeVN0YXRlICE9PSBXU19PUEVOKSB7XG4gICAgICAgICAgICAvLyBXZWJzb2NrZXQgaGFzIGJlZW4gY2xvc2VkXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVDb25uZWN0aW9uRXJyb3IoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU29tZSBvdGhlciBlcnJvciBvY2N1cmVkXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKFwiRG9uJ3Qga25vdyBob3cgdG8gc2VuZCBidWZmZXI6IFwiICsgYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCBhZnRlciBjaGFubmVsIGlzIGNsb3NlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoX3RoaXMuX3dzICYmIF90aGlzLl93cy5yZWFkeVN0YXRlICE9PSBXU19DTE9TRUQpIHtcbiAgICAgICAgICBfdGhpcy5fb3BlbiA9IGZhbHNlO1xuXG4gICAgICAgICAgX3RoaXMuX2NsZWFyQ29ubmVjdGlvblRpbWVvdXQoKTtcblxuICAgICAgICAgIF90aGlzLl93cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMuX3dzLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGNvbm5lY3Rpb24gdGltZW91dCBvbiB0aGUgZ2l2ZW4gV2ViU29ja2V0LCBpZiBjb25maWd1cmVkLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIHRpbWVvdXQgaWQgb3IgbnVsbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwQ29ubmVjdGlvblRpbWVvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwQ29ubmVjdGlvblRpbWVvdXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHRpbWVvdXQgPSB0aGlzLl9jb25maWcuY29ubmVjdGlvblRpbWVvdXQ7XG5cbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIHZhciB3ZWJTb2NrZXQgPSB0aGlzLl93cztcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh3ZWJTb2NrZXQucmVhZHlTdGF0ZSAhPT0gV1NfT1BFTikge1xuICAgICAgICAgICAgX3RoaXMyLl9jb25uZWN0aW9uVGltZW91dEZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHdlYlNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWN0aXZlIGNvbm5lY3Rpb24gdGltZW91dCwgaWYgYW55LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2xlYXJDb25uZWN0aW9uVGltZW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYXJDb25uZWN0aW9uVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0SWQgPSB0aGlzLl9jb25uZWN0aW9uVGltZW91dElkO1xuXG4gICAgICBpZiAodGltZW91dElkIHx8IHRpbWVvdXRJZCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uVGltZW91dEZpcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFdlYlNvY2tldENoYW5uZWw7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gV2ViU29ja2V0Q2hhbm5lbDtcblxuZnVuY3Rpb24gY3JlYXRlV2ViU29ja2V0KHNjaGVtZSwgYWRkcmVzcywgc29ja2V0RmFjdG9yeSkge1xuICB2YXIgdXJsID0gc2NoZW1lICsgJzovLycgKyBhZGRyZXNzLmFzSG9zdFBvcnQoKTtcblxuICB0cnkge1xuICAgIHJldHVybiBzb2NrZXRGYWN0b3J5KHVybCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzSVB2NkFkZHJlc3NJc3N1ZU9uV2luZG93cyhlcnJvciwgYWRkcmVzcykpIHtcbiAgICAgIC8vIFdlYlNvY2tldCBpbiBJRSBhbmQgRWRnZSBicm93c2VycyBvbiBXaW5kb3dzIGRvIG5vdCBzdXBwb3J0IHJlZ3VsYXIgSVB2NiBhZGRyZXNzIHN5bnRheCBiZWNhdXNlIHRoZXkgY29udGFpbiAnOicuXG4gICAgICAvLyBJdCdzIGFuIGludmFsaWQgY2hhcmFjdGVyIGZvciBVTkMgKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lQdjZfYWRkcmVzcyNMaXRlcmFsX0lQdjZfYWRkcmVzc2VzX2luX1VOQ19wYXRoX25hbWVzKVxuICAgICAgLy8gYW5kIFdpbmRvd3MgcmVxdWlyZXMgSVB2NiB0byBiZSBjaGFuZ2VzIGluIHRoZSBmb2xsb3dpbmcgd2F5OlxuICAgICAgLy8gICAxKSByZXBsYWNlIGFsbCAnOicgd2l0aCAnLSdcbiAgICAgIC8vICAgMikgcmVwbGFjZSAnJScgd2l0aCAncycgZm9yIGxpbmstbG9jYWwgYWRkcmVzc1xuICAgICAgLy8gICAzKSBhcHBlbmQgJy5pcHY2LWxpdGVyYWwubmV0JyBzdWZmaXhcbiAgICAgIC8vIG9ubHkgdGhlbiByZXN1bHRpbmcgc3RyaW5nIGNhbiBiZSBjb25zaWRlcmVkIGEgdmFsaWQgSVB2NiBhZGRyZXNzLiBZZXMsIHRoaXMgaXMgZXh0cmVtZWx5IHdlaXJkIVxuICAgICAgLy8gRm9yIG1vcmUgZGV0YWlscyBzZWU6XG4gICAgICAvLyAgIGh0dHBzOi8vc29jaWFsLm1zZG4ubWljcm9zb2Z0LmNvbS9Gb3J1bXMvaWUvZW4tVVMvMDZjY2E3M2ItNjNjMi00YmY5LTg5OWItYjIyOWM1MDQ0OWZmL3doZXRoZXItaWUxMC13ZWJzb2NrZXQtc3VwcG9ydC1pcHY2P2ZvcnVtPWlld2ViZGV2ZWxvcG1lbnRcbiAgICAgIC8vICAgaHR0cHM6Ly93d3cuaXRkb2pvLmNvbS9pcHY2LWFkZHJlc3Nlcy1hbmQtdW5jLXBhdGgtbmFtZXMtb3ZlcmNvbWluZy1pbGxlZ2FsL1xuICAgICAgLy8gQ3JlYXRpb24gb2YgV2ViU29ja2V0IHdpdGggdW5jb252ZXJ0ZWQgYWRkcmVzcyByZXN1bHRzIGluIFN5bnRheEVycm9yIHdpdGhvdXQgbWVzc2FnZSBvciBzdGFja3RyYWNlLlxuICAgICAgLy8gVGhhdCBpcyB3aHkgaGVyZSB3ZSBcImNhdGNoXCIgU3ludGF4RXJyb3IgYW5kIHJld3JpdGUgSVB2NiBhZGRyZXNzIGlmIG5lZWRlZC5cbiAgICAgIHZhciB3aW5kb3dzRnJpZW5kbHlVcmwgPSBhc1dpbmRvd3NGcmllbmRseUlQdjZBZGRyZXNzKHNjaGVtZSwgYWRkcmVzcyk7XG4gICAgICByZXR1cm4gc29ja2V0RmFjdG9yeSh3aW5kb3dzRnJpZW5kbHlVcmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJUHY2QWRkcmVzc0lzc3VlT25XaW5kb3dzKGVycm9yLCBhZGRyZXNzKSB7XG4gIHJldHVybiBlcnJvci5uYW1lID09PSAnU3ludGF4RXJyb3InICYmIGlzSVB2NkFkZHJlc3MoYWRkcmVzcy5hc0hvc3RQb3J0KCkpO1xufVxuXG5mdW5jdGlvbiBpc0lQdjZBZGRyZXNzKGhvc3RBbmRQb3J0KSB7XG4gIHJldHVybiBob3N0QW5kUG9ydC5jaGFyQXQoMCkgPT09ICdbJyAmJiBob3N0QW5kUG9ydC5pbmRleE9mKCddJykgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBhc1dpbmRvd3NGcmllbmRseUlQdjZBZGRyZXNzKHNjaGVtZSwgYWRkcmVzcykge1xuICAvLyByZXBsYWNlIGFsbCAnOicgd2l0aCAnLSdcbiAgdmFyIGhvc3RXaXRob3V0Q29sb25zID0gYWRkcmVzcy5ob3N0KCkucmVwbGFjZShuZXcgUmVnRXhwKCc6JywgJ2cnKSwgJy0nKTsgLy8gcmVwbGFjZSAnJScgd2l0aCAncycgZm9yIGxpbmstbG9jYWwgSVB2NiBhZGRyZXNzIGxpa2UgJ2ZlODA6OjElbG8wJ1xuXG4gIHZhciBob3N0V2l0aG91dFBlcmNlbnQgPSBob3N0V2l0aG91dENvbG9ucy5yZXBsYWNlKCclJywgJ3MnKTsgLy8gYXBwZW5kIG1hZ2ljICcuaXB2Ni1saXRlcmFsLm5ldCcgc3VmZml4XG5cbiAgdmFyIGlwdjZIb3N0ID0gaG9zdFdpdGhvdXRQZXJjZW50ICsgJy5pcHY2LWxpdGVyYWwubmV0JztcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHNjaGVtZSwgXCI6Ly9cIikuY29uY2F0KGlwdjZIb3N0LCBcIjpcIikuY29uY2F0KGFkZHJlc3MucG9ydCgpKTtcbn1cbi8qKlxuICogQHBhcmFtIHtDaGFubmVsQ29uZmlnfSBjb25maWcgLSBjb25maWd1cmF0aW9uIGZvciB0aGUgY2hhbm5lbC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogc3RyaW5nfSBwcm90b2NvbFN1cHBsaWVyIC0gZnVuY3Rpb24gdGhhdCBkZXRlY3RzIHByb3RvY29sIG9mIHRoZSB3ZWIgcGFnZS5cbiAqIEByZXR1cm4ge3tzY2hlbWU6IHN0cmluZ3xudWxsLCBlcnJvcjogTmVvNGpFcnJvcnxudWxsfX0gb2JqZWN0IGNvbnRhaW5pbmcgZWl0aGVyIHNjaGVtZSBvciBlcnJvci5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRldGVybWluZVdlYlNvY2tldFNjaGVtZShjb25maWcsIHByb3RvY29sU3VwcGxpZXIpIHtcbiAgdmFyIGVuY3J5cHRpb25PbiA9IGlzRW5jcnlwdGlvbkV4cGxpY2l0bHlUdXJuZWRPbihjb25maWcpO1xuICB2YXIgZW5jcnlwdGlvbk9mZiA9IGlzRW5jcnlwdGlvbkV4cGxpY2l0bHlUdXJuZWRPZmYoY29uZmlnKTtcbiAgdmFyIHRydXN0ID0gY29uZmlnLnRydXN0O1xuICB2YXIgc2VjdXJlUHJvdG9jb2wgPSBpc1Byb3RvY29sU2VjdXJlKHByb3RvY29sU3VwcGxpZXIpO1xuICB2ZXJpZnlFbmNyeXB0aW9uU2V0dGluZ3MoZW5jcnlwdGlvbk9uLCBlbmNyeXB0aW9uT2ZmLCBzZWN1cmVQcm90b2NvbCk7XG5cbiAgaWYgKGVuY3J5cHRpb25PZmYpIHtcbiAgICAvLyBlbmNyeXB0aW9uIGV4cGxpY2l0bHkgdHVybmVkIG9mZiBpbiB0aGUgY29uZmlnXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtZTogJ3dzJyxcbiAgICAgIGVycm9yOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIGlmIChzZWN1cmVQcm90b2NvbCkge1xuICAgIC8vIGRyaXZlciBpcyB1c2VkIGluIGEgc2VjdXJlIGh0dHBzIHdlYiBwYWdlLCB1c2UgJ3dzcydcbiAgICByZXR1cm4ge1xuICAgICAgc2NoZW1lOiAnd3NzJyxcbiAgICAgIGVycm9yOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIGlmIChlbmNyeXB0aW9uT24pIHtcbiAgICAvLyBlbmNyeXB0aW9uIGV4cGxpY2l0bHkgcmVxdWVzdGVkIGluIHRoZSBjb25maWdcbiAgICBpZiAoIXRydXN0IHx8IHRydXN0ID09PSAnVFJVU1RfU1lTVEVNX0NBX1NJR05FRF9DRVJUSUZJQ0FURVMnKSB7XG4gICAgICAvLyB0cnVzdCBzdHJhdGVneSBub3Qgc3BlY2lmaWVkIG9yIHRoZSBvbmx5IHN1cHBvcnRlZCBzdHJhdGVneSBpcyBzcGVjaWZpZWRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogJ3dzcycsXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXJyb3IgPSAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnVGhlIGJyb3dzZXIgdmVyc2lvbiBvZiB0aGlzIGRyaXZlciBvbmx5IHN1cHBvcnRzIG9uZSB0cnVzdCAnICsgXCJzdHJhdGVneSwgJ1RSVVNUX1NZU1RFTV9DQV9TSUdORURfQ0VSVElGSUNBVEVTJy4gXCIgKyB0cnVzdCArICcgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlICcgKyAnZWl0aGVyIHVzZSBUUlVTVF9TWVNURU1fQ0FfU0lHTkVEX0NFUlRJRklDQVRFUyBvciBkaXNhYmxlIGVuY3J5cHRpb24gYnkgc2V0dGluZyAnICsgJ2BlbmNyeXB0ZWQ6XCInICsgX3V0aWwuRU5DUllQVElPTl9PRkYgKyAnXCJgIGluIHRoZSBkcml2ZXIgY29uZmlndXJhdGlvbi4nKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogbnVsbCxcbiAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBkZWZhdWx0IHRvIHVuZW5jcnlwdGVkIHdlYiBzb2NrZXRcblxuXG4gIHJldHVybiB7XG4gICAgc2NoZW1lOiAnd3MnLFxuICAgIGVycm9yOiBudWxsXG4gIH07XG59XG4vKipcbiAqIEBwYXJhbSB7Q2hhbm5lbENvbmZpZ30gY29uZmlnIC0gY29uZmlndXJhdGlvbiBmb3IgdGhlIGNoYW5uZWwuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgZW5jcnlwdGlvbiBlbmFibGVkIGluIHRoZSBjb25maWcsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5cblxuZnVuY3Rpb24gaXNFbmNyeXB0aW9uRXhwbGljaXRseVR1cm5lZE9uKGNvbmZpZykge1xuICByZXR1cm4gY29uZmlnLmVuY3J5cHRlZCA9PT0gdHJ1ZSB8fCBjb25maWcuZW5jcnlwdGVkID09PSBfdXRpbC5FTkNSWVBUSU9OX09OO1xufVxuLyoqXG4gKiBAcGFyYW0ge0NoYW5uZWxDb25maWd9IGNvbmZpZyAtIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBjaGFubmVsLlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGVuY3J5cHRpb24gZGlzYWJsZWQgaW4gdGhlIGNvbmZpZywgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cblxuXG5mdW5jdGlvbiBpc0VuY3J5cHRpb25FeHBsaWNpdGx5VHVybmVkT2ZmKGNvbmZpZykge1xuICByZXR1cm4gY29uZmlnLmVuY3J5cHRlZCA9PT0gZmFsc2UgfHwgY29uZmlnLmVuY3J5cHRlZCA9PT0gX3V0aWwuRU5DUllQVElPTl9PRkY7XG59XG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogc3RyaW5nfSBwcm90b2NvbFN1cHBsaWVyIC0gZnVuY3Rpb24gdGhhdCBkZXRlY3RzIHByb3RvY29sIG9mIHRoZSB3ZWIgcGFnZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBwcm90b2NvbCByZXR1cm5lZCBieSB0aGUgZ2l2ZW4gZnVuY3Rpb24gaXMgc2VjdXJlLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzUHJvdG9jb2xTZWN1cmUocHJvdG9jb2xTdXBwbGllcikge1xuICB2YXIgcHJvdG9jb2wgPSB0eXBlb2YgcHJvdG9jb2xTdXBwbGllciA9PT0gJ2Z1bmN0aW9uJyA/IHByb3RvY29sU3VwcGxpZXIoKSA6ICcnO1xuICByZXR1cm4gcHJvdG9jb2wgJiYgcHJvdG9jb2wudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdodHRwcycpID49IDA7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeUVuY3J5cHRpb25TZXR0aW5ncyhlbmNyeXB0aW9uT24sIGVuY3J5cHRpb25PZmYsIHNlY3VyZVByb3RvY29sKSB7XG4gIGlmIChlbmNyeXB0aW9uT24gJiYgIXNlY3VyZVByb3RvY29sKSB7XG4gICAgLy8gZW5jcnlwdGlvbiBleHBsaWNpdGx5IHR1cm5lZCBvbiBmb3IgYSBkcml2ZXIgdXNlZCBvbiBhIEhUVFAgd2ViIHBhZ2VcbiAgICBjb25zb2xlLndhcm4oJ05lbzRqIGRyaXZlciBpcyBjb25maWd1cmVkIHRvIHVzZSBzZWN1cmUgV2ViU29ja2V0IG9uIGEgSFRUUCB3ZWIgcGFnZS4gJyArICdXZWJTb2NrZXRzIG1pZ2h0IG5vdCB3b3JrIGluIGEgbWl4ZWQgY29udGVudCBlbnZpcm9ubWVudC4gJyArICdQbGVhc2UgY29uc2lkZXIgY29uZmlndXJpbmcgZHJpdmVyIHRvIG5vdCB1c2UgZW5jcnlwdGlvbi4nKTtcbiAgfSBlbHNlIGlmIChlbmNyeXB0aW9uT2ZmICYmIHNlY3VyZVByb3RvY29sKSB7XG4gICAgLy8gZW5jcnlwdGlvbiBleHBsaWNpdGx5IHR1cm5lZCBvZmYgZm9yIGEgZHJpdmVyIHVzZWQgb24gYSBIVFRQUyB3ZWIgcGFnZVxuICAgIGNvbnNvbGUud2FybignTmVvNGogZHJpdmVyIGlzIGNvbmZpZ3VyZWQgdG8gdXNlIGluc2VjdXJlIFdlYlNvY2tldCBvbiBhIEhUVFBTIHdlYiBwYWdlLiAnICsgJ1dlYlNvY2tldHMgbWlnaHQgbm90IHdvcmsgaW4gYSBtaXhlZCBjb250ZW50IGVudmlyb25tZW50LiAnICsgJ1BsZWFzZSBjb25zaWRlciBjb25maWd1cmluZyBkcml2ZXIgdG8gdXNlIGVuY3J5cHRpb24uJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZWN0V2ViUGFnZVByb3RvY29sKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uID8gd2luZG93LmxvY2F0aW9uLnByb3RvY29sIDogbnVsbDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfYmFzZUhvc3ROYW1lUmVzb2x2ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9yZXNvbHZlci9iYXNlLWhvc3QtbmFtZS1yZXNvbHZlclwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yW1wiZGVmYXVsdFwiXSkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBCcm93c2VySG9zdE5hbWVSZXNvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VIb3N0TmFtZVJlc29sdmVyKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoQnJvd3Nlckhvc3ROYW1lUmVzb2x2ZXIsIF9CYXNlSG9zdE5hbWVSZXNvbHZlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihCcm93c2VySG9zdE5hbWVSZXNvbHZlcik7XG5cbiAgZnVuY3Rpb24gQnJvd3Nlckhvc3ROYW1lUmVzb2x2ZXIoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBCcm93c2VySG9zdE5hbWVSZXNvbHZlcik7XG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShCcm93c2VySG9zdE5hbWVSZXNvbHZlciwgW3tcbiAgICBrZXk6IFwicmVzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKGFkZHJlc3MpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlVG9JdHNlbGYoYWRkcmVzcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCcm93c2VySG9zdE5hbWVSZXNvbHZlcjtcbn0oX2Jhc2VIb3N0TmFtZVJlc29sdmVyW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQnJvd3Nlckhvc3ROYW1lUmVzb2x2ZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfYnJvd3NlckJ1ZiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2Jyb3dzZXIvYnJvd3Nlci1idWZcIikpO1xuXG52YXIgX3RleHRFbmNvZGluZ1V0ZiA9IHJlcXVpcmUoXCJ0ZXh0LWVuY29kaW5nLXV0Zi04XCIpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBlbmNvZGVyID0gbmV3IF90ZXh0RW5jb2RpbmdVdGYuVGV4dEVuY29kZXIoJ3V0Zi04Jyk7XG52YXIgZGVjb2RlciA9IG5ldyBfdGV4dEVuY29kaW5nVXRmLlRleHREZWNvZGVyKCd1dGYtOCcpO1xuXG5mdW5jdGlvbiBlbmNvZGUoc3RyKSB7XG4gIHJldHVybiBuZXcgX2Jyb3dzZXJCdWZbXCJkZWZhdWx0XCJdKGVuY29kZXIuZW5jb2RlKHN0cikuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlKGJ1ZmZlciwgbGVuZ3RoKSB7XG4gIGlmIChidWZmZXIgaW5zdGFuY2VvZiBfYnJvd3NlckJ1ZltcImRlZmF1bHRcIl0pIHtcbiAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnJlYWRWaWV3KE1hdGgubWluKGxlbmd0aCwgYnVmZmVyLmxlbmd0aCAtIGJ1ZmZlci5wb3NpdGlvbikpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb3B5IHRoZSBnaXZlbiBidWZmZXIgaW50byBhIHJlZ3VsYXIgYnVmZmVyIGFuZCBkZWNvZGUgdGhhdFxuICAgIHZhciB0bXBCdWYgPSBuZXcgX2Jyb3dzZXJCdWZbXCJkZWZhdWx0XCJdKGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB0bXBCdWYud3JpdGVVSW50OChidWZmZXIucmVhZFVJbnQ4KCkpO1xuICAgIH1cblxuICAgIHRtcEJ1Zi5yZXNldCgpO1xuICAgIHJldHVybiBkZWNvZGVyLmRlY29kZSh0bXBCdWYucmVhZFZpZXcobGVuZ3RoKSk7XG4gIH1cbn1cblxudmFyIF9kZWZhdWx0ID0ge1xuICBlbmNvZGU6IGVuY29kZSxcbiAgZGVjb2RlOiBkZWNvZGVcbn07XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudXRmOCA9IGV4cG9ydHMuSG9zdE5hbWVSZXNvbHZlciA9IGV4cG9ydHMuQ2hhbm5lbCA9IGV4cG9ydHMuYWxsb2MgPSB2b2lkIDA7XG5cbnZhciBfYnJvd3NlckJ1ZiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYnJvd3Nlci1idWZcIikpO1xuXG52YXIgX2Jyb3dzZXJDaGFubmVsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9icm93c2VyLWNoYW5uZWxcIikpO1xuXG52YXIgX2Jyb3dzZXJIb3N0TmFtZVJlc29sdmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9icm93c2VyLWhvc3QtbmFtZS1yZXNvbHZlclwiKSk7XG5cbnZhciBfYnJvd3NlclV0ZiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYnJvd3Nlci11dGY4XCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qXG5cblRoaXMgbW9kdWxlIGV4cG9ydHMgYSBzZXQgb2YgY29tcG9uZW50cyB0byBiZSB1c2VkIGluIGJyb3dzZXIgZW52aXJvbm1lbnQuXG5UaGV5IGFyZSBub3QgY29tcGF0aWJsZSB3aXRoIE5vZGVKUyBlbnZpcm9ubWVudC5cbkFsbCBmaWxlcyBpbXBvcnQvcmVxdWlyZSBBUElzIGZyb20gYG5vZGUvaW5kZXguanNgIGJ5IGRlZmF1bHQuXG5TdWNoIGltcG9ydHMgYXJlIHJlcGxhY2VkIGF0IGJ1aWxkIHRpbWUgd2l0aCBgYnJvd3Nlci9pbmRleC5qc2Agd2hlbiBidWlsZGluZyBhIGJyb3dzZXIgYnVuZGxlLlxuXG5OT1RFOiBleHBvcnRzIGluIHRoaXMgbW9kdWxlIHNob3VsZCBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgbmFtZXMvc3RydWN0dXJlIGFzIGV4cG9ydHMgaW4gYG5vZGUvaW5kZXguanNgLlxuXG4gKi9cbnZhciBhbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKGFyZykge1xuICByZXR1cm4gbmV3IF9icm93c2VyQnVmW1wiZGVmYXVsdFwiXShhcmcpO1xufTtcblxuZXhwb3J0cy5hbGxvYyA9IGFsbG9jO1xudmFyIENoYW5uZWwgPSBfYnJvd3NlckNoYW5uZWxbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5DaGFubmVsID0gQ2hhbm5lbDtcbnZhciBIb3N0TmFtZVJlc29sdmVyID0gX2Jyb3dzZXJIb3N0TmFtZVJlc29sdmVyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuSG9zdE5hbWVSZXNvbHZlciA9IEhvc3ROYW1lUmVzb2x2ZXI7XG52YXIgdXRmOCA9IF9icm93c2VyVXRmW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMudXRmOCA9IHV0Zjg7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBDb21tb24gYmFzZSB3aXRoIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIG1vc3QgYnVmZmVyIG1ldGhvZHMuXG4gKiBCdWZmZXJzIGFyZSBzdGF0ZWZ1bCAtIHRoZXkgdHJhY2sgYSBjdXJyZW50IFwicG9zaXRpb25cIiwgdGhpcyBoZWxwcyBncmVhdGx5XG4gKiB3aGVuIHJlYWRpbmcgYW5kIHdyaXRpbmcgZnJvbSB0aGVtIGluY3JlbWVudGFsbHkuIFlvdSBjYW4gYWxzbyBpZ25vcmUgdGhlXG4gKiBzdGF0ZWZ1bCByZWFkL3dyaXRlIG1ldGhvZHMuXG4gKiByZWFkWFhYIGFuZCB3cml0ZVhYWC1tZXRob2RzIG1vdmUgdGhlIGlubmVyIHBvc2l0aW9uIG9mIHRoZSBidWZmZXIuXG4gKiBwdXRYWFggYW5kIGdldFhYWC1tZXRob2RzIGRvIG5vdC5cbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICovXG52YXIgQmFzZUJ1ZmZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBpbnN0YW5jZSB3aXRoIHRoZSBpbmplY3RlZCBzaXplLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBzaXplXG4gICAqL1xuICBmdW5jdGlvbiBCYXNlQnVmZmVyKHNpemUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIEJhc2VCdWZmZXIpO1xuICAgIHRoaXMucG9zaXRpb24gPSAwO1xuICAgIHRoaXMubGVuZ3RoID0gc2l6ZTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQmFzZUJ1ZmZlciwgW3tcbiAgICBrZXk6IFwiZ2V0VUludDhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VUludDgocG9zaXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEludDhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW50OChwb3NpdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmxvYXQ2NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGbG9hdDY0KHBvc2l0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwdXRVSW50OFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXRVSW50OChwb3NpdGlvbiwgdmFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwdXRJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1dEludDgocG9zaXRpb24sIHZhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHV0RmxvYXQ2NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXRGbG9hdDY0KHBvc2l0aW9uLCB2YWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRJbnQxNlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnQxNihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnQ4KHApIDw8IDggfCB0aGlzLmdldFVJbnQ4KHAgKyAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFVJbnQxNlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVSW50MTYocCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VUludDgocCkgPDwgOCB8IHRoaXMuZ2V0VUludDgocCArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW50MzJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW50MzIocCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50OChwKSA8PCAyNCB8IHRoaXMuZ2V0VUludDgocCArIDEpIDw8IDE2IHwgdGhpcy5nZXRVSW50OChwICsgMikgPDwgOCB8IHRoaXMuZ2V0VUludDgocCArIDMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VUludDMyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVJbnQzMihwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRVSW50OChwKSA8PCAyNCB8IHRoaXMuZ2V0VUludDgocCArIDEpIDw8IDE2IHwgdGhpcy5nZXRVSW50OChwICsgMikgPDwgOCB8IHRoaXMuZ2V0VUludDgocCArIDMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW50NjRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW50NjQocCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50OChwKSA8PCA1NiB8IHRoaXMuZ2V0VUludDgocCArIDEpIDw8IDQ4IHwgdGhpcy5nZXRVSW50OChwICsgMikgPDwgNDAgfCB0aGlzLmdldFVJbnQ4KHAgKyAzKSA8PCAzMiB8IHRoaXMuZ2V0VUludDgocCArIDQpIDw8IDI0IHwgdGhpcy5nZXRVSW50OChwICsgNSkgPDwgMTYgfCB0aGlzLmdldFVJbnQ4KHAgKyA2KSA8PCA4IHwgdGhpcy5nZXRVSW50OChwICsgNyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHNsaWNlIG9mIHRoaXMgYnVmZmVyLiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBjb3B5IGFueSBkYXRhLFxuICAgICAqIGJ1dCBzaW1wbHkgcHJvdmlkZXMgYSBzbGljZSB2aWV3IG9mIHRoaXMgYnVmZmVyXG4gICAgICogQHBhcmFtIHN0YXJ0XG4gICAgICogQHBhcmFtIGxlbmd0aFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2xpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2xpY2Uoc3RhcnQsIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBTbGljZUJ1ZmZlcihzdGFydCwgbGVuZ3RoLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBcbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdXRJbnQxNlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXRJbnQxNihwLCB2YWwpIHtcbiAgICAgIHRoaXMucHV0SW50OChwLCB2YWwgPj4gOCk7XG4gICAgICB0aGlzLnB1dFVJbnQ4KHAgKyAxLCB2YWwgJiAweGZmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBcbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdXRVSW50MTZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0VUludDE2KHAsIHZhbCkge1xuICAgICAgdGhpcy5wdXRVSW50OChwLCB2YWwgPj4gOCAmIDB4ZmYpO1xuICAgICAgdGhpcy5wdXRVSW50OChwICsgMSwgdmFsICYgMHhmZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwXG4gICAgICogQHBhcmFtIHZhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHV0SW50MzJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0SW50MzIocCwgdmFsKSB7XG4gICAgICB0aGlzLnB1dEludDgocCwgdmFsID4+IDI0KTtcbiAgICAgIHRoaXMucHV0VUludDgocCArIDEsIHZhbCA+PiAxNiAmIDB4ZmYpO1xuICAgICAgdGhpcy5wdXRVSW50OChwICsgMiwgdmFsID4+IDggJiAweGZmKTtcbiAgICAgIHRoaXMucHV0VUludDgocCArIDMsIHZhbCAmIDB4ZmYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcFxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1dFVJbnQzMlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXRVSW50MzIocCwgdmFsKSB7XG4gICAgICB0aGlzLnB1dFVJbnQ4KHAsIHZhbCA+PiAyNCAmIDB4ZmYpO1xuICAgICAgdGhpcy5wdXRVSW50OChwICsgMSwgdmFsID4+IDE2ICYgMHhmZik7XG4gICAgICB0aGlzLnB1dFVJbnQ4KHAgKyAyLCB2YWwgPj4gOCAmIDB4ZmYpO1xuICAgICAgdGhpcy5wdXRVSW50OChwICsgMywgdmFsICYgMHhmZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwXG4gICAgICogQHBhcmFtIHZhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHV0SW50NjRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0SW50NjQocCwgdmFsKSB7XG4gICAgICB0aGlzLnB1dEludDgocCwgdmFsID4+IDQ4KTtcbiAgICAgIHRoaXMucHV0VUludDgocCArIDEsIHZhbCA+PiA0MiAmIDB4ZmYpO1xuICAgICAgdGhpcy5wdXRVSW50OChwICsgMiwgdmFsID4+IDM2ICYgMHhmZik7XG4gICAgICB0aGlzLnB1dFVJbnQ4KHAgKyAzLCB2YWwgPj4gMzAgJiAweGZmKTtcbiAgICAgIHRoaXMucHV0VUludDgocCArIDQsIHZhbCA+PiAyNCAmIDB4ZmYpO1xuICAgICAgdGhpcy5wdXRVSW50OChwICsgNSwgdmFsID4+IDE2ICYgMHhmZik7XG4gICAgICB0aGlzLnB1dFVJbnQ4KHAgKyA2LCB2YWwgPj4gOCAmIDB4ZmYpO1xuICAgICAgdGhpcy5wdXRVSW50OChwICsgNywgdmFsICYgMHhmZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBvdGhlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHV0Qnl0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0Qnl0ZXMocG9zaXRpb24sIG90aGVyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgZW5kID0gb3RoZXIucmVtYWluaW5nKCk7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICB0aGlzLnB1dFVJbnQ4KHBvc2l0aW9uICsgaSwgb3RoZXIucmVhZFVJbnQ4KCkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGZyb20gc3RhdGUgcG9zaXRpb24uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWFkVUludDhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZFVJbnQ4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VUludDgodGhpcy5fdXBkYXRlUG9zKDEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBmcm9tIHN0YXRlIHBvc2l0aW9uLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZEludDhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZEludDgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnQ4KHRoaXMuX3VwZGF0ZVBvcygxKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgZnJvbSBzdGF0ZSBwb3NpdGlvbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRVSW50MTZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZFVJbnQxNigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFVJbnQxNih0aGlzLl91cGRhdGVQb3MoMikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGZyb20gc3RhdGUgcG9zaXRpb24uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWFkVUludDMyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRVSW50MzIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRVSW50MzIodGhpcy5fdXBkYXRlUG9zKDQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBmcm9tIHN0YXRlIHBvc2l0aW9uLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZEludDE2XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRJbnQxNigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEludDE2KHRoaXMuX3VwZGF0ZVBvcygyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgZnJvbSBzdGF0ZSBwb3NpdGlvbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRJbnQzMlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkSW50MzIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnQzMih0aGlzLl91cGRhdGVQb3MoNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGZyb20gc3RhdGUgcG9zaXRpb24uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWFkSW50NjRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZEludDY0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50MzIodGhpcy5fdXBkYXRlUG9zKDgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBmcm9tIHN0YXRlIHBvc2l0aW9uLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZEZsb2F0NjRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZEZsb2F0NjQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGbG9hdDY0KHRoaXMuX3VwZGF0ZVBvcyg4KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIHRvIHN0YXRlIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlVUludDhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVVSW50OCh2YWwpIHtcbiAgICAgIHRoaXMucHV0VUludDgodGhpcy5fdXBkYXRlUG9zKDEpLCB2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0byBzdGF0ZSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZUludDhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVJbnQ4KHZhbCkge1xuICAgICAgdGhpcy5wdXRJbnQ4KHRoaXMuX3VwZGF0ZVBvcygxKSwgdmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgdG8gc3RhdGUgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHZhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVJbnQxNlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZUludDE2KHZhbCkge1xuICAgICAgdGhpcy5wdXRJbnQxNih0aGlzLl91cGRhdGVQb3MoMiksIHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIHRvIHN0YXRlIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlSW50MzJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVJbnQzMih2YWwpIHtcbiAgICAgIHRoaXMucHV0SW50MzIodGhpcy5fdXBkYXRlUG9zKDQpLCB2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0byBzdGF0ZSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZVVJbnQzMlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZVVJbnQzMih2YWwpIHtcbiAgICAgIHRoaXMucHV0VUludDMyKHRoaXMuX3VwZGF0ZVBvcyg0KSwgdmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgdG8gc3RhdGUgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHZhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVJbnQ2NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZUludDY0KHZhbCkge1xuICAgICAgdGhpcy5wdXRJbnQ2NCh0aGlzLl91cGRhdGVQb3MoOCksIHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIHRvIHN0YXRlIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlRmxvYXQ2NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZUZsb2F0NjQodmFsKSB7XG4gICAgICB0aGlzLnB1dEZsb2F0NjQodGhpcy5fdXBkYXRlUG9zKDgpLCB2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0byBzdGF0ZSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZUJ5dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlQnl0ZXModmFsKSB7XG4gICAgICB0aGlzLnB1dEJ5dGVzKHRoaXMuX3VwZGF0ZVBvcyh2YWwucmVtYWluaW5nKCkpLCB2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzbGljZSBvZiB0aGlzIGJ1ZmZlci4gVGhpcyBtZXRob2QgZG9lcyBub3QgY29weSBhbnkgZGF0YSxcbiAgICAgKiBidXQgc2ltcGx5IHByb3ZpZGVzIGEgc2xpY2UgdmlldyBvZiB0aGlzIGJ1ZmZlclxuICAgICAqIEBwYXJhbSBsZW5ndGhcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRTbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkU2xpY2UobGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTbGljZSh0aGlzLl91cGRhdGVQb3MobGVuZ3RoKSwgbGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVBvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUG9zKGxlbmd0aCkge1xuICAgICAgdmFyIHAgPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgdGhpcy5wb3NpdGlvbiArPSBsZW5ndGg7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHJlbWFpbmluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtYWluaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbWFpbmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCAtIHRoaXMucG9zaXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhcyByZW1haW5pbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhhc1JlbWFpbmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNSZW1haW5pbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1haW5pbmcoKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHBvc2l0aW9uIHN0YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMucG9zaXRpb24gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGJ1ZmZlciBhbmQgaXQncyBzdGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJ1ZmZlciBhcyBhIHN0cmluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyggcG9zaXRpb249JyArIHRoaXMucG9zaXRpb24gKyAnIClcXG4gICcgKyB0aGlzLnRvSGV4KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYnVmZmVyLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQnVmZmVyIGFzIGEgc3RyaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b0hleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0hleCgpIHtcbiAgICAgIHZhciBvdXQgPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBoZXhCeXRlID0gdGhpcy5nZXRVSW50OChpKS50b1N0cmluZygxNik7XG5cbiAgICAgICAgaWYgKGhleEJ5dGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgaGV4Qnl0ZSA9ICcwJyArIGhleEJ5dGU7XG4gICAgICAgIH1cblxuICAgICAgICBvdXQgKz0gaGV4Qnl0ZTtcblxuICAgICAgICBpZiAoaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgb3V0ICs9ICcgJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQmFzZUJ1ZmZlcjtcbn0oKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHZpZXcgYXMgc2xpY2Ugb2YgYW5vdGhlciBidWZmZXIuXG4gKiBAYWNjZXNzIHByaXZhdGVcbiAqL1xuXG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQmFzZUJ1ZmZlcjtcblxudmFyIFNsaWNlQnVmZmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUJ1ZmZlcikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKFNsaWNlQnVmZmVyLCBfQmFzZUJ1ZmZlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihTbGljZUJ1ZmZlcik7XG5cbiAgZnVuY3Rpb24gU2xpY2VCdWZmZXIoc3RhcnQsIGxlbmd0aCwgaW5uZXIpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFNsaWNlQnVmZmVyKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlbmd0aCk7XG4gICAgX3RoaXMuX3N0YXJ0ID0gc3RhcnQ7XG4gICAgX3RoaXMuX2lubmVyID0gaW5uZXI7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShTbGljZUJ1ZmZlciwgW3tcbiAgICBrZXk6IFwicHV0VUludDhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0VUludDgocG9zaXRpb24sIHZhbCkge1xuICAgICAgdGhpcy5faW5uZXIucHV0VUludDgodGhpcy5fc3RhcnQgKyBwb3NpdGlvbiwgdmFsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VUludDhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VUludDgocG9zaXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbm5lci5nZXRVSW50OCh0aGlzLl9zdGFydCArIHBvc2l0aW9uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHV0SW50OFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXRJbnQ4KHBvc2l0aW9uLCB2YWwpIHtcbiAgICAgIHRoaXMuX2lubmVyLnB1dEludDgodGhpcy5fc3RhcnQgKyBwb3NpdGlvbiwgdmFsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHV0RmxvYXQ2NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXRGbG9hdDY0KHBvc2l0aW9uLCB2YWwpIHtcbiAgICAgIHRoaXMuX2lubmVyLnB1dEZsb2F0NjQodGhpcy5fc3RhcnQgKyBwb3NpdGlvbiwgdmFsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW50OFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnQ4KHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5uZXIuZ2V0SW50OCh0aGlzLl9zdGFydCArIHBvc2l0aW9uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmxvYXQ2NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGbG9hdDY0KHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5uZXIuZ2V0RmxvYXQ2NCh0aGlzLl9zdGFydCArIHBvc2l0aW9uKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNsaWNlQnVmZmVyO1xufShCYXNlQnVmZmVyKTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfYmFzZUJ1ZiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYmFzZS1idWZcIikpO1xuXG52YXIgX25vZGUgPSByZXF1aXJlKFwiLi4vbm9kZVwiKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBCdWZmZXIgdGhhdCBjb21iaW5lcyBtdWx0aXBsZSBidWZmZXJzLCBleHBvc2luZyB0aGVtIGFzIG9uZSBzaW5nbGUgYnVmZmVyLlxuICovXG52YXIgQ29tYmluZWRCdWZmZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQnVmZmVyKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoQ29tYmluZWRCdWZmZXIsIF9CYXNlQnVmZmVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENvbWJpbmVkQnVmZmVyKTtcblxuICBmdW5jdGlvbiBDb21iaW5lZEJ1ZmZlcihidWZmZXJzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBDb21iaW5lZEJ1ZmZlcik7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxlbmd0aCArPSBidWZmZXJzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlbmd0aCk7XG4gICAgX3RoaXMuX2J1ZmZlcnMgPSBidWZmZXJzO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQ29tYmluZWRCdWZmZXIsIFt7XG4gICAga2V5OiBcImdldFVJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVJbnQ4KHBvc2l0aW9uKSB7XG4gICAgICAvLyBTdXJlbHkgdGhlcmUncyBhIGZhc3RlciB3YXkgdG8gZG8gdGhpcy4uIHNvbWUgc29ydCBvZiBsb29rdXAgdGFibGUgdGhpbmc/XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2J1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcnNbaV07IC8vIElmIHRoZSBwb3NpdGlvbiBpcyBub3QgaW4gdGhlIGN1cnJlbnQgYnVmZmVyLCBza2lwIHRoZSBjdXJyZW50IGJ1ZmZlclxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcG9zaXRpb24gLT0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYnVmZmVyLmdldFVJbnQ4KHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEludDgocG9zaXRpb24pIHtcbiAgICAgIC8vIFN1cmVseSB0aGVyZSdzIGEgZmFzdGVyIHdheSB0byBkbyB0aGlzLi4gc29tZSBzb3J0IG9mIGxvb2t1cCB0YWJsZSB0aGluZz9cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5fYnVmZmVyc1tpXTsgLy8gSWYgdGhlIHBvc2l0aW9uIGlzIG5vdCBpbiB0aGUgY3VycmVudCBidWZmZXIsIHNraXAgdGhlIGN1cnJlbnQgYnVmZmVyXG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICBwb3NpdGlvbiAtPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBidWZmZXIuZ2V0SW50OChwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmxvYXQ2NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGbG9hdDY0KHBvc2l0aW9uKSB7XG4gICAgICAvLyBBdCBzb21lIHBvaW50LCBhIG1vcmUgZWZmaWNpZW50IGltcGwuIEZvciBub3csIHdlIGNvcHkgdGhlIDggYnl0ZXNcbiAgICAgIC8vIHdlIHdhbnQgdG8gcmVhZCBhbmQgZGVwZW5kIG9uIHRoZSBwbGF0Zm9ybSBpbXBsIG9mIElFRUUgNzU0LlxuICAgICAgdmFyIGIgPSAoMCwgX25vZGUuYWxsb2MpKDgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICBiLnB1dFVJbnQ4KGksIHRoaXMuZ2V0VUludDgocG9zaXRpb24gKyBpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiLmdldEZsb2F0NjQoMCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb21iaW5lZEJ1ZmZlcjtcbn0oX2Jhc2VCdWZbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDb21iaW5lZEJ1ZmZlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuLi9lcnJvclwiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgREVGQVVMVF9DT05ORUNUSU9OX1RJTUVPVVRfTUlMTElTID0gMzAwMDA7IC8vIDMwIHNlY29uZHMgYnkgZGVmYXVsdFxuXG52YXIgQUxMT1dFRF9WQUxVRVNfRU5DUllQVEVEID0gW251bGwsIHVuZGVmaW5lZCwgdHJ1ZSwgZmFsc2UsIF91dGlsLkVOQ1JZUFRJT05fT04sIF91dGlsLkVOQ1JZUFRJT05fT0ZGXTtcbnZhciBBTExPV0VEX1ZBTFVFU19UUlVTVCA9IFtudWxsLCB1bmRlZmluZWQsICdUUlVTVF9BTExfQ0VSVElGSUNBVEVTJywgJ1RSVVNUX0NVU1RPTV9DQV9TSUdORURfQ0VSVElGSUNBVEVTJywgJ1RSVVNUX1NZU1RFTV9DQV9TSUdORURfQ0VSVElGSUNBVEVTJ107XG5cbnZhciBDaGFubmVsQ29uZmlnID1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1NlcnZlckFkZHJlc3N9IGFkZHJlc3MgdGhlIGFkZHJlc3MgZm9yIHRoZSBjaGFubmVsIHRvIGNvbm5lY3QgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gZHJpdmVyQ29uZmlnIHRoZSBkcml2ZXIgY29uZmlnIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIHdoZW4gZHJpdmVyIGlzIGNyZWF0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29ubmVjdGlvbkVycm9yQ29kZSB0aGUgZGVmYXVsdCBlcnJvciBjb2RlIHRvIHVzZSBvbiBjb25uZWN0aW9uIGVycm9ycy5cbiAqL1xuZnVuY3Rpb24gQ2hhbm5lbENvbmZpZyhhZGRyZXNzLCBkcml2ZXJDb25maWcsIGNvbm5lY3Rpb25FcnJvckNvZGUpIHtcbiAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBDaGFubmVsQ29uZmlnKTtcbiAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgdGhpcy5lbmNyeXB0ZWQgPSBleHRyYWN0RW5jcnlwdGVkKGRyaXZlckNvbmZpZyk7XG4gIHRoaXMudHJ1c3QgPSBleHRyYWN0VHJ1c3QoZHJpdmVyQ29uZmlnKTtcbiAgdGhpcy50cnVzdGVkQ2VydGlmaWNhdGVzID0gZXh0cmFjdFRydXN0ZWRDZXJ0aWZpY2F0ZXMoZHJpdmVyQ29uZmlnKTtcbiAgdGhpcy5rbm93bkhvc3RzUGF0aCA9IGV4dHJhY3RLbm93bkhvc3RzUGF0aChkcml2ZXJDb25maWcpO1xuICB0aGlzLmNvbm5lY3Rpb25FcnJvckNvZGUgPSBjb25uZWN0aW9uRXJyb3JDb2RlIHx8IF9lcnJvci5TRVJWSUNFX1VOQVZBSUxBQkxFO1xuICB0aGlzLmNvbm5lY3Rpb25UaW1lb3V0ID0gZXh0cmFjdENvbm5lY3Rpb25UaW1lb3V0KGRyaXZlckNvbmZpZyk7XG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENoYW5uZWxDb25maWc7XG5cbmZ1bmN0aW9uIGV4dHJhY3RFbmNyeXB0ZWQoZHJpdmVyQ29uZmlnKSB7XG4gIHZhciB2YWx1ZSA9IGRyaXZlckNvbmZpZy5lbmNyeXB0ZWQ7XG5cbiAgaWYgKEFMTE9XRURfVkFMVUVTX0VOQ1JZUFRFRC5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKShcIklsbGVnYWwgdmFsdWUgb2YgdGhlIGVuY3J5cHRlZCBzZXR0aW5nIFwiLmNvbmNhdCh2YWx1ZSwgXCIuIEV4cGVjdGVkIG9uZSBvZiBcIikuY29uY2F0KEFMTE9XRURfVkFMVUVTX0VOQ1JZUFRFRCkpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJ1c3QoZHJpdmVyQ29uZmlnKSB7XG4gIHZhciB2YWx1ZSA9IGRyaXZlckNvbmZpZy50cnVzdDtcblxuICBpZiAoQUxMT1dFRF9WQUxVRVNfVFJVU1QuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoXCJJbGxlZ2FsIHZhbHVlIG9mIHRoZSB0cnVzdCBzZXR0aW5nIFwiLmNvbmNhdCh2YWx1ZSwgXCIuIEV4cGVjdGVkIG9uZSBvZiBcIikuY29uY2F0KEFMTE9XRURfVkFMVUVTX1RSVVNUKSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcnVzdGVkQ2VydGlmaWNhdGVzKGRyaXZlckNvbmZpZykge1xuICByZXR1cm4gZHJpdmVyQ29uZmlnLnRydXN0ZWRDZXJ0aWZpY2F0ZXMgfHwgW107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RLbm93bkhvc3RzUGF0aChkcml2ZXJDb25maWcpIHtcbiAgcmV0dXJuIGRyaXZlckNvbmZpZy5rbm93bkhvc3RzIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RDb25uZWN0aW9uVGltZW91dChkcml2ZXJDb25maWcpIHtcbiAgdmFyIGNvbmZpZ3VyZWRUaW1lb3V0ID0gcGFyc2VJbnQoZHJpdmVyQ29uZmlnLmNvbm5lY3Rpb25UaW1lb3V0LCAxMCk7XG5cbiAgaWYgKGNvbmZpZ3VyZWRUaW1lb3V0ID09PSAwKSB7XG4gICAgLy8gdGltZW91dCBleHBsaWNpdGx5IGNvbmZpZ3VyZWQgdG8gMFxuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKGNvbmZpZ3VyZWRUaW1lb3V0ICYmIGNvbmZpZ3VyZWRUaW1lb3V0IDwgMCkge1xuICAgIC8vIHRpbWVvdXQgZXhwbGljaXRseSBjb25maWd1cmVkIHRvIGEgbmVnYXRpdmUgdmFsdWVcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICghY29uZmlndXJlZFRpbWVvdXQpIHtcbiAgICAvLyB0aW1lb3V0IG5vdCBjb25maWd1cmVkLCB1c2UgZGVmYXVsdCB2YWx1ZVxuICAgIHJldHVybiBERUZBVUxUX0NPTk5FQ1RJT05fVElNRU9VVF9NSUxMSVM7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGltZW91dCBjb25maWd1cmVkLCB1c2UgdGhlIHByb3ZpZGVkIHZhbHVlXG4gICAgcmV0dXJuIGNvbmZpZ3VyZWRUaW1lb3V0O1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5EZWNodW5rZXIgPSBleHBvcnRzLkNodW5rZXIgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2Jhc2VCdWYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2J1Zi9iYXNlLWJ1ZlwiKSk7XG5cbnZhciBfbm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIik7XG5cbnZhciBfY29tYmluZWRCdWYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2J1Zi9jb21iaW5lZC1idWZcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgX0NIVU5LX0hFQURFUl9TSVpFID0gMjtcbnZhciBfTUVTU0FHRV9CT1VOREFSWSA9IDB4MDA7XG52YXIgX0RFRkFVTFRfQlVGRkVSX1NJWkUgPSAxNDAwOyAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI2MTM3MzQvbWF4aW11bS1wYWNrZXQtc2l6ZS1mb3ItYS10Y3AtY29ubmVjdGlvblxuXG4vKipcbiAqIExvb2tzIGxpa2UgYSB3cml0YWJsZSBidWZmZXIsIGNodW5rcyBvdXRwdXQgdHJhbnNwYXJlbnRseSBpbnRvIGEgY2hhbm5lbCBiZWxvdy5cbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICovXG5cbnZhciBDaHVua2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUJ1ZmZlcikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKENodW5rZXIsIF9CYXNlQnVmZmVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENodW5rZXIpO1xuXG4gIGZ1bmN0aW9uIENodW5rZXIoY2hhbm5lbCwgYnVmZmVyU2l6ZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgQ2h1bmtlcik7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAwKTtcbiAgICBfdGhpcy5fYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemUgfHwgX0RFRkFVTFRfQlVGRkVSX1NJWkU7XG4gICAgX3RoaXMuX2NoID0gY2hhbm5lbDtcbiAgICBfdGhpcy5fYnVmZmVyID0gKDAsIF9ub2RlLmFsbG9jKShfdGhpcy5fYnVmZmVyU2l6ZSk7XG4gICAgX3RoaXMuX2N1cnJlbnRDaHVua1N0YXJ0ID0gMDtcbiAgICBfdGhpcy5fY2h1bmtPcGVuID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShDaHVua2VyLCBbe1xuICAgIGtleTogXCJwdXRVSW50OFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXRVSW50OChwb3NpdGlvbiwgdmFsKSB7XG4gICAgICB0aGlzLl9lbnN1cmUoMSk7XG5cbiAgICAgIHRoaXMuX2J1ZmZlci53cml0ZVVJbnQ4KHZhbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1dEludDhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0SW50OChwb3NpdGlvbiwgdmFsKSB7XG4gICAgICB0aGlzLl9lbnN1cmUoMSk7XG5cbiAgICAgIHRoaXMuX2J1ZmZlci53cml0ZUludDgodmFsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHV0RmxvYXQ2NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXRGbG9hdDY0KHBvc2l0aW9uLCB2YWwpIHtcbiAgICAgIHRoaXMuX2Vuc3VyZSg4KTtcblxuICAgICAgdGhpcy5fYnVmZmVyLndyaXRlRmxvYXQ2NCh2YWwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwdXRCeXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXRCeXRlcyhwb3NpdGlvbiwgZGF0YSkge1xuICAgICAgLy8gVE9ETzogSWYgZGF0YSBpcyBsYXJnZXIgdGhhbiBvdXIgY2h1bmsgc2l6ZSBvciBzbywgd2UncmUgdmVyeSBsaWtlbHkgYmV0dGVyIG9mZiBqdXN0IHBhc3NpbmcgdGhpcyBidWZmZXIgb25cbiAgICAgIC8vIHJhdGhlciB0aGFuIGRvaW5nIHRoZSBjb3B5IGhlcmUgVE9ETzogKmhvd2V2ZXIqIG5vdGUgdGhhdCB3ZSBuZWVkIHNvbWUgd2F5IHRvIGZpbmQgb3V0IHdoZW4gdGhlIGRhdGEgaGFzIGJlZW5cbiAgICAgIC8vIHdyaXR0ZW4gKGFuZCB0aHVzIHRoZSBidWZmZXIgY2FuIGJlIHJlLXVzZWQpIGlmIHdlIHRha2UgdGhhdCBhcHByb2FjaFxuICAgICAgd2hpbGUgKGRhdGEucmVtYWluaW5nKCkgPiAwKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGVyZSBpcyBhbiBvcGVuIGNodW5rLCBhbmQgdGhhdCBpdCBoYXMgYXQgbGVhc3Qgb25lIGJ5dGUgb2Ygc3BhY2UgbGVmdFxuICAgICAgICB0aGlzLl9lbnN1cmUoMSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2J1ZmZlci5yZW1haW5pbmcoKSA+IGRhdGEucmVtYWluaW5nKCkpIHtcbiAgICAgICAgICB0aGlzLl9idWZmZXIud3JpdGVCeXRlcyhkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9idWZmZXIud3JpdGVCeXRlcyhkYXRhLnJlYWRTbGljZSh0aGlzLl9idWZmZXIucmVtYWluaW5nKCkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmx1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICBpZiAodGhpcy5fYnVmZmVyLnBvc2l0aW9uID4gMCkge1xuICAgICAgICB0aGlzLl9jbG9zZUNodW5rSWZPcGVuKCk7IC8vIExvY2FsIGNvcHkgYW5kIGNsZWFyIHRoZSBidWZmZXIgZmllbGQuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBidWZmZXIgaXMgbm90IHJlLXJlbGVhc2VkIGlmIHRoZSBmbHVzaCBjYWxsIGZhaWxzXG5cblxuICAgICAgICB2YXIgb3V0ID0gdGhpcy5fYnVmZmVyO1xuICAgICAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlKG91dC5nZXRTbGljZSgwLCBvdXQucG9zaXRpb24pKTsgLy8gQWxsb2MgYSBuZXcgb3V0cHV0IGJ1ZmZlci4gV2UgYXNzdW1lIHdlJ3JlIHVzaW5nIE5vZGVKUydzIGJ1ZmZlciBwb29saW5nIHVuZGVyIHRoZSBob29kIGhlcmUhXG5cblxuICAgICAgICB0aGlzLl9idWZmZXIgPSAoMCwgX25vZGUuYWxsb2MpKHRoaXMuX2J1ZmZlclNpemUpO1xuICAgICAgICB0aGlzLl9jaHVua09wZW4gPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJvbHQgbWVzc2FnZXMgYXJlIGVuY29kZWQgaW4gb25lIG9yIG1vcmUgY2h1bmtzLCBhbmQgdGhlIGJvdW5kYXJ5IGJldHdlZW4gdHdvIG1lc3NhZ2VzXG4gICAgICogaXMgZW5jb2RlZCBhcyBhIDAtbGVuZ3RoIGNodW5rLCBgMDAgMDBgLiBUaGlzIGluc2VydHMgc3VjaCBhIG1lc3NhZ2UgYm91bmRhcnksIGNsb3NpbmdcbiAgICAgKiBhbnkgY3VycmVudGx5IG9wZW4gY2h1bmsgYXMgbmVlZGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtZXNzYWdlQm91bmRhcnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVzc2FnZUJvdW5kYXJ5KCkge1xuICAgICAgdGhpcy5fY2xvc2VDaHVua0lmT3BlbigpO1xuXG4gICAgICBpZiAodGhpcy5fYnVmZmVyLnJlbWFpbmluZygpIDwgX0NIVU5LX0hFQURFUl9TSVpFKSB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgIH0gLy8gV3JpdGUgbWVzc2FnZSBib3VuZGFyeVxuXG5cbiAgICAgIHRoaXMuX2J1ZmZlci53cml0ZUludDE2KF9NRVNTQUdFX0JPVU5EQVJZKTtcbiAgICB9XG4gICAgLyoqIEVuc3VyZSBhdCBsZWFzdCB0aGUgZ2l2ZW4gc2l6ZSBpcyBhdmFpbGFibGUgZm9yIHdyaXRpbmcgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbnN1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Vuc3VyZShzaXplKSB7XG4gICAgICB2YXIgdG9Xcml0ZVNpemUgPSB0aGlzLl9jaHVua09wZW4gPyBzaXplIDogc2l6ZSArIF9DSFVOS19IRUFERVJfU0laRTtcblxuICAgICAgaWYgKHRoaXMuX2J1ZmZlci5yZW1haW5pbmcoKSA8IHRvV3JpdGVTaXplKSB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9jaHVua09wZW4pIHtcbiAgICAgICAgdGhpcy5fY3VycmVudENodW5rU3RhcnQgPSB0aGlzLl9idWZmZXIucG9zaXRpb247XG4gICAgICAgIHRoaXMuX2J1ZmZlci5wb3NpdGlvbiA9IHRoaXMuX2J1ZmZlci5wb3NpdGlvbiArIF9DSFVOS19IRUFERVJfU0laRTtcbiAgICAgICAgdGhpcy5fY2h1bmtPcGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2Nsb3NlQ2h1bmtJZk9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Nsb3NlQ2h1bmtJZk9wZW4oKSB7XG4gICAgICBpZiAodGhpcy5fY2h1bmtPcGVuKSB7XG4gICAgICAgIHZhciBjaHVua1NpemUgPSB0aGlzLl9idWZmZXIucG9zaXRpb24gLSAodGhpcy5fY3VycmVudENodW5rU3RhcnQgKyBfQ0hVTktfSEVBREVSX1NJWkUpO1xuXG4gICAgICAgIHRoaXMuX2J1ZmZlci5wdXRVSW50MTYodGhpcy5fY3VycmVudENodW5rU3RhcnQsIGNodW5rU2l6ZSk7XG5cbiAgICAgICAgdGhpcy5fY2h1bmtPcGVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDaHVua2VyO1xufShfYmFzZUJ1ZltcImRlZmF1bHRcIl0pO1xuLyoqXG4gKiBDb21iaW5lcyBjaHVua3MgdW50aWwgYSBjb21wbGV0ZSBtZXNzYWdlIGlzIGdhdGhlcmVkIHVwLCBhbmQgdGhlbiBmb3J3YXJkcyB0aGF0XG4gKiBtZXNzYWdlIHRvIGFuICdvbm1lc3NhZ2UnIGxpc3RlbmVyLlxuICogQGFjY2VzcyBwcml2YXRlXG4gKi9cblxuXG5leHBvcnRzLkNodW5rZXIgPSBDaHVua2VyO1xuXG52YXIgRGVjaHVua2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGVjaHVua2VyKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgRGVjaHVua2VyKTtcbiAgICB0aGlzLl9jdXJyZW50TWVzc2FnZSA9IFtdO1xuICAgIHRoaXMuX3BhcnRpYWxDaHVua0hlYWRlciA9IDA7XG4gICAgdGhpcy5fc3RhdGUgPSB0aGlzLkFXQUlUSU5HX0NIVU5LO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShEZWNodW5rZXIsIFt7XG4gICAga2V5OiBcIkFXQUlUSU5HX0NIVU5LXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIEFXQUlUSU5HX0NIVU5LKGJ1Zikge1xuICAgICAgaWYgKGJ1Zi5yZW1haW5pbmcoKSA+PSAyKSB7XG4gICAgICAgIC8vIFdob2xlIGhlYWRlciBhdmFpbGFibGUsIHJlYWQgdGhhdFxuICAgICAgICByZXR1cm4gdGhpcy5fb25IZWFkZXIoYnVmLnJlYWRVSW50MTYoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbmx5IG9uZSBieXRlIGF2YWlsYWJsZSwgcmVhZCB0aGF0IGFuZCB3YWl0IGZvciB0aGUgc2Vjb25kIGJ5dGVcbiAgICAgICAgdGhpcy5fcGFydGlhbENodW5rSGVhZGVyID0gYnVmLnJlYWRVSW50OCgpIDw8IDg7XG4gICAgICAgIHJldHVybiB0aGlzLklOX0hFQURFUjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiSU5fSEVBREVSXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIElOX0hFQURFUihidWYpIHtcbiAgICAgIC8vIEZpcnN0IGhlYWRlciBieXRlIHJlYWQsIG5vdyB3ZSByZWFkIHRoZSBuZXh0IG9uZVxuICAgICAgcmV0dXJuIHRoaXMuX29uSGVhZGVyKCh0aGlzLl9wYXJ0aWFsQ2h1bmtIZWFkZXIgfCBidWYucmVhZFVJbnQ4KCkpICYgMHhmZmZmKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiSU5fQ0hVTktcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gSU5fQ0hVTksoYnVmKSB7XG4gICAgICBpZiAodGhpcy5fY2h1bmtTaXplIDw9IGJ1Zi5yZW1haW5pbmcoKSkge1xuICAgICAgICAvLyBDdXJyZW50IHBhY2tldCBpcyBsYXJnZXIgdGhhbiBjdXJyZW50IGNodW5rLCBvciBzYW1lIHNpemU6XG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZXNzYWdlLnB1c2goYnVmLnJlYWRTbGljZSh0aGlzLl9jaHVua1NpemUpKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5BV0FJVElOR19DSFVOSztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEN1cnJlbnQgcGFja2V0IGlzIHNtYWxsZXIgdGhhbiB0aGUgY2h1bmsgd2UncmUgcmVhZGluZywgc3BsaXQgdGhlIGN1cnJlbnQgY2h1bmsgaXRzZWxmIHVwXG4gICAgICAgIHRoaXMuX2NodW5rU2l6ZSAtPSBidWYucmVtYWluaW5nKCk7XG5cbiAgICAgICAgdGhpcy5fY3VycmVudE1lc3NhZ2UucHVzaChidWYucmVhZFNsaWNlKGJ1Zi5yZW1haW5pbmcoKSkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLklOX0NIVU5LO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJDTE9TRURcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gQ0xPU0VEKGJ1Zikge30gLy8gbm8tb3BcblxuICAgIC8qKiBDYWxsZWQgd2hlbiBhIGNvbXBsZXRlIGNodW5rIGhlYWRlciBoYXMgYmVlbiByZWNlaXZlZCAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX29uSGVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkhlYWRlcihoZWFkZXIpIHtcbiAgICAgIGlmIChoZWFkZXIgPT09IDApIHtcbiAgICAgICAgLy8gTWVzc2FnZSBib3VuZGFyeVxuICAgICAgICB2YXIgbWVzc2FnZTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuX2N1cnJlbnRNZXNzYWdlLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIC8vIEtlZXAgYWxpdmUgY2h1bmssIHNlbnQgYnkgc2VydmVyIHRvIGtlZXAgbmV0d29yayBhbGl2ZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLkFXQUlUSU5HX0NIVU5LO1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gQWxsIGRhdGEgaW4gb25lIGNodW5rLCB0aGlzIHNpZ25hbHMgdGhlIGVuZCBvZiB0aGF0IGNodW5rLlxuICAgICAgICAgICAgbWVzc2FnZSA9IHRoaXMuX2N1cnJlbnRNZXNzYWdlWzBdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gQSBsYXJnZSBjaHVuayBvZiBkYXRhIHJlY2VpdmVkLCB0aGlzIHNpZ25hbHMgdGhhdCB0aGUgbGFzdCBjaHVuayBoYXMgYmVlbiByZWNlaXZlZC5cbiAgICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgX2NvbWJpbmVkQnVmW1wiZGVmYXVsdFwiXSh0aGlzLl9jdXJyZW50TWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZXNzYWdlID0gW107XG4gICAgICAgIHRoaXMub25tZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5BV0FJVElOR19DSFVOSztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NodW5rU2l6ZSA9IGhlYWRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuSU5fQ0hVTks7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlKGJ1Zikge1xuICAgICAgd2hpbGUgKGJ1Zi5oYXNSZW1haW5pbmcoKSkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX3N0YXRlKGJ1Zik7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEZWNodW5rZXI7XG59KCk7XG5cbmV4cG9ydHMuRGVjaHVua2VyID0gRGVjaHVua2VyOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9ub2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKTtcblxudmFyIF9jaHVua2luZyA9IHJlcXVpcmUoXCIuL2NodW5raW5nXCIpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xuXG52YXIgX2NoYW5uZWxDb25maWcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NoYW5uZWwtY29uZmlnXCIpKTtcblxudmFyIF9wcm90b2NvbEhhbmRzaGFrZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Byb3RvY29sLWhhbmRzaGFrZXJcIikpO1xuXG52YXIgX2Nvbm5lY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb25cIikpO1xuXG52YXIgX2JvbHRQcm90b2NvbFYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2JvbHQtcHJvdG9jb2wtdjFcIikpO1xuXG52YXIgX3N0cmVhbU9ic2VydmVycyA9IHJlcXVpcmUoXCIuL3N0cmVhbS1vYnNlcnZlcnNcIik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yW1wiZGVmYXVsdFwiXSkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8vIFNpZ25hdHVyZSBieXRlcyBmb3IgZWFjaCByZXNwb25zZSBtZXNzYWdlIHR5cGVcbnZhciBTVUNDRVNTID0gMHg3MDsgLy8gMDExMSAwMDAwIC8vIFNVQ0NFU1MgPG1ldGFkYXRhPlxuXG52YXIgUkVDT1JEID0gMHg3MTsgLy8gMDExMSAwMDAxIC8vIFJFQ09SRCA8dmFsdWU+XG5cbnZhciBJR05PUkVEID0gMHg3ZTsgLy8gMDExMSAxMTEwIC8vIElHTk9SRUQgPG1ldGFkYXRhPlxuXG52YXIgRkFJTFVSRSA9IDB4N2Y7IC8vIDAxMTEgMTExMSAvLyBGQUlMVVJFIDxtZXRhZGF0YT5cblxuZnVuY3Rpb24gTk9fT1AoKSB7fVxuXG52YXIgTk9fT1BfT0JTRVJWRVIgPSB7XG4gIG9uTmV4dDogTk9fT1AsXG4gIG9uQ29tcGxldGVkOiBOT19PUCxcbiAgb25FcnJvcjogTk9fT1Bcbn07XG52YXIgaWRHZW5lcmF0b3IgPSAwO1xuXG52YXIgQ2hhbm5lbENvbm5lY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db25uZWN0aW9uKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoQ2hhbm5lbENvbm5lY3Rpb24sIF9Db25uZWN0aW9uKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENoYW5uZWxDb25uZWN0aW9uKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Q2hhbm5lbH0gY2hhbm5lbCAtIGNoYW5uZWwgd2l0aCBhICd3cml0ZScgZnVuY3Rpb24gYW5kIGEgJ29ubWVzc2FnZScgY2FsbGJhY2sgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbkVycm9ySGFuZGxlcn0gZXJyb3JIYW5kbGVyIHRoZSBlcnJvciBoYW5kbGVyLlxuICAgKiBAcGFyYW0ge1NlcnZlckFkZHJlc3N9IGFkZHJlc3MgLSB0aGUgc2VydmVyIGFkZHJlc3MgdG8gY29ubmVjdCB0by5cbiAgICogQHBhcmFtIHtMb2dnZXJ9IGxvZyAtIHRoZSBjb25maWd1cmVkIGxvZ2dlci5cbiAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlTG9zc2xlc3NJbnRlZ2VycyBpZiB0aGlzIGNvbm5lY3Rpb24gc2hvdWxkIGNvbnZlcnQgYWxsIHJlY2VpdmVkIGludGVnZXJzIHRvIG5hdGl2ZSBKUyBudW1iZXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2hhbm5lbENvbm5lY3Rpb24oY2hhbm5lbCwgZXJyb3JIYW5kbGVyLCBhZGRyZXNzLCBsb2cpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuICAgIHZhciBzZXJ2ZXJzaWRlUm91dGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogbnVsbDtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIENoYW5uZWxDb25uZWN0aW9uKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGVycm9ySGFuZGxlcik7XG4gICAgX3RoaXMuX2lkID0gaWRHZW5lcmF0b3IrKztcbiAgICBfdGhpcy5fYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgX3RoaXMuX3NlcnZlciA9IHtcbiAgICAgIGFkZHJlc3M6IGFkZHJlc3MuYXNIb3N0UG9ydCgpXG4gICAgfTtcbiAgICBfdGhpcy5jcmVhdGlvblRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgX3RoaXMuX2Rpc2FibGVMb3NzbGVzc0ludGVnZXJzID0gZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnM7XG4gICAgX3RoaXMuX3BlbmRpbmdPYnNlcnZlcnMgPSBbXTtcbiAgICBfdGhpcy5fY3VycmVudE9ic2VydmVyID0gdW5kZWZpbmVkO1xuICAgIF90aGlzLl9jaCA9IGNoYW5uZWw7XG4gICAgX3RoaXMuX2RlY2h1bmtlciA9IG5ldyBfY2h1bmtpbmcuRGVjaHVua2VyKCk7XG4gICAgX3RoaXMuX2NodW5rZXIgPSBuZXcgX2NodW5raW5nLkNodW5rZXIoY2hhbm5lbCk7XG4gICAgX3RoaXMuX2xvZyA9IGxvZztcbiAgICBfdGhpcy5fc2VydmVyc2lkZVJvdXRpbmcgPSBzZXJ2ZXJzaWRlUm91dGluZzsgLy8gY29ubmVjdGlvbiBmcm9tIHRoZSBkYXRhYmFzZSwgcmV0dXJuZWQgaW4gcmVzcG9uc2UgZm9yIEhFTExPIG1lc3NhZ2UgYW5kIG1pZ2h0IG5vdCBiZSBhdmFpbGFibGVcblxuICAgIF90aGlzLl9kYkNvbm5lY3Rpb25JZCA9IG51bGw7IC8vIGJvbHQgcHJvdG9jb2wgaXMgaW5pdGlhbGx5IG5vdCBpbml0aWFsaXplZFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Qm9sdFByb3RvY29sfVxuICAgICAqL1xuXG4gICAgX3RoaXMuX3Byb3RvY29sID0gbnVsbDsgLy8gZXJyb3IgZXh0cmFjdGVkIGZyb20gYSBGQUlMVVJFIG1lc3NhZ2VcblxuICAgIF90aGlzLl9jdXJyZW50RmFpbHVyZSA9IG51bGw7IC8vIFNldCB0byB0cnVlIG9uIGZhdGFsIGVycm9ycywgdG8gZ2V0IHRoaXMgb3V0IG9mIGNvbm5lY3Rpb24gcG9vbC5cblxuICAgIF90aGlzLl9pc0Jyb2tlbiA9IGZhbHNlO1xuXG4gICAgaWYgKF90aGlzLl9sb2cuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgX3RoaXMuX2xvZy5kZWJ1ZyhcIlwiLmNvbmNhdCgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDJbXCJkZWZhdWx0XCJdKShfdGhpcyksIFwiIGNyZWF0ZWQgdG93YXJkcyBcIikuY29uY2F0KGFkZHJlc3MpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZXRlIG5ldyBjb25uZWN0aW9uIHRvIHRoZSBwcm92aWRlZCBhZGRyZXNzLiBSZXR1cm5lZCBjb25uZWN0aW9uIGlzIG5vdCBjb25uZWN0ZWQuXG4gICAqIEBwYXJhbSB7U2VydmVyQWRkcmVzc30gYWRkcmVzcyAtIHRoZSBCb2x0IGVuZHBvaW50IHRvIGNvbm5lY3QgdG8uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSB0aGUgZHJpdmVyIGNvbmZpZ3VyYXRpb24uXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbkVycm9ySGFuZGxlcn0gZXJyb3JIYW5kbGVyIC0gdGhlIGVycm9yIGhhbmRsZXIgZm9yIGNvbm5lY3Rpb24gZXJyb3JzLlxuICAgKiBAcGFyYW0ge0xvZ2dlcn0gbG9nIC0gY29uZmlndXJlZCBsb2dnZXIuXG4gICAqIEByZXR1cm4ge0Nvbm5lY3Rpb259IC0gbmV3IGNvbm5lY3Rpb24uXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShDaGFubmVsQ29ubmVjdGlvbiwgW3tcbiAgICBrZXk6IFwiY29ubmVjdFwiLFxuXG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgdGFyZ2V0IGFkZHJlc3MsIG5lZ290aWF0ZSBCb2x0IHByb3RvY29sIGFuZCBzZW5kIGluaXRpYWxpemF0aW9uIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJBZ2VudCB0aGUgdXNlciBhZ2VudCBmb3IgdGhpcyBkcml2ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF1dGhUb2tlbiB0aGUgb2JqZWN0IGNvbnRhaW5pbmcgYXV0aCBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbm5lY3Rpb24+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBpZiBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWwuIFJlamVjdGVkIHByb21pc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KHVzZXJBZ2VudCwgYXV0aFRva2VuKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuX25lZ290aWF0ZVByb3RvY29sKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuX2luaXRpYWxpemUodXNlckFnZW50LCBhdXRoVG9rZW4pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgQm9sdCBwcm90b2NvbCBoYW5kc2hha2UgdG8gaW5pdGlhbGl6ZSB0aGUgcHJvdG9jb2wgdmVyc2lvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbm5lY3Rpb24+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBpZiBoYW5kc2hha2UgaXMgc3VjY2Vzc2Z1bC4gUmVqZWN0ZWQgcHJvbWlzZSBvdGhlcndpc2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbmVnb3RpYXRlUHJvdG9jb2xcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25lZ290aWF0ZVByb3RvY29sKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBwcm90b2NvbEhhbmRzaGFrZXIgPSBuZXcgX3Byb3RvY29sSGFuZHNoYWtlcltcImRlZmF1bHRcIl0odGhpcywgdGhpcy5fY2gsIHRoaXMuX2NodW5rZXIsIHRoaXMuX2Rpc2FibGVMb3NzbGVzc0ludGVnZXJzLCB0aGlzLl9sb2csIHRoaXMuX3NlcnZlcnNpZGVSb3V0aW5nKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBoYW5kc2hha2VFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kc2hha2VFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgICAgICAgICBfdGhpczMuX2hhbmRsZUZhdGFsRXJyb3IoZXJyb3IpO1xuXG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpczMuX2NoLm9uZXJyb3IgPSBoYW5kc2hha2VFcnJvckhhbmRsZXIuYmluZChfdGhpczMpO1xuXG4gICAgICAgIGlmIChfdGhpczMuX2NoLl9lcnJvcikge1xuICAgICAgICAgIC8vIGNoYW5uZWwgaXMgYWxyZWFkeSBicm9rZW5cbiAgICAgICAgICBoYW5kc2hha2VFcnJvckhhbmRsZXIoX3RoaXMzLl9jaC5fZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMzLl9jaC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHJlYWQgdGhlIHJlc3BvbnNlIGJ1ZmZlciBhbmQgaW5pdGlhbGl6ZSB0aGUgcHJvdG9jb2xcbiAgICAgICAgICAgIF90aGlzMy5fcHJvdG9jb2wgPSBwcm90b2NvbEhhbmRzaGFrZXIuY3JlYXRlTmVnb3RpYXRlZFByb3RvY29sKGJ1ZmZlcik7IC8vIHJlc2V0IHRoZSBlcnJvciBoYW5kbGVyIHRvIGp1c3QgaGFuZGxlIGVycm9ycyBhbmQgZm9yZ2V0IGFib3V0IHRoZSBoYW5kc2hha2UgcHJvbWlzZVxuXG4gICAgICAgICAgICBfdGhpczMuX2NoLm9uZXJyb3IgPSBfdGhpczMuX2hhbmRsZUZhdGFsRXJyb3IuYmluZChfdGhpczMpOyAvLyBPaywgcHJvdG9jb2wgcnVubmluZy4gU2ltcGx5IGZvcndhcmQgYWxsIG1lc3NhZ2VzIHRvIHRoZSBkZWNodW5rZXJcblxuICAgICAgICAgICAgX3RoaXMzLl9jaC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczMuX2RlY2h1bmtlci53cml0ZShidWYpO1xuICAgICAgICAgICAgfTsgLy8gc2V0dXAgZGVjaHVua2VyIHRvIGRlY2h1bmsgbWVzc2FnZXMgYW5kIGZvcndhcmQgdGhlbSB0byB0aGUgbWVzc2FnZSBoYW5kbGVyXG5cblxuICAgICAgICAgICAgX3RoaXMzLl9kZWNodW5rZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgICAgICAgICBfdGhpczMuX2hhbmRsZU1lc3NhZ2UoX3RoaXMzLl9wcm90b2NvbC51bnBhY2tlcigpLnVucGFjayhidWYpKTtcbiAgICAgICAgICAgIH07IC8vIGZvcndhcmQgYWxsIHBlbmRpbmcgYnl0ZXMgdG8gdGhlIGRlY2h1bmtlclxuXG5cbiAgICAgICAgICAgIGlmIChidWZmZXIuaGFzUmVtYWluaW5nKCkpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLl9kZWNodW5rZXIud3JpdGUoYnVmZmVyLnJlYWRTbGljZShidWZmZXIucmVtYWluaW5nKCkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShfdGhpczMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIF90aGlzMy5faGFuZGxlRmF0YWxFcnJvcihlKTtcblxuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBwcm90b2NvbEhhbmRzaGFrZXIud3JpdGVIYW5kc2hha2VSZXF1ZXN0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBwcm90b2NvbC1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiB3aGljaCBpbmNsdWRlcyBhdXRoZW50aWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlckFnZW50IHRoZSB1c2VyIGFnZW50IGZvciB0aGlzIGRyaXZlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXV0aFRva2VuIHRoZSBvYmplY3QgY29udGFpbmluZyBhdXRoIGluZm9ybWF0aW9uLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8Q29ubmVjdGlvbj59IHByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgY3VycmVudCBjb25uZWN0aW9uIGlmIGluaXRpYWxpemF0aW9uIGlzIHN1Y2Nlc3NmdWwuIFJlamVjdGVkIHByb21pc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRpYWxpemUodXNlckFnZW50LCBhdXRoVG9rZW4pIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfdGhpczQuX3Byb3RvY29sLmluaXRpYWxpemUoe1xuICAgICAgICAgIHVzZXJBZ2VudDogdXNlckFnZW50LFxuICAgICAgICAgIGF1dGhUb2tlbjogYXV0aFRva2VuLFxuICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEJvbHQgcHJvdG9jb2wgZm9yIHRoZSBjb25uZWN0aW9uLlxuICAgICAqIEByZXR1cm4ge0JvbHRQcm90b2NvbH0gdGhlIHByb3RvY29sLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJvdG9jb2xcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvdG9jb2woKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2w7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlXCIsXG5cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIG1lc3NhZ2UgdG8gdGhlIG5ldHdvcmsgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0ge1JlcXVlc3RNZXNzYWdlfSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSB7UmVzdWx0U3RyZWFtT2JzZXJ2ZXJ9IG9ic2VydmVyIHRoZSByZXNwb25zZSBvYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsdXNoIGB0cnVlYCBpZiBmbHVzaCBzaG91bGQgaGFwcGVuIGFmdGVyIHRoZSBtZXNzYWdlIGlzIHdyaXR0ZW4gdG8gdGhlIGJ1ZmZlci5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGUobWVzc2FnZSwgb2JzZXJ2ZXIsIGZsdXNoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIHF1ZXVlZCA9IHRoaXMuX3F1ZXVlT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuXG4gICAgICBpZiAocXVldWVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9sb2cuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIlwiLmNvbmNhdCh0aGlzLCBcIiBDOiBcIikuY29uY2F0KG1lc3NhZ2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Byb3RvY29sLnBhY2tlcigpLnBhY2tTdHJ1Y3QobWVzc2FnZS5zaWduYXR1cmUsIG1lc3NhZ2UuZmllbGRzLm1hcChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM1Ll9wYWNrYWJsZShmaWVsZCk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICB0aGlzLl9jaHVua2VyLm1lc3NhZ2VCb3VuZGFyeSgpO1xuXG4gICAgICAgIGlmIChmbHVzaCkge1xuICAgICAgICAgIHRoaXMuX2NodW5rZXIuZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBcIkZhdGFsXCIgbWVhbnMgdGhlIGNvbm5lY3Rpb24gaXMgZGVhZC4gT25seSBjYWxsIHRoaXMgaWYgc29tZXRoaW5nXG4gICAgICogaGFwcGVucyB0aGF0IGNhbm5vdCBiZSByZWNvdmVyZWQgZnJvbS4gVGhpcyB3aWxsIGxlYWQgdG8gYWxsIHN1YnNjcmliZXJzXG4gICAgICogZmFpbGluZywgYW5kIHRoZSBjb25uZWN0aW9uIGdldHRpbmcgZWplY3RlZCBmcm9tIHRoZSBzZXNzaW9uIHBvb2wuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3IgYW4gZXJyb3Igb2JqZWN0LCBmb3J3YXJkZWQgdG8gYWxsIGN1cnJlbnQgYW5kIGZ1dHVyZSBzdWJzY3JpYmVyc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZUZhdGFsRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUZhdGFsRXJyb3IoZXJyb3IpIHtcbiAgICAgIHRoaXMuX2lzQnJva2VuID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2Vycm9yID0gdGhpcy5oYW5kbGVBbmRUcmFuc2Zvcm1FcnJvcihlcnJvciwgdGhpcy5fYWRkcmVzcyk7XG5cbiAgICAgIGlmICh0aGlzLl9sb2cuaXNFcnJvckVuYWJsZWQoKSkge1xuICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJcIi5jb25jYXQodGhpcywgXCIgZXhwZXJpZW5jZWQgYSBmYXRhbCBlcnJvciBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KHRoaXMuX2Vycm9yKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY3VycmVudE9ic2VydmVyICYmIHRoaXMuX2N1cnJlbnRPYnNlcnZlci5vbkVycm9yKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRPYnNlcnZlci5vbkVycm9yKHRoaXMuX2Vycm9yKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRoaXMuX3BlbmRpbmdPYnNlcnZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLl9wZW5kaW5nT2JzZXJ2ZXJzLnNoaWZ0KCk7XG5cbiAgICAgICAgaWYgKG9ic2VydmVyICYmIG9ic2VydmVyLm9uRXJyb3IpIHtcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKHRoaXMuX2Vycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTWVzc2FnZShtc2cpIHtcbiAgICAgIGlmICh0aGlzLl9pc0Jyb2tlbikge1xuICAgICAgICAvLyBpZ25vcmUgYWxsIGluY29taW5nIG1lc3NhZ2VzIHdoZW4gdGhpcyBjb25uZWN0aW9uIGlzIGJyb2tlbi4gYWxsIHByZXZpb3VzbHkgcGVuZGluZyBvYnNlcnZlcnMgZmFpbGVkXG4gICAgICAgIC8vIHdpdGggdGhlIGZhdGFsIGVycm9yLiBhbGwgZnV0dXJlIG9ic2VydmVycyB3aWxsIGZhaWwgd2l0aCBzYW1lIGZhdGFsIGVycm9yLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXlsb2FkID0gbXNnLmZpZWxkc1swXTtcblxuICAgICAgc3dpdGNoIChtc2cuc2lnbmF0dXJlKSB7XG4gICAgICAgIGNhc2UgUkVDT1JEOlxuICAgICAgICAgIGlmICh0aGlzLl9sb2cuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiXCIuY29uY2F0KHRoaXMsIFwiIFM6IFJFQ09SRCBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KG1zZykpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9jdXJyZW50T2JzZXJ2ZXIub25OZXh0KHBheWxvYWQpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTVUNDRVNTOlxuICAgICAgICAgIGlmICh0aGlzLl9sb2cuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiXCIuY29uY2F0KHRoaXMsIFwiIFM6IFNVQ0NFU1MgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShtc2cpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHRoaXMuX3Byb3RvY29sLnRyYW5zZm9ybU1ldGFkYXRhKHBheWxvYWQpO1xuXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50T2JzZXJ2ZXIub25Db21wbGV0ZWQobWV0YWRhdGEpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDdXJyZW50T2JzZXJ2ZXIoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEZBSUxVUkU6XG4gICAgICAgICAgaWYgKHRoaXMuX2xvZy5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJcIi5jb25jYXQodGhpcywgXCIgUzogRkFJTFVSRSBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KG1zZykpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gKDAsIF9lcnJvci5uZXdFcnJvcikocGF5bG9hZC5tZXNzYWdlLCBwYXlsb2FkLmNvZGUpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEZhaWx1cmUgPSB0aGlzLmhhbmRsZUFuZFRyYW5zZm9ybUVycm9yKGVycm9yLCB0aGlzLl9hZGRyZXNzKTtcblxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE9ic2VydmVyLm9uRXJyb3IodGhpcy5fY3VycmVudEZhaWx1cmUpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDdXJyZW50T2JzZXJ2ZXIoKTsgLy8gVGhpbmdzIGFyZSBub3cgYnJva2VuLiBQZW5kaW5nIG9ic2VydmVycyB3aWxsIGdldCBGQUlMVVJFIG1lc3NhZ2VzIHJvdXRlZCB1bnRpbCB3ZSBhcmUgZG9uZSBoYW5kbGluZyB0aGlzIGZhaWx1cmUuXG5cblxuICAgICAgICAgICAgdGhpcy5fcmVzZXRPbkZhaWx1cmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIElHTk9SRUQ6XG4gICAgICAgICAgaWYgKHRoaXMuX2xvZy5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJcIi5jb25jYXQodGhpcywgXCIgUzogSUdOT1JFRCBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KG1zZykpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRGYWlsdXJlICYmIHRoaXMuX2N1cnJlbnRPYnNlcnZlci5vbkVycm9yKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPYnNlcnZlci5vbkVycm9yKHRoaXMuX2N1cnJlbnRGYWlsdXJlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY3VycmVudE9ic2VydmVyLm9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudE9ic2VydmVyLm9uRXJyb3IoKDAsIF9lcnJvci5uZXdFcnJvcikoJ0lnbm9yZWQgZWl0aGVyIGJlY2F1c2Ugb2YgYW4gZXJyb3Igb3IgUkVTRVQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUN1cnJlbnRPYnNlcnZlcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5faGFuZGxlRmF0YWxFcnJvcigoMCwgX2Vycm9yLm5ld0Vycm9yKSgnVW5rbm93biBCb2x0IHByb3RvY29sIG1lc3NhZ2U6ICcgKyBtc2cpKTtcblxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgUkVTRVQtbWVzc2FnZSB0byB0aGUgZGF0YWJhc2UuIE1lc3NhZ2UgaXMgaW1tZWRpYXRlbHkgZmx1c2hlZCB0byB0aGUgbmV0d29yay5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSBwcm9taXNlIHJlc29sdmVkIHdoZW4gU1VDQ0VTUy1tZXNzYWdlIHJlc3BvbnNlIGFycml2ZXMsIG9yIGZhaWxlZCB3aGVuIG90aGVyIHJlc3BvbnNlIG1lc3NhZ2VzIGFycml2ZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNldEFuZEZsdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0QW5kRmx1c2goKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXM2Ll9wcm90b2NvbC5yZXNldCh7XG4gICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgICAgICAgaWYgKF90aGlzNi5faXNCcm9rZW4pIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxpbmcgYSBmYXRhbCBlcnJvciwgbm8gbmVlZCB0byByYWlzZSBhIHByb3RvY29sIHZpb2xhdGlvblxuICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIG5lbzRqRXJyb3IgPSBfdGhpczYuX2hhbmRsZVByb3RvY29sRXJyb3IoJ1JlY2VpdmVkIEZBSUxVUkUgYXMgYSByZXNwb25zZSBmb3IgUkVTRVQ6ICcgKyBlcnJvcik7XG5cbiAgICAgICAgICAgICAgcmVqZWN0KG5lbzRqRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNldE9uRmFpbHVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzZXRPbkZhaWx1cmUoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdGhpcy5fcHJvdG9jb2wucmVzZXQoe1xuICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgICAgICAgIF90aGlzNy5fY3VycmVudEZhaWx1cmUgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgIF90aGlzNy5fY3VycmVudEZhaWx1cmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3F1ZXVlT2JzZXJ2ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3F1ZXVlT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9pc0Jyb2tlbikge1xuICAgICAgICBpZiAob2JzZXJ2ZXIgJiYgb2JzZXJ2ZXIub25FcnJvcikge1xuICAgICAgICAgIG9ic2VydmVyLm9uRXJyb3IodGhpcy5fZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBvYnNlcnZlciA9IG9ic2VydmVyIHx8IE5PX09QX09CU0VSVkVSO1xuICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQgPSBvYnNlcnZlci5vbkNvbXBsZXRlZCB8fCBOT19PUDtcbiAgICAgIG9ic2VydmVyLm9uRXJyb3IgPSBvYnNlcnZlci5vbkVycm9yIHx8IE5PX09QO1xuICAgICAgb2JzZXJ2ZXIub25OZXh0ID0gb2JzZXJ2ZXIub25OZXh0IHx8IE5PX09QO1xuXG4gICAgICBpZiAodGhpcy5fY3VycmVudE9ic2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudE9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wZW5kaW5nT2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBQb3AgbmV4dCBwZW5kaW5nIG9ic2VydmVyIGZvcm0gdGhlIGxpc3Qgb2Ygb2JzZXJ2ZXJzIGFuZCBtYWtlIGl0IGN1cnJlbnQgb2JzZXJ2ZXIuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUN1cnJlbnRPYnNlcnZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQ3VycmVudE9ic2VydmVyKCkge1xuICAgICAgdGhpcy5fY3VycmVudE9ic2VydmVyID0gdGhpcy5fcGVuZGluZ09ic2VydmVycy5zaGlmdCgpO1xuICAgIH1cbiAgICAvKiogQ2hlY2sgaWYgdGhpcyBjb25uZWN0aW9uIGlzIGluIHdvcmtpbmcgY29uZGl0aW9uICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc09wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNPcGVuKCkge1xuICAgICAgcmV0dXJuICF0aGlzLl9pc0Jyb2tlbiAmJiB0aGlzLl9jaC5fb3BlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBjbG9zZSBvbiB0aGUgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gLSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIHVuZGVybHlpbmcgY2hhbm5lbCBpcyBjbG9zZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2Nsb3NlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvZy5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJcIi5jb25jYXQodGhpcywgXCIgY2xvc2luZ1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Byb3RvY29sICYmIHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHByb3RvY29sIGhhcyBiZWVuIGluaXRpYWxpemVkIGFuZCB0aGlzIGNvbm5lY3Rpb24gaXMgaGVhbHRoeVxuICAgICAgICAgICAgICAgICAgLy8gbm90aWZ5IHRoZSBkYXRhYmFzZSBhYm91dCB0aGUgdXBjb21pbmcgY2xvc2Ugb2YgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLnByZXBhcmVUb0Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb2cuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiXCIuY29uY2F0KHRoaXMsIFwiIGNsb3NlZFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiBfY2xvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb3NlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiQ29ubmVjdGlvbiBbXCIuY29uY2F0KHRoaXMuaWQsIFwiXVtcIikuY29uY2F0KHRoaXMuZGF0YWJhc2VJZCB8fCAnJywgXCJdXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcGFja2FibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhY2thYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2wucGFja2VyKCkucGFja2FibGUodmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlUHJvdG9jb2xFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlUHJvdG9jb2xFcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aGlzLl9jdXJyZW50RmFpbHVyZSA9IG51bGw7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZUN1cnJlbnRPYnNlcnZlcigpO1xuXG4gICAgICB2YXIgZXJyb3IgPSAoMCwgX2Vycm9yLm5ld0Vycm9yKShtZXNzYWdlLCBfZXJyb3IuUFJPVE9DT0xfRVJST1IpO1xuXG4gICAgICB0aGlzLl9oYW5kbGVGYXRhbEVycm9yKGVycm9yKTtcblxuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXRhYmFzZUlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGJDb25uZWN0aW9uSWQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5fZGJDb25uZWN0aW9uSWQgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkcmVzc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmVyc2lvbiBvZiB0aGUgY29ubmVjdGVkIHNlcnZlci5cbiAgICAgKiBBdmFpbGFibGUgb25seSBhZnRlciBpbml0aWFsaXphdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1NlcnZlclZlcnNpb259IHZlcnNpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZlcnNpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXJ2ZXIudmVyc2lvbjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXJ2ZXIudmVyc2lvbiA9IHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJ2ZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXJ2ZXI7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShhZGRyZXNzLCBjb25maWcsIGVycm9ySGFuZGxlciwgbG9nKSB7XG4gICAgICB2YXIgc2VydmVyc2lkZVJvdXRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IG51bGw7XG4gICAgICB2YXIgY2hhbm5lbENvbmZpZyA9IG5ldyBfY2hhbm5lbENvbmZpZ1tcImRlZmF1bHRcIl0oYWRkcmVzcywgY29uZmlnLCBlcnJvckhhbmRsZXIuZXJyb3JDb2RlKCkpO1xuICAgICAgcmV0dXJuIG5ldyBDaGFubmVsQ29ubmVjdGlvbihuZXcgX25vZGUuQ2hhbm5lbChjaGFubmVsQ29uZmlnKSwgZXJyb3JIYW5kbGVyLCBhZGRyZXNzLCBsb2csIGNvbmZpZy5kaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycywgc2VydmVyc2lkZVJvdXRpbmcpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2hhbm5lbENvbm5lY3Rpb247XG59KF9jb25uZWN0aW9uW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ2hhbm5lbENvbm5lY3Rpb247IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2Nvbm5lY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb25cIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgRGVsZWdhdGVDb25uZWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29ubmVjdGlvbikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKERlbGVnYXRlQ29ubmVjdGlvbiwgX0Nvbm5lY3Rpb24pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGVsZWdhdGVDb25uZWN0aW9uKTtcblxuICAvKipcbiAgICogQHBhcmFtIGRlbGVnYXRlIHtDb25uZWN0aW9ufSB0aGUgZGVsZWdhdGVkIGNvbm5lY3Rpb25cbiAgICogQHBhcmFtIGVycm9ySGFuZGxlciB7Q29ubmVjdGlvbkVycm9ySGFuZGxlcn0gdGhlIGVycm9yIGhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIERlbGVnYXRlQ29ubmVjdGlvbihkZWxlZ2F0ZSwgZXJyb3JIYW5kbGVyKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBEZWxlZ2F0ZUNvbm5lY3Rpb24pO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZXJyb3JIYW5kbGVyKTtcblxuICAgIGlmIChlcnJvckhhbmRsZXIpIHtcbiAgICAgIF90aGlzLl9vcmlnaW5hbEVycm9ySGFuZGxlciA9IGRlbGVnYXRlLl9lcnJvckhhbmRsZXI7XG4gICAgICBkZWxlZ2F0ZS5fZXJyb3JIYW5kbGVyID0gX3RoaXMuX2Vycm9ySGFuZGxlcjtcbiAgICB9XG5cbiAgICBfdGhpcy5fZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKERlbGVnYXRlQ29ubmVjdGlvbiwgW3tcbiAgICBrZXk6IFwiaXNPcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3BlbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5pc09wZW4oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvdG9jb2xcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvdG9jb2woKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUucHJvdG9jb2woKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KHVzZXJBZ2VudCwgYXV0aFRva2VuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY29ubmVjdCh1c2VyQWdlbnQsIGF1dGhUb2tlbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlKG1lc3NhZ2UsIG9ic2VydmVyLCBmbHVzaCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLndyaXRlKG1lc3NhZ2UsIG9ic2VydmVyLCBmbHVzaCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0QW5kRmx1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRBbmRGbHVzaCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5yZXNldEFuZEZsdXNoKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNsb3NlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZWxlYXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWxlYXNlKCkge1xuICAgICAgaWYgKHRoaXMuX29yaWdpbmFsRXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2RlbGVnYXRlLl9lcnJvckhhbmRsZXIgPSB0aGlzLl9vcmlnaW5hbEVycm9ySGFuZGxlcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLl9yZWxlYXNlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuaWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGFiYXNlSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5kYXRhYmFzZUlkO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuX2RlbGVnYXRlLmRhdGFiYXNlSWQgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VydmVyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuc2VydmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRyZXNzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuYWRkcmVzcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmVyc2lvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLnZlcnNpb247XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5fZGVsZWdhdGUudmVyc2lvbiA9IHZhbHVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRGVsZWdhdGVDb25uZWN0aW9uO1xufShfY29ubmVjdGlvbltcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IERlbGVnYXRlQ29ubmVjdGlvbjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuLi9lcnJvclwiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQ29ubmVjdGlvbkVycm9ySGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbm5lY3Rpb25FcnJvckhhbmRsZXIoZXJyb3JDb2RlLCBoYW5kbGVVbmF2YWlsYWJpbGl0eSwgaGFuZGxlV3JpdGVGYWlsdXJlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBDb25uZWN0aW9uRXJyb3JIYW5kbGVyKTtcbiAgICB0aGlzLl9lcnJvckNvZGUgPSBlcnJvckNvZGU7XG4gICAgdGhpcy5faGFuZGxlVW5hdmFpbGFiaWxpdHkgPSBoYW5kbGVVbmF2YWlsYWJpbGl0eSB8fCBub09wSGFuZGxlcjtcbiAgICB0aGlzLl9oYW5kbGVXcml0ZUZhaWx1cmUgPSBoYW5kbGVXcml0ZUZhaWx1cmUgfHwgbm9PcEhhbmRsZXI7XG4gIH1cbiAgLyoqXG4gICAqIEVycm9yIGNvZGUgdG8gdXNlIGZvciBuZXR3b3JrIGVycm9ycy5cbiAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXJyb3IgY29kZS5cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKENvbm5lY3Rpb25FcnJvckhhbmRsZXIsIFt7XG4gICAga2V5OiBcImVycm9yQ29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvckNvZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3JDb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW5kIHRyYW5zZm9ybSB0aGUgZXJyb3IuXG4gICAgICogQHBhcmFtIHtOZW80akVycm9yfSBlcnJvciB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gICAgICogQHBhcmFtIHtTZXJ2ZXJBZGRyZXNzfSBhZGRyZXNzIHRoZSBhZGRyZXNzIG9mIHRoZSBjb25uZWN0aW9uIHdoZXJlIHRoZSBlcnJvciBoYXBwZW5lZC5cbiAgICAgKiBAcmV0dXJuIHtOZW80akVycm9yfSBuZXcgZXJyb3IgdGhhdCBzaG91bGQgYmUgcHJvcGFnYXRlZCB0byB0aGUgdXNlci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUFuZFRyYW5zZm9ybUVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUFuZFRyYW5zZm9ybUVycm9yKGVycm9yLCBhZGRyZXNzKSB7XG4gICAgICBpZiAoaXNBdmFpbGFiaWxpdHlFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVVuYXZhaWxhYmlsaXR5KGVycm9yLCBhZGRyZXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRmFpbHVyZVRvV3JpdGUoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVXcml0ZUZhaWx1cmUoZXJyb3IsIGFkZHJlc3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb25uZWN0aW9uRXJyb3JIYW5kbGVyO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENvbm5lY3Rpb25FcnJvckhhbmRsZXI7XG5cbmZ1bmN0aW9uIGlzQXZhaWxhYmlsaXR5RXJyb3IoZXJyb3IpIHtcbiAgaWYgKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLmNvZGUgPT09IF9lcnJvci5TRVNTSU9OX0VYUElSRUQgfHwgZXJyb3IuY29kZSA9PT0gX2Vycm9yLlNFUlZJQ0VfVU5BVkFJTEFCTEUgfHwgZXJyb3IuY29kZSA9PT0gJ05lby5UcmFuc2llbnRFcnJvci5HZW5lcmFsLkRhdGFiYXNlVW5hdmFpbGFibGUnO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ZhaWx1cmVUb1dyaXRlKGVycm9yKSB7XG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5jb2RlID09PSAnTmVvLkNsaWVudEVycm9yLkNsdXN0ZXIuTm90QUxlYWRlcicgfHwgZXJyb3IuY29kZSA9PT0gJ05lby5DbGllbnRFcnJvci5HZW5lcmFsLkZvcmJpZGRlbk9uUmVhZE9ubHlEYXRhYmFzZSc7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG5vT3BIYW5kbGVyKGVycm9yKSB7XG4gIHJldHVybiBlcnJvcjtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkVNUFRZX0NPTk5FQ1RJT05fSE9MREVSID0gZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcblxudmFyIF9ib29rbWFyayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYm9va21hcmtcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIFV0aWxpdHkgdG8gbGF6aWx5IGluaXRpYWxpemUgY29ubmVjdGlvbnMgYW5kIHJldHVybiB0aGVtIGJhY2sgdG8gdGhlIHBvb2wgd2hlbiB1bnVzZWQuXG4gKi9cbnZhciBDb25uZWN0aW9uSG9sZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAtIHRoZSBhY2Nlc3MgbW9kZSBmb3IgbmV3IGNvbm5lY3Rpb24gaG9sZGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2UgLSB0aGUgdGFyZ2V0IGRhdGFiYXNlIG5hbWUuXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvblByb3ZpZGVyfSBjb25uZWN0aW9uUHJvdmlkZXIgLSB0aGUgY29ubmVjdGlvbiBwcm92aWRlciB0byBhY3F1aXJlIGNvbm5lY3Rpb25zIGZyb20uXG4gICAqL1xuICBmdW5jdGlvbiBDb25uZWN0aW9uSG9sZGVyKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgX3JlZiRtb2RlID0gX3JlZi5tb2RlLFxuICAgICAgICBtb2RlID0gX3JlZiRtb2RlID09PSB2b2lkIDAgPyBfY29uc3RhbnRzLkFDQ0VTU19NT0RFX1dSSVRFIDogX3JlZiRtb2RlLFxuICAgICAgICBfcmVmJGRhdGFiYXNlID0gX3JlZi5kYXRhYmFzZSxcbiAgICAgICAgZGF0YWJhc2UgPSBfcmVmJGRhdGFiYXNlID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkZGF0YWJhc2UsXG4gICAgICAgIGJvb2ttYXJrID0gX3JlZi5ib29rbWFyayxcbiAgICAgICAgY29ubmVjdGlvblByb3ZpZGVyID0gX3JlZi5jb25uZWN0aW9uUHJvdmlkZXI7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIENvbm5lY3Rpb25Ib2xkZXIpO1xuICAgIHRoaXMuX21vZGUgPSBtb2RlO1xuICAgIHRoaXMuX2RhdGFiYXNlID0gZGF0YWJhc2UgPyAoMCwgX3V0aWwuYXNzZXJ0U3RyaW5nKShkYXRhYmFzZSwgJ2RhdGFiYXNlJykgOiAnJztcbiAgICB0aGlzLl9ib29rbWFyayA9IGJvb2ttYXJrIHx8IF9ib29rbWFya1tcImRlZmF1bHRcIl0uZW1wdHkoKTtcbiAgICB0aGlzLl9jb25uZWN0aW9uUHJvdmlkZXIgPSBjb25uZWN0aW9uUHJvdmlkZXI7XG4gICAgdGhpcy5fcmVmZXJlbmNlQ291bnQgPSAwO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhc3NpZ25lZCBhY2Nlc3MgbW9kZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gYWNjZXNzIG1vZGVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKENvbm5lY3Rpb25Ib2xkZXIsIFt7XG4gICAga2V5OiBcIm1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0YXJnZXQgZGF0YWJhc2UgbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBkYXRhYmFzZSBuYW1lXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkYXRhYmFzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRhYmFzZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRhYmFzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZSB0aGlzIGhvbGRlciBpbml0aWFsaXplIG5ldyBjb25uZWN0aW9uIGlmIG5vbmUgZXhpc3RzIGFscmVhZHkuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxpemVDb25uZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVDb25uZWN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX3JlZmVyZW5jZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlID0gdGhpcy5fY29ubmVjdGlvblByb3ZpZGVyLmFjcXVpcmVDb25uZWN0aW9uKHtcbiAgICAgICAgICBhY2Nlc3NNb2RlOiB0aGlzLl9tb2RlLFxuICAgICAgICAgIGRhdGFiYXNlOiB0aGlzLl9kYXRhYmFzZSxcbiAgICAgICAgICBib29rbWFyazogdGhpcy5fYm9va21hcmtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZWZlcmVuY2VDb3VudCsrO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlZmVyZW5jZUNvdW50Kys7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gcHJvbWlzZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbm5lY3Rpb24+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGN1cnJlbnQgY29ubmVjdGlvbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldENvbm5lY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoaXMgaG9sZGVyIHRoYXQgc2luZ2xlIHBhcnR5IGRvZXMgbm90IHJlcXVpcmUgY3VycmVudCBjb25uZWN0aW9uIGFueSBtb3JlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8Q29ubmVjdGlvbj59IHByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgY3VycmVudCBjb25uZWN0aW9uLCBuZXZlciBhIHJlamVjdGVkIHByb21pc2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWxlYXNlQ29ubmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWxlYXNlQ29ubmVjdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9yZWZlcmVuY2VDb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblByb21pc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlZmVyZW5jZUNvdW50LS07XG5cbiAgICAgIGlmICh0aGlzLl9yZWZlcmVuY2VDb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVsZWFzZUNvbm5lY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhpcyBob2xkZXIgYW5kIHJlbGVhc2VzIGN1cnJlbnQgY29ubmVjdGlvbiAoaWYgYW55KSBkZXNwaXRlIGFueSBleGlzdGluZyB1c2Vycy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbm5lY3Rpb24+fSBwcm9taXNlIHJlc29sdmVkIHdoZW4gY3VycmVudCBjb25uZWN0aW9uIGlzIHJlbGVhc2VkIHRvIHRoZSBwb29sLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAodGhpcy5fcmVmZXJlbmNlQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZWZlcmVuY2VDb3VudCA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5fcmVsZWFzZUNvbm5lY3Rpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjdXJyZW50IHBvb2xlZCBjb25uZWN0aW9uIGluc3RhbmNlIHRvIHRoZSBjb25uZWN0aW9uIHBvb2wuXG4gICAgICogV2UgZG9uJ3QgcG9vbCBTZXNzaW9uIGluc3RhbmNlcywgdG8gYXZvaWQgdXNlcnMgdXNpbmcgdGhlIFNlc3Npb24gYWZ0ZXIgdGhleSd2ZSBjYWxsZWQgY2xvc2UuXG4gICAgICogVGhlIGBTZXNzaW9uYCBvYmplY3QgaXMganVzdCBhIHRoaW4gd3JhcHBlciBhcm91bmQgQ29ubmVjdGlvbiBhbnl3YXksIHNvIGl0IG1ha2VzIGxpdHRsZSBkaWZmZXJlbmNlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IC0gcHJvbWlzZSByZXNvbHZlZCB0aGVuIGNvbm5lY3Rpb24gaXMgcmV0dXJuZWQgdG8gdGhlIHBvb2wuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZWxlYXNlQ29ubmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVsZWFzZUNvbm5lY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZSA9IHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlLnRoZW4oZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5yZXNldEFuZEZsdXNoKClbXCJjYXRjaFwiXShpZ25vcmVFcnJvcikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5fcmVsZWFzZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSlbXCJjYXRjaFwiXShpZ25vcmVFcnJvcik7XG4gICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblByb21pc2U7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb25uZWN0aW9uSG9sZGVyO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENvbm5lY3Rpb25Ib2xkZXI7XG5cbnZhciBFbXB0eUNvbm5lY3Rpb25Ib2xkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db25uZWN0aW9uSG9sZGVyKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoRW1wdHlDb25uZWN0aW9uSG9sZGVyLCBfQ29ubmVjdGlvbkhvbGRlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihFbXB0eUNvbm5lY3Rpb25Ib2xkZXIpO1xuXG4gIGZ1bmN0aW9uIEVtcHR5Q29ubmVjdGlvbkhvbGRlcigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIEVtcHR5Q29ubmVjdGlvbkhvbGRlcik7XG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShFbXB0eUNvbm5lY3Rpb25Ib2xkZXIsIFt7XG4gICAga2V5OiBcImluaXRpYWxpemVDb25uZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVDb25uZWN0aW9uKCkge1xuICAgICAgLy8gbm90aGluZyB0byBpbml0aWFsaXplXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29ubmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25uZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCgwLCBfZXJyb3IubmV3RXJyb3IpKCdUaGlzIGNvbm5lY3Rpb24gaG9sZGVyIGRvZXMgbm90IHNlcnZlIGNvbm5lY3Rpb25zJykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWxlYXNlQ29ubmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWxlYXNlQ29ubmVjdGlvbigpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFbXB0eUNvbm5lY3Rpb25Ib2xkZXI7XG59KENvbm5lY3Rpb25Ib2xkZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaGFuZGxlLWNhbGxiYWNrLWVyclxuXG5cbmZ1bmN0aW9uIGlnbm9yZUVycm9yKGVycm9yKSB7fVxuLyoqXG4gKiBDb25uZWN0aW9uIGhvbGRlciB0aGF0IGRvZXMgbm90IG1hbmFnZSBhbnkgY29ubmVjdGlvbnMuXG4gKiBAdHlwZSB7Q29ubmVjdGlvbkhvbGRlcn1cbiAqL1xuXG5cbnZhciBFTVBUWV9DT05ORUNUSU9OX0hPTERFUiA9IG5ldyBFbXB0eUNvbm5lY3Rpb25Ib2xkZXIoKTtcbmV4cG9ydHMuRU1QVFlfQ09OTkVDVElPTl9IT0xERVIgPSBFTVBUWV9DT05ORUNUSU9OX0hPTERFUjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2Nvbm5lY3Rpb25Qcm92aWRlclBvb2xlZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29ubmVjdGlvbi1wcm92aWRlci1wb29sZWRcIikpO1xuXG52YXIgX2Nvbm5lY3Rpb25EZWxlZ2F0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29ubmVjdGlvbi1kZWxlZ2F0ZVwiKSk7XG5cbnZhciBfY29ubmVjdGlvbkNoYW5uZWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tY2hhbm5lbFwiKSk7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgRGlyZWN0Q29ubmVjdGlvblByb3ZpZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUG9vbGVkQ29ubmVjdGlvblByb3YpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShEaXJlY3RDb25uZWN0aW9uUHJvdmlkZXIsIF9Qb29sZWRDb25uZWN0aW9uUHJvdik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEaXJlY3RDb25uZWN0aW9uUHJvdmlkZXIpO1xuXG4gIGZ1bmN0aW9uIERpcmVjdENvbm5lY3Rpb25Qcm92aWRlcihfcmVmKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICAgICAgY29uZmlnID0gX3JlZi5jb25maWcsXG4gICAgICAgIGxvZyA9IF9yZWYubG9nLFxuICAgICAgICBhZGRyZXNzID0gX3JlZi5hZGRyZXNzLFxuICAgICAgICB1c2VyQWdlbnQgPSBfcmVmLnVzZXJBZ2VudCxcbiAgICAgICAgYXV0aFRva2VuID0gX3JlZi5hdXRoVG9rZW47XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBEaXJlY3RDb25uZWN0aW9uUHJvdmlkZXIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywge1xuICAgICAgaWQ6IGlkLFxuICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICBsb2c6IGxvZyxcbiAgICAgIHVzZXJBZ2VudDogdXNlckFnZW50LFxuICAgICAgYXV0aFRva2VuOiBhdXRoVG9rZW5cbiAgICB9KTtcbiAgICBfdGhpcy5fYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIENvbm5lY3Rpb25Qcm92aWRlcn0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBtZXRob2QgYW5kXG4gICAqIGl0cyBhcmd1bWVudHMuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShEaXJlY3RDb25uZWN0aW9uUHJvdmlkZXIsIFt7XG4gICAga2V5OiBcImFjcXVpcmVDb25uZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjcXVpcmVDb25uZWN0aW9uKCkge1xuICAgICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBhY2Nlc3NNb2RlID0gX3JlZjIuYWNjZXNzTW9kZSxcbiAgICAgICAgICBkYXRhYmFzZSA9IF9yZWYyLmRhdGFiYXNlLFxuICAgICAgICAgIGJvb2ttYXJrcyA9IF9yZWYyLmJvb2ttYXJrcztcblxuICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25Qb29sLmFjcXVpcmUodGhpcy5fYWRkcmVzcykudGhlbihmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IF9jb25uZWN0aW9uRGVsZWdhdGVbXCJkZWZhdWx0XCJdKGNvbm5lY3Rpb24sIG51bGwpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9oYXNQcm90b2NvbFZlcnNpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9oYXNQcm90b2NvbFZlcnNpb24yID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUodmVyc2lvblByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgY29ubmVjdGlvbiwgcHJvdG9jb2w7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IF9jb25uZWN0aW9uQ2hhbm5lbFtcImRlZmF1bHRcIl0uY3JlYXRlKHRoaXMuX2FkZHJlc3MsIHRoaXMuX2NvbmZpZywgdGhpcy5fY3JlYXRlQ29ubmVjdGlvbkVycm9ySGFuZGxlcigpLCB0aGlzLl9sb2cpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLl9uZWdvdGlhdGVQcm90b2NvbCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBwcm90b2NvbCA9IGNvbm5lY3Rpb24ucHJvdG9jb2woKTtcblxuICAgICAgICAgICAgICAgIGlmICghcHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB2ZXJzaW9uUHJlZGljYXRlKHByb3RvY29sLnZlcnNpb24pKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA4O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5jbG9zZSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCg4KTtcblxuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMSwsIDgsIDEyXV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfaGFzUHJvdG9jb2xWZXJzaW9uKF94KSB7XG4gICAgICAgIHJldHVybiBfaGFzUHJvdG9jb2xWZXJzaW9uMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2hhc1Byb3RvY29sVmVyc2lvbjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJzdXBwb3J0c011bHRpRGJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zdXBwb3J0c011bHRpRGIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzUHJvdG9jb2xWZXJzaW9uKGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbiA+PSBfY29uc3RhbnRzLkJPTFRfUFJPVE9DT0xfVjRfMDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyLnNlbnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzdXBwb3J0c011bHRpRGIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwcG9ydHNNdWx0aURiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdXBwb3J0c011bHRpRGI7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic3VwcG9ydHNUcmFuc2FjdGlvbkNvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3N1cHBvcnRzVHJhbnNhY3Rpb25Db25maWcgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzUHJvdG9jb2xWZXJzaW9uKGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbiA+PSBfY29uc3RhbnRzLkJPTFRfUFJPVE9DT0xfVjM7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0My5zZW50KTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc3VwcG9ydHNUcmFuc2FjdGlvbkNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBwb3J0c1RyYW5zYWN0aW9uQ29uZmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdXBwb3J0c1RyYW5zYWN0aW9uQ29uZmlnO1xuICAgIH0oKVxuICB9XSk7XG4gIHJldHVybiBEaXJlY3RDb25uZWN0aW9uUHJvdmlkZXI7XG59KF9jb25uZWN0aW9uUHJvdmlkZXJQb29sZWRbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBEaXJlY3RDb25uZWN0aW9uUHJvdmlkZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2Nvbm5lY3Rpb25DaGFubmVsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb25uZWN0aW9uLWNoYW5uZWxcIikpO1xuXG52YXIgX3Bvb2wgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Bvb2xcIikpO1xuXG52YXIgX3Bvb2xDb25maWcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Bvb2wtY29uZmlnXCIpKTtcblxudmFyIF9jb25uZWN0aW9uRXJyb3JIYW5kbGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb25uZWN0aW9uLWVycm9yLWhhbmRsZXJcIikpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xuXG52YXIgX2Nvbm5lY3Rpb25Qcm92aWRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29ubmVjdGlvbi1wcm92aWRlclwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yW1wiZGVmYXVsdFwiXSkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBQb29sZWRDb25uZWN0aW9uUHJvdmlkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db25uZWN0aW9uUHJvdmlkZXIpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShQb29sZWRDb25uZWN0aW9uUHJvdmlkZXIsIF9Db25uZWN0aW9uUHJvdmlkZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUG9vbGVkQ29ubmVjdGlvblByb3ZpZGVyKTtcblxuICBmdW5jdGlvbiBQb29sZWRDb25uZWN0aW9uUHJvdmlkZXIoX3JlZikge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBpZCA9IF9yZWYuaWQsXG4gICAgICAgIGNvbmZpZyA9IF9yZWYuY29uZmlnLFxuICAgICAgICBsb2cgPSBfcmVmLmxvZyxcbiAgICAgICAgdXNlckFnZW50ID0gX3JlZi51c2VyQWdlbnQsXG4gICAgICAgIGF1dGhUb2tlbiA9IF9yZWYuYXV0aFRva2VuO1xuICAgIHZhciBjcmVhdGVDaGFubmVsQ29ubmVjdGlvbkhvb2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBQb29sZWRDb25uZWN0aW9uUHJvdmlkZXIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMuX2lkID0gaWQ7XG4gICAgX3RoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICBfdGhpcy5fbG9nID0gbG9nO1xuICAgIF90aGlzLl91c2VyQWdlbnQgPSB1c2VyQWdlbnQ7XG4gICAgX3RoaXMuX2F1dGhUb2tlbiA9IGF1dGhUb2tlbjtcblxuICAgIF90aGlzLl9jcmVhdGVDaGFubmVsQ29ubmVjdGlvbiA9IGNyZWF0ZUNoYW5uZWxDb25uZWN0aW9uSG9vayB8fCBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgcmV0dXJuIF9jb25uZWN0aW9uQ2hhbm5lbFtcImRlZmF1bHRcIl0uY3JlYXRlKGFkZHJlc3MsIF90aGlzLl9jb25maWcsIF90aGlzLl9jcmVhdGVDb25uZWN0aW9uRXJyb3JIYW5kbGVyKCksIF90aGlzLl9sb2cpO1xuICAgIH07XG5cbiAgICBfdGhpcy5fY29ubmVjdGlvblBvb2wgPSBuZXcgX3Bvb2xbXCJkZWZhdWx0XCJdKHtcbiAgICAgIGNyZWF0ZTogX3RoaXMuX2NyZWF0ZUNvbm5lY3Rpb24uYmluZCgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDJbXCJkZWZhdWx0XCJdKShfdGhpcykpLFxuICAgICAgZGVzdHJveTogX3RoaXMuX2Rlc3Ryb3lDb25uZWN0aW9uLmJpbmQoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyW1wiZGVmYXVsdFwiXSkoX3RoaXMpKSxcbiAgICAgIHZhbGlkYXRlOiBfdGhpcy5fdmFsaWRhdGVDb25uZWN0aW9uLmJpbmQoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyW1wiZGVmYXVsdFwiXSkoX3RoaXMpKSxcbiAgICAgIGluc3RhbGxJZGxlT2JzZXJ2ZXI6IFBvb2xlZENvbm5lY3Rpb25Qcm92aWRlci5faW5zdGFsbElkbGVPYnNlcnZlck9uQ29ubmVjdGlvbi5iaW5kKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMltcImRlZmF1bHRcIl0pKF90aGlzKSksXG4gICAgICByZW1vdmVJZGxlT2JzZXJ2ZXI6IFBvb2xlZENvbm5lY3Rpb25Qcm92aWRlci5fcmVtb3ZlSWRsZU9ic2VydmVyT25Db25uZWN0aW9uLmJpbmQoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyW1wiZGVmYXVsdFwiXSkoX3RoaXMpKSxcbiAgICAgIGNvbmZpZzogX3Bvb2xDb25maWdbXCJkZWZhdWx0XCJdLmZyb21Ecml2ZXJDb25maWcoY29uZmlnKSxcbiAgICAgIGxvZzogX3RoaXMuX2xvZ1xuICAgIH0pO1xuICAgIF90aGlzLl9vcGVuQ29ubmVjdGlvbnMgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFBvb2xlZENvbm5lY3Rpb25Qcm92aWRlciwgW3tcbiAgICBrZXk6IFwiX2NyZWF0ZUNvbm5lY3Rpb25FcnJvckhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUNvbm5lY3Rpb25FcnJvckhhbmRsZXIoKSB7XG4gICAgICByZXR1cm4gbmV3IF9jb25uZWN0aW9uRXJyb3JIYW5kbGVyW1wiZGVmYXVsdFwiXShfZXJyb3IuU0VSVklDRV9VTkFWQUlMQUJMRSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBjb25uZWN0aW9uIGFuZCBpbml0aWFsaXplIGl0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8Q29ubmVjdGlvbj59IHByb21pc2UgcmVzb2x2ZWQgd2l0aCBhIG5ldyBjb25uZWN0aW9uIG9yIHJlamVjdGVkIHdoZW4gZmFpbGVkIHRvIGNvbm5lY3QuXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQ29ubmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQ29ubmVjdGlvbihhZGRyZXNzLCByZWxlYXNlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLl9jcmVhdGVDaGFubmVsQ29ubmVjdGlvbihhZGRyZXNzKTtcblxuICAgICAgY29ubmVjdGlvbi5fcmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlbGVhc2UoYWRkcmVzcywgY29ubmVjdGlvbik7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9vcGVuQ29ubmVjdGlvbnNbY29ubmVjdGlvbi5pZF0gPSBjb25uZWN0aW9uO1xuICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uY29ubmVjdCh0aGlzLl91c2VyQWdlbnQsIHRoaXMuX2F1dGhUb2tlbilbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgLy8gbGV0J3MgZGVzdHJveSB0aGlzIGNvbm5lY3Rpb25cbiAgICAgICAgX3RoaXMyLl9kZXN0cm95Q29ubmVjdGlvbihjb25uZWN0aW9uKTsgLy8gcHJvcGFnYXRlIHRoZSBlcnJvciBiZWNhdXNlIGNvbm5lY3Rpb24gZmFpbGVkIHRvIGNvbm5lY3QgLyBpbml0aWFsaXplXG5cblxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IGEgY29ubmVjdGlvbiBpcyB1c2FibGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBjb25uZWN0aW9uIGlzIG9wZW5cbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdmFsaWRhdGVDb25uZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92YWxpZGF0ZUNvbm5lY3Rpb24oY29ubikge1xuICAgICAgaWYgKCFjb25uLmlzT3BlbigpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heENvbm5lY3Rpb25MaWZldGltZSA9IHRoaXMuX2NvbmZpZy5tYXhDb25uZWN0aW9uTGlmZXRpbWU7XG4gICAgICB2YXIgbGlmZXRpbWUgPSBEYXRlLm5vdygpIC0gY29ubi5jcmVhdGlvblRpbWVzdGFtcDtcbiAgICAgIHJldHVybiBsaWZldGltZSA8PSBtYXhDb25uZWN0aW9uTGlmZXRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgYSBjb25uZWN0aW9uLlxuICAgICAqIEByZXR1cm4ge0Nvbm5lY3Rpb259IHRoZSBjb25uZWN0aW9uIHRvIGRpc3Bvc2UuXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveUNvbm5lY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3lDb25uZWN0aW9uKGNvbm4pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9vcGVuQ29ubmVjdGlvbnNbY29ubi5pZF07XG4gICAgICByZXR1cm4gY29ubi5jbG9zZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2Nsb3NlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25Qb29sLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChPYmplY3QudmFsdWVzKHRoaXMuX29wZW5Db25uZWN0aW9ucykubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICByZXR1cm4gX2Nsb3NlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9zZTtcbiAgICB9KClcbiAgfV0sIFt7XG4gICAga2V5OiBcIl9pbnN0YWxsSWRsZU9ic2VydmVyT25Db25uZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbnN0YWxsSWRsZU9ic2VydmVyT25Db25uZWN0aW9uKGNvbm4sIG9ic2VydmVyKSB7XG4gICAgICBjb25uLl9xdWV1ZU9ic2VydmVyKG9ic2VydmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZUlkbGVPYnNlcnZlck9uQ29ubmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlSWRsZU9ic2VydmVyT25Db25uZWN0aW9uKGNvbm4pIHtcbiAgICAgIGNvbm4uX3VwZGF0ZUN1cnJlbnRPYnNlcnZlcigpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUG9vbGVkQ29ubmVjdGlvblByb3ZpZGVyO1xufShfY29ubmVjdGlvblByb3ZpZGVyW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUG9vbGVkQ29ubmVjdGlvblByb3ZpZGVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG5cbnZhciBfZHJpdmVyID0gcmVxdWlyZShcIi4uL2RyaXZlclwiKTtcblxudmFyIF9zZXNzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vc2Vzc2lvblwiKSk7XG5cbnZhciBfcm91dGluZ1RhYmxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yb3V0aW5nLXRhYmxlXCIpKTtcblxudmFyIF9yZWRpc2NvdmVyeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVkaXNjb3ZlcnlcIikpO1xuXG52YXIgX3JvdXRpbmdVdGlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yb3V0aW5nLXV0aWxcIikpO1xuXG52YXIgX25vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuXG52YXIgX2Nvbm5lY3Rpb25Qcm92aWRlclNpbmdsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29ubmVjdGlvbi1wcm92aWRlci1zaW5nbGVcIikpO1xuXG52YXIgX2Nvbm5lY3Rpb25Qcm92aWRlclBvb2xlZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29ubmVjdGlvbi1wcm92aWRlci1wb29sZWRcIikpO1xuXG52YXIgX2Nvbm5lY3Rpb25FcnJvckhhbmRsZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tZXJyb3ItaGFuZGxlclwiKSk7XG5cbnZhciBfY29ubmVjdGlvbkRlbGVnYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb25uZWN0aW9uLWRlbGVnYXRlXCIpKTtcblxudmFyIF9sZWFzdENvbm5lY3RlZExvYWRCYWxhbmNpbmdTdHJhdGVneSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGVhc3QtY29ubmVjdGVkLWxvYWQtYmFsYW5jaW5nLXN0cmF0ZWd5XCIpKTtcblxudmFyIF9ib29rbWFyayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYm9va21hcmtcIikpO1xuXG52YXIgX2Nvbm5lY3Rpb25DaGFubmVsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb25uZWN0aW9uLWNoYW5uZWxcIikpO1xuXG52YXIgX2ludGVnZXIgPSByZXF1aXJlKFwiLi4vaW50ZWdlclwiKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yW1wiZGVmYXVsdFwiXSkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBVTkFVVEhPUklaRURfRVJST1JfQ09ERSA9ICdOZW8uQ2xpZW50RXJyb3IuU2VjdXJpdHkuVW5hdXRob3JpemVkJztcbnZhciBEQVRBQkFTRV9OT1RfRk9VTkRfRVJST1JfQ09ERSA9ICdOZW8uQ2xpZW50RXJyb3IuRGF0YWJhc2UuRGF0YWJhc2VOb3RGb3VuZCc7XG52YXIgU1lTVEVNX0RCX05BTUUgPSAnc3lzdGVtJztcbnZhciBERUZBVUxUX0RCX05BTUUgPSAnJztcbnZhciBERUZBVUxUX1JPVVRJTkdfVEFCTEVfUFVSR0VfREVMQVkgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKDMwMDAwKTtcblxudmFyIFJvdXRpbmdDb25uZWN0aW9uUHJvdmlkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Qb29sZWRDb25uZWN0aW9uUHJvdikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKFJvdXRpbmdDb25uZWN0aW9uUHJvdmlkZXIsIF9Qb29sZWRDb25uZWN0aW9uUHJvdik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSb3V0aW5nQ29ubmVjdGlvblByb3ZpZGVyKTtcblxuICBmdW5jdGlvbiBSb3V0aW5nQ29ubmVjdGlvblByb3ZpZGVyKF9yZWYpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgICBhZGRyZXNzID0gX3JlZi5hZGRyZXNzLFxuICAgICAgICByb3V0aW5nQ29udGV4dCA9IF9yZWYucm91dGluZ0NvbnRleHQsXG4gICAgICAgIGhvc3ROYW1lUmVzb2x2ZXIgPSBfcmVmLmhvc3ROYW1lUmVzb2x2ZXIsXG4gICAgICAgIGNvbmZpZyA9IF9yZWYuY29uZmlnLFxuICAgICAgICBsb2cgPSBfcmVmLmxvZyxcbiAgICAgICAgdXNlckFnZW50ID0gX3JlZi51c2VyQWdlbnQsXG4gICAgICAgIGF1dGhUb2tlbiA9IF9yZWYuYXV0aFRva2VuLFxuICAgICAgICByb3V0aW5nVGFibGVQdXJnZURlbGF5ID0gX3JlZi5yb3V0aW5nVGFibGVQdXJnZURlbGF5O1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUm91dGluZ0Nvbm5lY3Rpb25Qcm92aWRlcik7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7XG4gICAgICBpZDogaWQsXG4gICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgIGxvZzogbG9nLFxuICAgICAgdXNlckFnZW50OiB1c2VyQWdlbnQsXG4gICAgICBhdXRoVG9rZW46IGF1dGhUb2tlblxuICAgIH0sIGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICByZXR1cm4gX2Nvbm5lY3Rpb25DaGFubmVsW1wiZGVmYXVsdFwiXS5jcmVhdGUoYWRkcmVzcywgX3RoaXMuX2NvbmZpZywgX3RoaXMuX2NyZWF0ZUNvbm5lY3Rpb25FcnJvckhhbmRsZXIoKSwgX3RoaXMuX2xvZywgcm91dGluZ0NvbnRleHQgfHwge30pO1xuICAgIH0pO1xuICAgIF90aGlzLl9zZWVkUm91dGVyID0gYWRkcmVzcztcbiAgICBfdGhpcy5fcm91dGluZ1RhYmxlcyA9IHt9O1xuICAgIF90aGlzLl9yZWRpc2NvdmVyeSA9IG5ldyBfcmVkaXNjb3ZlcnlbXCJkZWZhdWx0XCJdKG5ldyBfcm91dGluZ1V0aWxbXCJkZWZhdWx0XCJdKHJvdXRpbmdDb250ZXh0LCBhZGRyZXNzLnRvU3RyaW5nKCkpKTtcbiAgICBfdGhpcy5fbG9hZEJhbGFuY2luZ1N0cmF0ZWd5ID0gbmV3IF9sZWFzdENvbm5lY3RlZExvYWRCYWxhbmNpbmdTdHJhdGVneVtcImRlZmF1bHRcIl0oX3RoaXMuX2Nvbm5lY3Rpb25Qb29sKTtcbiAgICBfdGhpcy5faG9zdE5hbWVSZXNvbHZlciA9IGhvc3ROYW1lUmVzb2x2ZXI7XG4gICAgX3RoaXMuX2Ruc1Jlc29sdmVyID0gbmV3IF9ub2RlLkhvc3ROYW1lUmVzb2x2ZXIoKTtcbiAgICBfdGhpcy5fbG9nID0gbG9nO1xuICAgIF90aGlzLl91c2VTZWVkUm91dGVyID0gdHJ1ZTtcbiAgICBfdGhpcy5fcm91dGluZ1RhYmxlUHVyZ2VEZWxheSA9IHJvdXRpbmdUYWJsZVB1cmdlRGVsYXkgPyAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHJvdXRpbmdUYWJsZVB1cmdlRGVsYXkpIDogREVGQVVMVF9ST1VUSU5HX1RBQkxFX1BVUkdFX0RFTEFZO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUm91dGluZ0Nvbm5lY3Rpb25Qcm92aWRlciwgW3tcbiAgICBrZXk6IFwiX2NyZWF0ZUNvbm5lY3Rpb25FcnJvckhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUNvbm5lY3Rpb25FcnJvckhhbmRsZXIoKSB7XG4gICAgICAvLyBjb25uZWN0aW9uIGVycm9ycyBtZWFuIFNFUlZJQ0VfVU5BVkFJTEFCTEUgZm9yIGRpcmVjdCBkcml2ZXIgYnV0IGZvciByb3V0aW5nIGRyaXZlciB0aGV5IHNob3VsZCBvbmx5XG4gICAgICAvLyByZXN1bHQgaW4gU0VTU0lPTl9FWFBJUkVEIGJlY2F1c2UgdGhlcmUgbWlnaHQgc3RpbGwgZXhpc3Qgb3RoZXIgc2VydmVycyBjYXBhYmxlIG9mIHNlcnZpbmcgdGhlIHJlcXVlc3RcbiAgICAgIHJldHVybiBuZXcgX2Nvbm5lY3Rpb25FcnJvckhhbmRsZXJbXCJkZWZhdWx0XCJdKF9lcnJvci5TRVNTSU9OX0VYUElSRUQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlVW5hdmFpbGFiaWxpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVVuYXZhaWxhYmlsaXR5KGVycm9yLCBhZGRyZXNzLCBkYXRhYmFzZSkge1xuICAgICAgdGhpcy5fbG9nLndhcm4oXCJSb3V0aW5nIGRyaXZlciBcIi5jb25jYXQodGhpcy5faWQsIFwiIHdpbGwgZm9yZ2V0IFwiKS5jb25jYXQoYWRkcmVzcywgXCIgZm9yIGRhdGFiYXNlICdcIikuY29uY2F0KGRhdGFiYXNlLCBcIicgYmVjYXVzZSBvZiBhbiBlcnJvciBcIikuY29uY2F0KGVycm9yLmNvZGUsIFwiICdcIikuY29uY2F0KGVycm9yLm1lc3NhZ2UsIFwiJ1wiKSk7XG5cbiAgICAgIHRoaXMuZm9yZ2V0KGFkZHJlc3MsIGRhdGFiYXNlIHx8ICcnKTtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZVdyaXRlRmFpbHVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlV3JpdGVGYWlsdXJlKGVycm9yLCBhZGRyZXNzLCBkYXRhYmFzZSkge1xuICAgICAgdGhpcy5fbG9nLndhcm4oXCJSb3V0aW5nIGRyaXZlciBcIi5jb25jYXQodGhpcy5faWQsIFwiIHdpbGwgZm9yZ2V0IHdyaXRlciBcIikuY29uY2F0KGFkZHJlc3MsIFwiIGZvciBkYXRhYmFzZSAnXCIpLmNvbmNhdChkYXRhYmFzZSwgXCInIGJlY2F1c2Ugb2YgYW4gZXJyb3IgXCIpLmNvbmNhdChlcnJvci5jb2RlLCBcIiAnXCIpLmNvbmNhdChlcnJvci5tZXNzYWdlLCBcIidcIikpO1xuXG4gICAgICB0aGlzLmZvcmdldFdyaXRlcihhZGRyZXNzLCBkYXRhYmFzZSB8fCAnJyk7XG4gICAgICByZXR1cm4gKDAsIF9lcnJvci5uZXdFcnJvcikoJ05vIGxvbmdlciBwb3NzaWJsZSB0byB3cml0ZSB0byBzZXJ2ZXIgYXQgJyArIGFkZHJlc3MsIF9lcnJvci5TRVNTSU9OX0VYUElSRUQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWUge0BsaW5rIENvbm5lY3Rpb25Qcm92aWRlcn0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBtZXRob2QgYW5kXG4gICAgICogaXRzIGFyZ3VtZW50cy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFjcXVpcmVDb25uZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYWNxdWlyZUNvbm5lY3Rpb24gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIF9yZWYyLFxuICAgICAgICAgICAgYWNjZXNzTW9kZSxcbiAgICAgICAgICAgIGRhdGFiYXNlLFxuICAgICAgICAgICAgYm9va21hcmssXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGFiYXNlU3BlY2lmaWNFcnJvckhhbmRsZXIsXG4gICAgICAgICAgICByb3V0aW5nVGFibGUsXG4gICAgICAgICAgICBjb25uZWN0aW9uLFxuICAgICAgICAgICAgdHJhbnNmb3JtZWQsXG4gICAgICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9yZWYyID0gX2FyZ3MubGVuZ3RoID4gMCAmJiBfYXJnc1swXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMF0gOiB7fSwgYWNjZXNzTW9kZSA9IF9yZWYyLmFjY2Vzc01vZGUsIGRhdGFiYXNlID0gX3JlZjIuZGF0YWJhc2UsIGJvb2ttYXJrID0gX3JlZjIuYm9va21hcms7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VTcGVjaWZpY0Vycm9ySGFuZGxlciA9IG5ldyBfY29ubmVjdGlvbkVycm9ySGFuZGxlcltcImRlZmF1bHRcIl0oX2Vycm9yLlNFU1NJT05fRVhQSVJFRCwgZnVuY3Rpb24gKGVycm9yLCBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9oYW5kbGVVbmF2YWlsYWJpbGl0eShlcnJvciwgYWRkcmVzcywgZGF0YWJhc2UpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvciwgYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5faGFuZGxlV3JpdGVGYWlsdXJlKGVycm9yLCBhZGRyZXNzLCBkYXRhYmFzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZyZXNoUm91dGluZ1RhYmxlKHtcbiAgICAgICAgICAgICAgICAgIGFjY2Vzc01vZGU6IGFjY2Vzc01vZGUsXG4gICAgICAgICAgICAgICAgICBkYXRhYmFzZTogZGF0YWJhc2UgfHwgREVGQVVMVF9EQl9OQU1FLFxuICAgICAgICAgICAgICAgICAgYm9va21hcms6IGJvb2ttYXJrXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJvdXRpbmdUYWJsZSA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShhY2Nlc3NNb2RlID09PSBfZHJpdmVyLlJFQUQpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5fbG9hZEJhbGFuY2luZ1N0cmF0ZWd5LnNlbGVjdFJlYWRlcihyb3V0aW5nVGFibGUucmVhZGVycyk7XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdyZWFkJztcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBpZiAoIShhY2Nlc3NNb2RlID09PSBfZHJpdmVyLldSSVRFKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IHRoaXMuX2xvYWRCYWxhbmNpbmdTdHJhdGVneS5zZWxlY3RXcml0ZXIocm91dGluZ1RhYmxlLndyaXRlcnMpO1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnd3JpdGUnO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdJbGxlZ2FsIG1vZGUgJyArIGFjY2Vzc01vZGUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKFwiRmFpbGVkIHRvIG9idGFpbiBjb25uZWN0aW9uIHRvd2FyZHMgXCIuY29uY2F0KG5hbWUsIFwiIHNlcnZlci4gS25vd24gcm91dGluZyB0YWJsZSBpczogXCIpLmNvbmNhdChyb3V0aW5nVGFibGUpLCBfZXJyb3IuU0VTU0lPTl9FWFBJUkVEKTtcblxuICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxODtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVDb25uZWN0aW9uVG9TZXJ2ZXIoYWRkcmVzcywgbmFtZSwgcm91dGluZ1RhYmxlKTtcblxuICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3IF9jb25uZWN0aW9uRGVsZWdhdGVbXCJkZWZhdWx0XCJdKGNvbm5lY3Rpb24sIGRhdGFiYXNlU3BlY2lmaWNFcnJvckhhbmRsZXIpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyNTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMTgpO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkID0gZGF0YWJhc2VTcGVjaWZpY0Vycm9ySGFuZGxlci5oYW5kbGVBbmRUcmFuc2Zvcm1FcnJvcihfY29udGV4dC50MCwgYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgdHJhbnNmb3JtZWQ7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzE4LCAyNV1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gYWNxdWlyZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfYWNxdWlyZUNvbm5lY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjcXVpcmVDb25uZWN0aW9uO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9oYXNQcm90b2NvbFZlcnNpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9oYXNQcm90b2NvbFZlcnNpb24yID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHZlcnNpb25QcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIGFkZHJlc3NlcywgbGFzdEVycm9yLCBpLCBjb25uZWN0aW9uLCBwcm90b2NvbDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlU2VlZFJvdXRlcih0aGlzLl9zZWVkUm91dGVyKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGlmICghKGkgPCBhZGRyZXNzZXMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPSBfY29ubmVjdGlvbkNoYW5uZWxbXCJkZWZhdWx0XCJdLmNyZWF0ZShhZGRyZXNzZXNbaV0sIHRoaXMuX2NvbmZpZywgdGhpcy5fY3JlYXRlQ29ubmVjdGlvbkVycm9ySGFuZGxlcigpLCB0aGlzLl9sb2cpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gNjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uX25lZ290aWF0ZVByb3RvY29sKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gY29ubmVjdGlvbi5wcm90b2NvbCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwcm90b2NvbCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHZlcnNpb25QcmVkaWNhdGUocHJvdG9jb2wudmVyc2lvbikpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxNTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSg2KTtcbiAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBfY29udGV4dDIudDA7XG5cbiAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE4O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uY2xvc2UoKTtcblxuICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDE4KTtcblxuICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3RFcnJvcikge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyNztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IGxhc3RFcnJvcjtcblxuICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGZhbHNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1s2LCAxNSwgMTgsIDIyXV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfaGFzUHJvdG9jb2xWZXJzaW9uKF94KSB7XG4gICAgICAgIHJldHVybiBfaGFzUHJvdG9jb2xWZXJzaW9uMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2hhc1Byb3RvY29sVmVyc2lvbjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJzdXBwb3J0c011bHRpRGJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zdXBwb3J0c011bHRpRGIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzUHJvdG9jb2xWZXJzaW9uKGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbiA+PSBfY29uc3RhbnRzLkJPTFRfUFJPVE9DT0xfVjRfMDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQzLnNlbnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzdXBwb3J0c011bHRpRGIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwcG9ydHNNdWx0aURiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdXBwb3J0c011bHRpRGI7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic3VwcG9ydHNUcmFuc2FjdGlvbkNvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3N1cHBvcnRzVHJhbnNhY3Rpb25Db25maWcgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzUHJvdG9jb2xWZXJzaW9uKGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbiA+PSBfY29uc3RhbnRzLkJPTFRfUFJPVE9DT0xfVjM7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NC5zZW50KTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc3VwcG9ydHNUcmFuc2FjdGlvbkNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBwb3J0c1RyYW5zYWN0aW9uQ29uZmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdXBwb3J0c1RyYW5zYWN0aW9uQ29uZmlnO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImZvcmdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JnZXQoYWRkcmVzcywgZGF0YWJhc2UpIHtcbiAgICAgIGlmIChkYXRhYmFzZSB8fCBkYXRhYmFzZSA9PT0gJycpIHtcbiAgICAgICAgdGhpcy5fcm91dGluZ1RhYmxlc1tkYXRhYmFzZV0uZm9yZ2V0KGFkZHJlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLl9yb3V0aW5nVGFibGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0aW5nVGFibGUpIHtcbiAgICAgICAgICByZXR1cm4gcm91dGluZ1RhYmxlLmZvcmdldChhZGRyZXNzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFdlJ3JlIGZpcmluZyBhbmQgZm9yZ2V0dGluZyB0aGlzIG9wZXJhdGlvbiBleHBsaWNpdGx5IGFuZCBsaXN0ZW5pbmcgZm9yIGFueVxuICAgICAgLy8gZXJyb3JzIHRvIGF2b2lkIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvblxuXG5cbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Qb29sLnB1cmdlKGFkZHJlc3MpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge30pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JnZXRXcml0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yZ2V0V3JpdGVyKGFkZHJlc3MsIGRhdGFiYXNlKSB7XG4gICAgICBpZiAoZGF0YWJhc2UgfHwgZGF0YWJhc2UgPT09ICcnKSB7XG4gICAgICAgIHRoaXMuX3JvdXRpbmdUYWJsZXNbZGF0YWJhc2VdLmZvcmdldFdyaXRlcihhZGRyZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5fcm91dGluZ1RhYmxlcykuZm9yRWFjaChmdW5jdGlvbiAocm91dGluZ1RhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIHJvdXRpbmdUYWJsZS5mb3JnZXRXcml0ZXIoYWRkcmVzcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYWNxdWlyZUNvbm5lY3Rpb25Ub1NlcnZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWNxdWlyZUNvbm5lY3Rpb25Ub1NlcnZlcihhZGRyZXNzLCBzZXJ2ZXJOYW1lLCByb3V0aW5nVGFibGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUG9vbC5hY3F1aXJlKGFkZHJlc3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZnJlc2hSb3V0aW5nVGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZyZXNoUm91dGluZ1RhYmxlKCkge1xuICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBhY2Nlc3NNb2RlID0gX3JlZjMuYWNjZXNzTW9kZSxcbiAgICAgICAgICBkYXRhYmFzZSA9IF9yZWYzLmRhdGFiYXNlLFxuICAgICAgICAgIGJvb2ttYXJrID0gX3JlZjMuYm9va21hcms7XG5cbiAgICAgIHZhciBjdXJyZW50Um91dGluZ1RhYmxlID0gdGhpcy5fcm91dGluZ1RhYmxlc1tkYXRhYmFzZV0gfHwgbmV3IF9yb3V0aW5nVGFibGVbXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgZGF0YWJhc2U6IGRhdGFiYXNlXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFjdXJyZW50Um91dGluZ1RhYmxlLmlzU3RhbGVGb3IoYWNjZXNzTW9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSb3V0aW5nVGFibGU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xvZy5pbmZvKFwiUm91dGluZyB0YWJsZSBpcyBzdGFsZSBmb3IgZGF0YWJhc2U6IFxcXCJcIi5jb25jYXQoZGF0YWJhc2UsIFwiXFxcIiBhbmQgYWNjZXNzIG1vZGU6IFxcXCJcIikuY29uY2F0KGFjY2Vzc01vZGUsIFwiXFxcIjogXCIpLmNvbmNhdChjdXJyZW50Um91dGluZ1RhYmxlKSk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZWZyZXNoUm91dGluZ1RhYmxlKGN1cnJlbnRSb3V0aW5nVGFibGUsIGJvb2ttYXJrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlZnJlc2hSb3V0aW5nVGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZnJlc2hSb3V0aW5nVGFibGUoY3VycmVudFJvdXRpbmdUYWJsZSwgYm9va21hcmspIHtcbiAgICAgIHZhciBrbm93blJvdXRlcnMgPSBjdXJyZW50Um91dGluZ1RhYmxlLnJvdXRlcnM7XG5cbiAgICAgIGlmICh0aGlzLl91c2VTZWVkUm91dGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mZXRjaFJvdXRpbmdUYWJsZUZyb21TZWVkUm91dGVyRmFsbGJhY2tUb0tub3duUm91dGVycyhrbm93blJvdXRlcnMsIGN1cnJlbnRSb3V0aW5nVGFibGUsIGJvb2ttYXJrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoUm91dGluZ1RhYmxlRnJvbUtub3duUm91dGVyc0ZhbGxiYWNrVG9TZWVkUm91dGVyKGtub3duUm91dGVycywgY3VycmVudFJvdXRpbmdUYWJsZSwgYm9va21hcmspO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZmV0Y2hSb3V0aW5nVGFibGVGcm9tU2VlZFJvdXRlckZhbGxiYWNrVG9Lbm93blJvdXRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9mZXRjaFJvdXRpbmdUYWJsZUZyb21TZWVkUm91dGVyRmFsbGJhY2tUb0tub3duUm91dGVyczIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoa25vd25Sb3V0ZXJzLCBjdXJyZW50Um91dGluZ1RhYmxlLCBib29rbWFyaykge1xuICAgICAgICB2YXIgc2VlblJvdXRlcnMsIG5ld1JvdXRpbmdUYWJsZTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgLy8gd2Ugc3RhcnQgd2l0aCBzZWVkIHJvdXRlciwgbm8gcm91dGVycyB3ZXJlIHByb2JlZCBiZWZvcmVcbiAgICAgICAgICAgICAgICBzZWVuUm91dGVycyA9IFtdO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hSb3V0aW5nVGFibGVVc2luZ1NlZWRSb3V0ZXIoc2VlblJvdXRlcnMsIHRoaXMuX3NlZWRSb3V0ZXIsIGN1cnJlbnRSb3V0aW5nVGFibGUsIGJvb2ttYXJrKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgbmV3Um91dGluZ1RhYmxlID0gX2NvbnRleHQ1LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5ld1JvdXRpbmdUYWJsZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlU2VlZFJvdXRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoUm91dGluZ1RhYmxlVXNpbmdLbm93blJvdXRlcnMoa25vd25Sb3V0ZXJzLCBjdXJyZW50Um91dGluZ1RhYmxlLCBib29rbWFyayk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBuZXdSb3V0aW5nVGFibGUgPSBfY29udGV4dDUuc2VudDtcblxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Um91dGluZ1RhYmxlSWZQb3NzaWJsZShjdXJyZW50Um91dGluZ1RhYmxlLCBuZXdSb3V0aW5nVGFibGUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ1LnNlbnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2ZldGNoUm91dGluZ1RhYmxlRnJvbVNlZWRSb3V0ZXJGYWxsYmFja1RvS25vd25Sb3V0ZXJzKF94MiwgX3gzLCBfeDQpIHtcbiAgICAgICAgcmV0dXJuIF9mZXRjaFJvdXRpbmdUYWJsZUZyb21TZWVkUm91dGVyRmFsbGJhY2tUb0tub3duUm91dGVyczIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9mZXRjaFJvdXRpbmdUYWJsZUZyb21TZWVkUm91dGVyRmFsbGJhY2tUb0tub3duUm91dGVycztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfZmV0Y2hSb3V0aW5nVGFibGVGcm9tS25vd25Sb3V0ZXJzRmFsbGJhY2tUb1NlZWRSb3V0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9mZXRjaFJvdXRpbmdUYWJsZUZyb21Lbm93blJvdXRlcnNGYWxsYmFja1RvU2VlZFJvdXRlcjIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoa25vd25Sb3V0ZXJzLCBjdXJyZW50Um91dGluZ1RhYmxlLCBib29rbWFyaykge1xuICAgICAgICB2YXIgbmV3Um91dGluZ1RhYmxlO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoUm91dGluZ1RhYmxlVXNpbmdLbm93blJvdXRlcnMoa25vd25Sb3V0ZXJzLCBjdXJyZW50Um91dGluZ1RhYmxlLCBib29rbWFyayk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG5ld1JvdXRpbmdUYWJsZSA9IF9jb250ZXh0Ni5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ld1JvdXRpbmdUYWJsZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mZXRjaFJvdXRpbmdUYWJsZVVzaW5nU2VlZFJvdXRlcihrbm93blJvdXRlcnMsIHRoaXMuX3NlZWRSb3V0ZXIsIGN1cnJlbnRSb3V0aW5nVGFibGUsIGJvb2ttYXJrKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgbmV3Um91dGluZ1RhYmxlID0gX2NvbnRleHQ2LnNlbnQ7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlSb3V0aW5nVGFibGVJZlBvc3NpYmxlKGN1cnJlbnRSb3V0aW5nVGFibGUsIG5ld1JvdXRpbmdUYWJsZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Ni5zZW50KTtcblxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9mZXRjaFJvdXRpbmdUYWJsZUZyb21Lbm93blJvdXRlcnNGYWxsYmFja1RvU2VlZFJvdXRlcihfeDUsIF94NiwgX3g3KSB7XG4gICAgICAgIHJldHVybiBfZmV0Y2hSb3V0aW5nVGFibGVGcm9tS25vd25Sb3V0ZXJzRmFsbGJhY2tUb1NlZWRSb3V0ZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZmV0Y2hSb3V0aW5nVGFibGVGcm9tS25vd25Sb3V0ZXJzRmFsbGJhY2tUb1NlZWRSb3V0ZXI7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZldGNoUm91dGluZ1RhYmxlVXNpbmdLbm93blJvdXRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9mZXRjaFJvdXRpbmdUYWJsZVVzaW5nS25vd25Sb3V0ZXJzMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhrbm93blJvdXRlcnMsIGN1cnJlbnRSb3V0aW5nVGFibGUsIGJvb2ttYXJrKSB7XG4gICAgICAgIHZhciBuZXdSb3V0aW5nVGFibGUsIGxhc3RSb3V0ZXJJbmRleDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mZXRjaFJvdXRpbmdUYWJsZShrbm93blJvdXRlcnMsIGN1cnJlbnRSb3V0aW5nVGFibGUsIGJvb2ttYXJrKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbmV3Um91dGluZ1RhYmxlID0gX2NvbnRleHQ3LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5ld1JvdXRpbmdUYWJsZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3Um91dGluZ1RhYmxlKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuZWQgcm91dGluZyB0YWJsZSB3YXMgdW5kZWZpbmVkLCB0aGlzIG1lYW5zIGEgY29ubmVjdGlvbiBlcnJvciBoYXBwZW5lZCBhbmQgdGhlIGxhc3Qga25vd25cbiAgICAgICAgICAgICAgICAvLyByb3V0ZXIgZGlkIG5vdCByZXR1cm4gYSB2YWxpZCByb3V0aW5nIHRhYmxlLCBzbyB3ZSBuZWVkIHRvIGZvcmdldCBpdFxuICAgICAgICAgICAgICAgIGxhc3RSb3V0ZXJJbmRleCA9IGtub3duUm91dGVycy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICAgICAgUm91dGluZ0Nvbm5lY3Rpb25Qcm92aWRlci5fZm9yZ2V0Um91dGVyKGN1cnJlbnRSb3V0aW5nVGFibGUsIGtub3duUm91dGVycywgbGFzdFJvdXRlckluZGV4KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTcsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfZmV0Y2hSb3V0aW5nVGFibGVVc2luZ0tub3duUm91dGVycyhfeDgsIF94OSwgX3gxMCkge1xuICAgICAgICByZXR1cm4gX2ZldGNoUm91dGluZ1RhYmxlVXNpbmdLbm93blJvdXRlcnMyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZmV0Y2hSb3V0aW5nVGFibGVVc2luZ0tub3duUm91dGVycztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfZmV0Y2hSb3V0aW5nVGFibGVVc2luZ1NlZWRSb3V0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9mZXRjaFJvdXRpbmdUYWJsZVVzaW5nU2VlZFJvdXRlcjIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTgoc2VlblJvdXRlcnMsIHNlZWRSb3V0ZXIsIHJvdXRpbmdUYWJsZSwgYm9va21hcmspIHtcbiAgICAgICAgdmFyIHJlc29sdmVkQWRkcmVzc2VzLCBuZXdBZGRyZXNzZXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVNlZWRSb3V0ZXIoc2VlZFJvdXRlcik7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJlc29sdmVkQWRkcmVzc2VzID0gX2NvbnRleHQ4LnNlbnQ7XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBhbGwgYWRkcmVzc2VzIHRoYXQgd2UndmUgYWxyZWFkeSB0cmllZFxuICAgICAgICAgICAgICAgIG5ld0FkZHJlc3NlcyA9IHJlc29sdmVkQWRkcmVzc2VzLmZpbHRlcihmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlZW5Sb3V0ZXJzLmluZGV4T2YoYWRkcmVzcykgPCAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hSb3V0aW5nVGFibGUobmV3QWRkcmVzc2VzLCByb3V0aW5nVGFibGUsIGJvb2ttYXJrKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ4LnNlbnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTgsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfZmV0Y2hSb3V0aW5nVGFibGVVc2luZ1NlZWRSb3V0ZXIoX3gxMSwgX3gxMiwgX3gxMywgX3gxNCkge1xuICAgICAgICByZXR1cm4gX2ZldGNoUm91dGluZ1RhYmxlVXNpbmdTZWVkUm91dGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2ZldGNoUm91dGluZ1RhYmxlVXNpbmdTZWVkUm91dGVyO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNvbHZlU2VlZFJvdXRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3Jlc29sdmVTZWVkUm91dGVyMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOShzZWVkUm91dGVyKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciByZXNvbHZlZEFkZHJlc3NlcywgZG5zUmVzb2x2ZWRBZGRyZXNzZXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkkKF9jb250ZXh0OSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faG9zdE5hbWVSZXNvbHZlci5yZXNvbHZlKHNlZWRSb3V0ZXIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFkZHJlc3NlcyA9IF9jb250ZXh0OS5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVzb2x2ZWRBZGRyZXNzZXMubWFwKGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLl9kbnNSZXNvbHZlci5yZXNvbHZlKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgZG5zUmVzb2x2ZWRBZGRyZXNzZXMgPSBfY29udGV4dDkuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdChcInJldHVyblwiLCBbXS5jb25jYXQuYXBwbHkoW10sIGRuc1Jlc29sdmVkQWRkcmVzc2VzKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9yZXNvbHZlU2VlZFJvdXRlcihfeDE1KSB7XG4gICAgICAgIHJldHVybiBfcmVzb2x2ZVNlZWRSb3V0ZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVzb2x2ZVNlZWRSb3V0ZXI7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZldGNoUm91dGluZ1RhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9mZXRjaFJvdXRpbmdUYWJsZShyb3V0ZXJBZGRyZXNzZXMsIHJvdXRpbmdUYWJsZSwgYm9va21hcmspIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gcm91dGVyQWRkcmVzc2VzLnJlZHVjZSggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWY0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMChyZWZyZXNoZWRUYWJsZVByb21pc2UsIGN1cnJlbnRSb3V0ZXIsIGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgIHZhciBuZXdSb3V0aW5nVGFibGUsIHByZXZpb3VzUm91dGVySW5kZXgsIHNlc3Npb247XG4gICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZWZyZXNoZWRUYWJsZVByb21pc2U7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICBuZXdSb3V0aW5nVGFibGUgPSBfY29udGV4dDEwLnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgIGlmICghbmV3Um91dGluZ1RhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3Um91dGluZ1RhYmxlKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIC8vIHJldHVybmVkIHJvdXRpbmcgdGFibGUgd2FzIHVuZGVmaW5lZCwgdGhpcyBtZWFucyBhIGNvbm5lY3Rpb24gZXJyb3IgaGFwcGVuZWQgYW5kIHdlIG5lZWQgdG8gZm9yZ2V0IHRoZVxuICAgICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgcm91dGVyIGFuZCB0cnkgdGhlIG5leHQgb25lXG4gICAgICAgICAgICAgICAgICBwcmV2aW91c1JvdXRlckluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcblxuICAgICAgICAgICAgICAgICAgUm91dGluZ0Nvbm5lY3Rpb25Qcm92aWRlci5fZm9yZ2V0Um91dGVyKHJvdXRpbmdUYWJsZSwgcm91dGVyQWRkcmVzc2VzLCBwcmV2aW91c1JvdXRlckluZGV4KTtcblxuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5fY3JlYXRlU2Vzc2lvbkZvclJlZGlzY292ZXJ5KGN1cnJlbnRSb3V0ZXIsIGJvb2ttYXJrKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICBzZXNzaW9uID0gX2NvbnRleHQxMC5zZW50O1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMjc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDEwLnByZXYgPSAxMztcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5fcmVkaXNjb3ZlcnkubG9va3VwUm91dGluZ1RhYmxlT25Sb3V0ZXIoc2Vzc2lvbiwgcm91dGluZ1RhYmxlLmRhdGFiYXNlLCBjdXJyZW50Um91dGVyKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQxMC5zZW50KTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDEwLnByZXYgPSAxOTtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAudDAgPSBfY29udGV4dDEwW1wiY2F0Y2hcIl0oMTMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIShfY29udGV4dDEwLnQwICYmIF9jb250ZXh0MTAudDAuY29kZSA9PT0gREFUQUJBU0VfTk9UX0ZPVU5EX0VSUk9SX0NPREUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDIzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQxMC50MDtcblxuICAgICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgICBfdGhpczQuX2xvZy53YXJuKFwidW5hYmxlIHRvIGZldGNoIHJvdXRpbmcgdGFibGUgYmVjYXVzZSBvZiBhbiBlcnJvciBcIi5jb25jYXQoX2NvbnRleHQxMC50MCkpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMjg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUxMCwgbnVsbCwgW1sxMywgMTldXSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94MTYsIF94MTcsIF94MTgpIHtcbiAgICAgICAgICByZXR1cm4gX3JlZjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oKSwgUHJvbWlzZS5yZXNvbHZlKG51bGwpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVNlc3Npb25Gb3JSZWRpc2NvdmVyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2NyZWF0ZVNlc3Npb25Gb3JSZWRpc2NvdmVyeTIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKHJvdXRlckFkZHJlc3MsIGJvb2ttYXJrKSB7XG4gICAgICAgIHZhciBjb25uZWN0aW9uLCBjb25uZWN0aW9uUHJvdmlkZXIsIHByb3RvY29sVmVyc2lvbjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTEkKF9jb250ZXh0MTEpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDExLnByZXYgPSBfY29udGV4dDExLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTEucHJldiA9IDA7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblBvb2wuYWNxdWlyZShyb3V0ZXJBZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IF9jb250ZXh0MTEuc2VudDtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uUHJvdmlkZXIgPSBuZXcgX2Nvbm5lY3Rpb25Qcm92aWRlclNpbmdsZVtcImRlZmF1bHRcIl0oY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgcHJvdG9jb2xWZXJzaW9uID0gY29ubmVjdGlvbi5wcm90b2NvbCgpLnZlcnNpb247XG5cbiAgICAgICAgICAgICAgICBpZiAoIShwcm90b2NvbFZlcnNpb24gPCA0LjApKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBfc2Vzc2lvbltcImRlZmF1bHRcIl0oe1xuICAgICAgICAgICAgICAgICAgbW9kZTogX2RyaXZlci5XUklURSxcbiAgICAgICAgICAgICAgICAgIGJvb2ttYXJrOiBfYm9va21hcmtbXCJkZWZhdWx0XCJdLmVtcHR5KCksXG4gICAgICAgICAgICAgICAgICBjb25uZWN0aW9uUHJvdmlkZXI6IGNvbm5lY3Rpb25Qcm92aWRlclxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBfc2Vzc2lvbltcImRlZmF1bHRcIl0oe1xuICAgICAgICAgICAgICAgICAgbW9kZTogX2RyaXZlci5SRUFELFxuICAgICAgICAgICAgICAgICAgZGF0YWJhc2U6IFNZU1RFTV9EQl9OQU1FLFxuICAgICAgICAgICAgICAgICAgYm9va21hcms6IGJvb2ttYXJrLFxuICAgICAgICAgICAgICAgICAgY29ubmVjdGlvblByb3ZpZGVyOiBjb25uZWN0aW9uUHJvdmlkZXJcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDExLnByZXYgPSAxMTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDExLnQwID0gX2NvbnRleHQxMVtcImNhdGNoXCJdKDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoX2NvbnRleHQxMS50MCAmJiBfY29udGV4dDExLnQwLmNvZGUgPT09IFVOQVVUSE9SSVpFRF9FUlJPUl9DT0RFKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDExLnQwO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTEsIHRoaXMsIFtbMCwgMTFdXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9jcmVhdGVTZXNzaW9uRm9yUmVkaXNjb3ZlcnkoX3gxOSwgX3gyMCkge1xuICAgICAgICByZXR1cm4gX2NyZWF0ZVNlc3Npb25Gb3JSZWRpc2NvdmVyeTIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9jcmVhdGVTZXNzaW9uRm9yUmVkaXNjb3Zlcnk7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FwcGx5Um91dGluZ1RhYmxlSWZQb3NzaWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2FwcGx5Um91dGluZ1RhYmxlSWZQb3NzaWJsZTIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEyKGN1cnJlbnRSb3V0aW5nVGFibGUsIG5ld1JvdXRpbmdUYWJsZSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMiQoX2NvbnRleHQxMikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKG5ld1JvdXRpbmdUYWJsZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKFwiQ291bGQgbm90IHBlcmZvcm0gZGlzY292ZXJ5LiBObyByb3V0aW5nIHNlcnZlcnMgYXZhaWxhYmxlLiBLbm93biByb3V0aW5nIHRhYmxlOiBcIi5jb25jYXQoY3VycmVudFJvdXRpbmdUYWJsZSksIF9lcnJvci5TRVJWSUNFX1VOQVZBSUxBQkxFKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaWYgKG5ld1JvdXRpbmdUYWJsZS53cml0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgLy8gdXNlIHNlZWQgcm91dGVyIG5leHQgdGltZS4gdGhpcyBpcyBpbXBvcnRhbnQgd2hlbiBjbHVzdGVyIGlzIHBhcnRpdGlvbmVkLiBpdCB0cmllcyB0byBtYWtlIHN1cmUgZHJpdmVyXG4gICAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBhbHdheXMgZ2V0IHJvdXRpbmcgdGFibGUgd2l0aG91dCB3cml0ZXJzIGJlY2F1c2UgaXQgdGFsa3MgZXhjbHVzaXZlbHkgdG8gYSBtaW5vcml0eSBwYXJ0aXRpb25cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3VzZVNlZWRSb3V0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZVJvdXRpbmdUYWJsZShuZXdSb3V0aW5nVGFibGUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3Um91dGluZ1RhYmxlKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfYXBwbHlSb3V0aW5nVGFibGVJZlBvc3NpYmxlKF94MjEsIF94MjIpIHtcbiAgICAgICAgcmV0dXJuIF9hcHBseVJvdXRpbmdUYWJsZUlmUG9zc2libGUyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfYXBwbHlSb3V0aW5nVGFibGVJZlBvc3NpYmxlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVSb3V0aW5nVGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF91cGRhdGVSb3V0aW5nVGFibGUyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMyhuZXdSb3V0aW5nVGFibGUpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTMkKF9jb250ZXh0MTMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEzLnByZXYgPSBfY29udGV4dDEzLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25Qb29sLmtlZXBBbGwobmV3Um91dGluZ1RhYmxlLmFsbFNlcnZlcnMoKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgZXhwaXJlZCB0byBwdXJnZSAoZXhwaXJlZCBmb3IgYSBwcmUtY29uZmlndXJlZCBhbW91bnQgb2YgdGltZSkgcm91dGluZyB0YWJsZSBlbnRyaWVzXG4gICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLl9yb3V0aW5nVGFibGVzKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmlzRXhwaXJlZEZvcihfdGhpczUuX3JvdXRpbmdUYWJsZVB1cmdlRGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpczUuX3JvdXRpbmdUYWJsZXNbdmFsdWUuZGF0YWJhc2VdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pOyAvLyBtYWtlIHRoaXMgZHJpdmVyIGluc3RhbmNlIGF3YXJlIG9mIHRoZSBuZXcgdGFibGVcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JvdXRpbmdUYWJsZXNbbmV3Um91dGluZ1RhYmxlLmRhdGFiYXNlXSA9IG5ld1JvdXRpbmdUYWJsZTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5pbmZvKFwiVXBkYXRlZCByb3V0aW5nIHRhYmxlIFwiLmNvbmNhdChuZXdSb3V0aW5nVGFibGUpKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfdXBkYXRlUm91dGluZ1RhYmxlKF94MjMpIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVSb3V0aW5nVGFibGUyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdXBkYXRlUm91dGluZ1RhYmxlO1xuICAgIH0oKVxuICB9XSwgW3tcbiAgICBrZXk6IFwiX2ZvcmdldFJvdXRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZm9yZ2V0Um91dGVyKHJvdXRpbmdUYWJsZSwgcm91dGVyc0FycmF5LCByb3V0ZXJJbmRleCkge1xuICAgICAgdmFyIGFkZHJlc3MgPSByb3V0ZXJzQXJyYXlbcm91dGVySW5kZXhdO1xuXG4gICAgICBpZiAocm91dGluZ1RhYmxlICYmIGFkZHJlc3MpIHtcbiAgICAgICAgcm91dGluZ1RhYmxlLmZvcmdldFJvdXRlcihhZGRyZXNzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJvdXRpbmdDb25uZWN0aW9uUHJvdmlkZXI7XG59KF9jb25uZWN0aW9uUHJvdmlkZXJQb29sZWRbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSb3V0aW5nQ29ubmVjdGlvblByb3ZpZGVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9jb25uZWN0aW9uUHJvdmlkZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tcHJvdmlkZXJcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgU2luZ2xlQ29ubmVjdGlvblByb3ZpZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29ubmVjdGlvblByb3ZpZGVyKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoU2luZ2xlQ29ubmVjdGlvblByb3ZpZGVyLCBfQ29ubmVjdGlvblByb3ZpZGVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFNpbmdsZUNvbm5lY3Rpb25Qcm92aWRlcik7XG5cbiAgZnVuY3Rpb24gU2luZ2xlQ29ubmVjdGlvblByb3ZpZGVyKGNvbm5lY3Rpb24pIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFNpbmdsZUNvbm5lY3Rpb25Qcm92aWRlcik7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIENvbm5lY3Rpb25Qcm92aWRlcn0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBtZXRob2QgYW5kXG4gICAqIGl0cyBhcmd1bWVudHMuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShTaW5nbGVDb25uZWN0aW9uUHJvdmlkZXIsIFt7XG4gICAga2V5OiBcImFjcXVpcmVDb25uZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjcXVpcmVDb25uZWN0aW9uKCkge1xuICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIGFjY2Vzc01vZGUgPSBfcmVmLmFjY2Vzc01vZGUsXG4gICAgICAgICAgZGF0YWJhc2UgPSBfcmVmLmRhdGFiYXNlLFxuICAgICAgICAgIGJvb2ttYXJrcyA9IF9yZWYuYm9va21hcmtzO1xuXG4gICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb247XG4gICAgICB0aGlzLl9jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29ubmVjdGlvbik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTaW5nbGVDb25uZWN0aW9uUHJvdmlkZXI7XG59KF9jb25uZWN0aW9uUHJvdmlkZXJbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTaW5nbGVDb25uZWN0aW9uUHJvdmlkZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfYm9va21hcmsgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jvb2ttYXJrXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQ29ubmVjdGlvblByb3ZpZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29ubmVjdGlvblByb3ZpZGVyKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgQ29ubmVjdGlvblByb3ZpZGVyKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQ29ubmVjdGlvblByb3ZpZGVyLCBbe1xuICAgIGtleTogXCJhY3F1aXJlQ29ubmVjdGlvblwiLFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgYWNxdWlyZXMgYSBjb25uZWN0aW9uIGFnYWluc3QgdGhlIHNwZWNpZmllZCBkYXRhYmFzZS5cbiAgICAgKlxuICAgICAqIEFjY2VzcyBtb2RlIGFuZCBCb29rbWFya3Mgb25seSBhcHBsaWVzIHRvIHJvdXRpbmcgZHJpdmVyLiBBY2Nlc3MgbW9kZSBvbmx5XG4gICAgICogZGlmZmVyZW50aWF0ZXMgdGhlIHRhcmdldCBzZXJ2ZXIgZm9yIHRoZSBjb25uZWN0aW9uLCB3aGVyZSBXUklURSBzZWxlY3RzIGFcbiAgICAgKiBXUklURVIgc2VydmVyLCB3aGVyZWFzIFJFQUQgc2VsZWN0cyBhIFJFQUQgc2VydmVyLiBCb29rbWFya3MsIHdoZW4gc3BlY2lmaWVkLFxuICAgICAqIGlzIG9ubHkgcGFzc2VkIHRvIHRoZSByb3V0aW5nIGRpc2NvdmVyeSBwcm9jZWR1cmUsIGZvciB0aGUgc3lzdGVtIGRhdGFiYXNlIHRvXG4gICAgICogc3luY2hyb25pemUgb24gY3JlYXRpb24gb2YgZGF0YWJhc2VzIGFuZCBpcyBuZXZlciB1c2VkIGluIGRpcmVjdCBkcml2ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtIC0gb2JqZWN0IHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbS5hY2Nlc3NNb2RlIC0gdGhlIGFjY2VzcyBtb2RlIGZvciB0aGUgdG8tYmUtYWNxdWlyZWQgY29ubmVjdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbS5kYXRhYmFzZSAtIHRoZSB0YXJnZXQgZGF0YWJhc2UgZm9yIHRoZSB0by1iZS1hY3F1aXJlZCBjb25uZWN0aW9uXG4gICAgICogQHBhcmFtIHtCb29rbWFya30gcGFyYW0uYm9va21hcmtzIC0gdGhlIGJvb2ttYXJrcyB0byBzZW5kIHRvIHJvdXRpbmcgZGlzY292ZXJ5XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjcXVpcmVDb25uZWN0aW9uKCkge1xuICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIGFjY2Vzc01vZGUgPSBfcmVmLmFjY2Vzc01vZGUsXG4gICAgICAgICAgZGF0YWJhc2UgPSBfcmVmLmRhdGFiYXNlLFxuICAgICAgICAgIGJvb2ttYXJrcyA9IF9yZWYuYm9va21hcmtzO1xuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciB0aGUgYmFja2VuZCBkYXRhYmFzZSBzdXBwb3J0cyBtdWx0aSBkYXRhYmFzZSBmdW5jdGlvbmFsaXR5XG4gICAgICogYnkgY2hlY2tpbmcgcHJvdG9jb2wgaGFuZHNoYWtlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3VwcG9ydHNNdWx0aURiXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1cHBvcnRzTXVsdGlEYigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIHRoZSBiYWNrZW5kIGRhdGFiYXNlIHN1cHBvcnRzIHRyYW5zYWN0aW9uIGNvbmZpZyBmdW5jdGlvbmFsaXR5XG4gICAgICogYnkgY2hlY2tpbmcgcHJvdG9jb2wgaGFuZHNoYWtlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3VwcG9ydHNUcmFuc2FjdGlvbkNvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdXBwb3J0c1RyYW5zYWN0aW9uQ29uZmlnKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoaXMgY29ubmVjdGlvbiBwcm92aWRlciBhbG9uZyB3aXRoIGl0cyBpbnRlcm5hbHMgKGNvbm5lY3Rpb25zLCBwb29scywgZXRjLilcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29ubmVjdGlvblByb3ZpZGVyO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENvbm5lY3Rpb25Qcm92aWRlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9zdHJlYW1PYnNlcnZlcnMgPSByZXF1aXJlKFwiLi9zdHJlYW0tb2JzZXJ2ZXJzXCIpO1xuXG52YXIgX2JvbHRQcm90b2NvbFYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2JvbHQtcHJvdG9jb2wtdjFcIikpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBDb25uZWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbkVycm9ySGFuZGxlcn0gZXJyb3JIYW5kbGVyIHRoZSBlcnJvciBoYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBDb25uZWN0aW9uKGVycm9ySGFuZGxlcikge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgQ29ubmVjdGlvbik7XG4gICAgdGhpcy5fZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShDb25uZWN0aW9uLCBbe1xuICAgIGtleTogXCJpc09wZW5cIixcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoaXMgY29ubmVjdGlvbiBpcyBpbiBhIHdvcmtpbmcgY29uZGl0aW9uXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3BlbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb2x0UHJvdG9jb2x9IHRoZSB1bmRlcmx5aW5nIGJvbHQgcHJvdG9jb2wgYXNzaWduZWQgdG8gdGhpcyBjb25uZWN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcm90b2NvbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm90b2NvbCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTZXJ2ZXJBZGRyZXNzfSB0aGUgc2VydmVyIGFkZHJlc3MgdGhpcyBjb25uZWN0aW9uIGlzIG9wZW5lZCBhZ2FpbnN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25uZWN0XCIsXG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRvIHRoZSB0YXJnZXQgYWRkcmVzcywgbmVnb3RpYXRlIEJvbHQgcHJvdG9jb2wgYW5kIHNlbmQgaW5pdGlhbGl6YXRpb24gbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlckFnZW50IHRoZSB1c2VyIGFnZW50IGZvciB0aGlzIGRyaXZlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXV0aFRva2VuIHRoZSBvYmplY3QgY29udGFpbmluZyBhdXRoIGluZm9ybWF0aW9uLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8Q29ubmVjdGlvbj59IHByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgY3VycmVudCBjb25uZWN0aW9uIGlmIGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bC4gUmVqZWN0ZWQgcHJvbWlzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QodXNlckFnZW50LCBhdXRoVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgbWVzc2FnZSB0byB0aGUgbmV0d29yayBjaGFubmVsLlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdE1lc3NhZ2V9IG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIHtSZXN1bHRTdHJlYW1PYnNlcnZlcn0gb2JzZXJ2ZXIgdGhlIHJlc3BvbnNlIG9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmx1c2ggYHRydWVgIGlmIGZsdXNoIHNob3VsZCBoYXBwZW4gYWZ0ZXIgdGhlIG1lc3NhZ2UgaXMgd3JpdHRlbiB0byB0aGUgYnVmZmVyLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGUobWVzc2FnZSwgb2JzZXJ2ZXIsIGZsdXNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgUkVTRVQtbWVzc2FnZSB0byB0aGUgZGF0YWJhc2UuIE1lc3NhZ2UgaXMgaW1tZWRpYXRlbHkgZmx1c2hlZCB0byB0aGUgbmV0d29yay5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSBwcm9taXNlIHJlc29sdmVkIHdoZW4gU1VDQ0VTUy1tZXNzYWdlIHJlc3BvbnNlIGFycml2ZXMsIG9yIGZhaWxlZCB3aGVuIG90aGVyIHJlc3BvbnNlIG1lc3NhZ2VzIGFycml2ZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNldEFuZEZsdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0QW5kRmx1c2goKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIGNsb3NlIG9uIHRoZSBjaGFubmVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSAtIEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zZWQuXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3JcbiAgICAgKiBAcGFyYW0gYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIHtOZW80akVycm9yfCp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVBbmRUcmFuc2Zvcm1FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVBbmRUcmFuc2Zvcm1FcnJvcihlcnJvciwgYWRkcmVzcykge1xuICAgICAgaWYgKHRoaXMuX2Vycm9ySGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3JIYW5kbGVyLmhhbmRsZUFuZFRyYW5zZm9ybUVycm9yKGVycm9yLCBhZGRyZXNzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0YWJhc2VJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRyZXNzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U2VydmVyVmVyc2lvbn0gdGhlIHZlcnNpb24gb2YgdGhlIHNlcnZlciB0aGlzIGNvbm5lY3Rpb24gaXMgY29ubmVjdGVkIHRvXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2ZXJzaW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcnZlclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbm5lY3Rpb247XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ29ubmVjdGlvbjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9jb25uZWN0aW9uSG9sZGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb25uZWN0aW9uLWhvbGRlclwiKSk7XG5cbnZhciBfZHJpdmVyID0gcmVxdWlyZShcIi4uL2RyaXZlclwiKTtcblxudmFyIF9zdHJlYW1PYnNlcnZlcnMgPSByZXF1aXJlKFwiLi9zdHJlYW0tb2JzZXJ2ZXJzXCIpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBWZXJpZmllcyBjb25uZWN0aXZpdHkgdXNpbmcgdGhlIGdpdmVuIGNvbm5lY3Rpb24gcHJvdmlkZXIuXG4gKi9cbnZhciBDb25uZWN0aXZpdHlWZXJpZmllciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtDb25uZWN0aW9uUHJvdmlkZXJ9IGNvbm5lY3Rpb25Qcm92aWRlciB0aGUgcHJvdmlkZXIgdG8gb2J0YWluIGNvbm5lY3Rpb25zIGZyb20uXG4gICAqL1xuICBmdW5jdGlvbiBDb25uZWN0aXZpdHlWZXJpZmllcihjb25uZWN0aW9uUHJvdmlkZXIpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIENvbm5lY3Rpdml0eVZlcmlmaWVyKTtcbiAgICB0aGlzLl9jb25uZWN0aW9uUHJvdmlkZXIgPSBjb25uZWN0aW9uUHJvdmlkZXI7XG4gIH1cbiAgLyoqXG4gICAqIFRyeSB0byBvYnRhaW4gYSB3b3JraW5nIGNvbm5lY3Rpb24gZnJvbSB0aGUgY29ubmVjdGlvbiBwcm92aWRlci5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gcHJvbWlzZSByZXNvbHZlZCB3aXRoIHNlcnZlciBpbmZvIG9yIHJlamVjdGVkIHdpdGggZXJyb3IuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShDb25uZWN0aXZpdHlWZXJpZmllciwgW3tcbiAgICBrZXk6IFwidmVyaWZ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZlcmlmeSgpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBfcmVmJGRhdGFiYXNlID0gX3JlZi5kYXRhYmFzZSxcbiAgICAgICAgICBkYXRhYmFzZSA9IF9yZWYkZGF0YWJhc2UgPT09IHZvaWQgMCA/ICcnIDogX3JlZiRkYXRhYmFzZTtcblxuICAgICAgcmV0dXJuIGFjcXVpcmVBbmRSZWxlYXNlRHVtbXlDb25uZWN0aW9uKHRoaXMuX2Nvbm5lY3Rpb25Qcm92aWRlciwgZGF0YWJhc2UpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29ubmVjdGl2aXR5VmVyaWZpZXI7XG59KCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb25Qcm92aWRlcn0gY29ubmVjdGlvblByb3ZpZGVyIHRoZSBwcm92aWRlciB0byBvYnRhaW4gY29ubmVjdGlvbnMgZnJvbS5cbiAqIEByZXR1cm4ge1Byb21pc2U8b2JqZWN0Pn0gcHJvbWlzZSByZXNvbHZlZCB3aXRoIHNlcnZlciBpbmZvIG9yIHJlamVjdGVkIHdpdGggZXJyb3IuXG4gKi9cblxuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENvbm5lY3Rpdml0eVZlcmlmaWVyO1xuXG5mdW5jdGlvbiBhY3F1aXJlQW5kUmVsZWFzZUR1bW15Q29ubmVjdGlvbihjb25uZWN0aW9uUHJvdmlkZXIsIGRhdGFiYXNlKSB7XG4gIHZhciBjb25uZWN0aW9uSG9sZGVyID0gbmV3IF9jb25uZWN0aW9uSG9sZGVyW1wiZGVmYXVsdFwiXSh7XG4gICAgbW9kZTogX2RyaXZlci5SRUFELFxuICAgIGRhdGFiYXNlOiBkYXRhYmFzZSxcbiAgICBjb25uZWN0aW9uUHJvdmlkZXI6IGNvbm5lY3Rpb25Qcm92aWRlclxuICB9KTtcbiAgY29ubmVjdGlvbkhvbGRlci5pbml0aWFsaXplQ29ubmVjdGlvbigpO1xuICByZXR1cm4gY29ubmVjdGlvbkhvbGRlci5nZXRDb25uZWN0aW9uKCkudGhlbihmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgIC8vIGFibGUgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvblxuICAgIHJldHVybiBjb25uZWN0aW9uSG9sZGVyLmNsb3NlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY29ubmVjdGlvbi5zZXJ2ZXI7XG4gICAgfSk7XG4gIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgLy8gZmFpbGVkIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb25cbiAgICByZXR1cm4gY29ubmVjdGlvbkhvbGRlci5jbG9zZSgpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGlnbm9yZWRFcnJvcikgey8vIGlnbm9yZSBjb25uZWN0aW9uIHJlbGVhc2UgZXJyb3JcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfSk7XG4gIH0pO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5CT0xUX1BST1RPQ09MX1Y0XzEgPSBleHBvcnRzLkJPTFRfUFJPVE9DT0xfVjRfMCA9IGV4cG9ydHMuQk9MVF9QUk9UT0NPTF9WMyA9IGV4cG9ydHMuQk9MVF9QUk9UT0NPTF9WMiA9IGV4cG9ydHMuQk9MVF9QUk9UT0NPTF9WMSA9IGV4cG9ydHMuQUNDRVNTX01PREVfV1JJVEUgPSBleHBvcnRzLkFDQ0VTU19NT0RFX1JFQUQgPSB2b2lkIDA7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEFDQ0VTU19NT0RFX1JFQUQgPSAnUkVBRCc7XG5leHBvcnRzLkFDQ0VTU19NT0RFX1JFQUQgPSBBQ0NFU1NfTU9ERV9SRUFEO1xudmFyIEFDQ0VTU19NT0RFX1dSSVRFID0gJ1dSSVRFJztcbmV4cG9ydHMuQUNDRVNTX01PREVfV1JJVEUgPSBBQ0NFU1NfTU9ERV9XUklURTtcbnZhciBCT0xUX1BST1RPQ09MX1YxID0gMTtcbmV4cG9ydHMuQk9MVF9QUk9UT0NPTF9WMSA9IEJPTFRfUFJPVE9DT0xfVjE7XG52YXIgQk9MVF9QUk9UT0NPTF9WMiA9IDI7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjIgPSBCT0xUX1BST1RPQ09MX1YyO1xudmFyIEJPTFRfUFJPVE9DT0xfVjMgPSAzO1xuZXhwb3J0cy5CT0xUX1BST1RPQ09MX1YzID0gQk9MVF9QUk9UT0NPTF9WMztcbnZhciBCT0xUX1BST1RPQ09MX1Y0XzAgPSA0LjA7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjRfMCA9IEJPTFRfUFJPVE9DT0xfVjRfMDtcbnZhciBCT0xUX1BST1RPQ09MX1Y0XzEgPSA0LjE7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjRfMSA9IEJPTFRfUFJPVE9DT0xfVjRfMTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfcm91bmRSb2JpbkFycmF5SW5kZXggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JvdW5kLXJvYmluLWFycmF5LWluZGV4XCIpKTtcblxudmFyIF9sb2FkQmFsYW5jaW5nU3RyYXRlZ3kgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jaW5nLXN0cmF0ZWd5XCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIExlYXN0Q29ubmVjdGVkTG9hZEJhbGFuY2luZ1N0cmF0ZWd5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTG9hZEJhbGFuY2luZ1N0cmF0ZWcpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShMZWFzdENvbm5lY3RlZExvYWRCYWxhbmNpbmdTdHJhdGVneSwgX0xvYWRCYWxhbmNpbmdTdHJhdGVnKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKExlYXN0Q29ubmVjdGVkTG9hZEJhbGFuY2luZ1N0cmF0ZWd5KTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7UG9vbH0gY29ubmVjdGlvblBvb2wgdGhlIGNvbm5lY3Rpb24gcG9vbCBvZiB0aGlzIGRyaXZlci5cbiAgICovXG4gIGZ1bmN0aW9uIExlYXN0Q29ubmVjdGVkTG9hZEJhbGFuY2luZ1N0cmF0ZWd5KGNvbm5lY3Rpb25Qb29sKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBMZWFzdENvbm5lY3RlZExvYWRCYWxhbmNpbmdTdHJhdGVneSk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5fcmVhZGVyc0luZGV4ID0gbmV3IF9yb3VuZFJvYmluQXJyYXlJbmRleFtcImRlZmF1bHRcIl0oKTtcbiAgICBfdGhpcy5fd3JpdGVyc0luZGV4ID0gbmV3IF9yb3VuZFJvYmluQXJyYXlJbmRleFtcImRlZmF1bHRcIl0oKTtcbiAgICBfdGhpcy5fY29ubmVjdGlvblBvb2wgPSBjb25uZWN0aW9uUG9vbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShMZWFzdENvbm5lY3RlZExvYWRCYWxhbmNpbmdTdHJhdGVneSwgW3tcbiAgICBrZXk6IFwic2VsZWN0UmVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdFJlYWRlcihrbm93blJlYWRlcnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Qoa25vd25SZWFkZXJzLCB0aGlzLl9yZWFkZXJzSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0V3JpdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdFdyaXRlcihrbm93bldyaXRlcnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Qoa25vd25Xcml0ZXJzLCB0aGlzLl93cml0ZXJzSW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2VsZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZWxlY3QoYWRkcmVzc2VzLCByb3VuZFJvYmluSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhZGRyZXNzZXMubGVuZ3RoO1xuXG4gICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyBjaG9vc2Ugc3RhcnQgaW5kZXggZm9yIGl0ZXJhdGlvbiBpbiByb3VuZC1yb2JpbiBmYXNoaW9uXG5cblxuICAgICAgdmFyIHN0YXJ0SW5kZXggPSByb3VuZFJvYmluSW5kZXgubmV4dChsZW5ndGgpO1xuICAgICAgdmFyIGluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgIHZhciBsZWFzdENvbm5lY3RlZEFkZHJlc3MgPSBudWxsO1xuICAgICAgdmFyIGxlYXN0QWN0aXZlQ29ubmVjdGlvbnMgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjsgLy8gaXRlcmF0ZSBvdmVyIHRoZSBhcnJheSB0byBmaW5kIGxlYXN0IGNvbm5lY3RlZCBhZGRyZXNzXG5cbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIGFkZHJlc3MgPSBhZGRyZXNzZXNbaW5kZXhdO1xuXG4gICAgICAgIHZhciBhY3RpdmVDb25uZWN0aW9ucyA9IHRoaXMuX2Nvbm5lY3Rpb25Qb29sLmFjdGl2ZVJlc291cmNlQ291bnQoYWRkcmVzcyk7XG5cbiAgICAgICAgaWYgKGFjdGl2ZUNvbm5lY3Rpb25zIDwgbGVhc3RBY3RpdmVDb25uZWN0aW9ucykge1xuICAgICAgICAgIGxlYXN0Q29ubmVjdGVkQWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgICAgbGVhc3RBY3RpdmVDb25uZWN0aW9ucyA9IGFjdGl2ZUNvbm5lY3Rpb25zO1xuICAgICAgICB9IC8vIGxvb3Agb3ZlciB0byB0aGUgc3RhcnQgb2YgdGhlIGFycmF5IHdoZW4gZW5kIGlzIHJlYWNoZWRcblxuXG4gICAgICAgIGlmIChpbmRleCA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChpbmRleCAhPT0gc3RhcnRJbmRleCk7XG5cbiAgICAgIHJldHVybiBsZWFzdENvbm5lY3RlZEFkZHJlc3M7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMZWFzdENvbm5lY3RlZExvYWRCYWxhbmNpbmdTdHJhdGVneTtcbn0oX2xvYWRCYWxhbmNpbmdTdHJhdGVneVtcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IExlYXN0Q29ubmVjdGVkTG9hZEJhbGFuY2luZ1N0cmF0ZWd5OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBBIGZhY2lsaXR5IHRvIHNlbGVjdCBtb3N0IGFwcHJvcHJpYXRlIHJlYWRlciBvciB3cml0ZXIgYW1vbmcgdGhlIGdpdmVuIGFkZHJlc3NlcyBmb3IgcmVxdWVzdCBwcm9jZXNzaW5nLlxuICovXG52YXIgTG9hZEJhbGFuY2luZ1N0cmF0ZWd5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTG9hZEJhbGFuY2luZ1N0cmF0ZWd5KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgTG9hZEJhbGFuY2luZ1N0cmF0ZWd5KTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoTG9hZEJhbGFuY2luZ1N0cmF0ZWd5LCBbe1xuICAgIGtleTogXCJzZWxlY3RSZWFkZXJcIixcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBuZXh0IG1vc3QgYXBwcm9wcmlhdGUgcmVhZGVyIGZyb20gdGhlIGxpc3Qgb2YgZ2l2ZW4gcmVhZGVycy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBrbm93blJlYWRlcnMgYW4gYXJyYXkgb2YgY3VycmVudGx5IGtub3duIHJlYWRlcnMgdG8gc2VsZWN0IGZyb20uXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBtb3N0IGFwcHJvcHJpYXRlIHJlYWRlciBvciBgbnVsbGAgaWYgZ2l2ZW4gYXJyYXkgaXMgZW1wdHkuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdFJlYWRlcihrbm93blJlYWRlcnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWJzdHJhY3QgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0IG5leHQgbW9zdCBhcHByb3ByaWF0ZSB3cml0ZXIgZnJvbSB0aGUgbGlzdCBvZiBnaXZlbiB3cml0ZXJzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGtub3duV3JpdGVycyBhbiBhcnJheSBvZiBjdXJyZW50bHkga25vd24gd3JpdGVycyB0byBzZWxlY3QgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IG1vc3QgYXBwcm9wcmlhdGUgd3JpdGVyIG9yIGBudWxsYCBpZiBnaXZlbiBhcnJheSBpcyBlbXB0eS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdFdyaXRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RXcml0ZXIoa25vd25Xcml0ZXJzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fic3RyYWN0IGZ1bmN0aW9uJyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMb2FkQmFsYW5jaW5nU3RyYXRlZ3k7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gTG9hZEJhbGFuY2luZ1N0cmF0ZWd5OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuLi9lcnJvclwiKTtcblxudmFyIF9sZXZlbHM7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yW1wiZGVmYXVsdFwiXSkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBFUlJPUiA9ICdlcnJvcic7XG52YXIgV0FSTiA9ICd3YXJuJztcbnZhciBJTkZPID0gJ2luZm8nO1xudmFyIERFQlVHID0gJ2RlYnVnJztcbnZhciBERUZBVUxUX0xFVkVMID0gSU5GTztcbnZhciBsZXZlbHMgPSAoX2xldmVscyA9IHt9LCAoMCwgX2RlZmluZVByb3BlcnR5MltcImRlZmF1bHRcIl0pKF9sZXZlbHMsIEVSUk9SLCAwKSwgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKShfbGV2ZWxzLCBXQVJOLCAxKSwgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKShfbGV2ZWxzLCBJTkZPLCAyKSwgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKShfbGV2ZWxzLCBERUJVRywgMyksIF9sZXZlbHMpO1xuLyoqXG4gKiBMb2dnZXIgdXNlZCBieSB0aGUgZHJpdmVyIHRvIG5vdGlmeSBhYm91dCB2YXJpb3VzIGludGVybmFsIGV2ZW50cy4gU2luZ2xlIGxvZ2dlciBzaG91bGQgYmUgdXNlZCBwZXIgZHJpdmVyLlxuICovXG5cbnZhciBMb2dnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZXZlbCB0aGUgZW5hYmxlZCBsb2dnaW5nIGxldmVsLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGxldmVsOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZyl9IGxvZ2dlckZ1bmN0aW9uIHRoZSBmdW5jdGlvbiB0byB3cml0ZSB0aGUgbG9nIGxldmVsIGFuZCBtZXNzYWdlLlxuICAgKi9cbiAgZnVuY3Rpb24gTG9nZ2VyKGxldmVsLCBsb2dnZXJGdW5jdGlvbikge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgTG9nZ2VyKTtcbiAgICB0aGlzLl9sZXZlbCA9IGxldmVsO1xuICAgIHRoaXMuX2xvZ2dlckZ1bmN0aW9uID0gbG9nZ2VyRnVuY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBsb2dnZXIgYmFzZWQgb24gdGhlIGdpdmVuIGRyaXZlciBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZHJpdmVyQ29uZmlnIHRoZSBkcml2ZXIgY29uZmlndXJhdGlvbiBhcyBzdXBwbGllZCBieSB0aGUgdXNlci5cbiAgICogQHJldHVybiB7TG9nZ2VyfSBhIG5ldyBsb2dnZXIgaW5zdGFuY2Ugb3IgYSBuby1vcCBsb2dnZXIgd2hlbiBub3QgY29uZmlndXJlZC5cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKExvZ2dlciwgW3tcbiAgICBrZXk6IFwiaXNFcnJvckVuYWJsZWRcIixcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGVycm9yIGxvZ2dpbmcgaXMgZW5hYmxlZCwgaS5lLiBpdCBpcyBub3QgYSBuby1vcCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgd2hlbiBlbmFibGVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFcnJvckVuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gaXNMZXZlbEVuYWJsZWQodGhpcy5fbGV2ZWwsIEVSUk9SKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nIGFuIGVycm9yIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gbG9nLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICAgICAgaWYgKHRoaXMuaXNFcnJvckVuYWJsZWQoKSkge1xuICAgICAgICB0aGlzLl9sb2dnZXJGdW5jdGlvbihFUlJPUiwgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHdhcm4gbG9nZ2luZyBpcyBlbmFibGVkLCBpLmUuIGl0IGlzIG5vdCBhIG5vLW9wIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCB3aGVuIGVuYWJsZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNXYXJuRW5hYmxlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1dhcm5FbmFibGVkKCkge1xuICAgICAgcmV0dXJuIGlzTGV2ZWxFbmFibGVkKHRoaXMuX2xldmVsLCBXQVJOKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nIGFuIHdhcm5pbmcgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBsb2cuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3YXJuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdhcm4obWVzc2FnZSkge1xuICAgICAgaWYgKHRoaXMuaXNXYXJuRW5hYmxlZCgpKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlckZ1bmN0aW9uKFdBUk4sIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBpbmZvIGxvZ2dpbmcgaXMgZW5hYmxlZCwgaS5lLiBpdCBpcyBub3QgYSBuby1vcCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgd2hlbiBlbmFibGVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzSW5mb0VuYWJsZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbmZvRW5hYmxlZCgpIHtcbiAgICAgIHJldHVybiBpc0xldmVsRW5hYmxlZCh0aGlzLl9sZXZlbCwgSU5GTyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBhbiBpbmZvIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gbG9nLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5mb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZvKG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0aGlzLmlzSW5mb0VuYWJsZWQoKSkge1xuICAgICAgICB0aGlzLl9sb2dnZXJGdW5jdGlvbihJTkZPLCBtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgZGVidWcgbG9nZ2luZyBpcyBlbmFibGVkLCBpLmUuIGl0IGlzIG5vdCBhIG5vLW9wIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCB3aGVuIGVuYWJsZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNEZWJ1Z0VuYWJsZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNEZWJ1Z0VuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gaXNMZXZlbEVuYWJsZWQodGhpcy5fbGV2ZWwsIERFQlVHKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nIGEgZGVidWcgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBsb2cuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWJ1Z1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWJ1ZyhtZXNzYWdlKSB7XG4gICAgICBpZiAodGhpcy5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlckZ1bmN0aW9uKERFQlVHLCBtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKGRyaXZlckNvbmZpZykge1xuICAgICAgaWYgKGRyaXZlckNvbmZpZyAmJiBkcml2ZXJDb25maWcubG9nZ2luZykge1xuICAgICAgICB2YXIgbG9nZ2luZ0NvbmZpZyA9IGRyaXZlckNvbmZpZy5sb2dnaW5nO1xuICAgICAgICB2YXIgbGV2ZWwgPSBleHRyYWN0Q29uZmlndXJlZExldmVsKGxvZ2dpbmdDb25maWcpO1xuICAgICAgICB2YXIgbG9nZ2VyRnVuY3Rpb24gPSBleHRyYWN0Q29uZmlndXJlZExvZ2dlcihsb2dnaW5nQ29uZmlnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2dnZXIobGV2ZWwsIGxvZ2dlckZ1bmN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubm9PcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuby1vcCBsb2dnZXIgaW1wbGVtZW50YXRpb24uXG4gICAgICogQHJldHVybiB7TG9nZ2VyfSB0aGUgbm8tb3AgbG9nZ2VyIGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibm9PcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub09wKCkge1xuICAgICAgcmV0dXJuIG5vT3BMb2dnZXI7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMb2dnZXI7XG59KCk7XG5cbnZhciBOb09wTG9nZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTG9nZ2VyKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoTm9PcExvZ2dlciwgX0xvZ2dlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihOb09wTG9nZ2VyKTtcblxuICBmdW5jdGlvbiBOb09wTG9nZ2VyKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgTm9PcExvZ2dlcik7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShOb09wTG9nZ2VyLCBbe1xuICAgIGtleTogXCJpc0Vycm9yRW5hYmxlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Vycm9yRW5hYmxlZCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge31cbiAgfSwge1xuICAgIGtleTogXCJpc1dhcm5FbmFibGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzV2FybkVuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndhcm5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7fVxuICB9LCB7XG4gICAga2V5OiBcImlzSW5mb0VuYWJsZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbmZvRW5hYmxlZCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5mb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZvKG1lc3NhZ2UpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNEZWJ1Z0VuYWJsZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNEZWJ1Z0VuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlYnVnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlYnVnKG1lc3NhZ2UpIHt9XG4gIH1dKTtcbiAgcmV0dXJuIE5vT3BMb2dnZXI7XG59KExvZ2dlcik7XG5cbnZhciBub09wTG9nZ2VyID0gbmV3IE5vT3BMb2dnZXIoKTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGxvZ2dpbmcgbGV2ZWwgaXMgZW5hYmxlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWd1cmVkTGV2ZWwgdGhlIGNvbmZpZ3VyZWQgbGV2ZWwuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0TGV2ZWwgdGhlIGxldmVsIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdmFsdWUgb2YgYHRydWVgIHdoZW4gZW5hYmxlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNMZXZlbEVuYWJsZWQoY29uZmlndXJlZExldmVsLCB0YXJnZXRMZXZlbCkge1xuICByZXR1cm4gbGV2ZWxzW2NvbmZpZ3VyZWRMZXZlbF0gPj0gbGV2ZWxzW3RhcmdldExldmVsXTtcbn1cbi8qKlxuICogRXh0cmFjdCB0aGUgY29uZmlndXJlZCBsb2dnaW5nIGxldmVsIGZyb20gdGhlIGRyaXZlcidzIGxvZ2dpbmcgY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2dnaW5nQ29uZmlnIHRoZSBsb2dnaW5nIGNvbmZpZ3VyYXRpb24uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBjb25maWd1cmVkIGxvZyBsZXZlbCBvciBkZWZhdWx0IHdoZW4gbm9uZSBjb25maWd1cmVkLlxuICovXG5cblxuZnVuY3Rpb24gZXh0cmFjdENvbmZpZ3VyZWRMZXZlbChsb2dnaW5nQ29uZmlnKSB7XG4gIGlmIChsb2dnaW5nQ29uZmlnICYmIGxvZ2dpbmdDb25maWcubGV2ZWwpIHtcbiAgICB2YXIgY29uZmlndXJlZExldmVsID0gbG9nZ2luZ0NvbmZpZy5sZXZlbDtcbiAgICB2YXIgdmFsdWUgPSBsZXZlbHNbY29uZmlndXJlZExldmVsXTtcblxuICAgIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcbiAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKFwiSWxsZWdhbCBsb2dnaW5nIGxldmVsOiBcIi5jb25jYXQoY29uZmlndXJlZExldmVsLCBcIi4gU3VwcG9ydGVkIGxldmVscyBhcmU6IFwiKS5jb25jYXQoT2JqZWN0LmtleXMobGV2ZWxzKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBjb25maWd1cmVkTGV2ZWw7XG4gIH1cblxuICByZXR1cm4gREVGQVVMVF9MRVZFTDtcbn1cbi8qKlxuICogRXh0cmFjdCB0aGUgY29uZmlndXJlZCBsb2dnZXIgZnVuY3Rpb24gZnJvbSB0aGUgZHJpdmVyJ3MgbG9nZ2luZyBjb25maWd1cmF0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IGxvZ2dpbmdDb25maWcgdGhlIGxvZ2dpbmcgY29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGxldmVsOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZyl9IHRoZSBjb25maWd1cmVkIGxvZ2dpbmcgZnVuY3Rpb24uXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0Q29uZmlndXJlZExvZ2dlcihsb2dnaW5nQ29uZmlnKSB7XG4gIGlmIChsb2dnaW5nQ29uZmlnICYmIGxvZ2dpbmdDb25maWcubG9nZ2VyKSB7XG4gICAgdmFyIGNvbmZpZ3VyZWRMb2dnZXIgPSBsb2dnaW5nQ29uZmlnLmxvZ2dlcjtcblxuICAgIGlmIChjb25maWd1cmVkTG9nZ2VyICYmIHR5cGVvZiBjb25maWd1cmVkTG9nZ2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJlZExvZ2dlcjtcbiAgICB9XG4gIH1cblxuICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKShcIklsbGVnYWwgbG9nZ2VyIGZ1bmN0aW9uOiBcIi5jb25jYXQobG9nZ2luZ0NvbmZpZy5sb2dnZXIpKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gTG9nZ2VyO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZFwiKTtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlN0cnVjdHVyZSA9IGV4cG9ydHMuVW5wYWNrZXIgPSBleHBvcnRzLlBhY2tlciA9IHZvaWQgMDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX25vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuXG52YXIgX2ludGVnZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi4vaW50ZWdlclwiKSk7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG5cbnZhciBfZ3JhcGhUeXBlcyA9IHJlcXVpcmUoXCIuLi9ncmFwaC10eXBlc1wiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgVElOWV9TVFJJTkcgPSAweDgwO1xudmFyIFRJTllfTElTVCA9IDB4OTA7XG52YXIgVElOWV9NQVAgPSAweGEwO1xudmFyIFRJTllfU1RSVUNUID0gMHhiMDtcbnZhciBOVUxMID0gMHhjMDtcbnZhciBGTE9BVF82NCA9IDB4YzE7XG52YXIgRkFMU0UgPSAweGMyO1xudmFyIFRSVUUgPSAweGMzO1xudmFyIElOVF84ID0gMHhjODtcbnZhciBJTlRfMTYgPSAweGM5O1xudmFyIElOVF8zMiA9IDB4Y2E7XG52YXIgSU5UXzY0ID0gMHhjYjtcbnZhciBTVFJJTkdfOCA9IDB4ZDA7XG52YXIgU1RSSU5HXzE2ID0gMHhkMTtcbnZhciBTVFJJTkdfMzIgPSAweGQyO1xudmFyIExJU1RfOCA9IDB4ZDQ7XG52YXIgTElTVF8xNiA9IDB4ZDU7XG52YXIgTElTVF8zMiA9IDB4ZDY7XG52YXIgQllURVNfOCA9IDB4Y2M7XG52YXIgQllURVNfMTYgPSAweGNkO1xudmFyIEJZVEVTXzMyID0gMHhjZTtcbnZhciBNQVBfOCA9IDB4ZDg7XG52YXIgTUFQXzE2ID0gMHhkOTtcbnZhciBNQVBfMzIgPSAweGRhO1xudmFyIFNUUlVDVF84ID0gMHhkYztcbnZhciBTVFJVQ1RfMTYgPSAweGRkO1xudmFyIE5PREUgPSAweDRlO1xudmFyIE5PREVfU1RSVUNUX1NJWkUgPSAzO1xudmFyIFJFTEFUSU9OU0hJUCA9IDB4NTI7XG52YXIgUkVMQVRJT05TSElQX1NUUlVDVF9TSVpFID0gNTtcbnZhciBVTkJPVU5EX1JFTEFUSU9OU0hJUCA9IDB4NzI7XG52YXIgVU5CT1VORF9SRUxBVElPTlNISVBfU1RSVUNUX1NJWkUgPSAzO1xudmFyIFBBVEggPSAweDUwO1xudmFyIFBBVEhfU1RSVUNUX1NJWkUgPSAzO1xuLyoqXG4gKiBBIFN0cnVjdHVyZSBoYXZlIGEgc2lnbmF0dXJlIGFuZCBmaWVsZHMuXG4gKiBAYWNjZXNzIHByaXZhdGVcbiAqL1xuXG52YXIgU3RydWN0dXJlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBuZXcgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFN0cnVjdHVyZShzaWduYXR1cmUsIGZpZWxkcykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgU3RydWN0dXJlKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoU3RydWN0dXJlLCBbe1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBmaWVsZFN0ciA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGZpZWxkU3RyICs9ICcsICc7XG4gICAgICAgIH1cblxuICAgICAgICBmaWVsZFN0ciArPSB0aGlzLmZpZWxkc1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdTdHJ1Y3R1cmUoJyArIHRoaXMuc2lnbmF0dXJlICsgJywgWycgKyBmaWVsZFN0ciArICddKSc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTdHJ1Y3R1cmU7XG59KCk7XG4vKipcbiAqIENsYXNzIHRvIHBhY2tcbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICovXG5cblxuZXhwb3J0cy5TdHJ1Y3R1cmUgPSBTdHJ1Y3R1cmU7XG5cbnZhciBQYWNrZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Q2h1bmtlcn0gY2hhbm5lbCB0aGUgY2h1bmtlciBiYWNrZWQgYnkgYSBuZXR3b3JrIGNoYW5uZWwuXG4gICAqL1xuICBmdW5jdGlvbiBQYWNrZXIoY2hhbm5lbCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUGFja2VyKTtcbiAgICB0aGlzLl9jaCA9IGNoYW5uZWw7XG4gICAgdGhpcy5fYnl0ZUFycmF5c1N1cHBvcnRlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBwYWNrYWJsZSBmdW5jdGlvbiBvdXQgb2YgdGhlIHByb3ZpZGVkIHZhbHVlXG4gICAqIEBwYXJhbSB4IHRoZSB2YWx1ZSB0byBwYWNrXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShQYWNrZXIsIFt7XG4gICAga2V5OiBcInBhY2thYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhY2thYmxlKHgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh4ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9jaC53cml0ZVVJbnQ4KE5VTEwpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh4ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9jaC53cml0ZVVJbnQ4KFRSVUUpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh4ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fY2gud3JpdGVVSW50OChGQUxTRSk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5wYWNrRmxvYXQoeCk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5wYWNrU3RyaW5nKHgpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICgoMCwgX2ludGVnZXIuaXNJbnQpKHgpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnBhY2tJbnRlZ2VyKHgpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh4IGluc3RhbmNlb2YgSW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnBhY2tCeXRlcyh4KTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMucGFja0xpc3RIZWFkZXIoeC5sZW5ndGgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHgubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBfdGhpcy5wYWNrYWJsZSh4W19pXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHhbX2ldKSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoaXNJdGVyYWJsZSh4KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWNrYWJsZUl0ZXJhYmxlKHgpO1xuICAgICAgfSBlbHNlIGlmICh4IGluc3RhbmNlb2YgX2dyYXBoVHlwZXMuTm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9uUGFja2FibGVWYWx1ZShcIkl0IGlzIG5vdCBhbGxvd2VkIHRvIHBhc3Mgbm9kZXMgaW4gcXVlcnkgcGFyYW1ldGVycywgZ2l2ZW46IFwiLmNvbmNhdCh4KSk7XG4gICAgICB9IGVsc2UgaWYgKHggaW5zdGFuY2VvZiBfZ3JhcGhUeXBlcy5SZWxhdGlvbnNoaXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vblBhY2thYmxlVmFsdWUoXCJJdCBpcyBub3QgYWxsb3dlZCB0byBwYXNzIHJlbGF0aW9uc2hpcHMgaW4gcXVlcnkgcGFyYW1ldGVycywgZ2l2ZW46IFwiLmNvbmNhdCh4KSk7XG4gICAgICB9IGVsc2UgaWYgKHggaW5zdGFuY2VvZiBfZ3JhcGhUeXBlcy5QYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub25QYWNrYWJsZVZhbHVlKFwiSXQgaXMgbm90IGFsbG93ZWQgdG8gcGFzcyBwYXRocyBpbiBxdWVyeSBwYXJhbWV0ZXJzLCBnaXZlbjogXCIuY29uY2F0KHgpKTtcbiAgICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIFN0cnVjdHVyZSkge1xuICAgICAgICB2YXIgcGFja2FibGVGaWVsZHMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHguZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcGFja2FibGVGaWVsZHNbaV0gPSB0aGlzLnBhY2thYmxlKHguZmllbGRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnBhY2tTdHJ1Y3QoeC5zaWduYXR1cmUsIHBhY2thYmxlRmllbGRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF90eXBlb2YyW1wiZGVmYXVsdFwiXSkoeCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh4KTtcbiAgICAgICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwga2V5cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICBpZiAoeFtrZXlzW19pMl1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5wYWNrTWFwSGVhZGVyKGNvdW50KTtcblxuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGtleXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbX2kzXTtcblxuICAgICAgICAgICAgaWYgKHhba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIF90aGlzLnBhY2tTdHJpbmcoa2V5KTtcblxuICAgICAgICAgICAgICBfdGhpcy5wYWNrYWJsZSh4W2tleV0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vblBhY2thYmxlVmFsdWUoXCJVbmFibGUgdG8gcGFjayB0aGUgZ2l2ZW4gdmFsdWU6IFwiLmNvbmNhdCh4KSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhY2thYmxlSXRlcmFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFja2FibGVJdGVyYWJsZShpdGVyYWJsZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGFycmF5ID0gQXJyYXkuZnJvbShpdGVyYWJsZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhY2thYmxlKGFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaGFuZGxlIGVycm9ycyBmcm9tIGl0ZXJhYmxlIHRvIGFycmF5IGNvbnZlcnNpb25cbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoXCJDYW5ub3QgcGFjayBnaXZlbiBpdGVyYWJsZSwgXCIuY29uY2F0KGUubWVzc2FnZSwgXCI6IFwiKS5jb25jYXQoaXRlcmFibGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFja3MgYSBzdHJ1Y3RcbiAgICAgKiBAcGFyYW0gc2lnbmF0dXJlIHRoZSBzaWduYXR1cmUgb2YgdGhlIHN0cnVjdFxuICAgICAqIEBwYXJhbSBwYWNrYWJsZUZpZWxkcyB0aGUgZmllbGRzIG9mIHRoZSBzdHJ1Y3QsIG1ha2Ugc3VyZSB5b3UgY2FsbCBgcGFja2FibGUgb24gYWxsIGZpZWxkc2BcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhY2tTdHJ1Y3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFja1N0cnVjdChzaWduYXR1cmUsIHBhY2thYmxlRmllbGRzKSB7XG4gICAgICBwYWNrYWJsZUZpZWxkcyA9IHBhY2thYmxlRmllbGRzIHx8IFtdO1xuICAgICAgdGhpcy5wYWNrU3RydWN0SGVhZGVyKHBhY2thYmxlRmllbGRzLmxlbmd0aCwgc2lnbmF0dXJlKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWNrYWJsZUZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYWNrYWJsZUZpZWxkc1tpXSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWNrSW50ZWdlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWNrSW50ZWdlcih4KSB7XG4gICAgICB2YXIgaGlnaCA9IHguaGlnaDtcbiAgICAgIHZhciBsb3cgPSB4LmxvdztcblxuICAgICAgaWYgKHguZ3JlYXRlclRoYW5PckVxdWFsKC0weDEwKSAmJiB4Lmxlc3NUaGFuKDB4ODApKSB7XG4gICAgICAgIHRoaXMuX2NoLndyaXRlSW50OChsb3cpO1xuICAgICAgfSBlbHNlIGlmICh4LmdyZWF0ZXJUaGFuT3JFcXVhbCgtMHg4MCkgJiYgeC5sZXNzVGhhbigtMHgxMCkpIHtcbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChJTlRfOCk7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVJbnQ4KGxvdyk7XG4gICAgICB9IGVsc2UgaWYgKHguZ3JlYXRlclRoYW5PckVxdWFsKC0weDgwMDApICYmIHgubGVzc1RoYW4oMHg4MDAwKSkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KElOVF8xNik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVJbnQxNihsb3cpO1xuICAgICAgfSBlbHNlIGlmICh4LmdyZWF0ZXJUaGFuT3JFcXVhbCgtMHg4MDAwMDAwMCkgJiYgeC5sZXNzVGhhbigweDgwMDAwMDAwKSkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KElOVF8zMik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVJbnQzMihsb3cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChJTlRfNjQpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlSW50MzIoaGlnaCk7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVJbnQzMihsb3cpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWNrRmxvYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFja0Zsb2F0KHgpIHtcbiAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoRkxPQVRfNjQpO1xuXG4gICAgICB0aGlzLl9jaC53cml0ZUZsb2F0NjQoeCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhY2tTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFja1N0cmluZyh4KSB7XG4gICAgICB2YXIgYnl0ZXMgPSBfbm9kZS51dGY4LmVuY29kZSh4KTtcblxuICAgICAgdmFyIHNpemUgPSBieXRlcy5sZW5ndGg7XG5cbiAgICAgIGlmIChzaXplIDwgMHgxMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KFRJTllfU1RSSU5HIHwgc2l6ZSk7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVCeXRlcyhieXRlcyk7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KFNUUklOR184KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KHNpemUpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlQnl0ZXMoYnl0ZXMpO1xuICAgICAgfSBlbHNlIGlmIChzaXplIDwgMHgxMDAwMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KFNUUklOR18xNik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChzaXplIC8gMjU2ID4+IDApO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoc2l6ZSAlIDI1Nik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVCeXRlcyhieXRlcyk7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KFNUUklOR18zMik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OCgoc2l6ZSAvIDE2Nzc3MjE2ID4+IDApICUgMjU2KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KChzaXplIC8gNjU1MzYgPj4gMCkgJSAyNTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoKHNpemUgLyAyNTYgPj4gMCkgJSAyNTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoc2l6ZSAlIDI1Nik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVCeXRlcyhieXRlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnVVRGLTggc3RyaW5ncyBvZiBzaXplICcgKyBzaXplICsgJyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWNrTGlzdEhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWNrTGlzdEhlYWRlcihzaXplKSB7XG4gICAgICBpZiAoc2l6ZSA8IDB4MTApIHtcbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChUSU5ZX0xJU1QgfCBzaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDB4MTAwKSB7XG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoTElTVF84KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KHNpemUpO1xuICAgICAgfSBlbHNlIGlmIChzaXplIDwgMHgxMDAwMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KExJU1RfMTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoKHNpemUgLyAyNTYgPj4gMCkgJSAyNTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoc2l6ZSAlIDI1Nik7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KExJU1RfMzIpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoKHNpemUgLyAxNjc3NzIxNiA+PiAwKSAlIDI1Nik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OCgoc2l6ZSAvIDY1NTM2ID4+IDApICUgMjU2KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KChzaXplIC8gMjU2ID4+IDApICUgMjU2KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KHNpemUgJSAyNTYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ0xpc3RzIG9mIHNpemUgJyArIHNpemUgKyAnIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhY2tCeXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWNrQnl0ZXMoYXJyYXkpIHtcbiAgICAgIGlmICh0aGlzLl9ieXRlQXJyYXlzU3VwcG9ydGVkKSB7XG4gICAgICAgIHRoaXMucGFja0J5dGVzSGVhZGVyKGFycmF5Lmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuX2NoLndyaXRlSW50OChhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdCeXRlIGFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgZGF0YWJhc2UgdGhpcyBkcml2ZXIgaXMgY29ubmVjdGVkIHRvJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhY2tCeXRlc0hlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWNrQnl0ZXNIZWFkZXIoc2l6ZSkge1xuICAgICAgaWYgKHNpemUgPCAweDEwMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KEJZVEVTXzgpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwKSB7XG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoQllURVNfMTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoKHNpemUgLyAyNTYgPj4gMCkgJSAyNTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoc2l6ZSAlIDI1Nik7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KEJZVEVTXzMyKTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KChzaXplIC8gMTY3NzcyMTYgPj4gMCkgJSAyNTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoKHNpemUgLyA2NTUzNiA+PiAwKSAlIDI1Nik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OCgoc2l6ZSAvIDI1NiA+PiAwKSAlIDI1Nik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChzaXplICUgMjU2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdCeXRlIGFycmF5cyBvZiBzaXplICcgKyBzaXplICsgJyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWNrTWFwSGVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhY2tNYXBIZWFkZXIoc2l6ZSkge1xuICAgICAgaWYgKHNpemUgPCAweDEwKSB7XG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoVElOWV9NQVAgfCBzaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDB4MTAwKSB7XG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoTUFQXzgpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwKSB7XG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoTUFQXzE2KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KHNpemUgLyAyNTYgPj4gMCk7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChzaXplICUgMjU2KTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoTUFQXzMyKTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KChzaXplIC8gMTY3NzcyMTYgPj4gMCkgJSAyNTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoKHNpemUgLyA2NTUzNiA+PiAwKSAlIDI1Nik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OCgoc2l6ZSAvIDI1NiA+PiAwKSAlIDI1Nik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChzaXplICUgMjU2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdNYXBzIG9mIHNpemUgJyArIHNpemUgKyAnIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhY2tTdHJ1Y3RIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFja1N0cnVjdEhlYWRlcihzaXplLCBzaWduYXR1cmUpIHtcbiAgICAgIGlmIChzaXplIDwgMHgxMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KFRJTllfU1RSVUNUIHwgc2l6ZSk7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChzaWduYXR1cmUpO1xuICAgICAgfSBlbHNlIGlmIChzaXplIDwgMHgxMDApIHtcbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChTVFJVQ1RfOCk7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChzaXplKTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KHNpZ25hdHVyZSk7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwKSB7XG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoU1RSVUNUXzE2KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KHNpemUgLyAyNTYgPj4gMCk7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChzaXplICUgMjU2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdTdHJ1Y3R1cmVzIG9mIHNpemUgJyArIHNpemUgKyAnIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc2FibGVCeXRlQXJyYXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVCeXRlQXJyYXlzKCkge1xuICAgICAgdGhpcy5fYnl0ZUFycmF5c1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbm9uUGFja2FibGVWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbm9uUGFja2FibGVWYWx1ZShtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKShtZXNzYWdlLCBfZXJyb3IuUFJPVE9DT0xfRVJST1IpO1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBhY2tlcjtcbn0oKTtcbi8qKlxuICogQ2xhc3MgdG8gdW5wYWNrXG4gKiBAYWNjZXNzIHByaXZhdGVcbiAqL1xuXG5cbmV4cG9ydHMuUGFja2VyID0gUGFja2VyO1xuXG52YXIgVW5wYWNrZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMgaWYgdGhpcyB1bnBhY2tlciBzaG91bGQgY29udmVydCBhbGwgcmVjZWl2ZWQgaW50ZWdlcnMgdG8gbmF0aXZlIEpTIG51bWJlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBVbnBhY2tlcigpIHtcbiAgICB2YXIgZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgVW5wYWNrZXIpO1xuICAgIHRoaXMuX2Rpc2FibGVMb3NzbGVzc0ludGVnZXJzID0gZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFVucGFja2VyLCBbe1xuICAgIGtleTogXCJ1bnBhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5wYWNrKGJ1ZmZlcikge1xuICAgICAgdmFyIG1hcmtlciA9IGJ1ZmZlci5yZWFkVUludDgoKTtcbiAgICAgIHZhciBtYXJrZXJIaWdoID0gbWFya2VyICYgMHhmMDtcbiAgICAgIHZhciBtYXJrZXJMb3cgPSBtYXJrZXIgJiAweDBmO1xuXG4gICAgICBpZiAobWFya2VyID09PSBOVUxMKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2Jvb2xlYW4gPSB0aGlzLl91bnBhY2tCb29sZWFuKG1hcmtlcik7XG5cbiAgICAgIGlmIChfYm9vbGVhbiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gX2Jvb2xlYW47XG4gICAgICB9XG5cbiAgICAgIHZhciBudW1iZXJPckludGVnZXIgPSB0aGlzLl91bnBhY2tOdW1iZXJPckludGVnZXIobWFya2VyLCBidWZmZXIpO1xuXG4gICAgICBpZiAobnVtYmVyT3JJbnRlZ2VyICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNhYmxlTG9zc2xlc3NJbnRlZ2VycyAmJiAoMCwgX2ludGVnZXIuaXNJbnQpKG51bWJlck9ySW50ZWdlcikpIHtcbiAgICAgICAgICByZXR1cm4gbnVtYmVyT3JJbnRlZ2VyLnRvTnVtYmVyT3JJbmZpbml0eSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bWJlck9ySW50ZWdlcjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0cmluZyA9IHRoaXMuX3VucGFja1N0cmluZyhtYXJrZXIsIG1hcmtlckhpZ2gsIG1hcmtlckxvdywgYnVmZmVyKTtcblxuICAgICAgaWYgKHN0cmluZyAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGlzdCA9IHRoaXMuX3VucGFja0xpc3QobWFya2VyLCBtYXJrZXJIaWdoLCBtYXJrZXJMb3csIGJ1ZmZlcik7XG5cbiAgICAgIGlmIChsaXN0ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgfVxuXG4gICAgICB2YXIgYnl0ZUFycmF5ID0gdGhpcy5fdW5wYWNrQnl0ZUFycmF5KG1hcmtlciwgYnVmZmVyKTtcblxuICAgICAgaWYgKGJ5dGVBcnJheSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYnl0ZUFycmF5O1xuICAgICAgfVxuXG4gICAgICB2YXIgbWFwID0gdGhpcy5fdW5wYWNrTWFwKG1hcmtlciwgbWFya2VySGlnaCwgbWFya2VyTG93LCBidWZmZXIpO1xuXG4gICAgICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHJ1Y3QgPSB0aGlzLl91bnBhY2tTdHJ1Y3QobWFya2VyLCBtYXJrZXJIaWdoLCBtYXJrZXJMb3csIGJ1ZmZlcik7XG5cbiAgICAgIGlmIChzdHJ1Y3QgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ1Vua25vd24gcGFja2VkIHZhbHVlIHdpdGggbWFya2VyICcgKyBtYXJrZXIudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5wYWNrSW50ZWdlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnBhY2tJbnRlZ2VyKGJ1ZmZlcikge1xuICAgICAgdmFyIG1hcmtlciA9IGJ1ZmZlci5yZWFkVUludDgoKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3VucGFja0ludGVnZXIobWFya2VyLCBidWZmZXIpO1xuXG4gICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ1VuYWJsZSB0byB1bnBhY2sgaW50ZWdlciB2YWx1ZSB3aXRoIG1hcmtlciAnICsgbWFya2VyLnRvU3RyaW5nKDE2KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bnBhY2tCb29sZWFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnBhY2tCb29sZWFuKG1hcmtlcikge1xuICAgICAgaWYgKG1hcmtlciA9PT0gVFJVRSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyID09PSBGQUxTRSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VucGFja051bWJlck9ySW50ZWdlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wYWNrTnVtYmVyT3JJbnRlZ2VyKG1hcmtlciwgYnVmZmVyKSB7XG4gICAgICBpZiAobWFya2VyID09PSBGTE9BVF82NCkge1xuICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRGbG9hdDY0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5wYWNrSW50ZWdlcihtYXJrZXIsIGJ1ZmZlcik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bnBhY2tJbnRlZ2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnBhY2tJbnRlZ2VyKG1hcmtlciwgYnVmZmVyKSB7XG4gICAgICBpZiAobWFya2VyID49IDAgJiYgbWFya2VyIDwgMTI4KSB7XG4gICAgICAgIHJldHVybiAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKG1hcmtlcik7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlciA+PSAyNDAgJiYgbWFya2VyIDwgMjU2KSB7XG4gICAgICAgIHJldHVybiAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKG1hcmtlciAtIDI1Nik7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlciA9PT0gSU5UXzgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfaW50ZWdlcltcImludFwiXSkoYnVmZmVyLnJlYWRJbnQ4KCkpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIgPT09IElOVF8xNikge1xuICAgICAgICByZXR1cm4gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShidWZmZXIucmVhZEludDE2KCkpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIgPT09IElOVF8zMikge1xuICAgICAgICB2YXIgYiA9IGJ1ZmZlci5yZWFkSW50MzIoKTtcbiAgICAgICAgcmV0dXJuICgwLCBfaW50ZWdlcltcImludFwiXSkoYik7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlciA9PT0gSU5UXzY0KSB7XG4gICAgICAgIHZhciBoaWdoID0gYnVmZmVyLnJlYWRJbnQzMigpO1xuICAgICAgICB2YXIgbG93ID0gYnVmZmVyLnJlYWRJbnQzMigpO1xuICAgICAgICByZXR1cm4gbmV3IF9pbnRlZ2VyW1wiZGVmYXVsdFwiXShsb3csIGhpZ2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bnBhY2tTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VucGFja1N0cmluZyhtYXJrZXIsIG1hcmtlckhpZ2gsIG1hcmtlckxvdywgYnVmZmVyKSB7XG4gICAgICBpZiAobWFya2VySGlnaCA9PT0gVElOWV9TVFJJTkcpIHtcbiAgICAgICAgcmV0dXJuIF9ub2RlLnV0ZjguZGVjb2RlKGJ1ZmZlciwgbWFya2VyTG93KTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyID09PSBTVFJJTkdfOCkge1xuICAgICAgICByZXR1cm4gX25vZGUudXRmOC5kZWNvZGUoYnVmZmVyLCBidWZmZXIucmVhZFVJbnQ4KCkpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIgPT09IFNUUklOR18xNikge1xuICAgICAgICByZXR1cm4gX25vZGUudXRmOC5kZWNvZGUoYnVmZmVyLCBidWZmZXIucmVhZFVJbnQxNigpKTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyID09PSBTVFJJTkdfMzIpIHtcbiAgICAgICAgcmV0dXJuIF9ub2RlLnV0ZjguZGVjb2RlKGJ1ZmZlciwgYnVmZmVyLnJlYWRVSW50MzIoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VucGFja0xpc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VucGFja0xpc3QobWFya2VyLCBtYXJrZXJIaWdoLCBtYXJrZXJMb3csIGJ1ZmZlcikge1xuICAgICAgaWYgKG1hcmtlckhpZ2ggPT09IFRJTllfTElTVCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5wYWNrTGlzdFdpdGhTaXplKG1hcmtlckxvdywgYnVmZmVyKTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyID09PSBMSVNUXzgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucGFja0xpc3RXaXRoU2l6ZShidWZmZXIucmVhZFVJbnQ4KCksIGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlciA9PT0gTElTVF8xNikge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5wYWNrTGlzdFdpdGhTaXplKGJ1ZmZlci5yZWFkVUludDE2KCksIGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlciA9PT0gTElTVF8zMikge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5wYWNrTGlzdFdpdGhTaXplKGJ1ZmZlci5yZWFkVUludDMyKCksIGJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VucGFja0xpc3RXaXRoU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wYWNrTGlzdFdpdGhTaXplKHNpemUsIGJ1ZmZlcikge1xuICAgICAgdmFyIHZhbHVlID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhbHVlLnB1c2godGhpcy51bnBhY2soYnVmZmVyKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VucGFja0J5dGVBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wYWNrQnl0ZUFycmF5KG1hcmtlciwgYnVmZmVyKSB7XG4gICAgICBpZiAobWFya2VyID09PSBCWVRFU184KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnBhY2tCeXRlQXJyYXlXaXRoU2l6ZShidWZmZXIucmVhZFVJbnQ4KCksIGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlciA9PT0gQllURVNfMTYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucGFja0J5dGVBcnJheVdpdGhTaXplKGJ1ZmZlci5yZWFkVUludDE2KCksIGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlciA9PT0gQllURVNfMzIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucGFja0J5dGVBcnJheVdpdGhTaXplKGJ1ZmZlci5yZWFkVUludDMyKCksIGJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VucGFja0J5dGVBcnJheVdpdGhTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnBhY2tCeXRlQXJyYXlXaXRoU2l6ZShzaXplLCBidWZmZXIpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG5ldyBJbnQ4QXJyYXkoc2l6ZSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhbHVlW2ldID0gYnVmZmVyLnJlYWRJbnQ4KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VucGFja01hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wYWNrTWFwKG1hcmtlciwgbWFya2VySGlnaCwgbWFya2VyTG93LCBidWZmZXIpIHtcbiAgICAgIGlmIChtYXJrZXJIaWdoID09PSBUSU5ZX01BUCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5wYWNrTWFwV2l0aFNpemUobWFya2VyTG93LCBidWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIgPT09IE1BUF84KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnBhY2tNYXBXaXRoU2l6ZShidWZmZXIucmVhZFVJbnQ4KCksIGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlciA9PT0gTUFQXzE2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnBhY2tNYXBXaXRoU2l6ZShidWZmZXIucmVhZFVJbnQxNigpLCBidWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIgPT09IE1BUF8zMikge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5wYWNrTWFwV2l0aFNpemUoYnVmZmVyLnJlYWRVSW50MzIoKSwgYnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdW5wYWNrTWFwV2l0aFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VucGFja01hcFdpdGhTaXplKHNpemUsIGJ1ZmZlcikge1xuICAgICAgdmFyIHZhbHVlID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLnVucGFjayhidWZmZXIpO1xuICAgICAgICB2YWx1ZVtrZXldID0gdGhpcy51bnBhY2soYnVmZmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdW5wYWNrU3RydWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnBhY2tTdHJ1Y3QobWFya2VyLCBtYXJrZXJIaWdoLCBtYXJrZXJMb3csIGJ1ZmZlcikge1xuICAgICAgaWYgKG1hcmtlckhpZ2ggPT09IFRJTllfU1RSVUNUKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnBhY2tTdHJ1Y3RXaXRoU2l6ZShtYXJrZXJMb3csIGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlciA9PT0gU1RSVUNUXzgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucGFja1N0cnVjdFdpdGhTaXplKGJ1ZmZlci5yZWFkVUludDgoKSwgYnVmZmVyKTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyID09PSBTVFJVQ1RfMTYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucGFja1N0cnVjdFdpdGhTaXplKGJ1ZmZlci5yZWFkVUludDE2KCksIGJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VucGFja1N0cnVjdFdpdGhTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnBhY2tTdHJ1Y3RXaXRoU2l6ZShzdHJ1Y3RTaXplLCBidWZmZXIpIHtcbiAgICAgIHZhciBzaWduYXR1cmUgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG5cbiAgICAgIGlmIChzaWduYXR1cmUgPT09IE5PREUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucGFja05vZGUoc3RydWN0U2l6ZSwgYnVmZmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoc2lnbmF0dXJlID09PSBSRUxBVElPTlNISVApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucGFja1JlbGF0aW9uc2hpcChzdHJ1Y3RTaXplLCBidWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09IFVOQk9VTkRfUkVMQVRJT05TSElQKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnBhY2tVbmJvdW5kUmVsYXRpb25zaGlwKHN0cnVjdFNpemUsIGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gUEFUSCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5wYWNrUGF0aChzdHJ1Y3RTaXplLCBidWZmZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucGFja1Vua25vd25TdHJ1Y3Qoc2lnbmF0dXJlLCBzdHJ1Y3RTaXplLCBidWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdW5wYWNrTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wYWNrTm9kZShzdHJ1Y3RTaXplLCBidWZmZXIpIHtcbiAgICAgIHRoaXMuX3ZlcmlmeVN0cnVjdFNpemUoJ05vZGUnLCBOT0RFX1NUUlVDVF9TSVpFLCBzdHJ1Y3RTaXplKTtcblxuICAgICAgcmV0dXJuIG5ldyBfZ3JhcGhUeXBlcy5Ob2RlKHRoaXMudW5wYWNrKGJ1ZmZlciksIC8vIElkZW50aXR5XG4gICAgICB0aGlzLnVucGFjayhidWZmZXIpLCAvLyBMYWJlbHNcbiAgICAgIHRoaXMudW5wYWNrKGJ1ZmZlcikgLy8gUHJvcGVydGllc1xuICAgICAgKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VucGFja1JlbGF0aW9uc2hpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wYWNrUmVsYXRpb25zaGlwKHN0cnVjdFNpemUsIGJ1ZmZlcikge1xuICAgICAgdGhpcy5fdmVyaWZ5U3RydWN0U2l6ZSgnUmVsYXRpb25zaGlwJywgUkVMQVRJT05TSElQX1NUUlVDVF9TSVpFLCBzdHJ1Y3RTaXplKTtcblxuICAgICAgcmV0dXJuIG5ldyBfZ3JhcGhUeXBlcy5SZWxhdGlvbnNoaXAodGhpcy51bnBhY2soYnVmZmVyKSwgLy8gSWRlbnRpdHlcbiAgICAgIHRoaXMudW5wYWNrKGJ1ZmZlciksIC8vIFN0YXJ0IE5vZGUgSWRlbnRpdHlcbiAgICAgIHRoaXMudW5wYWNrKGJ1ZmZlciksIC8vIEVuZCBOb2RlIElkZW50aXR5XG4gICAgICB0aGlzLnVucGFjayhidWZmZXIpLCAvLyBUeXBlXG4gICAgICB0aGlzLnVucGFjayhidWZmZXIpIC8vIFByb3BlcnRpZXNcbiAgICAgICk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bnBhY2tVbmJvdW5kUmVsYXRpb25zaGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnBhY2tVbmJvdW5kUmVsYXRpb25zaGlwKHN0cnVjdFNpemUsIGJ1ZmZlcikge1xuICAgICAgdGhpcy5fdmVyaWZ5U3RydWN0U2l6ZSgnVW5ib3VuZFJlbGF0aW9uc2hpcCcsIFVOQk9VTkRfUkVMQVRJT05TSElQX1NUUlVDVF9TSVpFLCBzdHJ1Y3RTaXplKTtcblxuICAgICAgcmV0dXJuIG5ldyBfZ3JhcGhUeXBlcy5VbmJvdW5kUmVsYXRpb25zaGlwKHRoaXMudW5wYWNrKGJ1ZmZlciksIC8vIElkZW50aXR5XG4gICAgICB0aGlzLnVucGFjayhidWZmZXIpLCAvLyBUeXBlXG4gICAgICB0aGlzLnVucGFjayhidWZmZXIpIC8vIFByb3BlcnRpZXNcbiAgICAgICk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bnBhY2tQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnBhY2tQYXRoKHN0cnVjdFNpemUsIGJ1ZmZlcikge1xuICAgICAgdGhpcy5fdmVyaWZ5U3RydWN0U2l6ZSgnUGF0aCcsIFBBVEhfU1RSVUNUX1NJWkUsIHN0cnVjdFNpemUpO1xuXG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLnVucGFjayhidWZmZXIpO1xuICAgICAgdmFyIHJlbHMgPSB0aGlzLnVucGFjayhidWZmZXIpO1xuICAgICAgdmFyIHNlcXVlbmNlID0gdGhpcy51bnBhY2soYnVmZmVyKTtcbiAgICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgICAgdmFyIHByZXZOb2RlID0gbm9kZXNbMF07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIG5leHROb2RlID0gbm9kZXNbc2VxdWVuY2VbaSArIDFdXTtcbiAgICAgICAgdmFyIHJlbEluZGV4ID0gc2VxdWVuY2VbaV07XG4gICAgICAgIHZhciByZWwgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHJlbEluZGV4ID4gMCkge1xuICAgICAgICAgIHJlbCA9IHJlbHNbcmVsSW5kZXggLSAxXTtcblxuICAgICAgICAgIGlmIChyZWwgaW5zdGFuY2VvZiBfZ3JhcGhUeXBlcy5VbmJvdW5kUmVsYXRpb25zaGlwKSB7XG4gICAgICAgICAgICAvLyBUbyBhdm9pZCBkdXBsaWNhdGlvbiwgcmVsYXRpb25zaGlwcyBpbiBhIHBhdGggZG8gbm90IGNvbnRhaW5cbiAgICAgICAgICAgIC8vIGluZm9ybWF0aW9uIGFib3V0IHRoZWlyIHN0YXJ0IGFuZCBlbmQgbm9kZXMsIHRoYXQncyBpbnN0ZWFkXG4gICAgICAgICAgICAvLyBpbmZlcnJlZCBmcm9tIHRoZSBwYXRoIHNlcXVlbmNlLiBUaGlzIGlzIHVzIGluZmVycmluZyAoYW5kLFxuICAgICAgICAgICAgLy8gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgcmVtZW1iZXJpbmcpIHRoZSBzdGFydC9lbmQgb2YgYSByZWwuXG4gICAgICAgICAgICByZWxzW3JlbEluZGV4IC0gMV0gPSByZWwgPSByZWwuYmluZChwcmV2Tm9kZS5pZGVudGl0eSwgbmV4dE5vZGUuaWRlbnRpdHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWwgPSByZWxzWy1yZWxJbmRleCAtIDFdO1xuXG4gICAgICAgICAgaWYgKHJlbCBpbnN0YW5jZW9mIF9ncmFwaFR5cGVzLlVuYm91bmRSZWxhdGlvbnNoaXApIHtcbiAgICAgICAgICAgIC8vIFNlZSBhYm92ZVxuICAgICAgICAgICAgcmVsc1stcmVsSW5kZXggLSAxXSA9IHJlbCA9IHJlbC5iaW5kKG5leHROb2RlLmlkZW50aXR5LCBwcmV2Tm9kZS5pZGVudGl0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIERvbmUgaHlkcmF0aW5nIG9uZSBwYXRoIHNlZ21lbnQuXG5cblxuICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBfZ3JhcGhUeXBlcy5QYXRoU2VnbWVudChwcmV2Tm9kZSwgcmVsLCBuZXh0Tm9kZSkpO1xuICAgICAgICBwcmV2Tm9kZSA9IG5leHROb2RlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IF9ncmFwaFR5cGVzLlBhdGgobm9kZXNbMF0sIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLCBzZWdtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bnBhY2tVbmtub3duU3RydWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnBhY2tVbmtub3duU3RydWN0KHNpZ25hdHVyZSwgc3RydWN0U2l6ZSwgYnVmZmVyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IFN0cnVjdHVyZShzaWduYXR1cmUsIFtdKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJ1Y3RTaXplOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LmZpZWxkcy5wdXNoKHRoaXMudW5wYWNrKGJ1ZmZlcikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdmVyaWZ5U3RydWN0U2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdmVyaWZ5U3RydWN0U2l6ZShzdHJ1Y3ROYW1lLCBleHBlY3RlZFNpemUsIGFjdHVhbFNpemUpIHtcbiAgICAgIGlmIChleHBlY3RlZFNpemUgIT09IGFjdHVhbFNpemUpIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoXCJXcm9uZyBzdHJ1Y3Qgc2l6ZSBmb3IgXCIuY29uY2F0KHN0cnVjdE5hbWUsIFwiLCBleHBlY3RlZCBcIikuY29uY2F0KGV4cGVjdGVkU2l6ZSwgXCIgYnV0IHdhcyBcIikuY29uY2F0KGFjdHVhbFNpemUpLCBfZXJyb3IuUFJPVE9DT0xfRVJST1IpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVW5wYWNrZXI7XG59KCk7XG5cbmV4cG9ydHMuVW5wYWNrZXIgPSBVbnBhY2tlcjtcblxuZnVuY3Rpb24gaXNJdGVyYWJsZShvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBvYmpbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZFwiKTtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlVucGFja2VyID0gZXhwb3J0cy5QYWNrZXIgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0XCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciB2MSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3BhY2tzdHJlYW0tdjFcIikpO1xuXG52YXIgX3NwYXRpYWxUeXBlcyA9IHJlcXVpcmUoXCIuLi9zcGF0aWFsLXR5cGVzXCIpO1xuXG52YXIgX3RlbXBvcmFsVHlwZXMgPSByZXF1aXJlKFwiLi4vdGVtcG9yYWwtdHlwZXNcIik7XG5cbnZhciBfaW50ZWdlciA9IHJlcXVpcmUoXCIuLi9pbnRlZ2VyXCIpO1xuXG52YXIgX3RlbXBvcmFsVXRpbCA9IHJlcXVpcmUoXCIuL3RlbXBvcmFsLXV0aWxcIik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yW1wiZGVmYXVsdFwiXSkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBQT0lOVF8yRCA9IDB4NTg7XG52YXIgUE9JTlRfMkRfU1RSVUNUX1NJWkUgPSAzO1xudmFyIFBPSU5UXzNEID0gMHg1OTtcbnZhciBQT0lOVF8zRF9TVFJVQ1RfU0laRSA9IDQ7XG52YXIgRFVSQVRJT04gPSAweDQ1O1xudmFyIERVUkFUSU9OX1NUUlVDVF9TSVpFID0gNDtcbnZhciBMT0NBTF9USU1FID0gMHg3NDtcbnZhciBMT0NBTF9USU1FX1NUUlVDVF9TSVpFID0gMTtcbnZhciBUSU1FID0gMHg1NDtcbnZhciBUSU1FX1NUUlVDVF9TSVpFID0gMjtcbnZhciBEQVRFID0gMHg0NDtcbnZhciBEQVRFX1NUUlVDVF9TSVpFID0gMTtcbnZhciBMT0NBTF9EQVRFX1RJTUUgPSAweDY0O1xudmFyIExPQ0FMX0RBVEVfVElNRV9TVFJVQ1RfU0laRSA9IDI7XG52YXIgREFURV9USU1FX1dJVEhfWk9ORV9PRkZTRVQgPSAweDQ2O1xudmFyIERBVEVfVElNRV9XSVRIX1pPTkVfT0ZGU0VUX1NUUlVDVF9TSVpFID0gMztcbnZhciBEQVRFX1RJTUVfV0lUSF9aT05FX0lEID0gMHg2NjtcbnZhciBEQVRFX1RJTUVfV0lUSF9aT05FX0lEX1NUUlVDVF9TSVpFID0gMztcblxudmFyIFBhY2tlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3YxJFBhY2tlcikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKFBhY2tlciwgX3YxJFBhY2tlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQYWNrZXIpO1xuXG4gIGZ1bmN0aW9uIFBhY2tlcigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFBhY2tlcik7XG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShQYWNrZXIsIFt7XG4gICAga2V5OiBcImRpc2FibGVCeXRlQXJyYXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVCeXRlQXJyYXlzKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb2x0IFYyIHNob3VsZCBhbHdheXMgc3VwcG9ydCBieXRlIGFycmF5cycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWNrYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWNrYWJsZShvYmopIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICgoMCwgX3NwYXRpYWxUeXBlcy5pc1BvaW50KShvYmopKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhY2tQb2ludChvYmosIF90aGlzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF90ZW1wb3JhbFR5cGVzLmlzRHVyYXRpb24pKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcGFja0R1cmF0aW9uKG9iaiwgX3RoaXMpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICgoMCwgX3RlbXBvcmFsVHlwZXMuaXNMb2NhbFRpbWUpKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcGFja0xvY2FsVGltZShvYmosIF90aGlzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF90ZW1wb3JhbFR5cGVzLmlzVGltZSkob2JqKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwYWNrVGltZShvYmosIF90aGlzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF90ZW1wb3JhbFR5cGVzLmlzRGF0ZSkob2JqKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwYWNrRGF0ZShvYmosIF90aGlzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF90ZW1wb3JhbFR5cGVzLmlzTG9jYWxEYXRlVGltZSkob2JqKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwYWNrTG9jYWxEYXRlVGltZShvYmosIF90aGlzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF90ZW1wb3JhbFR5cGVzLmlzRGF0ZVRpbWUpKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcGFja0RhdGVUaW1lKG9iaiwgX3RoaXMpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICgwLCBfZ2V0MltcImRlZmF1bHRcIl0pKCgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoUGFja2VyLnByb3RvdHlwZSksIFwicGFja2FibGVcIiwgdGhpcykuY2FsbCh0aGlzLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUGFja2VyO1xufSh2MS5QYWNrZXIpO1xuXG5leHBvcnRzLlBhY2tlciA9IFBhY2tlcjtcblxudmFyIFVucGFja2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfdjEkVW5wYWNrZXIpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShVbnBhY2tlciwgX3YxJFVucGFja2VyKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihVbnBhY2tlcik7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVMb3NzbGVzc0ludGVnZXJzIGlmIHRoaXMgdW5wYWNrZXIgc2hvdWxkIGNvbnZlcnQgYWxsIHJlY2VpdmVkIGludGVnZXJzIHRvIG5hdGl2ZSBKUyBudW1iZXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gVW5wYWNrZXIoKSB7XG4gICAgdmFyIGRpc2FibGVMb3NzbGVzc0ludGVnZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFVucGFja2VyKTtcbiAgICByZXR1cm4gX3N1cGVyMi5jYWxsKHRoaXMsIGRpc2FibGVMb3NzbGVzc0ludGVnZXJzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoVW5wYWNrZXIsIFt7XG4gICAga2V5OiBcIl91bnBhY2tVbmtub3duU3RydWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnBhY2tVbmtub3duU3RydWN0KHNpZ25hdHVyZSwgc3RydWN0U2l6ZSwgYnVmZmVyKSB7XG4gICAgICBpZiAoc2lnbmF0dXJlID09PSBQT0lOVF8yRCkge1xuICAgICAgICByZXR1cm4gdW5wYWNrUG9pbnQyRCh0aGlzLCBzdHJ1Y3RTaXplLCBidWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09IFBPSU5UXzNEKSB7XG4gICAgICAgIHJldHVybiB1bnBhY2tQb2ludDNEKHRoaXMsIHN0cnVjdFNpemUsIGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gRFVSQVRJT04pIHtcbiAgICAgICAgcmV0dXJuIHVucGFja0R1cmF0aW9uKHRoaXMsIHN0cnVjdFNpemUsIGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gTE9DQUxfVElNRSkge1xuICAgICAgICByZXR1cm4gdW5wYWNrTG9jYWxUaW1lKHRoaXMsIHN0cnVjdFNpemUsIGJ1ZmZlciwgdGhpcy5fZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xuICAgICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09IFRJTUUpIHtcbiAgICAgICAgcmV0dXJuIHVucGFja1RpbWUodGhpcywgc3RydWN0U2l6ZSwgYnVmZmVyLCB0aGlzLl9kaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycyk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gREFURSkge1xuICAgICAgICByZXR1cm4gdW5wYWNrRGF0ZSh0aGlzLCBzdHJ1Y3RTaXplLCBidWZmZXIsIHRoaXMuX2Rpc2FibGVMb3NzbGVzc0ludGVnZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAoc2lnbmF0dXJlID09PSBMT0NBTF9EQVRFX1RJTUUpIHtcbiAgICAgICAgcmV0dXJuIHVucGFja0xvY2FsRGF0ZVRpbWUodGhpcywgc3RydWN0U2l6ZSwgYnVmZmVyLCB0aGlzLl9kaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycyk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gREFURV9USU1FX1dJVEhfWk9ORV9PRkZTRVQpIHtcbiAgICAgICAgcmV0dXJuIHVucGFja0RhdGVUaW1lV2l0aFpvbmVPZmZzZXQodGhpcywgc3RydWN0U2l6ZSwgYnVmZmVyLCB0aGlzLl9kaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycyk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gREFURV9USU1FX1dJVEhfWk9ORV9JRCkge1xuICAgICAgICByZXR1cm4gdW5wYWNrRGF0ZVRpbWVXaXRoWm9uZUlkKHRoaXMsIHN0cnVjdFNpemUsIGJ1ZmZlciwgdGhpcy5fZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICgwLCBfZ2V0MltcImRlZmF1bHRcIl0pKCgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoVW5wYWNrZXIucHJvdG90eXBlKSwgXCJfdW5wYWNrVW5rbm93blN0cnVjdFwiLCB0aGlzKS5jYWxsKHRoaXMsIHNpZ25hdHVyZSwgc3RydWN0U2l6ZSwgYnVmZmVyLCB0aGlzLl9kaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycyk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBVbnBhY2tlcjtcbn0odjEuVW5wYWNrZXIpO1xuLyoqXG4gKiBQYWNrIGdpdmVuIDJEIG9yIDNEIHBvaW50LlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnQgdGhlIHBvaW50IHZhbHVlIHRvIHBhY2suXG4gKiBAcGFyYW0ge1BhY2tlcn0gcGFja2VyIHRoZSBwYWNrZXIgdG8gdXNlLlxuICovXG5cblxuZXhwb3J0cy5VbnBhY2tlciA9IFVucGFja2VyO1xuXG5mdW5jdGlvbiBwYWNrUG9pbnQocG9pbnQsIHBhY2tlcikge1xuICB2YXIgaXMyRFBvaW50ID0gcG9pbnQueiA9PT0gbnVsbCB8fCBwb2ludC56ID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzMkRQb2ludCkge1xuICAgIHBhY2tQb2ludDJEKHBvaW50LCBwYWNrZXIpO1xuICB9IGVsc2Uge1xuICAgIHBhY2tQb2ludDNEKHBvaW50LCBwYWNrZXIpO1xuICB9XG59XG4vKipcbiAqIFBhY2sgZ2l2ZW4gMkQgcG9pbnQuXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludCB0aGUgcG9pbnQgdmFsdWUgdG8gcGFjay5cbiAqIEBwYXJhbSB7UGFja2VyfSBwYWNrZXIgdGhlIHBhY2tlciB0byB1c2UuXG4gKi9cblxuXG5mdW5jdGlvbiBwYWNrUG9pbnQyRChwb2ludCwgcGFja2VyKSB7XG4gIHZhciBwYWNrYWJsZVN0cnVjdEZpZWxkcyA9IFtwYWNrZXIucGFja2FibGUoKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShwb2ludC5zcmlkKSksIHBhY2tlci5wYWNrYWJsZShwb2ludC54KSwgcGFja2VyLnBhY2thYmxlKHBvaW50LnkpXTtcbiAgcGFja2VyLnBhY2tTdHJ1Y3QoUE9JTlRfMkQsIHBhY2thYmxlU3RydWN0RmllbGRzKTtcbn1cbi8qKlxuICogUGFjayBnaXZlbiAzRCBwb2ludC5cbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IHRoZSBwb2ludCB2YWx1ZSB0byBwYWNrLlxuICogQHBhcmFtIHtQYWNrZXJ9IHBhY2tlciB0aGUgcGFja2VyIHRvIHVzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhY2tQb2ludDNEKHBvaW50LCBwYWNrZXIpIHtcbiAgdmFyIHBhY2thYmxlU3RydWN0RmllbGRzID0gW3BhY2tlci5wYWNrYWJsZSgoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHBvaW50LnNyaWQpKSwgcGFja2VyLnBhY2thYmxlKHBvaW50LngpLCBwYWNrZXIucGFja2FibGUocG9pbnQueSksIHBhY2tlci5wYWNrYWJsZShwb2ludC56KV07XG4gIHBhY2tlci5wYWNrU3RydWN0KFBPSU5UXzNELCBwYWNrYWJsZVN0cnVjdEZpZWxkcyk7XG59XG4vKipcbiAqIFVucGFjayAyRCBwb2ludCB2YWx1ZSB1c2luZyB0aGUgZ2l2ZW4gdW5wYWNrZXIuXG4gKiBAcGFyYW0ge1VucGFja2VyfSB1bnBhY2tlciB0aGUgdW5wYWNrZXIgdG8gdXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cnVjdFNpemUgdGhlIHJldHJpZXZlZCBzdHJ1Y3Qgc2l6ZS5cbiAqIEBwYXJhbSB7QmFzZUJ1ZmZlcn0gYnVmZmVyIHRoZSBidWZmZXIgdG8gdW5wYWNrIGZyb20uXG4gKiBAcmV0dXJuIHtQb2ludH0gdGhlIHVucGFja2VkIDJEIHBvaW50IHZhbHVlLlxuICovXG5cblxuZnVuY3Rpb24gdW5wYWNrUG9pbnQyRCh1bnBhY2tlciwgc3RydWN0U2l6ZSwgYnVmZmVyKSB7XG4gIHVucGFja2VyLl92ZXJpZnlTdHJ1Y3RTaXplKCdQb2ludDJEJywgUE9JTlRfMkRfU1RSVUNUX1NJWkUsIHN0cnVjdFNpemUpO1xuXG4gIHJldHVybiBuZXcgX3NwYXRpYWxUeXBlcy5Qb2ludCh1bnBhY2tlci51bnBhY2soYnVmZmVyKSwgLy8gc3JpZFxuICB1bnBhY2tlci51bnBhY2soYnVmZmVyKSwgLy8geFxuICB1bnBhY2tlci51bnBhY2soYnVmZmVyKSwgLy8geVxuICB1bmRlZmluZWQgLy8gelxuICApO1xufVxuLyoqXG4gKiBVbnBhY2sgM0QgcG9pbnQgdmFsdWUgdXNpbmcgdGhlIGdpdmVuIHVucGFja2VyLlxuICogQHBhcmFtIHtVbnBhY2tlcn0gdW5wYWNrZXIgdGhlIHVucGFja2VyIHRvIHVzZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJ1Y3RTaXplIHRoZSByZXRyaWV2ZWQgc3RydWN0IHNpemUuXG4gKiBAcGFyYW0ge0Jhc2VCdWZmZXJ9IGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHVucGFjayBmcm9tLlxuICogQHJldHVybiB7UG9pbnR9IHRoZSB1bnBhY2tlZCAzRCBwb2ludCB2YWx1ZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHVucGFja1BvaW50M0QodW5wYWNrZXIsIHN0cnVjdFNpemUsIGJ1ZmZlcikge1xuICB1bnBhY2tlci5fdmVyaWZ5U3RydWN0U2l6ZSgnUG9pbnQzRCcsIFBPSU5UXzNEX1NUUlVDVF9TSVpFLCBzdHJ1Y3RTaXplKTtcblxuICByZXR1cm4gbmV3IF9zcGF0aWFsVHlwZXMuUG9pbnQodW5wYWNrZXIudW5wYWNrKGJ1ZmZlciksIC8vIHNyaWRcbiAgdW5wYWNrZXIudW5wYWNrKGJ1ZmZlciksIC8vIHhcbiAgdW5wYWNrZXIudW5wYWNrKGJ1ZmZlciksIC8vIHlcbiAgdW5wYWNrZXIudW5wYWNrKGJ1ZmZlcikgLy8gelxuICApO1xufVxuLyoqXG4gKiBQYWNrIGdpdmVuIGR1cmF0aW9uLlxuICogQHBhcmFtIHtEdXJhdGlvbn0gdmFsdWUgdGhlIGR1cmF0aW9uIHZhbHVlIHRvIHBhY2suXG4gKiBAcGFyYW0ge1BhY2tlcn0gcGFja2VyIHRoZSBwYWNrZXIgdG8gdXNlLlxuICovXG5cblxuZnVuY3Rpb24gcGFja0R1cmF0aW9uKHZhbHVlLCBwYWNrZXIpIHtcbiAgdmFyIG1vbnRocyA9ICgwLCBfaW50ZWdlcltcImludFwiXSkodmFsdWUubW9udGhzKTtcbiAgdmFyIGRheXMgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHZhbHVlLmRheXMpO1xuICB2YXIgc2Vjb25kcyA9ICgwLCBfaW50ZWdlcltcImludFwiXSkodmFsdWUuc2Vjb25kcyk7XG4gIHZhciBuYW5vc2Vjb25kcyA9ICgwLCBfaW50ZWdlcltcImludFwiXSkodmFsdWUubmFub3NlY29uZHMpO1xuICB2YXIgcGFja2FibGVTdHJ1Y3RGaWVsZHMgPSBbcGFja2VyLnBhY2thYmxlKG1vbnRocyksIHBhY2tlci5wYWNrYWJsZShkYXlzKSwgcGFja2VyLnBhY2thYmxlKHNlY29uZHMpLCBwYWNrZXIucGFja2FibGUobmFub3NlY29uZHMpXTtcbiAgcGFja2VyLnBhY2tTdHJ1Y3QoRFVSQVRJT04sIHBhY2thYmxlU3RydWN0RmllbGRzKTtcbn1cbi8qKlxuICogVW5wYWNrIGR1cmF0aW9uIHZhbHVlIHVzaW5nIHRoZSBnaXZlbiB1bnBhY2tlci5cbiAqIEBwYXJhbSB7VW5wYWNrZXJ9IHVucGFja2VyIHRoZSB1bnBhY2tlciB0byB1c2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RydWN0U2l6ZSB0aGUgcmV0cmlldmVkIHN0cnVjdCBzaXplLlxuICogQHBhcmFtIHtCYXNlQnVmZmVyfSBidWZmZXIgdGhlIGJ1ZmZlciB0byB1bnBhY2sgZnJvbS5cbiAqIEByZXR1cm4ge0R1cmF0aW9ufSB0aGUgdW5wYWNrZWQgZHVyYXRpb24gdmFsdWUuXG4gKi9cblxuXG5mdW5jdGlvbiB1bnBhY2tEdXJhdGlvbih1bnBhY2tlciwgc3RydWN0U2l6ZSwgYnVmZmVyKSB7XG4gIHVucGFja2VyLl92ZXJpZnlTdHJ1Y3RTaXplKCdEdXJhdGlvbicsIERVUkFUSU9OX1NUUlVDVF9TSVpFLCBzdHJ1Y3RTaXplKTtcblxuICB2YXIgbW9udGhzID0gdW5wYWNrZXIudW5wYWNrKGJ1ZmZlcik7XG4gIHZhciBkYXlzID0gdW5wYWNrZXIudW5wYWNrKGJ1ZmZlcik7XG4gIHZhciBzZWNvbmRzID0gdW5wYWNrZXIudW5wYWNrKGJ1ZmZlcik7XG4gIHZhciBuYW5vc2Vjb25kcyA9IHVucGFja2VyLnVucGFjayhidWZmZXIpO1xuICByZXR1cm4gbmV3IF90ZW1wb3JhbFR5cGVzLkR1cmF0aW9uKG1vbnRocywgZGF5cywgc2Vjb25kcywgbmFub3NlY29uZHMpO1xufVxuLyoqXG4gKiBQYWNrIGdpdmVuIGxvY2FsIHRpbWUuXG4gKiBAcGFyYW0ge0xvY2FsVGltZX0gdmFsdWUgdGhlIGxvY2FsIHRpbWUgdmFsdWUgdG8gcGFjay5cbiAqIEBwYXJhbSB7UGFja2VyfSBwYWNrZXIgdGhlIHBhY2tlciB0byB1c2UuXG4gKi9cblxuXG5mdW5jdGlvbiBwYWNrTG9jYWxUaW1lKHZhbHVlLCBwYWNrZXIpIHtcbiAgdmFyIG5hbm9PZkRheSA9ICgwLCBfdGVtcG9yYWxVdGlsLmxvY2FsVGltZVRvTmFub09mRGF5KSh2YWx1ZS5ob3VyLCB2YWx1ZS5taW51dGUsIHZhbHVlLnNlY29uZCwgdmFsdWUubmFub3NlY29uZCk7XG4gIHZhciBwYWNrYWJsZVN0cnVjdEZpZWxkcyA9IFtwYWNrZXIucGFja2FibGUobmFub09mRGF5KV07XG4gIHBhY2tlci5wYWNrU3RydWN0KExPQ0FMX1RJTUUsIHBhY2thYmxlU3RydWN0RmllbGRzKTtcbn1cbi8qKlxuICogVW5wYWNrIGxvY2FsIHRpbWUgdmFsdWUgdXNpbmcgdGhlIGdpdmVuIHVucGFja2VyLlxuICogQHBhcmFtIHtVbnBhY2tlcn0gdW5wYWNrZXIgdGhlIHVucGFja2VyIHRvIHVzZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJ1Y3RTaXplIHRoZSByZXRyaWV2ZWQgc3RydWN0IHNpemUuXG4gKiBAcGFyYW0ge0Jhc2VCdWZmZXJ9IGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHVucGFjayBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlTG9zc2xlc3NJbnRlZ2VycyBpZiBpbnRlZ2VyIHByb3BlcnRpZXMgaW4gdGhlIHJlc3VsdCBsb2NhbCB0aW1lIHNob3VsZCBiZSBuYXRpdmUgSlMgbnVtYmVycy5cbiAqIEByZXR1cm4ge0xvY2FsVGltZX0gdGhlIHVucGFja2VkIGxvY2FsIHRpbWUgdmFsdWUuXG4gKi9cblxuXG5mdW5jdGlvbiB1bnBhY2tMb2NhbFRpbWUodW5wYWNrZXIsIHN0cnVjdFNpemUsIGJ1ZmZlciwgZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpIHtcbiAgdW5wYWNrZXIuX3ZlcmlmeVN0cnVjdFNpemUoJ0xvY2FsVGltZScsIExPQ0FMX1RJTUVfU1RSVUNUX1NJWkUsIHN0cnVjdFNpemUpO1xuXG4gIHZhciBuYW5vT2ZEYXkgPSB1bnBhY2tlci51bnBhY2tJbnRlZ2VyKGJ1ZmZlcik7XG4gIHZhciByZXN1bHQgPSAoMCwgX3RlbXBvcmFsVXRpbC5uYW5vT2ZEYXlUb0xvY2FsVGltZSkobmFub09mRGF5KTtcbiAgcmV0dXJuIGNvbnZlcnRJbnRlZ2VyUHJvcHNJZk5lZWRlZChyZXN1bHQsIGRpc2FibGVMb3NzbGVzc0ludGVnZXJzKTtcbn1cbi8qKlxuICogUGFjayBnaXZlbiB0aW1lLlxuICogQHBhcmFtIHtUaW1lfSB2YWx1ZSB0aGUgdGltZSB2YWx1ZSB0byBwYWNrLlxuICogQHBhcmFtIHtQYWNrZXJ9IHBhY2tlciB0aGUgcGFja2VyIHRvIHVzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhY2tUaW1lKHZhbHVlLCBwYWNrZXIpIHtcbiAgdmFyIG5hbm9PZkRheSA9ICgwLCBfdGVtcG9yYWxVdGlsLmxvY2FsVGltZVRvTmFub09mRGF5KSh2YWx1ZS5ob3VyLCB2YWx1ZS5taW51dGUsIHZhbHVlLnNlY29uZCwgdmFsdWUubmFub3NlY29uZCk7XG4gIHZhciBvZmZzZXRTZWNvbmRzID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKSh2YWx1ZS50aW1lWm9uZU9mZnNldFNlY29uZHMpO1xuICB2YXIgcGFja2FibGVTdHJ1Y3RGaWVsZHMgPSBbcGFja2VyLnBhY2thYmxlKG5hbm9PZkRheSksIHBhY2tlci5wYWNrYWJsZShvZmZzZXRTZWNvbmRzKV07XG4gIHBhY2tlci5wYWNrU3RydWN0KFRJTUUsIHBhY2thYmxlU3RydWN0RmllbGRzKTtcbn1cbi8qKlxuICogVW5wYWNrIHRpbWUgdmFsdWUgdXNpbmcgdGhlIGdpdmVuIHVucGFja2VyLlxuICogQHBhcmFtIHtVbnBhY2tlcn0gdW5wYWNrZXIgdGhlIHVucGFja2VyIHRvIHVzZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJ1Y3RTaXplIHRoZSByZXRyaWV2ZWQgc3RydWN0IHNpemUuXG4gKiBAcGFyYW0ge0Jhc2VCdWZmZXJ9IGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHVucGFjayBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlTG9zc2xlc3NJbnRlZ2VycyBpZiBpbnRlZ2VyIHByb3BlcnRpZXMgaW4gdGhlIHJlc3VsdCB0aW1lIHNob3VsZCBiZSBuYXRpdmUgSlMgbnVtYmVycy5cbiAqIEByZXR1cm4ge1RpbWV9IHRoZSB1bnBhY2tlZCB0aW1lIHZhbHVlLlxuICovXG5cblxuZnVuY3Rpb24gdW5wYWNrVGltZSh1bnBhY2tlciwgc3RydWN0U2l6ZSwgYnVmZmVyLCBkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycykge1xuICB1bnBhY2tlci5fdmVyaWZ5U3RydWN0U2l6ZSgnVGltZScsIFRJTUVfU1RSVUNUX1NJWkUsIHN0cnVjdFNpemUpO1xuXG4gIHZhciBuYW5vT2ZEYXkgPSB1bnBhY2tlci51bnBhY2tJbnRlZ2VyKGJ1ZmZlcik7XG4gIHZhciBvZmZzZXRTZWNvbmRzID0gdW5wYWNrZXIudW5wYWNrSW50ZWdlcihidWZmZXIpO1xuICB2YXIgbG9jYWxUaW1lID0gKDAsIF90ZW1wb3JhbFV0aWwubmFub09mRGF5VG9Mb2NhbFRpbWUpKG5hbm9PZkRheSk7XG4gIHZhciByZXN1bHQgPSBuZXcgX3RlbXBvcmFsVHlwZXMuVGltZShsb2NhbFRpbWUuaG91ciwgbG9jYWxUaW1lLm1pbnV0ZSwgbG9jYWxUaW1lLnNlY29uZCwgbG9jYWxUaW1lLm5hbm9zZWNvbmQsIG9mZnNldFNlY29uZHMpO1xuICByZXR1cm4gY29udmVydEludGVnZXJQcm9wc0lmTmVlZGVkKHJlc3VsdCwgZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xufVxuLyoqXG4gKiBQYWNrIGdpdmVuIG5lbzRqIGRhdGUuXG4gKiBAcGFyYW0ge0RhdGV9IHZhbHVlIHRoZSBkYXRlIHZhbHVlIHRvIHBhY2suXG4gKiBAcGFyYW0ge1BhY2tlcn0gcGFja2VyIHRoZSBwYWNrZXIgdG8gdXNlLlxuICovXG5cblxuZnVuY3Rpb24gcGFja0RhdGUodmFsdWUsIHBhY2tlcikge1xuICB2YXIgZXBvY2hEYXkgPSAoMCwgX3RlbXBvcmFsVXRpbC5kYXRlVG9FcG9jaERheSkodmFsdWUueWVhciwgdmFsdWUubW9udGgsIHZhbHVlLmRheSk7XG4gIHZhciBwYWNrYWJsZVN0cnVjdEZpZWxkcyA9IFtwYWNrZXIucGFja2FibGUoZXBvY2hEYXkpXTtcbiAgcGFja2VyLnBhY2tTdHJ1Y3QoREFURSwgcGFja2FibGVTdHJ1Y3RGaWVsZHMpO1xufVxuLyoqXG4gKiBVbnBhY2sgbmVvNGogZGF0ZSB2YWx1ZSB1c2luZyB0aGUgZ2l2ZW4gdW5wYWNrZXIuXG4gKiBAcGFyYW0ge1VucGFja2VyfSB1bnBhY2tlciB0aGUgdW5wYWNrZXIgdG8gdXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cnVjdFNpemUgdGhlIHJldHJpZXZlZCBzdHJ1Y3Qgc2l6ZS5cbiAqIEBwYXJhbSB7QmFzZUJ1ZmZlcn0gYnVmZmVyIHRoZSBidWZmZXIgdG8gdW5wYWNrIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVMb3NzbGVzc0ludGVnZXJzIGlmIGludGVnZXIgcHJvcGVydGllcyBpbiB0aGUgcmVzdWx0IGRhdGUgc2hvdWxkIGJlIG5hdGl2ZSBKUyBudW1iZXJzLlxuICogQHJldHVybiB7RGF0ZX0gdGhlIHVucGFja2VkIG5lbzRqIGRhdGUgdmFsdWUuXG4gKi9cblxuXG5mdW5jdGlvbiB1bnBhY2tEYXRlKHVucGFja2VyLCBzdHJ1Y3RTaXplLCBidWZmZXIsIGRpc2FibGVMb3NzbGVzc0ludGVnZXJzKSB7XG4gIHVucGFja2VyLl92ZXJpZnlTdHJ1Y3RTaXplKCdEYXRlJywgREFURV9TVFJVQ1RfU0laRSwgc3RydWN0U2l6ZSk7XG5cbiAgdmFyIGVwb2NoRGF5ID0gdW5wYWNrZXIudW5wYWNrSW50ZWdlcihidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gKDAsIF90ZW1wb3JhbFV0aWwuZXBvY2hEYXlUb0RhdGUpKGVwb2NoRGF5KTtcbiAgcmV0dXJuIGNvbnZlcnRJbnRlZ2VyUHJvcHNJZk5lZWRlZChyZXN1bHQsIGRpc2FibGVMb3NzbGVzc0ludGVnZXJzKTtcbn1cbi8qKlxuICogUGFjayBnaXZlbiBsb2NhbCBkYXRlIHRpbWUuXG4gKiBAcGFyYW0ge0xvY2FsRGF0ZVRpbWV9IHZhbHVlIHRoZSBsb2NhbCBkYXRlIHRpbWUgdmFsdWUgdG8gcGFjay5cbiAqIEBwYXJhbSB7UGFja2VyfSBwYWNrZXIgdGhlIHBhY2tlciB0byB1c2UuXG4gKi9cblxuXG5mdW5jdGlvbiBwYWNrTG9jYWxEYXRlVGltZSh2YWx1ZSwgcGFja2VyKSB7XG4gIHZhciBlcG9jaFNlY29uZCA9ICgwLCBfdGVtcG9yYWxVdGlsLmxvY2FsRGF0ZVRpbWVUb0Vwb2NoU2Vjb25kKSh2YWx1ZS55ZWFyLCB2YWx1ZS5tb250aCwgdmFsdWUuZGF5LCB2YWx1ZS5ob3VyLCB2YWx1ZS5taW51dGUsIHZhbHVlLnNlY29uZCwgdmFsdWUubmFub3NlY29uZCk7XG4gIHZhciBuYW5vID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKSh2YWx1ZS5uYW5vc2Vjb25kKTtcbiAgdmFyIHBhY2thYmxlU3RydWN0RmllbGRzID0gW3BhY2tlci5wYWNrYWJsZShlcG9jaFNlY29uZCksIHBhY2tlci5wYWNrYWJsZShuYW5vKV07XG4gIHBhY2tlci5wYWNrU3RydWN0KExPQ0FMX0RBVEVfVElNRSwgcGFja2FibGVTdHJ1Y3RGaWVsZHMpO1xufVxuLyoqXG4gKiBVbnBhY2sgbG9jYWwgZGF0ZSB0aW1lIHZhbHVlIHVzaW5nIHRoZSBnaXZlbiB1bnBhY2tlci5cbiAqIEBwYXJhbSB7VW5wYWNrZXJ9IHVucGFja2VyIHRoZSB1bnBhY2tlciB0byB1c2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RydWN0U2l6ZSB0aGUgcmV0cmlldmVkIHN0cnVjdCBzaXplLlxuICogQHBhcmFtIHtCYXNlQnVmZmVyfSBidWZmZXIgdGhlIGJ1ZmZlciB0byB1bnBhY2sgZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMgaWYgaW50ZWdlciBwcm9wZXJ0aWVzIGluIHRoZSByZXN1bHQgbG9jYWwgZGF0ZS10aW1lIHNob3VsZCBiZSBuYXRpdmUgSlMgbnVtYmVycy5cbiAqIEByZXR1cm4ge0xvY2FsRGF0ZVRpbWV9IHRoZSB1bnBhY2tlZCBsb2NhbCBkYXRlIHRpbWUgdmFsdWUuXG4gKi9cblxuXG5mdW5jdGlvbiB1bnBhY2tMb2NhbERhdGVUaW1lKHVucGFja2VyLCBzdHJ1Y3RTaXplLCBidWZmZXIsIGRpc2FibGVMb3NzbGVzc0ludGVnZXJzKSB7XG4gIHVucGFja2VyLl92ZXJpZnlTdHJ1Y3RTaXplKCdMb2NhbERhdGVUaW1lJywgTE9DQUxfREFURV9USU1FX1NUUlVDVF9TSVpFLCBzdHJ1Y3RTaXplKTtcblxuICB2YXIgZXBvY2hTZWNvbmQgPSB1bnBhY2tlci51bnBhY2tJbnRlZ2VyKGJ1ZmZlcik7XG4gIHZhciBuYW5vID0gdW5wYWNrZXIudW5wYWNrSW50ZWdlcihidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gKDAsIF90ZW1wb3JhbFV0aWwuZXBvY2hTZWNvbmRBbmROYW5vVG9Mb2NhbERhdGVUaW1lKShlcG9jaFNlY29uZCwgbmFubyk7XG4gIHJldHVybiBjb252ZXJ0SW50ZWdlclByb3BzSWZOZWVkZWQocmVzdWx0LCBkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycyk7XG59XG4vKipcbiAqIFBhY2sgZ2l2ZW4gZGF0ZSB0aW1lLlxuICogQHBhcmFtIHtEYXRlVGltZX0gdmFsdWUgdGhlIGRhdGUgdGltZSB2YWx1ZSB0byBwYWNrLlxuICogQHBhcmFtIHtQYWNrZXJ9IHBhY2tlciB0aGUgcGFja2VyIHRvIHVzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhY2tEYXRlVGltZSh2YWx1ZSwgcGFja2VyKSB7XG4gIGlmICh2YWx1ZS50aW1lWm9uZUlkKSB7XG4gICAgcGFja0RhdGVUaW1lV2l0aFpvbmVJZCh2YWx1ZSwgcGFja2VyKTtcbiAgfSBlbHNlIHtcbiAgICBwYWNrRGF0ZVRpbWVXaXRoWm9uZU9mZnNldCh2YWx1ZSwgcGFja2VyKTtcbiAgfVxufVxuLyoqXG4gKiBQYWNrIGdpdmVuIGRhdGUgdGltZSB3aXRoIHpvbmUgb2Zmc2V0LlxuICogQHBhcmFtIHtEYXRlVGltZX0gdmFsdWUgdGhlIGRhdGUgdGltZSB2YWx1ZSB0byBwYWNrLlxuICogQHBhcmFtIHtQYWNrZXJ9IHBhY2tlciB0aGUgcGFja2VyIHRvIHVzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhY2tEYXRlVGltZVdpdGhab25lT2Zmc2V0KHZhbHVlLCBwYWNrZXIpIHtcbiAgdmFyIGVwb2NoU2Vjb25kID0gKDAsIF90ZW1wb3JhbFV0aWwubG9jYWxEYXRlVGltZVRvRXBvY2hTZWNvbmQpKHZhbHVlLnllYXIsIHZhbHVlLm1vbnRoLCB2YWx1ZS5kYXksIHZhbHVlLmhvdXIsIHZhbHVlLm1pbnV0ZSwgdmFsdWUuc2Vjb25kLCB2YWx1ZS5uYW5vc2Vjb25kKTtcbiAgdmFyIG5hbm8gPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHZhbHVlLm5hbm9zZWNvbmQpO1xuICB2YXIgdGltZVpvbmVPZmZzZXRTZWNvbmRzID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKSh2YWx1ZS50aW1lWm9uZU9mZnNldFNlY29uZHMpO1xuICB2YXIgcGFja2FibGVTdHJ1Y3RGaWVsZHMgPSBbcGFja2VyLnBhY2thYmxlKGVwb2NoU2Vjb25kKSwgcGFja2VyLnBhY2thYmxlKG5hbm8pLCBwYWNrZXIucGFja2FibGUodGltZVpvbmVPZmZzZXRTZWNvbmRzKV07XG4gIHBhY2tlci5wYWNrU3RydWN0KERBVEVfVElNRV9XSVRIX1pPTkVfT0ZGU0VULCBwYWNrYWJsZVN0cnVjdEZpZWxkcyk7XG59XG4vKipcbiAqIFVucGFjayBkYXRlIHRpbWUgd2l0aCB6b25lIG9mZnNldCB2YWx1ZSB1c2luZyB0aGUgZ2l2ZW4gdW5wYWNrZXIuXG4gKiBAcGFyYW0ge1VucGFja2VyfSB1bnBhY2tlciB0aGUgdW5wYWNrZXIgdG8gdXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cnVjdFNpemUgdGhlIHJldHJpZXZlZCBzdHJ1Y3Qgc2l6ZS5cbiAqIEBwYXJhbSB7QmFzZUJ1ZmZlcn0gYnVmZmVyIHRoZSBidWZmZXIgdG8gdW5wYWNrIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVMb3NzbGVzc0ludGVnZXJzIGlmIGludGVnZXIgcHJvcGVydGllcyBpbiB0aGUgcmVzdWx0IGRhdGUtdGltZSBzaG91bGQgYmUgbmF0aXZlIEpTIG51bWJlcnMuXG4gKiBAcmV0dXJuIHtEYXRlVGltZX0gdGhlIHVucGFja2VkIGRhdGUgdGltZSB3aXRoIHpvbmUgb2Zmc2V0IHZhbHVlLlxuICovXG5cblxuZnVuY3Rpb24gdW5wYWNrRGF0ZVRpbWVXaXRoWm9uZU9mZnNldCh1bnBhY2tlciwgc3RydWN0U2l6ZSwgYnVmZmVyLCBkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycykge1xuICB1bnBhY2tlci5fdmVyaWZ5U3RydWN0U2l6ZSgnRGF0ZVRpbWVXaXRoWm9uZU9mZnNldCcsIERBVEVfVElNRV9XSVRIX1pPTkVfT0ZGU0VUX1NUUlVDVF9TSVpFLCBzdHJ1Y3RTaXplKTtcblxuICB2YXIgZXBvY2hTZWNvbmQgPSB1bnBhY2tlci51bnBhY2tJbnRlZ2VyKGJ1ZmZlcik7XG4gIHZhciBuYW5vID0gdW5wYWNrZXIudW5wYWNrSW50ZWdlcihidWZmZXIpO1xuICB2YXIgdGltZVpvbmVPZmZzZXRTZWNvbmRzID0gdW5wYWNrZXIudW5wYWNrSW50ZWdlcihidWZmZXIpO1xuICB2YXIgbG9jYWxEYXRlVGltZSA9ICgwLCBfdGVtcG9yYWxVdGlsLmVwb2NoU2Vjb25kQW5kTmFub1RvTG9jYWxEYXRlVGltZSkoZXBvY2hTZWNvbmQsIG5hbm8pO1xuICB2YXIgcmVzdWx0ID0gbmV3IF90ZW1wb3JhbFR5cGVzLkRhdGVUaW1lKGxvY2FsRGF0ZVRpbWUueWVhciwgbG9jYWxEYXRlVGltZS5tb250aCwgbG9jYWxEYXRlVGltZS5kYXksIGxvY2FsRGF0ZVRpbWUuaG91ciwgbG9jYWxEYXRlVGltZS5taW51dGUsIGxvY2FsRGF0ZVRpbWUuc2Vjb25kLCBsb2NhbERhdGVUaW1lLm5hbm9zZWNvbmQsIHRpbWVab25lT2Zmc2V0U2Vjb25kcywgbnVsbCk7XG4gIHJldHVybiBjb252ZXJ0SW50ZWdlclByb3BzSWZOZWVkZWQocmVzdWx0LCBkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycyk7XG59XG4vKipcbiAqIFBhY2sgZ2l2ZW4gZGF0ZSB0aW1lIHdpdGggem9uZSBpZC5cbiAqIEBwYXJhbSB7RGF0ZVRpbWV9IHZhbHVlIHRoZSBkYXRlIHRpbWUgdmFsdWUgdG8gcGFjay5cbiAqIEBwYXJhbSB7UGFja2VyfSBwYWNrZXIgdGhlIHBhY2tlciB0byB1c2UuXG4gKi9cblxuXG5mdW5jdGlvbiBwYWNrRGF0ZVRpbWVXaXRoWm9uZUlkKHZhbHVlLCBwYWNrZXIpIHtcbiAgdmFyIGVwb2NoU2Vjb25kID0gKDAsIF90ZW1wb3JhbFV0aWwubG9jYWxEYXRlVGltZVRvRXBvY2hTZWNvbmQpKHZhbHVlLnllYXIsIHZhbHVlLm1vbnRoLCB2YWx1ZS5kYXksIHZhbHVlLmhvdXIsIHZhbHVlLm1pbnV0ZSwgdmFsdWUuc2Vjb25kLCB2YWx1ZS5uYW5vc2Vjb25kKTtcbiAgdmFyIG5hbm8gPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHZhbHVlLm5hbm9zZWNvbmQpO1xuICB2YXIgdGltZVpvbmVJZCA9IHZhbHVlLnRpbWVab25lSWQ7XG4gIHZhciBwYWNrYWJsZVN0cnVjdEZpZWxkcyA9IFtwYWNrZXIucGFja2FibGUoZXBvY2hTZWNvbmQpLCBwYWNrZXIucGFja2FibGUobmFubyksIHBhY2tlci5wYWNrYWJsZSh0aW1lWm9uZUlkKV07XG4gIHBhY2tlci5wYWNrU3RydWN0KERBVEVfVElNRV9XSVRIX1pPTkVfSUQsIHBhY2thYmxlU3RydWN0RmllbGRzKTtcbn1cbi8qKlxuICogVW5wYWNrIGRhdGUgdGltZSB3aXRoIHpvbmUgaWQgdmFsdWUgdXNpbmcgdGhlIGdpdmVuIHVucGFja2VyLlxuICogQHBhcmFtIHtVbnBhY2tlcn0gdW5wYWNrZXIgdGhlIHVucGFja2VyIHRvIHVzZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJ1Y3RTaXplIHRoZSByZXRyaWV2ZWQgc3RydWN0IHNpemUuXG4gKiBAcGFyYW0ge0Jhc2VCdWZmZXJ9IGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHVucGFjayBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlTG9zc2xlc3NJbnRlZ2VycyBpZiBpbnRlZ2VyIHByb3BlcnRpZXMgaW4gdGhlIHJlc3VsdCBkYXRlLXRpbWUgc2hvdWxkIGJlIG5hdGl2ZSBKUyBudW1iZXJzLlxuICogQHJldHVybiB7RGF0ZVRpbWV9IHRoZSB1bnBhY2tlZCBkYXRlIHRpbWUgd2l0aCB6b25lIGlkIHZhbHVlLlxuICovXG5cblxuZnVuY3Rpb24gdW5wYWNrRGF0ZVRpbWVXaXRoWm9uZUlkKHVucGFja2VyLCBzdHJ1Y3RTaXplLCBidWZmZXIsIGRpc2FibGVMb3NzbGVzc0ludGVnZXJzKSB7XG4gIHVucGFja2VyLl92ZXJpZnlTdHJ1Y3RTaXplKCdEYXRlVGltZVdpdGhab25lSWQnLCBEQVRFX1RJTUVfV0lUSF9aT05FX0lEX1NUUlVDVF9TSVpFLCBzdHJ1Y3RTaXplKTtcblxuICB2YXIgZXBvY2hTZWNvbmQgPSB1bnBhY2tlci51bnBhY2tJbnRlZ2VyKGJ1ZmZlcik7XG4gIHZhciBuYW5vID0gdW5wYWNrZXIudW5wYWNrSW50ZWdlcihidWZmZXIpO1xuICB2YXIgdGltZVpvbmVJZCA9IHVucGFja2VyLnVucGFjayhidWZmZXIpO1xuICB2YXIgbG9jYWxEYXRlVGltZSA9ICgwLCBfdGVtcG9yYWxVdGlsLmVwb2NoU2Vjb25kQW5kTmFub1RvTG9jYWxEYXRlVGltZSkoZXBvY2hTZWNvbmQsIG5hbm8pO1xuICB2YXIgcmVzdWx0ID0gbmV3IF90ZW1wb3JhbFR5cGVzLkRhdGVUaW1lKGxvY2FsRGF0ZVRpbWUueWVhciwgbG9jYWxEYXRlVGltZS5tb250aCwgbG9jYWxEYXRlVGltZS5kYXksIGxvY2FsRGF0ZVRpbWUuaG91ciwgbG9jYWxEYXRlVGltZS5taW51dGUsIGxvY2FsRGF0ZVRpbWUuc2Vjb25kLCBsb2NhbERhdGVUaW1lLm5hbm9zZWNvbmQsIG51bGwsIHRpbWVab25lSWQpO1xuICByZXR1cm4gY29udmVydEludGVnZXJQcm9wc0lmTmVlZGVkKHJlc3VsdCwgZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0SW50ZWdlclByb3BzSWZOZWVkZWQob2JqLCBkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycykge1xuICBpZiAoIWRpc2FibGVMb3NzbGVzc0ludGVnZXJzKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciBjbG9uZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpO1xuXG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xuICAgICAgY2xvbmVbcHJvcF0gPSAoMCwgX2ludGVnZXIuaXNJbnQpKHZhbHVlKSA/IHZhbHVlLnRvTnVtYmVyT3JJbmZpbml0eSgpIDogdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmZyZWV6ZShjbG9uZSk7XG4gIHJldHVybiBjbG9uZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkRFRkFVTFRfQUNRVUlTSVRJT05fVElNRU9VVCA9IGV4cG9ydHMuREVGQVVMVF9NQVhfU0laRSA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBERUZBVUxUX01BWF9TSVpFID0gMTAwO1xuZXhwb3J0cy5ERUZBVUxUX01BWF9TSVpFID0gREVGQVVMVF9NQVhfU0laRTtcbnZhciBERUZBVUxUX0FDUVVJU0lUSU9OX1RJTUVPVVQgPSA2MCAqIDEwMDA7IC8vIDYwIHNlY29uZHNcblxuZXhwb3J0cy5ERUZBVUxUX0FDUVVJU0lUSU9OX1RJTUVPVVQgPSBERUZBVUxUX0FDUVVJU0lUSU9OX1RJTUVPVVQ7XG5cbnZhciBQb29sQ29uZmlnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9vbENvbmZpZyhtYXhTaXplLCBhY3F1aXNpdGlvblRpbWVvdXQpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFBvb2xDb25maWcpO1xuICAgIHRoaXMubWF4U2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG1heFNpemUsIERFRkFVTFRfTUFYX1NJWkUpO1xuICAgIHRoaXMuYWNxdWlzaXRpb25UaW1lb3V0ID0gdmFsdWVPckRlZmF1bHQoYWNxdWlzaXRpb25UaW1lb3V0LCBERUZBVUxUX0FDUVVJU0lUSU9OX1RJTUVPVVQpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShQb29sQ29uZmlnLCBudWxsLCBbe1xuICAgIGtleTogXCJkZWZhdWx0Q29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlZmF1bHRDb25maWcoKSB7XG4gICAgICByZXR1cm4gbmV3IFBvb2xDb25maWcoREVGQVVMVF9NQVhfU0laRSwgREVGQVVMVF9BQ1FVSVNJVElPTl9USU1FT1VUKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbURyaXZlckNvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRHJpdmVyQ29uZmlnKGNvbmZpZykge1xuICAgICAgdmFyIG1heFNpemVDb25maWd1cmVkID0gaXNDb25maWd1cmVkKGNvbmZpZy5tYXhDb25uZWN0aW9uUG9vbFNpemUpO1xuICAgICAgdmFyIG1heFNpemUgPSBtYXhTaXplQ29uZmlndXJlZCA/IGNvbmZpZy5tYXhDb25uZWN0aW9uUG9vbFNpemUgOiBERUZBVUxUX01BWF9TSVpFO1xuICAgICAgdmFyIGFjcXVpc2l0aW9uVGltZW91dENvbmZpZ3VyZWQgPSBpc0NvbmZpZ3VyZWQoY29uZmlnLmNvbm5lY3Rpb25BY3F1aXNpdGlvblRpbWVvdXQpO1xuICAgICAgdmFyIGFjcXVpc2l0aW9uVGltZW91dCA9IGFjcXVpc2l0aW9uVGltZW91dENvbmZpZ3VyZWQgPyBjb25maWcuY29ubmVjdGlvbkFjcXVpc2l0aW9uVGltZW91dCA6IERFRkFVTFRfQUNRVUlTSVRJT05fVElNRU9VVDtcbiAgICAgIHJldHVybiBuZXcgUG9vbENvbmZpZyhtYXhTaXplLCBhY3F1aXNpdGlvblRpbWVvdXQpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUG9vbENvbmZpZztcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQb29sQ29uZmlnO1xuXG5mdW5jdGlvbiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gMCB8fCB2YWx1ZSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuXG5mdW5jdGlvbiBpc0NvbmZpZ3VyZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSAwIHx8IHZhbHVlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9wb29sQ29uZmlnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wb29sLWNvbmZpZ1wiKSk7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG5cbnZhciBfbG9nZ2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9sb2dnZXJcIikpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBQb29sID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oYWRkcmVzczogU2VydmVyQWRkcmVzcywgZnVuY3Rpb24oYWRkcmVzczogU2VydmVyQWRkcmVzcywgcmVzb3VyY2U6IG9iamVjdCk6IFByb21pc2U8b2JqZWN0Pik6IFByb21pc2U8b2JqZWN0Pn0gY3JlYXRlXG4gICAqICAgICAgICAgICAgICAgIGFuIGFsbG9jYXRpb24gZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgcHJvbWlzZSB3aXRoIGEgbmV3IHJlc291cmNlLiBJdCdzIGdpdmVuIGFuIGFkZHJlc3MgZm9yIHdoaWNoIHRvXG4gICAqICAgICAgICAgICAgICAgIGFsbG9jYXRlIHRoZSBjb25uZWN0aW9uIGFuZCBhIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXR1cm4gdGhlIHJlc291cmNlIHRvIHRoZSBwb29sIGlmIGludm9rZWQsIHdoaWNoIGlzXG4gICAqICAgICAgICAgICAgICAgIG1lYW50IHRvIGJlIGNhbGxlZCBvbiAuZGlzcG9zZSBvciAuY2xvc2Ugb3Igd2hhdGV2ZXIgbWVjaGFuaXNtIHRoZSByZXNvdXJjZSB1c2VzIHRvIGZpbmFsaXplLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHJlc291cmNlOiBvYmplY3QpOiBQcm9taXNlPHZvaWQ+fSBkZXN0cm95XG4gICAqICAgICAgICAgICAgICAgIGNhbGxlZCB3aXRoIHRoZSByZXNvdXJjZSB3aGVuIGl0IGlzIGV2aWN0ZWQgZnJvbSB0aGlzIHBvb2xcbiAgICogQHBhcmFtIHtmdW5jdGlvbihyZXNvdXJjZTogb2JqZWN0KTogYm9vbGVhbn0gdmFsaWRhdGVcbiAgICogICAgICAgICAgICAgICAgY2FsbGVkIGF0IHZhcmlvdXMgdGltZXMgKGxpa2Ugd2hlbiBhbiBpbnN0YW5jZSBpcyBhY3F1aXJlZCBhbmQgd2hlbiBpdCBpcyByZXR1cm5lZC5cbiAgICogICAgICAgICAgICAgICAgSWYgdGhpcyByZXR1cm5zIGZhbHNlLCB0aGUgcmVzb3VyY2Ugd2lsbCBiZSBldmljdGVkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24ocmVzb3VyY2U6IG9iamVjdCwgb2JzZXJ2ZXI6IHsgb25FcnJvciB9KTogdm9pZH0gaW5zdGFsbElkbGVPYnNlcnZlclxuICAgKiAgICAgICAgICAgICAgICBjYWxsZWQgd2hlbiB0aGUgcmVzb3VyY2UgaXMgcmVsZWFzZWQgYmFjayB0byBwb29sXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24ocmVzb3VyY2U6IG9iamVjdCk6IHZvaWR9IHJlbW92ZUlkbGVPYnNlcnZlclxuICAgKiAgICAgICAgICAgICAgICBjYWxsZWQgd2hlbiB0aGUgcmVzb3VyY2UgaXMgYWNxdWlyZWQgZnJvbSB0aGUgcG9vbFxuICAgKiBAcGFyYW0ge1Bvb2xDb25maWd9IGNvbmZpZyBjb25maWd1cmF0aW9uIGZvciB0aGUgbmV3IGRyaXZlci5cbiAgICogQHBhcmFtIHtMb2dnZXJ9IGxvZyB0aGUgZHJpdmVyIGxvZ2dlci5cbiAgICovXG4gIGZ1bmN0aW9uIFBvb2woKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBfcmVmJGNyZWF0ZSA9IF9yZWYuY3JlYXRlLFxuICAgICAgICBjcmVhdGUgPSBfcmVmJGNyZWF0ZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGFkZHJlc3MsIHJlbGVhc2UpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9IDogX3JlZiRjcmVhdGUsXG4gICAgICAgIF9yZWYkZGVzdHJveSA9IF9yZWYuZGVzdHJveSxcbiAgICAgICAgZGVzdHJveSA9IF9yZWYkZGVzdHJveSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGNvbm4pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9IDogX3JlZiRkZXN0cm95LFxuICAgICAgICBfcmVmJHZhbGlkYXRlID0gX3JlZi52YWxpZGF0ZSxcbiAgICAgICAgdmFsaWRhdGUgPSBfcmVmJHZhbGlkYXRlID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoY29ubikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSA6IF9yZWYkdmFsaWRhdGUsXG4gICAgICAgIF9yZWYkaW5zdGFsbElkbGVPYnNlciA9IF9yZWYuaW5zdGFsbElkbGVPYnNlcnZlcixcbiAgICAgICAgaW5zdGFsbElkbGVPYnNlcnZlciA9IF9yZWYkaW5zdGFsbElkbGVPYnNlciA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGNvbm4sIG9ic2VydmVyKSB7fSA6IF9yZWYkaW5zdGFsbElkbGVPYnNlcixcbiAgICAgICAgX3JlZiRyZW1vdmVJZGxlT2JzZXJ2ID0gX3JlZi5yZW1vdmVJZGxlT2JzZXJ2ZXIsXG4gICAgICAgIHJlbW92ZUlkbGVPYnNlcnZlciA9IF9yZWYkcmVtb3ZlSWRsZU9ic2VydiA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGNvbm4pIHt9IDogX3JlZiRyZW1vdmVJZGxlT2JzZXJ2LFxuICAgICAgICBfcmVmJGNvbmZpZyA9IF9yZWYuY29uZmlnLFxuICAgICAgICBjb25maWcgPSBfcmVmJGNvbmZpZyA9PT0gdm9pZCAwID8gX3Bvb2xDb25maWdbXCJkZWZhdWx0XCJdLmRlZmF1bHRDb25maWcoKSA6IF9yZWYkY29uZmlnLFxuICAgICAgICBfcmVmJGxvZyA9IF9yZWYubG9nLFxuICAgICAgICBsb2cgPSBfcmVmJGxvZyA9PT0gdm9pZCAwID8gX2xvZ2dlcltcImRlZmF1bHRcIl0ubm9PcCgpIDogX3JlZiRsb2c7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFBvb2wpO1xuICAgIHRoaXMuX2NyZWF0ZSA9IGNyZWF0ZTtcbiAgICB0aGlzLl9kZXN0cm95ID0gZGVzdHJveTtcbiAgICB0aGlzLl92YWxpZGF0ZSA9IHZhbGlkYXRlO1xuICAgIHRoaXMuX2luc3RhbGxJZGxlT2JzZXJ2ZXIgPSBpbnN0YWxsSWRsZU9ic2VydmVyO1xuICAgIHRoaXMuX3JlbW92ZUlkbGVPYnNlcnZlciA9IHJlbW92ZUlkbGVPYnNlcnZlcjtcbiAgICB0aGlzLl9tYXhTaXplID0gY29uZmlnLm1heFNpemU7XG4gICAgdGhpcy5fYWNxdWlzaXRpb25UaW1lb3V0ID0gY29uZmlnLmFjcXVpc2l0aW9uVGltZW91dDtcbiAgICB0aGlzLl9wb29scyA9IHt9O1xuICAgIHRoaXMuX3BlbmRpbmdDcmVhdGVzID0ge307XG4gICAgdGhpcy5fYWNxdWlyZVJlcXVlc3RzID0ge307XG4gICAgdGhpcy5fYWN0aXZlUmVzb3VyY2VDb3VudHMgPSB7fTtcbiAgICB0aGlzLl9yZWxlYXNlID0gdGhpcy5fcmVsZWFzZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2xvZyA9IGxvZztcbiAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQWNxdWlyZSBhbmQgaWRsZSByZXNvdXJjZSBmb20gdGhlIHBvb2wgb3IgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICogQHBhcmFtIHtTZXJ2ZXJBZGRyZXNzfSBhZGRyZXNzIHRoZSBhZGRyZXNzIGZvciB3aGljaCB3ZSdyZSBhY3F1aXJpbmcuXG4gICAqIEByZXR1cm4ge09iamVjdH0gcmVzb3VyY2UgdGhhdCBpcyByZWFkeSB0byB1c2UuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShQb29sLCBbe1xuICAgIGtleTogXCJhY3F1aXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjcXVpcmUoYWRkcmVzcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuX2FjcXVpcmUoYWRkcmVzcykudGhlbihmdW5jdGlvbiAocmVzb3VyY2UpIHtcbiAgICAgICAgdmFyIGtleSA9IGFkZHJlc3MuYXNLZXkoKTtcblxuICAgICAgICBpZiAocmVzb3VyY2UpIHtcbiAgICAgICAgICByZXNvdXJjZUFjcXVpcmVkKGtleSwgX3RoaXMuX2FjdGl2ZVJlc291cmNlQ291bnRzKTtcblxuICAgICAgICAgIGlmIChfdGhpcy5fbG9nLmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoXCJcIi5jb25jYXQocmVzb3VyY2UsIFwiIGFjcXVpcmVkIGZyb20gdGhlIHBvb2wgXCIpLmNvbmNhdChrZXkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzb3VyY2U7XG4gICAgICAgIH0gLy8gV2UncmUgb3V0IG9mIHJlc291cmNlcyBhbmQgd2lsbCB0cnkgdG8gYWNxdWlyZSBsYXRlciBvbiB3aGVuIGFuIGV4aXN0aW5nIHJlc291cmNlIGlzIHJlbGVhc2VkLlxuXG5cbiAgICAgICAgdmFyIGFsbFJlcXVlc3RzID0gX3RoaXMuX2FjcXVpcmVSZXF1ZXN0cztcbiAgICAgICAgdmFyIHJlcXVlc3RzID0gYWxsUmVxdWVzdHNba2V5XTtcblxuICAgICAgICBpZiAoIXJlcXVlc3RzKSB7XG4gICAgICAgICAgYWxsUmVxdWVzdHNba2V5XSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgcmVxdWVzdDtcbiAgICAgICAgICB2YXIgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBhY3F1aXNpdGlvbiB0aW1lb3V0IGZpcmVkXG4gICAgICAgICAgICAvLyByZW1vdmUgcmVxdWVzdCBmcm9tIHRoZSBxdWV1ZSBvZiBwZW5kaW5nIHJlcXVlc3RzLCBpZiBpdCdzIHN0aWxsIHRoZXJlXG4gICAgICAgICAgICAvLyByZXF1ZXN0IG1pZ2h0J3ZlIGJlZW4gdGFrZW4gb3V0IGJ5IHRoZSByZWxlYXNlIG9wZXJhdGlvblxuICAgICAgICAgICAgdmFyIHBlbmRpbmdSZXF1ZXN0cyA9IGFsbFJlcXVlc3RzW2tleV07XG5cbiAgICAgICAgICAgIGlmIChwZW5kaW5nUmVxdWVzdHMpIHtcbiAgICAgICAgICAgICAgYWxsUmVxdWVzdHNba2V5XSA9IHBlbmRpbmdSZXF1ZXN0cy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbSAhPT0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmlzQ29tcGxldGVkKCkpIHsvLyByZXF1ZXN0IGFscmVhZHkgcmVzb2x2ZWQvcmVqZWN0ZWQgYnkgdGhlIHJlbGVhc2Ugb3BlcmF0aW9uOyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZXF1ZXN0IGlzIHN0aWxsIHBlbmRpbmcgYW5kIG5lZWRzIHRvIGJlIGZhaWxlZFxuICAgICAgICAgICAgICB2YXIgYWN0aXZlQ291bnQgPSBfdGhpcy5hY3RpdmVSZXNvdXJjZUNvdW50KGFkZHJlc3MpO1xuXG4gICAgICAgICAgICAgIHZhciBpZGxlQ291bnQgPSBfdGhpcy5oYXMoYWRkcmVzcykgPyBfdGhpcy5fcG9vbHNba2V5XS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICByZXF1ZXN0LnJlamVjdCgoMCwgX2Vycm9yLm5ld0Vycm9yKShcIkNvbm5lY3Rpb24gYWNxdWlzaXRpb24gdGltZWQgb3V0IGluIFwiLmNvbmNhdChfdGhpcy5fYWNxdWlzaXRpb25UaW1lb3V0LCBcIiBtcy4gUG9vcyBzdGF0dXM6IEFjdGl2ZSBjb25uIGNvdW50ID0gXCIpLmNvbmNhdChhY3RpdmVDb3VudCwgXCIsIElkbGUgY29ubiBjb3VudCA9IFwiKS5jb25jYXQoaWRsZUNvdW50LCBcIi5cIikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBfdGhpcy5fYWNxdWlzaXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZXF1ZXN0ID0gbmV3IFBlbmRpbmdSZXF1ZXN0KGtleSwgcmVzb2x2ZSwgcmVqZWN0LCB0aW1lb3V0SWQsIF90aGlzLl9sb2cpO1xuICAgICAgICAgIGFsbFJlcXVlc3RzW2tleV0ucHVzaChyZXF1ZXN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBhbGwgaWRsZSByZXNvdXJjZXMgZm9yIHRoZSBnaXZlbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7U2VydmVyQWRkcmVzc30gYWRkcmVzcyB0aGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyIHRvIHB1cmdlIGl0cyBwb29sLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSByZXNvdXJjZXMgYXJlIHB1cmdlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHVyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVyZ2UoYWRkcmVzcykge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1cmdlS2V5KGFkZHJlc3MuYXNLZXkoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYWxsIGlkbGUgcmVzb3VyY2VzIGluIHRoaXMgcG9vbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgcmVzb3VyY2VzIGFyZSBwdXJnZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoT2JqZWN0LmtleXModGhpcy5fcG9vbHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuX3B1cmdlS2V5KGtleSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEtlZXAgdGhlIGlkbGUgcmVzb3VyY2VzIGZvciB0aGUgcHJvdmlkZWQgYWRkcmVzc2VzIGFuZCBwdXJnZSB0aGUgcmVzdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgb3RoZXIgcmVzb3VyY2VzIGFyZSBwdXJnZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImtlZXBBbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2VlcEFsbChhZGRyZXNzZXMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIga2V5c1RvS2VlcCA9IGFkZHJlc3Nlcy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGEuYXNLZXkoKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGtleXNQcmVzZW50ID0gT2JqZWN0LmtleXModGhpcy5fcG9vbHMpO1xuICAgICAgdmFyIGtleXNUb1B1cmdlID0ga2V5c1ByZXNlbnQuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrZXlzVG9LZWVwLmluZGV4T2YoaykgPT09IC0xO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoa2V5c1RvUHVyZ2UubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5fcHVyZ2VLZXkoa2V5KTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBwb29sIGNvbnRhaW5zIHJlc291cmNlcyBmb3IgdGhlIGdpdmVuIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHtTZXJ2ZXJBZGRyZXNzfSBhZGRyZXNzIHRoZSBhZGRyZXNzIG9mIHRoZSBzZXJ2ZXIgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIHdoZW4gcG9vbCBjb250YWlucyBlbnRyaWVzIGZvciB0aGUgZ2l2ZW4ga2V5LCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhhZGRyZXNzKSB7XG4gICAgICByZXR1cm4gYWRkcmVzcy5hc0tleSgpIGluIHRoaXMuX3Bvb2xzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgY291bnQgb2YgYWN0aXZlIChjaGVja2VkIG91dCBvZiB0aGUgcG9vbCkgcmVzb3VyY2VzIGZvciB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqIEBwYXJhbSB7U2VydmVyQWRkcmVzc30gYWRkcmVzcyB0aGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gY291bnQgb2YgcmVzb3VyY2VzIGFjcXVpcmVkIGJ5IGNsaWVudHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhY3RpdmVSZXNvdXJjZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjdGl2ZVJlc291cmNlQ291bnQoYWRkcmVzcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVJlc291cmNlQ291bnRzW2FkZHJlc3MuYXNLZXkoKV0gfHwgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FjcXVpcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hY3F1aXJlMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIGtleSwgcG9vbCwgX3Jlc291cmNlLCBudW1Db25uZWN0aW9ucywgcmVzb3VyY2U7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnUG9vbCBpcyBjbG9zZWQsIGl0IGlzIG5vIG1vcmUgYWJsZSB0byBzZXJ2ZSByZXF1ZXN0cy4nKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAga2V5ID0gYWRkcmVzcy5hc0tleSgpO1xuICAgICAgICAgICAgICAgIHBvb2wgPSB0aGlzLl9wb29sc1trZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwb29sKSB7XG4gICAgICAgICAgICAgICAgICBwb29sID0gW107XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wb29sc1trZXldID0gcG9vbDtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDcmVhdGVzW2tleV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgaWYgKCFwb29sLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3Jlc291cmNlID0gcG9vbC5wb3AoKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGUoX3Jlc291cmNlKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlbW92ZUlkbGVPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSWRsZU9ic2VydmVyKF9yZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfSAvLyBpZGxlIHJlc291cmNlIGlzIHZhbGlkIGFuZCBjYW4gYmUgYWNxdWlyZWRcblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBQcm9taXNlLnJlc29sdmUoX3Jlc291cmNlKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc3Ryb3koX3Jlc291cmNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcy5fbWF4U2l6ZSA+IDApKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHBlbmRpbmcgY3JlYXRlcyB3aGVuIGNoZWNraW5nIHBvb2wgc2l6ZSBzaW5jZSB0aGVzZSBwcm9iYWJseSB3aWxsIGFkZFxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBudW1iZXIgd2hlbiBmdWxmaWxsZWQuXG4gICAgICAgICAgICAgICAgbnVtQ29ubmVjdGlvbnMgPSB0aGlzLmFjdGl2ZVJlc291cmNlQ291bnQoYWRkcmVzcykgKyB0aGlzLl9wZW5kaW5nQ3JlYXRlc1trZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEobnVtQ29ubmVjdGlvbnMgPj0gdGhpcy5fbWF4U2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBleGlzdCBubyBpZGxlIHZhbGlkIHJlc291cmNlcywgY3JlYXRlIGEgbmV3IG9uZSBmb3IgYWNxdWlzaXRpb25cbiAgICAgICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIGhvdyBtYW55IHBlbmRpbmcgY3JlYXRlcyB0aGVyZSBhcmUgdG8gYXZvaWQgbWFraW5nIHRvbyBtYW55IGNvbm5lY3Rpb25zLlxuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDcmVhdGVzW2tleV0gPSB0aGlzLl9wZW5kaW5nQ3JlYXRlc1trZXldICsgMTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjE7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGUoYWRkcmVzcywgdGhpcy5fcmVsZWFzZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgICByZXNvdXJjZSA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0NyZWF0ZXNba2V5XSA9IHRoaXMuX3BlbmRpbmdDcmVhdGVzW2tleV0gLSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMjUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXNvdXJjZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzIxLCwgMjUsIDI4XV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfYWNxdWlyZShfeCkge1xuICAgICAgICByZXR1cm4gX2FjcXVpcmUyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfYWNxdWlyZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfcmVsZWFzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlbGVhc2UyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGFkZHJlc3MsIHJlc291cmNlKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBrZXksIHBvb2w7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGtleSA9IGFkZHJlc3MuYXNLZXkoKTtcbiAgICAgICAgICAgICAgICBwb29sID0gdGhpcy5fcG9vbHNba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmICghcG9vbCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl92YWxpZGF0ZShyZXNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb2cuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiXCIuY29uY2F0KHJlc291cmNlLCBcIiBkZXN0cm95ZWQgYW5kIGNhbid0IGJlIHJlbGVhc2VkIHRvIHRoZSBwb29sIFwiKS5jb25jYXQoa2V5LCBcIiBiZWNhdXNlIGl0IGlzIG5vdCBmdW5jdGlvbmFsXCIpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc3Ryb3kocmVzb3VyY2UpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5zdGFsbElkbGVPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5faW5zdGFsbElkbGVPYnNlcnZlcihyZXNvdXJjZSwge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXM0Ll9sb2cuZGVidWcoXCJJZGxlIGNvbm5lY3Rpb24gXCIuY29uY2F0KHJlc291cmNlLCBcIiBkZXN0cm95ZWQgYmVjYXVzZSBvZiBlcnJvcjogXCIpLmNvbmNhdChlcnJvcikpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHBvb2wgPSBfdGhpczQuX3Bvb2xzW2tleV07XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAocG9vbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXM0Ll9wb29sc1trZXldID0gcG9vbC5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgIT09IHJlc291cmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSAvLyBsZXQncyBub3QgY2FyZSBhYm91dCBiYWNrZ3JvdW5kIGNsZWFuLXVwcyBkdWUgdG8gZXJyb3JzIGJ1dCBqdXN0IHRyaWdnZXIgdGhlIGRlc3Ryb3lcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIGZvciB0aGUgcmVzb3VyY2UsIHdlIGVzcGVjaWFsbHkgY2F0Y2ggYW55IGVycm9ycyBhbmQgaWdub3JlIHRoZW0gdG8gYXZvaWRcbiAgICAgICAgICAgICAgICAgICAgICAvLyB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24gd2FybmluZ3NcblxuXG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXM0Ll9kZXN0cm95KHJlc291cmNlKVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcG9vbC5wdXNoKHJlc291cmNlKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb2cuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiXCIuY29uY2F0KHJlc291cmNlLCBcIiByZWxlYXNlZCB0byB0aGUgcG9vbCBcIikuY29uY2F0KGtleSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAvLyBrZXkgaGFzIGJlZW4gcHVyZ2VkLCBkb24ndCBwdXQgaXQgYmFjaywganVzdCBkZXN0cm95IHRoZSByZXNvdXJjZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb2cuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiXCIuY29uY2F0KHJlc291cmNlLCBcIiBkZXN0cm95ZWQgYW5kIGNhbid0IGJlIHJlbGVhc2VkIHRvIHRoZSBwb29sIFwiKS5jb25jYXQoa2V5LCBcIiBiZWNhdXNlIHBvb2wgaGFzIGJlZW4gcHVyZ2VkXCIpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE3O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXN0cm95KHJlc291cmNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgIHJlc291cmNlUmVsZWFzZWQoa2V5LCB0aGlzLl9hY3RpdmVSZXNvdXJjZUNvdW50cyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzUGVuZGluZ0FjcXVpcmVSZXF1ZXN0cyhhZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9yZWxlYXNlKF94MiwgX3gzKSB7XG4gICAgICAgIHJldHVybiBfcmVsZWFzZTIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9yZWxlYXNlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9wdXJnZUtleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3B1cmdlS2V5MiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhrZXkpIHtcbiAgICAgICAgdmFyIHBvb2wsIHJlc291cmNlO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBwb29sID0gdGhpcy5fcG9vbHNba2V5XSB8fCBbXTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKCFwb29sLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzb3VyY2UgPSBwb29sLnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlbW92ZUlkbGVPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSWRsZU9ic2VydmVyKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc3Ryb3kocmVzb3VyY2UpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wb29sc1trZXldO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfcHVyZ2VLZXkoX3g0KSB7XG4gICAgICAgIHJldHVybiBfcHVyZ2VLZXkyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcHVyZ2VLZXk7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Byb2Nlc3NQZW5kaW5nQWNxdWlyZVJlcXVlc3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcm9jZXNzUGVuZGluZ0FjcXVpcmVSZXF1ZXN0cyhhZGRyZXNzKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGtleSA9IGFkZHJlc3MuYXNLZXkoKTtcbiAgICAgIHZhciByZXF1ZXN0cyA9IHRoaXMuX2FjcXVpcmVSZXF1ZXN0c1trZXldO1xuXG4gICAgICBpZiAocmVxdWVzdHMpIHtcbiAgICAgICAgdmFyIHBlbmRpbmdSZXF1ZXN0ID0gcmVxdWVzdHMuc2hpZnQoKTsgLy8gcG9wIGEgcGVuZGluZyBhY3F1aXJlIHJlcXVlc3RcblxuICAgICAgICBpZiAocGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgICAgICB0aGlzLl9hY3F1aXJlKGFkZHJlc3MpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBmYWlsZWQgdG8gYWNxdWlyZS9jcmVhdGUgYSBuZXcgY29ubmVjdGlvbiB0byByZXNvbHZlIHRoZSBwZW5kaW5nIGFjcXVpcmUgcmVxdWVzdFxuICAgICAgICAgICAgLy8gcHJvcGFnYXRlIHRoZSBlcnJvciBieSBmYWlsaW5nIHRoZSBwZW5kaW5nIHJlcXVlc3RcbiAgICAgICAgICAgIHBlbmRpbmdSZXF1ZXN0LnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHJlc291cmNlKSB7XG4gICAgICAgICAgICAgIC8vIG1hbmFnZWQgdG8gYWNxdWlyZSBhIHZhbGlkIHJlc291cmNlIGZyb20gdGhlIHBvb2xcbiAgICAgICAgICAgICAgaWYgKHBlbmRpbmdSZXF1ZXN0LmlzQ29tcGxldGVkKCkpIHtcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGhhcyBiZWVuIGNvbXBsZXRlZCwgbW9zdCBsaWtlbHkgZmFpbGVkIGJ5IGEgdGltZW91dFxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgYWNxdWlyZWQgcmVzb3VyY2UgYmFjayB0byB0aGUgcG9vbFxuICAgICAgICAgICAgICAgIF90aGlzNS5fcmVsZWFzZShhZGRyZXNzLCByZXNvdXJjZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBpcyBzdGlsbCBwZW5kaW5nIGFuZCBjYW4gYmUgcmVzb2x2ZWQgd2l0aCB0aGUgbmV3bHkgYWNxdWlyZWQgcmVzb3VyY2VcbiAgICAgICAgICAgICAgICByZXNvdXJjZUFjcXVpcmVkKGtleSwgX3RoaXM1Ll9hY3RpdmVSZXNvdXJjZUNvdW50cyk7IC8vIGluY3JlbWVudCB0aGUgYWN0aXZlIGNvdW50ZXJcblxuICAgICAgICAgICAgICAgIHBlbmRpbmdSZXF1ZXN0LnJlc29sdmUocmVzb3VyY2UpOyAvLyByZXNvbHZlIHRoZSBwZW5kaW5nIHJlcXVlc3Qgd2l0aCB0aGUgYWNxdWlyZWQgcmVzb3VyY2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hY3F1aXJlUmVxdWVzdHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUG9vbDtcbn0oKTtcbi8qKlxuICogSW5jcmVtZW50IGFjdGl2ZSAoY2hlY2tlZCBvdXQgb2YgdGhlIHBvb2wpIHJlc291cmNlIGNvdW50ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRoZSByZXNvdXJjZSBncm91cCBpZGVudGlmaWVyIChzZXJ2ZXIgYWRkcmVzcyBmb3IgY29ubmVjdGlvbnMpLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gYWN0aXZlUmVzb3VyY2VDb3VudHMgdGhlIG9iamVjdCBob2xkaW5nIGFjdGl2ZSBjb3VudHMgcGVyIGtleS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlc291cmNlQWNxdWlyZWQoa2V5LCBhY3RpdmVSZXNvdXJjZUNvdW50cykge1xuICB2YXIgY3VycmVudENvdW50ID0gYWN0aXZlUmVzb3VyY2VDb3VudHNba2V5XSB8fCAwO1xuICBhY3RpdmVSZXNvdXJjZUNvdW50c1trZXldID0gY3VycmVudENvdW50ICsgMTtcbn1cbi8qKlxuICogRGVjcmVtZW50IGFjdGl2ZSAoY2hlY2tlZCBvdXQgb2YgdGhlIHBvb2wpIHJlc291cmNlIGNvdW50ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRoZSByZXNvdXJjZSBncm91cCBpZGVudGlmaWVyIChzZXJ2ZXIgYWRkcmVzcyBmb3IgY29ubmVjdGlvbnMpLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gYWN0aXZlUmVzb3VyY2VDb3VudHMgdGhlIG9iamVjdCBob2xkaW5nIGFjdGl2ZSBjb3VudHMgcGVyIGtleS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlc291cmNlUmVsZWFzZWQoa2V5LCBhY3RpdmVSZXNvdXJjZUNvdW50cykge1xuICB2YXIgY3VycmVudENvdW50ID0gYWN0aXZlUmVzb3VyY2VDb3VudHNba2V5XSB8fCAwO1xuICB2YXIgbmV4dENvdW50ID0gY3VycmVudENvdW50IC0gMTtcblxuICBpZiAobmV4dENvdW50ID4gMCkge1xuICAgIGFjdGl2ZVJlc291cmNlQ291bnRzW2tleV0gPSBuZXh0Q291bnQ7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIGFjdGl2ZVJlc291cmNlQ291bnRzW2tleV07XG4gIH1cbn1cblxudmFyIFBlbmRpbmdSZXF1ZXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGVuZGluZ1JlcXVlc3Qoa2V5LCByZXNvbHZlLCByZWplY3QsIHRpbWVvdXRJZCwgbG9nKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBQZW5kaW5nUmVxdWVzdCk7XG4gICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIHRoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICB0aGlzLl90aW1lb3V0SWQgPSB0aW1lb3V0SWQ7XG4gICAgdGhpcy5fbG9nID0gbG9nO1xuICAgIHRoaXMuX2NvbXBsZXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShQZW5kaW5nUmVxdWVzdCwgW3tcbiAgICBrZXk6IFwiaXNDb21wbGV0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNDb21wbGV0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29tcGxldGVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmUocmVzb3VyY2UpIHtcbiAgICAgIGlmICh0aGlzLl9jb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJZCk7XG5cbiAgICAgIGlmICh0aGlzLl9sb2cuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJcIi5jb25jYXQocmVzb3VyY2UsIFwiIGFjcXVpcmVkIGZyb20gdGhlIHBvb2wgXCIpLmNvbmNhdCh0aGlzLl9rZXkpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVzb2x2ZShyZXNvdXJjZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWplY3QoZXJyb3IpIHtcbiAgICAgIGlmICh0aGlzLl9jb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJZCk7XG5cbiAgICAgIHRoaXMuX3JlamVjdChlcnJvcik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQZW5kaW5nUmVxdWVzdDtcbn0oKTtcblxudmFyIF9kZWZhdWx0ID0gUG9vbDtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfbm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIik7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG5cbnZhciBfYm9sdFByb3RvY29sViA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYm9sdC1wcm90b2NvbC12MVwiKSk7XG5cbnZhciBfYm9sdFByb3RvY29sVjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2JvbHQtcHJvdG9jb2wtdjJcIikpO1xuXG52YXIgX2JvbHRQcm90b2NvbFYzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ib2x0LXByb3RvY29sLXYzXCIpKTtcblxudmFyIF9ib2x0UHJvdG9jb2xWNHggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2JvbHQtcHJvdG9jb2wtdjR4MFwiKSk7XG5cbnZhciBfYm9sdFByb3RvY29sVjR4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYm9sdC1wcm90b2NvbC12NHgxXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQk9MVF9NQUdJQ19QUkVBTUJMRSA9IDB4NjA2MGIwMTc7XG5cbnZhciBQcm90b2NvbEhhbmRzaGFrZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvbiB0aGUgY29ubmVjdGlvbiBvd25pbmcgdGhpcyBwcm90b2NvbC5cbiAgICogQHBhcmFtIHtDaGFubmVsfSBjaGFubmVsIHRoZSBuZXR3b3JrIGNoYW5uZWwuXG4gICAqIEBwYXJhbSB7Q2h1bmtlcn0gY2h1bmtlciB0aGUgbWVzc2FnZSBjaHVua2VyLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVMb3NzbGVzc0ludGVnZXJzIGZsYWcgdG8gdXNlIG5hdGl2ZSBKUyBudW1iZXJzLlxuICAgKiBAcGFyYW0ge0xvZ2dlcn0gbG9nIHRoZSBsb2dnZXIuXG4gICAqL1xuICBmdW5jdGlvbiBQcm90b2NvbEhhbmRzaGFrZXIoY29ubmVjdGlvbiwgY2hhbm5lbCwgY2h1bmtlciwgZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMsIGxvZykge1xuICAgIHZhciBzZXJ2ZXJzaWRlUm91dGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogbnVsbDtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFByb3RvY29sSGFuZHNoYWtlcik7XG4gICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5fY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgdGhpcy5fY2h1bmtlciA9IGNodW5rZXI7XG4gICAgdGhpcy5fZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMgPSBkaXNhYmxlTG9zc2xlc3NJbnRlZ2VycztcbiAgICB0aGlzLl9sb2cgPSBsb2c7XG4gICAgdGhpcy5fc2VydmVyc2lkZVJvdXRpbmcgPSBzZXJ2ZXJzaWRlUm91dGluZztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBCb2x0IGhhbmRzaGFrZSBpbnRvIHRoZSB1bmRlcmx5aW5nIG5ldHdvcmsgY2hhbm5lbC5cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFByb3RvY29sSGFuZHNoYWtlciwgW3tcbiAgICBrZXk6IFwid3JpdGVIYW5kc2hha2VSZXF1ZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlSGFuZHNoYWtlUmVxdWVzdCgpIHtcbiAgICAgIHRoaXMuX2NoYW5uZWwud3JpdGUobmV3SGFuZHNoYWtlQnVmZmVyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBnaXZlbiBoYW5kc2hha2UgcmVzcG9uc2UgYW5kIGNyZWF0ZSB0aGUgbmVnb3RpYXRlZCBib2x0IHByb3RvY29sLlxuICAgICAqIEBwYXJhbSB7QmFzZUJ1ZmZlcn0gYnVmZmVyIGJ5dGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGhhbmRzaGFrZSByZXNwb25zZS5cbiAgICAgKiBAcmV0dXJuIHtCb2x0UHJvdG9jb2x9IGJvbHQgcHJvdG9jb2wgY29ycmVzcG9uZGluZyB0byB0aGUgdmVyc2lvbiBzdWdnZXN0ZWQgYnkgdGhlIGRhdGFiYXNlLlxuICAgICAqIEB0aHJvd3Mge05lbzRqRXJyb3J9IHdoZW4gYm9sdCBwcm90b2NvbCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVOZWdvdGlhdGVkUHJvdG9jb2xcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlTmVnb3RpYXRlZFByb3RvY29sKGJ1ZmZlcikge1xuICAgICAgdmFyIGggPSBbYnVmZmVyLnJlYWRVSW50OCgpLCBidWZmZXIucmVhZFVJbnQ4KCksIGJ1ZmZlci5yZWFkVUludDgoKSwgYnVmZmVyLnJlYWRVSW50OCgpXTtcblxuICAgICAgaWYgKGhbMF0gPT09IDB4NDggJiYgaFsxXSA9PT0gMHg1NCAmJiBoWzJdID09PSAweDU0ICYmIGhbM10gPT09IDB4NTApIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ1NlcnZlciByZXNwb25kZWQgSFRUUC4gTWFrZSBzdXJlIHlvdSBhcmUgbm90IHRyeWluZyB0byBjb25uZWN0IHRvIHRoZSBodHRwIGVuZHBvaW50ICcgKyAnKEhUVFAgZGVmYXVsdHMgdG8gcG9ydCA3NDc0IHdoZXJlYXMgQk9MVCBkZWZhdWx0cyB0byBwb3J0IDc2ODcpJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWdvdGlhdGVkVmVyc2lvbiA9IE51bWJlcihoWzNdICsgJy4nICsgaFsyXSk7XG5cbiAgICAgIGlmICh0aGlzLl9sb2cuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJcIi5jb25jYXQodGhpcy5fY29ubmVjdGlvbiwgXCIgbmVnb3RpYXRlZCBwcm90b2NvbCB2ZXJzaW9uIFwiKS5jb25jYXQobmVnb3RpYXRlZFZlcnNpb24pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVByb3RvY29sV2l0aFZlcnNpb24obmVnb3RpYXRlZFZlcnNpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtCb2x0UHJvdG9jb2x9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVQcm90b2NvbFdpdGhWZXJzaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVQcm90b2NvbFdpdGhWZXJzaW9uKHZlcnNpb24pIHtcbiAgICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIG5ldyBfYm9sdFByb3RvY29sVltcImRlZmF1bHRcIl0odGhpcy5fY29ubmVjdGlvbiwgdGhpcy5fY2h1bmtlciwgdGhpcy5fZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gbmV3IF9ib2x0UHJvdG9jb2xWMltcImRlZmF1bHRcIl0odGhpcy5fY29ubmVjdGlvbiwgdGhpcy5fY2h1bmtlciwgdGhpcy5fZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gbmV3IF9ib2x0UHJvdG9jb2xWM1tcImRlZmF1bHRcIl0odGhpcy5fY29ubmVjdGlvbiwgdGhpcy5fY2h1bmtlciwgdGhpcy5fZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xuXG4gICAgICAgIGNhc2UgNC4wOlxuICAgICAgICAgIHJldHVybiBuZXcgX2JvbHRQcm90b2NvbFY0eFtcImRlZmF1bHRcIl0odGhpcy5fY29ubmVjdGlvbiwgdGhpcy5fY2h1bmtlciwgdGhpcy5fZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xuXG4gICAgICAgIGNhc2UgNC4xOlxuICAgICAgICAgIHJldHVybiBuZXcgX2JvbHRQcm90b2NvbFY0eDJbXCJkZWZhdWx0XCJdKHRoaXMuX2Nvbm5lY3Rpb24sIHRoaXMuX2NodW5rZXIsIHRoaXMuX2Rpc2FibGVMb3NzbGVzc0ludGVnZXJzLCB0aGlzLl9zZXJ2ZXJzaWRlUm91dGluZyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnVW5rbm93biBCb2x0IHByb3RvY29sIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFByb3RvY29sSGFuZHNoYWtlcjtcbn0oKTtcbi8qKlxuICogQHJldHVybiB7QmFzZUJ1ZmZlcn1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFByb3RvY29sSGFuZHNoYWtlcjtcblxuZnVuY3Rpb24gbmV3SGFuZHNoYWtlQnVmZmVyKCkge1xuICB2YXIgaGFuZHNoYWtlQnVmZmVyID0gKDAsIF9ub2RlLmFsbG9jKSg1ICogNCk7IC8vIG1hZ2ljIHByZWFtYmxlXG5cbiAgaGFuZHNoYWtlQnVmZmVyLndyaXRlSW50MzIoQk9MVF9NQUdJQ19QUkVBTUJMRSk7IC8vIHByb3Bvc2VkIHZlcnNpb25zXG5cbiAgaGFuZHNoYWtlQnVmZmVyLndyaXRlSW50MzIoMSA8PCA4IHwgNCk7XG4gIGhhbmRzaGFrZUJ1ZmZlci53cml0ZUludDMyKDQpO1xuICBoYW5kc2hha2VCdWZmZXIud3JpdGVJbnQzMigzKTtcbiAgaGFuZHNoYWtlQnVmZmVyLndyaXRlSW50MzIoMik7IC8vIHJlc2V0IHRoZSByZWFkZXIgcG9zaXRpb25cblxuICBoYW5kc2hha2VCdWZmZXIucmVzZXQoKTtcbiAgcmV0dXJuIGhhbmRzaGFrZUJ1ZmZlcjtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcm91dGluZ1RhYmxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yb3V0aW5nLXRhYmxlXCIpKTtcblxudmFyIF9yb3V0aW5nVXRpbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm91dGluZy11dGlsXCIpKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuLi9lcnJvclwiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgUmVkaXNjb3ZlcnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Um91dGluZ1V0aWx9IHJvdXRpbmdVdGlsIHRoZSB1dGlsIHRvIHVzZS5cbiAgICovXG4gIGZ1bmN0aW9uIFJlZGlzY292ZXJ5KHJvdXRpbmdVdGlsKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBSZWRpc2NvdmVyeSk7XG4gICAgdGhpcy5fcm91dGluZ1V0aWwgPSByb3V0aW5nVXRpbDtcbiAgfVxuICAvKipcbiAgICogVHJ5IHRvIGZldGNoIG5ldyByb3V0aW5nIHRhYmxlIGZyb20gdGhlIGdpdmVuIHJvdXRlci5cbiAgICogQHBhcmFtIHtTZXNzaW9ufSBzZXNzaW9uIHRoZSBzZXNzaW9uIHRvIHVzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlIHRoZSBkYXRhYmFzZSBmb3Igd2hpY2ggdG8gbG9va3VwIHJvdXRpbmcgdGFibGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb3V0ZXJBZGRyZXNzIHRoZSBVUkwgb2YgdGhlIHJvdXRlci5cbiAgICogQHJldHVybiB7UHJvbWlzZTxSb3V0aW5nVGFibGU+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggbmV3IHJvdXRpbmcgdGFibGUgb3IgbnVsbCB3aGVuIGNvbm5lY3Rpb24gZXJyb3IgaGFwcGVuZWQuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShSZWRpc2NvdmVyeSwgW3tcbiAgICBrZXk6IFwibG9va3VwUm91dGluZ1RhYmxlT25Sb3V0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9sb29rdXBSb3V0aW5nVGFibGVPblJvdXRlciA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKHNlc3Npb24sIGRhdGFiYXNlLCByb3V0ZXJBZGRyZXNzKSB7XG4gICAgICAgIHZhciByZWNvcmRzLCByZWNvcmQsIGV4cGlyYXRpb25UaW1lLCBfdGhpcyRfcm91dGluZ1V0aWwkcGEsIHJvdXRlcnMsIHJlYWRlcnMsIHdyaXRlcnM7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm91dGluZ1V0aWwuY2FsbFJvdXRpbmdQcm9jZWR1cmUoc2Vzc2lvbiwgZGF0YWJhc2UsIHJvdXRlckFkZHJlc3MpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZWNvcmRzID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICAgIGlmICghKHJlY29yZHMgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGlmICghKHJlY29yZHMubGVuZ3RoICE9PSAxKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnSWxsZWdhbCByZXNwb25zZSBmcm9tIHJvdXRlciBcIicgKyByb3V0ZXJBZGRyZXNzICsgJ1wiLiAnICsgJ1JlY2VpdmVkICcgKyByZWNvcmRzLmxlbmd0aCArICcgcmVjb3JkcyBidXQgZXhwZWN0ZWQgb25seSBvbmUuXFxuJyArIEpTT04uc3RyaW5naWZ5KHJlY29yZHMpLCBfZXJyb3IuUFJPVE9DT0xfRVJST1IpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICByZWNvcmQgPSByZWNvcmRzWzBdO1xuICAgICAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lID0gdGhpcy5fcm91dGluZ1V0aWwucGFyc2VUdGwocmVjb3JkLCByb3V0ZXJBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBfdGhpcyRfcm91dGluZ1V0aWwkcGEgPSB0aGlzLl9yb3V0aW5nVXRpbC5wYXJzZVNlcnZlcnMocmVjb3JkLCByb3V0ZXJBZGRyZXNzKSwgcm91dGVycyA9IF90aGlzJF9yb3V0aW5nVXRpbCRwYS5yb3V0ZXJzLCByZWFkZXJzID0gX3RoaXMkX3JvdXRpbmdVdGlsJHBhLnJlYWRlcnMsIHdyaXRlcnMgPSBfdGhpcyRfcm91dGluZ1V0aWwkcGEud3JpdGVycztcblxuICAgICAgICAgICAgICAgIFJlZGlzY292ZXJ5Ll9hc3NlcnROb25FbXB0eShyb3V0ZXJzLCAncm91dGVycycsIHJvdXRlckFkZHJlc3MpO1xuXG4gICAgICAgICAgICAgICAgUmVkaXNjb3ZlcnkuX2Fzc2VydE5vbkVtcHR5KHJlYWRlcnMsICdyZWFkZXJzJywgcm91dGVyQWRkcmVzcyk7IC8vIGNhc2Ugd2l0aCBubyB3cml0ZXJzIGlzIHByb2Nlc3NlZCBoaWdoZXIgaW4gdGhlIHByb21pc2UgY2hhaW4gYmVjYXVzZSBvbmx5IFJvdXRpbmdEcml2ZXIga25vd3NcbiAgICAgICAgICAgICAgICAvLyBob3cgdG8gZGVhbCB3aXRoIHN1Y2ggdGFibGUgYW5kIGhvdyB0byB0cmVhdCByb3V0ZXIgdGhhdCByZXR1cm5lZCBzdWNoIHRhYmxlXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3IF9yb3V0aW5nVGFibGVbXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgICAgICAgICAgIGRhdGFiYXNlOiBkYXRhYmFzZSxcbiAgICAgICAgICAgICAgICAgIHJvdXRlcnM6IHJvdXRlcnMsXG4gICAgICAgICAgICAgICAgICByZWFkZXJzOiByZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgd3JpdGVyczogd3JpdGVycyxcbiAgICAgICAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBsb29rdXBSb3V0aW5nVGFibGVPblJvdXRlcihfeCwgX3gyLCBfeDMpIHtcbiAgICAgICAgcmV0dXJuIF9sb29rdXBSb3V0aW5nVGFibGVPblJvdXRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9va3VwUm91dGluZ1RhYmxlT25Sb3V0ZXI7XG4gICAgfSgpXG4gIH1dLCBbe1xuICAgIGtleTogXCJfYXNzZXJ0Tm9uRW1wdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Fzc2VydE5vbkVtcHR5KHNlcnZlckFkZHJlc3Nlc0FycmF5LCBzZXJ2ZXJzTmFtZSwgcm91dGVyQWRkcmVzcykge1xuICAgICAgaWYgKHNlcnZlckFkZHJlc3Nlc0FycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnUmVjZWl2ZWQgbm8gJyArIHNlcnZlcnNOYW1lICsgJyBmcm9tIHJvdXRlciAnICsgcm91dGVyQWRkcmVzcywgX2Vycm9yLlBST1RPQ09MX0VSUk9SKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlZGlzY292ZXJ5O1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJlZGlzY292ZXJ5OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZXhwb3J0cy5BTEwgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXG52YXIgX2ludGVnZXIgPSByZXF1aXJlKFwiLi4vaW50ZWdlclwiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vLyBTaWduYXR1cmUgYnl0ZXMgZm9yIGVhY2ggcmVxdWVzdCBtZXNzYWdlIHR5cGVcbnZhciBJTklUID0gMHgwMTsgLy8gMDAwMCAwMDAxIC8vIElOSVQgPHVzZXJfYWdlbnQ+IDxhdXRoZW50aWNhdGlvbl90b2tlbj5cblxudmFyIEFDS19GQUlMVVJFID0gMHgwZTsgLy8gMDAwMCAxMTEwIC8vIEFDS19GQUlMVVJFIC0gdW51c2VkXG5cbnZhciBSRVNFVCA9IDB4MGY7IC8vIDAwMDAgMTExMSAvLyBSRVNFVFxuXG52YXIgUlVOID0gMHgxMDsgLy8gMDAwMSAwMDAwIC8vIFJVTiA8cXVlcnk+IDxwYXJhbWV0ZXJzPlxuXG52YXIgRElTQ0FSRF9BTEwgPSAweDJmOyAvLyAwMDEwIDExMTEgLy8gRElTQ0FSRF9BTEwgLSB1bnVzZWRcblxudmFyIFBVTExfQUxMID0gMHgzZjsgLy8gMDAxMSAxMTExIC8vIFBVTExfQUxMXG5cbnZhciBIRUxMTyA9IDB4MDE7IC8vIDAwMDAgMDAwMSAvLyBIRUxMTyA8bWV0YWRhdGE+XG5cbnZhciBHT09EQllFID0gMHgwMjsgLy8gMDAwMCAwMDEwIC8vIEdPT0RCWUVcblxudmFyIEJFR0lOID0gMHgxMTsgLy8gMDAwMSAwMDAxIC8vIEJFR0lOIDxtZXRhZGF0YT5cblxudmFyIENPTU1JVCA9IDB4MTI7IC8vIDAwMDEgMDAxMCAvLyBDT01NSVRcblxudmFyIFJPTExCQUNLID0gMHgxMzsgLy8gMDAwMSAwMDExIC8vIFJPTExCQUNLXG5cbnZhciBESVNDQVJEID0gMHgyZjsgLy8gMDAxMCAxMTExIC8vIERJU0NBUkRcblxudmFyIFBVTEwgPSAweDNmOyAvLyAwMDExIDExMTEgLy8gUFVMTFxuXG52YXIgUkVBRF9NT0RFID0gJ3InO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG52YXIgTk9fU1RBVEVNRU5UX0lEID0gLTE7XG52YXIgQUxMID0gLTE7XG5leHBvcnRzLkFMTCA9IEFMTDtcblxudmFyIFJlcXVlc3RNZXNzYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVxdWVzdE1lc3NhZ2Uoc2lnbmF0dXJlLCBmaWVsZHMsIHRvU3RyaW5nKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBSZXF1ZXN0TWVzc2FnZSk7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgdGhpcy50b1N0cmluZyA9IHRvU3RyaW5nO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgSU5JVCBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xpZW50TmFtZSB0aGUgY2xpZW50IG5hbWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdXRoVG9rZW4gdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuLlxuICAgKiBAcmV0dXJuIHtSZXF1ZXN0TWVzc2FnZX0gbmV3IElOSVQgbWVzc2FnZS5cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFJlcXVlc3RNZXNzYWdlLCBudWxsLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoY2xpZW50TmFtZSwgYXV0aFRva2VuKSB7XG4gICAgICByZXR1cm4gbmV3IFJlcXVlc3RNZXNzYWdlKElOSVQsIFtjbGllbnROYW1lLCBhdXRoVG9rZW5dLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIklOSVQgXCIuY29uY2F0KGNsaWVudE5hbWUsIFwiIHsuLi59XCIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBSVU4gbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgdGhlIGN5cGhlciBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyB0aGUgcXVlcnkgcGFyYW1ldGVycy5cbiAgICAgKiBAcmV0dXJuIHtSZXF1ZXN0TWVzc2FnZX0gbmV3IFJVTiBtZXNzYWdlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicnVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bihxdWVyeSwgcGFyYW1ldGVycykge1xuICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0TWVzc2FnZShSVU4sIFtxdWVyeSwgcGFyYW1ldGVyc10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiUlVOIFwiLmNvbmNhdChxdWVyeSwgXCIgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShwYXJhbWV0ZXJzKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgUFVMTF9BTEwgbWVzc2FnZS5cbiAgICAgKiBAcmV0dXJuIHtSZXF1ZXN0TWVzc2FnZX0gdGhlIFBVTExfQUxMIG1lc3NhZ2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWxsQWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1bGxBbGwoKSB7XG4gICAgICByZXR1cm4gUFVMTF9BTExfTUVTU0FHRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgUkVTRVQgbWVzc2FnZS5cbiAgICAgKiBAcmV0dXJuIHtSZXF1ZXN0TWVzc2FnZX0gdGhlIFJFU0VUIG1lc3NhZ2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHJldHVybiBSRVNFVF9NRVNTQUdFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgSEVMTE8gbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlckFnZW50IHRoZSB1c2VyIGFnZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdXRoVG9rZW4gdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25hbCBzZXJ2ZXIgc2lkZSByb3V0aW5nLCBzZXQgdG8gcm91dGluZyBjb250ZXh0IHRvIHR1cm4gb24gc2VydmVyIHNpZGUgcm91dGluZyAoPiA0LjEpXG4gICAgICogQHJldHVybiB7UmVxdWVzdE1lc3NhZ2V9IG5ldyBIRUxMTyBtZXNzYWdlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGVsbG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGVsbG8odXNlckFnZW50LCBhdXRoVG9rZW4pIHtcbiAgICAgIHZhciByb3V0aW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgdmFyIG1ldGFkYXRhID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHVzZXJfYWdlbnQ6IHVzZXJBZ2VudFxuICAgICAgfSwgYXV0aFRva2VuKTtcblxuICAgICAgaWYgKHJvdXRpbmcgIT0gbnVsbCkge1xuICAgICAgICBtZXRhZGF0YS5yb3V0aW5nID0gcm91dGluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0TWVzc2FnZShIRUxMTywgW21ldGFkYXRhXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJIRUxMTyB7dXNlcl9hZ2VudDogJ1wiLmNvbmNhdCh1c2VyQWdlbnQsIFwiJywgLi4ufVwiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgQkVHSU4gbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2ttYXJrfSBib29rbWFyayB0aGUgYm9va21hcmsuXG4gICAgICogQHBhcmFtIHtUeENvbmZpZ30gdHhDb25maWcgdGhlIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlIHRoZSBkYXRhYmFzZSBuYW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIHRoZSBhY2Nlc3MgbW9kZS5cbiAgICAgKiBAcmV0dXJuIHtSZXF1ZXN0TWVzc2FnZX0gbmV3IEJFR0lOIG1lc3NhZ2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJiZWdpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWdpbigpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBib29rbWFyayA9IF9yZWYuYm9va21hcmssXG4gICAgICAgICAgdHhDb25maWcgPSBfcmVmLnR4Q29uZmlnLFxuICAgICAgICAgIGRhdGFiYXNlID0gX3JlZi5kYXRhYmFzZSxcbiAgICAgICAgICBtb2RlID0gX3JlZi5tb2RlO1xuXG4gICAgICB2YXIgbWV0YWRhdGEgPSBidWlsZFR4TWV0YWRhdGEoYm9va21hcmssIHR4Q29uZmlnLCBkYXRhYmFzZSwgbW9kZSk7XG4gICAgICByZXR1cm4gbmV3IFJlcXVlc3RNZXNzYWdlKEJFR0lOLCBbbWV0YWRhdGFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkJFR0lOIFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIENPTU1JVCBtZXNzYWdlLlxuICAgICAqIEByZXR1cm4ge1JlcXVlc3RNZXNzYWdlfSB0aGUgQ09NTUlUIG1lc3NhZ2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb21taXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tbWl0KCkge1xuICAgICAgcmV0dXJuIENPTU1JVF9NRVNTQUdFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBST0xMQkFDSyBtZXNzYWdlLlxuICAgICAqIEByZXR1cm4ge1JlcXVlc3RNZXNzYWdlfSB0aGUgUk9MTEJBQ0sgbWVzc2FnZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJvbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvbGxiYWNrKCkge1xuICAgICAgcmV0dXJuIFJPTExCQUNLX01FU1NBR0U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBSVU4gbWVzc2FnZSB3aXRoIGFkZGl0aW9uYWwgbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IHRoZSBjeXBoZXIgcXVlcnkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgdGhlIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHtCb29rbWFya30gYm9va21hcmsgdGhlIGJvb2ttYXJrLlxuICAgICAqIEBwYXJhbSB7VHhDb25maWd9IHR4Q29uZmlnIHRoZSBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZSB0aGUgZGF0YWJhc2UgbmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSB0aGUgYWNjZXNzIG1vZGUuXG4gICAgICogQHJldHVybiB7UmVxdWVzdE1lc3NhZ2V9IG5ldyBSVU4gbWVzc2FnZSB3aXRoIGFkZGl0aW9uYWwgbWV0YWRhdGEuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJydW5XaXRoTWV0YWRhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuV2l0aE1ldGFkYXRhKHF1ZXJ5LCBwYXJhbWV0ZXJzKSB7XG4gICAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgICAgIGJvb2ttYXJrID0gX3JlZjIuYm9va21hcmssXG4gICAgICAgICAgdHhDb25maWcgPSBfcmVmMi50eENvbmZpZyxcbiAgICAgICAgICBkYXRhYmFzZSA9IF9yZWYyLmRhdGFiYXNlLFxuICAgICAgICAgIG1vZGUgPSBfcmVmMi5tb2RlO1xuXG4gICAgICB2YXIgbWV0YWRhdGEgPSBidWlsZFR4TWV0YWRhdGEoYm9va21hcmssIHR4Q29uZmlnLCBkYXRhYmFzZSwgbW9kZSk7XG4gICAgICByZXR1cm4gbmV3IFJlcXVlc3RNZXNzYWdlKFJVTiwgW3F1ZXJ5LCBwYXJhbWV0ZXJzLCBtZXRhZGF0YV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiUlVOIFwiLmNvbmNhdChxdWVyeSwgXCIgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShwYXJhbWV0ZXJzKSwgXCIgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIEdPT0RCWUUgbWVzc2FnZS5cbiAgICAgKiBAcmV0dXJuIHtSZXF1ZXN0TWVzc2FnZX0gdGhlIEdPT0RCWUUgbWVzc2FnZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdvb2RieWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ29vZGJ5ZSgpIHtcbiAgICAgIHJldHVybiBHT09EQllFX01FU1NBR0U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBQVUxMIG1lc3NhZ2Ugd2l0aCBhZGRpdGlvbmFsIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IHN0bXRJZFxuICAgICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IG5cbiAgICAgKiBAcmV0dXJuIHtSZXF1ZXN0TWVzc2FnZX0gdGhlIFBVTEwgbWVzc2FnZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1bGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVsbCgpIHtcbiAgICAgIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgX3JlZjMkc3RtdElkID0gX3JlZjMuc3RtdElkLFxuICAgICAgICAgIHN0bXRJZCA9IF9yZWYzJHN0bXRJZCA9PT0gdm9pZCAwID8gTk9fU1RBVEVNRU5UX0lEIDogX3JlZjMkc3RtdElkLFxuICAgICAgICAgIF9yZWYzJG4gPSBfcmVmMy5uLFxuICAgICAgICAgIG4gPSBfcmVmMyRuID09PSB2b2lkIDAgPyBBTEwgOiBfcmVmMyRuO1xuXG4gICAgICB2YXIgbWV0YWRhdGEgPSBidWlsZFN0cmVhbU1ldGFkYXRhKHN0bXRJZCB8fCBOT19TVEFURU1FTlRfSUQsIG4gfHwgQUxMKTtcbiAgICAgIHJldHVybiBuZXcgUmVxdWVzdE1lc3NhZ2UoUFVMTCwgW21ldGFkYXRhXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJQVUxMIFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBESVNDQVJEIG1lc3NhZ2Ugd2l0aCBhZGRpdGlvbmFsIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IHN0bXRJZFxuICAgICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IG5cbiAgICAgKiBAcmV0dXJuIHtSZXF1ZXN0TWVzc2FnZX0gdGhlIFBVTEwgbWVzc2FnZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2NhcmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY2FyZCgpIHtcbiAgICAgIHZhciBfcmVmNCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgX3JlZjQkc3RtdElkID0gX3JlZjQuc3RtdElkLFxuICAgICAgICAgIHN0bXRJZCA9IF9yZWY0JHN0bXRJZCA9PT0gdm9pZCAwID8gTk9fU1RBVEVNRU5UX0lEIDogX3JlZjQkc3RtdElkLFxuICAgICAgICAgIF9yZWY0JG4gPSBfcmVmNC5uLFxuICAgICAgICAgIG4gPSBfcmVmNCRuID09PSB2b2lkIDAgPyBBTEwgOiBfcmVmNCRuO1xuXG4gICAgICB2YXIgbWV0YWRhdGEgPSBidWlsZFN0cmVhbU1ldGFkYXRhKHN0bXRJZCB8fCBOT19TVEFURU1FTlRfSUQsIG4gfHwgQUxMKTtcbiAgICAgIHJldHVybiBuZXcgUmVxdWVzdE1lc3NhZ2UoRElTQ0FSRCwgW21ldGFkYXRhXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJESVNDQVJEIFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSZXF1ZXN0TWVzc2FnZTtcbn0oKTtcbi8qKlxuICogQ3JlYXRlIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudCB0cmFuc2FjdGlvbiBtZXRhZGF0YS5cbiAqIEBwYXJhbSB7Qm9va21hcmt9IGJvb2ttYXJrIHRoZSBib29rbWFyay5cbiAqIEBwYXJhbSB7VHhDb25maWd9IHR4Q29uZmlnIHRoZSBjb25maWd1cmF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlIHRoZSBkYXRhYmFzZSBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgdGhlIGFjY2VzcyBtb2RlLlxuICogQHJldHVybiB7T2JqZWN0fSBhIG1ldGFkYXRhIG9iamVjdC5cbiAqL1xuXG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUmVxdWVzdE1lc3NhZ2U7XG5cbmZ1bmN0aW9uIGJ1aWxkVHhNZXRhZGF0YShib29rbWFyaywgdHhDb25maWcsIGRhdGFiYXNlLCBtb2RlKSB7XG4gIHZhciBtZXRhZGF0YSA9IHt9O1xuXG4gIGlmICghYm9va21hcmsuaXNFbXB0eSgpKSB7XG4gICAgbWV0YWRhdGEuYm9va21hcmtzID0gYm9va21hcmsudmFsdWVzKCk7XG4gIH1cblxuICBpZiAodHhDb25maWcudGltZW91dCkge1xuICAgIG1ldGFkYXRhLnR4X3RpbWVvdXQgPSB0eENvbmZpZy50aW1lb3V0O1xuICB9XG5cbiAgaWYgKHR4Q29uZmlnLm1ldGFkYXRhKSB7XG4gICAgbWV0YWRhdGEudHhfbWV0YWRhdGEgPSB0eENvbmZpZy5tZXRhZGF0YTtcbiAgfVxuXG4gIGlmIChkYXRhYmFzZSkge1xuICAgIG1ldGFkYXRhLmRiID0gKDAsIF91dGlsLmFzc2VydFN0cmluZykoZGF0YWJhc2UsICdkYXRhYmFzZScpO1xuICB9XG5cbiAgaWYgKG1vZGUgPT09IF9jb25zdGFudHMuQUNDRVNTX01PREVfUkVBRCkge1xuICAgIG1ldGFkYXRhLm1vZGUgPSBSRUFEX01PREU7XG4gIH1cblxuICByZXR1cm4gbWV0YWRhdGE7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHN0cmVhbWluZyBtZXRhZGF0YS5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IHN0bXRJZCBUaGUgcXVlcnkgaWQgdG8gc3RyZWFtIGl0cyByZXN1bHRzLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHJlY29yZHMgdG8gc3RyZWFtLlxuICogQHJldHVybnMge09iamVjdH0gYSBtZXRhZGF0YSBvYmplY3QuXG4gKi9cblxuXG5mdW5jdGlvbiBidWlsZFN0cmVhbU1ldGFkYXRhKHN0bXRJZCwgbikge1xuICB2YXIgbWV0YWRhdGEgPSB7XG4gICAgbjogKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShuKVxuICB9O1xuXG4gIGlmIChzdG10SWQgIT09IE5PX1NUQVRFTUVOVF9JRCkge1xuICAgIG1ldGFkYXRhLnFpZCA9ICgwLCBfaW50ZWdlcltcImludFwiXSkoc3RtdElkKTtcbiAgfVxuXG4gIHJldHVybiBtZXRhZGF0YTtcbn0gLy8gY29uc3RhbnRzIGZvciBtZXNzYWdlcyB0aGF0IG5ldmVyIGNoYW5nZVxuXG5cbnZhciBQVUxMX0FMTF9NRVNTQUdFID0gbmV3IFJlcXVlc3RNZXNzYWdlKFBVTExfQUxMLCBbXSwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ1BVTExfQUxMJztcbn0pO1xudmFyIFJFU0VUX01FU1NBR0UgPSBuZXcgUmVxdWVzdE1lc3NhZ2UoUkVTRVQsIFtdLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnUkVTRVQnO1xufSk7XG52YXIgQ09NTUlUX01FU1NBR0UgPSBuZXcgUmVxdWVzdE1lc3NhZ2UoQ09NTUlULCBbXSwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ0NPTU1JVCc7XG59KTtcbnZhciBST0xMQkFDS19NRVNTQUdFID0gbmV3IFJlcXVlc3RNZXNzYWdlKFJPTExCQUNLLCBbXSwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ1JPTExCQUNLJztcbn0pO1xudmFyIEdPT0RCWUVfTUVTU0FHRSA9IG5ldyBSZXF1ZXN0TWVzc2FnZShHT09EQllFLCBbXSwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ0dPT0RCWUUnO1xufSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEJhc2VIb3N0TmFtZVJlc29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZUhvc3ROYW1lUmVzb2x2ZXIoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBCYXNlSG9zdE5hbWVSZXNvbHZlcik7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKEJhc2VIb3N0TmFtZVJlc29sdmVyLCBbe1xuICAgIGtleTogXCJyZXNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fic3RyYWN0IGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNvbHZlVG9JdHNlbGZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc29sdmVUb0l0c2VsZihhZGRyZXNzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFthZGRyZXNzXSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCYXNlSG9zdE5hbWVSZXNvbHZlcjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBCYXNlSG9zdE5hbWVSZXNvbHZlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9zZXJ2ZXJBZGRyZXNzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vc2VydmVyLWFkZHJlc3NcIikpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVUb1NlbGYoYWRkcmVzcykge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFthZGRyZXNzXSk7XG59XG5cbnZhciBDb25maWd1cmVkQ3VzdG9tUmVzb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb25maWd1cmVkQ3VzdG9tUmVzb2x2ZXIocmVzb2x2ZXJGdW5jdGlvbikge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgQ29uZmlndXJlZEN1c3RvbVJlc29sdmVyKTtcbiAgICB0aGlzLl9yZXNvbHZlckZ1bmN0aW9uID0gcmVzb2x2ZXJGdW5jdGlvbiB8fCByZXNvbHZlVG9TZWxmO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShDb25maWd1cmVkQ3VzdG9tUmVzb2x2ZXIsIFt7XG4gICAga2V5OiBcInJlc29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZShzZWVkUm91dGVyKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoX3RoaXMuX3Jlc29sdmVyRnVuY3Rpb24oc2VlZFJvdXRlci5hc0hvc3RQb3J0KCkpKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc29sdmVkKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXNvbHZlZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb25maWd1cmVkIHJlc29sdmVyIGZ1bmN0aW9uIHNob3VsZCBlaXRoZXIgcmV0dXJuIGFuIGFycmF5IG9mIGFkZHJlc3NlcyBvciBhIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBhbiBhcnJheSBvZiBhZGRyZXNzZXMuJyArIFwiRWFjaCBhZGRyZXNzIGlzICc8aG9zdD46PHBvcnQ+Jy4gR290OiBcIi5jb25jYXQocmVzb2x2ZWQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNvbHZlZC5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICByZXR1cm4gX3NlcnZlckFkZHJlc3NbXCJkZWZhdWx0XCJdLmZyb21Vcmwocik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb25maWd1cmVkQ3VzdG9tUmVzb2x2ZXI7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ29uZmlndXJlZEN1c3RvbVJlc29sdmVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xuXG52YXIgX3J4anMgPSByZXF1aXJlKFwicnhqc1wiKTtcblxudmFyIF9vcGVyYXRvcnMgPSByZXF1aXJlKFwicnhqcy9vcGVyYXRvcnNcIik7XG5cbnZhciBfbG9nZ2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9sb2dnZXJcIikpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBERUZBVUxUX01BWF9SRVRSWV9USU1FX01TID0gMzAgKiAxMDAwOyAvLyAzMCBzZWNvbmRzXG5cbnZhciBERUZBVUxUX0lOSVRJQUxfUkVUUllfREVMQVlfTVMgPSAxMDAwOyAvLyAxIHNlY29uZHNcblxudmFyIERFRkFVTFRfUkVUUllfREVMQVlfTVVMVElQTElFUiA9IDIuMDtcbnZhciBERUZBVUxUX1JFVFJZX0RFTEFZX0pJVFRFUl9GQUNUT1IgPSAwLjI7XG5cbnZhciBSeFJldHJ5TG9naWMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAgICogQHBhcmFtIHtMb2dnZXJ9IGFyZ3MubG9nZ2VyXG4gICAqL1xuICBmdW5jdGlvbiBSeFJldHJ5TG9naWMoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBfcmVmJG1heFJldHJ5VGltZW91dCA9IF9yZWYubWF4UmV0cnlUaW1lb3V0LFxuICAgICAgICBtYXhSZXRyeVRpbWVvdXQgPSBfcmVmJG1heFJldHJ5VGltZW91dCA9PT0gdm9pZCAwID8gREVGQVVMVF9NQVhfUkVUUllfVElNRV9NUyA6IF9yZWYkbWF4UmV0cnlUaW1lb3V0LFxuICAgICAgICBfcmVmJGluaXRpYWxEZWxheSA9IF9yZWYuaW5pdGlhbERlbGF5LFxuICAgICAgICBpbml0aWFsRGVsYXkgPSBfcmVmJGluaXRpYWxEZWxheSA9PT0gdm9pZCAwID8gREVGQVVMVF9JTklUSUFMX1JFVFJZX0RFTEFZX01TIDogX3JlZiRpbml0aWFsRGVsYXksXG4gICAgICAgIF9yZWYkZGVsYXlNdWx0aXBsaWVyID0gX3JlZi5kZWxheU11bHRpcGxpZXIsXG4gICAgICAgIGRlbGF5TXVsdGlwbGllciA9IF9yZWYkZGVsYXlNdWx0aXBsaWVyID09PSB2b2lkIDAgPyBERUZBVUxUX1JFVFJZX0RFTEFZX01VTFRJUExJRVIgOiBfcmVmJGRlbGF5TXVsdGlwbGllcixcbiAgICAgICAgX3JlZiRkZWxheUppdHRlciA9IF9yZWYuZGVsYXlKaXR0ZXIsXG4gICAgICAgIGRlbGF5Sml0dGVyID0gX3JlZiRkZWxheUppdHRlciA9PT0gdm9pZCAwID8gREVGQVVMVF9SRVRSWV9ERUxBWV9KSVRURVJfRkFDVE9SIDogX3JlZiRkZWxheUppdHRlcixcbiAgICAgICAgX3JlZiRsb2dnZXIgPSBfcmVmLmxvZ2dlcixcbiAgICAgICAgbG9nZ2VyID0gX3JlZiRsb2dnZXIgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmJGxvZ2dlcjtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUnhSZXRyeUxvZ2ljKTtcbiAgICB0aGlzLl9tYXhSZXRyeVRpbWVvdXQgPSB2YWx1ZU9yRGVmYXVsdChtYXhSZXRyeVRpbWVvdXQsIERFRkFVTFRfTUFYX1JFVFJZX1RJTUVfTVMpO1xuICAgIHRoaXMuX2luaXRpYWxEZWxheSA9IHZhbHVlT3JEZWZhdWx0KGluaXRpYWxEZWxheSwgREVGQVVMVF9JTklUSUFMX1JFVFJZX0RFTEFZX01TKTtcbiAgICB0aGlzLl9kZWxheU11bHRpcGxpZXIgPSB2YWx1ZU9yRGVmYXVsdChkZWxheU11bHRpcGxpZXIsIERFRkFVTFRfUkVUUllfREVMQVlfTVVMVElQTElFUik7XG4gICAgdGhpcy5fZGVsYXlKaXR0ZXIgPSB2YWx1ZU9yRGVmYXVsdChkZWxheUppdHRlciwgREVGQVVMVF9SRVRSWV9ERUxBWV9KSVRURVJfRkFDVE9SKTtcbiAgICB0aGlzLl9sb2dnZXIgPSBsb2dnZXI7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZTxBbnk+fSB3b3JrXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShSeFJldHJ5TG9naWMsIFt7XG4gICAga2V5OiBcInJldHJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldHJ5KHdvcmspIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB3b3JrLnBpcGUoKDAsIF9vcGVyYXRvcnMucmV0cnlXaGVuKShmdW5jdGlvbiAoZmFpbGVkV29yaykge1xuICAgICAgICB2YXIgaGFuZGxlZEV4Y2VwdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciByZXRyeUNvdW50ID0gMTtcbiAgICAgICAgdmFyIGRlbGF5RHVyYXRpb24gPSBfdGhpcy5faW5pdGlhbERlbGF5O1xuICAgICAgICByZXR1cm4gZmFpbGVkV29yay5waXBlKCgwLCBfb3BlcmF0b3JzLmZsYXRNYXApKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoIVJ4UmV0cnlMb2dpYy5fY2FuUmV0cnlPbihlcnIpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9yeGpzLnRocm93RXJyb3IpKGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFuZGxlZEV4Y2VwdGlvbnMucHVzaChlcnIpO1xuXG4gICAgICAgICAgaWYgKHJldHJ5Q291bnQgPj0gMiAmJiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lID49IF90aGlzLl9tYXhSZXRyeVRpbWVvdXQpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICgwLCBfZXJyb3IubmV3RXJyb3IpKFwiRmFpbGVkIGFmdGVyIHJldHJpZWQgZm9yIFwiLmNvbmNhdChyZXRyeUNvdW50LCBcIiB0aW1lcyBpbiBcIikuY29uY2F0KF90aGlzLl9tYXhSZXRyeVRpbWVvdXQsIFwiIG1zLiBNYWtlIHN1cmUgdGhhdCB5b3VyIGRhdGFiYXNlIGlzIG9ubGluZSBhbmQgcmV0cnkgYWdhaW4uXCIpLCBfZXJyb3IuU0VSVklDRV9VTkFWQUlMQUJMRSk7XG4gICAgICAgICAgICBlcnJvci5zZWVuRXJyb3JzID0gaGFuZGxlZEV4Y2VwdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9yeGpzLnRocm93RXJyb3IpKGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV4dERlbGF5RHVyYXRpb24gPSBfdGhpcy5fY29tcHV0ZU5leHREZWxheShkZWxheUR1cmF0aW9uKTtcblxuICAgICAgICAgIGRlbGF5RHVyYXRpb24gPSBkZWxheUR1cmF0aW9uICogX3RoaXMuX2RlbGF5TXVsdGlwbGllcjtcbiAgICAgICAgICByZXRyeUNvdW50Kys7XG5cbiAgICAgICAgICBpZiAoX3RoaXMuX2xvZ2dlcikge1xuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci53YXJuKFwiVHJhbnNhY3Rpb24gZmFpbGVkIGFuZCB3aWxsIGJlIHJldHJpZWQgaW4gXCIuY29uY2F0KG5leHREZWxheUR1cmF0aW9uKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICgwLCBfcnhqcy5vZikoMSkucGlwZSgoMCwgX29wZXJhdG9ycy5kZWxheSkobmV4dERlbGF5RHVyYXRpb24pKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY29tcHV0ZU5leHREZWxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcHV0ZU5leHREZWxheShkZWxheSkge1xuICAgICAgdmFyIGppdHRlciA9IGRlbGF5ICogdGhpcy5fZGVsYXlKaXR0ZXI7XG4gICAgICByZXR1cm4gZGVsYXkgLSBqaXR0ZXIgKyAyICogaml0dGVyICogTWF0aC5yYW5kb20oKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJfY2FuUmV0cnlPblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FuUmV0cnlPbihlcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yICYmIGVycm9yLmNvZGUgJiYgKGVycm9yLmNvZGUgPT09IF9lcnJvci5TRVJWSUNFX1VOQVZBSUxBQkxFIHx8IGVycm9yLmNvZGUgPT09IF9lcnJvci5TRVNTSU9OX0VYUElSRUQgfHwgdGhpcy5faXNUcmFuc2llbnRFcnJvcihlcnJvcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNUcmFuc2llbnRFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNUcmFuc2llbnRFcnJvcihlcnJvcikge1xuICAgICAgLy8gUmV0cmllcyBzaG91bGQgbm90IGhhcHBlbiB3aGVuIHRyYW5zYWN0aW9uIHdhcyBleHBsaWNpdGx5IHRlcm1pbmF0ZWQgYnkgdGhlIHVzZXIuXG4gICAgICAvLyBUZXJtaW5hdGlvbiBvZiB0cmFuc2FjdGlvbiBtaWdodCByZXN1bHQgaW4gdHdvIGRpZmZlcmVudCBlcnJvciBjb2RlcyBkZXBlbmRpbmcgb24gd2hlcmUgaXQgd2FzXG4gICAgICAvLyB0ZXJtaW5hdGVkLiBUaGVzZSBhcmUgcmVhbGx5IGNsaWVudCBlcnJvcnMgYnV0IGNsYXNzaWZpY2F0aW9uIG9uIHRoZSBzZXJ2ZXIgaXMgbm90IGVudGlyZWx5IGNvcnJlY3QgYW5kXG4gICAgICAvLyB0aGV5IGFyZSBjbGFzc2lmaWVkIGFzIHRyYW5zaWVudC5cbiAgICAgIHZhciBjb2RlID0gZXJyb3IuY29kZTtcblxuICAgICAgaWYgKGNvZGUuaW5kZXhPZignVHJhbnNpZW50RXJyb3InKSA+PSAwKSB7XG4gICAgICAgIGlmIChjb2RlID09PSAnTmVvLlRyYW5zaWVudEVycm9yLlRyYW5zYWN0aW9uLlRlcm1pbmF0ZWQnIHx8IGNvZGUgPT09ICdOZW8uVHJhbnNpZW50RXJyb3IuVHJhbnNhY3Rpb24uTG9ja0NsaWVudFN0b3BwZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJ4UmV0cnlMb2dpYztcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSeFJldHJ5TG9naWM7XG5cbmZ1bmN0aW9uIHZhbHVlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHZhbHVlIHx8IHZhbHVlID09PSAwKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgUm91bmRSb2JpbkFycmF5SW5kZXggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5pdGlhbE9mZnNldD0wXSB0aGUgaW5pdGlhbCBvZmZzZXQgZm9yIHJvdW5kIHJvYmluLlxuICAgKi9cbiAgZnVuY3Rpb24gUm91bmRSb2JpbkFycmF5SW5kZXgoaW5pdGlhbE9mZnNldCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUm91bmRSb2JpbkFycmF5SW5kZXgpO1xuICAgIHRoaXMuX29mZnNldCA9IGluaXRpYWxPZmZzZXQgfHwgMDtcbiAgfVxuICAvKipcbiAgICogR2V0IG5leHQgaW5kZXggZm9yIGFuIGFycmF5IHdpdGggZ2l2ZW4gbGVuZ3RoLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYXJyYXlMZW5ndGggdGhlIGFycmF5IGxlbmd0aC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmRleCBpbiB0aGUgYXJyYXkuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShSb3VuZFJvYmluQXJyYXlJbmRleCwgW3tcbiAgICBrZXk6IFwibmV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KGFycmF5TGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlMZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dE9mZnNldCA9IHRoaXMuX29mZnNldDtcbiAgICAgIHRoaXMuX29mZnNldCArPSAxO1xuXG4gICAgICBpZiAodGhpcy5fb2Zmc2V0ID09PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV4dE9mZnNldCAlIGFycmF5TGVuZ3RoO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUm91bmRSb2JpbkFycmF5SW5kZXg7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUm91bmRSb2JpbkFycmF5SW5kZXg7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfdG9Db25zdW1hYmxlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheVwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW50ZWdlciA9IHJlcXVpcmUoXCIuLi9pbnRlZ2VyXCIpO1xuXG52YXIgX2RyaXZlciA9IHJlcXVpcmUoXCIuLi9kcml2ZXJcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIE1JTl9ST1VURVJTID0gMTtcblxudmFyIFJvdXRpbmdUYWJsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJvdXRpbmdUYWJsZSgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIGRhdGFiYXNlID0gX3JlZi5kYXRhYmFzZSxcbiAgICAgICAgcm91dGVycyA9IF9yZWYucm91dGVycyxcbiAgICAgICAgcmVhZGVycyA9IF9yZWYucmVhZGVycyxcbiAgICAgICAgd3JpdGVycyA9IF9yZWYud3JpdGVycyxcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBfcmVmLmV4cGlyYXRpb25UaW1lO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBSb3V0aW5nVGFibGUpO1xuICAgIHRoaXMuZGF0YWJhc2UgPSBkYXRhYmFzZTtcbiAgICB0aGlzLmRhdGFiYXNlTmFtZSA9IGRhdGFiYXNlIHx8ICdkZWZhdWx0IGRhdGFiYXNlJztcbiAgICB0aGlzLnJvdXRlcnMgPSByb3V0ZXJzIHx8IFtdO1xuICAgIHRoaXMucmVhZGVycyA9IHJlYWRlcnMgfHwgW107XG4gICAgdGhpcy53cml0ZXJzID0gd3JpdGVycyB8fCBbXTtcbiAgICB0aGlzLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWUgfHwgKDAsIF9pbnRlZ2VyW1wiaW50XCJdKSgwKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUm91dGluZ1RhYmxlLCBbe1xuICAgIGtleTogXCJmb3JnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yZ2V0KGFkZHJlc3MpIHtcbiAgICAgIC8vIERvbid0IHJlbW92ZSBpdCBmcm9tIHRoZSBzZXQgb2Ygcm91dGVycywgc2luY2UgdGhhdCBtaWdodCBtZWFuIHdlIGxvc2Ugb3VyIGFiaWxpdHkgdG8gcmUtZGlzY292ZXIsXG4gICAgICAvLyBqdXN0IHJlbW92ZSBpdCBmcm9tIHRoZSBzZXQgb2YgcmVhZGVycyBhbmQgd3JpdGVycywgc28gdGhhdCB3ZSBkb24ndCB1c2UgaXQgZm9yIGFjdHVhbCB3b3JrIHdpdGhvdXRcbiAgICAgIC8vIHBlcmZvcm1pbmcgZGlzY292ZXJ5IGZpcnN0LlxuICAgICAgdGhpcy5yZWFkZXJzID0gcmVtb3ZlRnJvbUFycmF5KHRoaXMucmVhZGVycywgYWRkcmVzcyk7XG4gICAgICB0aGlzLndyaXRlcnMgPSByZW1vdmVGcm9tQXJyYXkodGhpcy53cml0ZXJzLCBhZGRyZXNzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yZ2V0Um91dGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcmdldFJvdXRlcihhZGRyZXNzKSB7XG4gICAgICB0aGlzLnJvdXRlcnMgPSByZW1vdmVGcm9tQXJyYXkodGhpcy5yb3V0ZXJzLCBhZGRyZXNzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yZ2V0V3JpdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcmdldFdyaXRlcihhZGRyZXNzKSB7XG4gICAgICB0aGlzLndyaXRlcnMgPSByZW1vdmVGcm9tQXJyYXkodGhpcy53cml0ZXJzLCBhZGRyZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyByb3V0aW5nIHRhYmxlIGlzIGZyZXNoIHRvIHBlcmZvcm0gdGhlIHJlcXVpcmVkIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzTW9kZSB0aGUgdHlwZSBvZiBvcGVyYXRpb24uIEFsbG93ZWQgdmFsdWVzIGFyZSB7QGxpbmsgUkVBRH0gYW5kIHtAbGluayBXUklURX0uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIHdoZW4gdGhpcyB0YWJsZSBjb250YWlucyBzZXJ2ZXJzIHRvIHNlcnZlIHRoZSByZXF1aXJlZCBvcGVyYXRpb24sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTdGFsZUZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N0YWxlRm9yKGFjY2Vzc01vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmV4cGlyYXRpb25UaW1lLmxlc3NUaGFuKERhdGUubm93KCkpIHx8IHRoaXMucm91dGVycy5sZW5ndGggPCBNSU5fUk9VVEVSUyB8fCBhY2Nlc3NNb2RlID09PSBfZHJpdmVyLlJFQUQgJiYgdGhpcy5yZWFkZXJzLmxlbmd0aCA9PT0gMCB8fCBhY2Nlc3NNb2RlID09PSBfZHJpdmVyLldSSVRFICYmIHRoaXMud3JpdGVycy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgcm91dGluZyB0YWJsZSBpcyBleHBpcmVkIGZvciBzcGVjaWZpZWQgYW1vdW50IG9mIGR1cmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGR1cmF0aW9uIGFtb3VudCBvZiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgdG8gY2hlY2sgZm9yIGV4cGlyYXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzRXhwaXJlZEZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0V4cGlyZWRGb3IoZHVyYXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLmV4cGlyYXRpb25UaW1lLmFkZChkdXJhdGlvbikubGVzc1RoYW4oRGF0ZS5ub3coKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFsbFNlcnZlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWxsU2VydmVycygpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTJbXCJkZWZhdWx0XCJdKSh0aGlzLnJvdXRlcnMpLCAoMCwgX3RvQ29uc3VtYWJsZUFycmF5MltcImRlZmF1bHRcIl0pKHRoaXMucmVhZGVycyksICgwLCBfdG9Db25zdW1hYmxlQXJyYXkyW1wiZGVmYXVsdFwiXSkodGhpcy53cml0ZXJzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdSb3V0aW5nVGFibGVbJyArIFwiZGF0YWJhc2U9XCIuY29uY2F0KHRoaXMuZGF0YWJhc2VOYW1lLCBcIiwgXCIpICsgXCJleHBpcmF0aW9uVGltZT1cIi5jb25jYXQodGhpcy5leHBpcmF0aW9uVGltZSwgXCIsIFwiKSArIFwiY3VycmVudFRpbWU9XCIuY29uY2F0KERhdGUubm93KCksIFwiLCBcIikgKyBcInJvdXRlcnM9W1wiLmNvbmNhdCh0aGlzLnJvdXRlcnMsIFwiXSwgXCIpICsgXCJyZWFkZXJzPVtcIi5jb25jYXQodGhpcy5yZWFkZXJzLCBcIl0sIFwiKSArIFwid3JpdGVycz1bXCIuY29uY2F0KHRoaXMud3JpdGVycywgXCJdXVwiKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJvdXRpbmdUYWJsZTtcbn0oKTtcbi8qKlxuICogUmVtb3ZlIGFsbCBvY2N1cnJlbmNlcyBvZiB0aGUgZWxlbWVudCBpbiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSB0aGUgYXJyYXkgdG8gZmlsdGVyLlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICogQHJldHVybiB7QXJyYXl9IG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuXG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUm91dGluZ1RhYmxlO1xuXG5mdW5jdGlvbiByZW1vdmVGcm9tQXJyYXkoYXJyYXksIGVsZW1lbnQpIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLmFzS2V5KCkgIT09IGVsZW1lbnQuYXNLZXkoKTtcbiAgfSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xuXG52YXIgX2ludGVnZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi4vaW50ZWdlclwiKSk7XG5cbnZhciBfc2VydmVyVmVyc2lvbiA9IHJlcXVpcmUoXCIuL3NlcnZlci12ZXJzaW9uXCIpO1xuXG52YXIgX2Jvb2ttYXJrID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ib29rbWFya1wiKSk7XG5cbnZhciBfc2Vzc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3Nlc3Npb25cIikpO1xuXG52YXIgX3R4Q29uZmlnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi90eC1jb25maWdcIikpO1xuXG52YXIgX3NlcnZlckFkZHJlc3MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3NlcnZlci1hZGRyZXNzXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQ09OVEVYVCA9ICdjb250ZXh0JztcbnZhciBDQUxMX0dFVF9ST1VUSU5HX1RBQkxFID0gXCJDQUxMIGRibXMuY2x1c3Rlci5yb3V0aW5nLmdldFJvdXRpbmdUYWJsZSgkXCIuY29uY2F0KENPTlRFWFQsIFwiKVwiKTtcbnZhciBEQVRBQkFTRSA9ICdkYXRhYmFzZSc7XG52YXIgQ0FMTF9HRVRfUk9VVElOR19UQUJMRV9NVUxUSV9EQiA9IFwiQ0FMTCBkYm1zLnJvdXRpbmcuZ2V0Um91dGluZ1RhYmxlKCRcIi5jb25jYXQoQ09OVEVYVCwgXCIsICRcIikuY29uY2F0KERBVEFCQVNFLCBcIilcIik7XG52YXIgUFJPQ0VEVVJFX05PVF9GT1VORF9DT0RFID0gJ05lby5DbGllbnRFcnJvci5Qcm9jZWR1cmUuUHJvY2VkdXJlTm90Rm91bmQnO1xudmFyIERBVEFCQVNFX05PVF9GT1VORF9DT0RFID0gJ05lby5DbGllbnRFcnJvci5EYXRhYmFzZS5EYXRhYmFzZU5vdEZvdW5kJztcblxudmFyIFJvdXRpbmdVdGlsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUm91dGluZ1V0aWwocm91dGluZ0NvbnRleHQsIGluaXRpYWxBZGRyZXNzKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBSb3V0aW5nVXRpbCk7XG4gICAgdGhpcy5fcm91dGluZ0NvbnRleHQgPSByb3V0aW5nQ29udGV4dDsgLy8gVGhlIGFkZHJlc3MgdGhhdCB0aGUgZHJpdmVyIGlzIGNvbm5lY3RpbmcgdG8sIHVzZWQgYnkgcm91dGluZyBhcyBhIGZhbGxiYWNrIHdoZW4gcm91dGluZ1xuICAgIC8vIGFuZCBjbHVzdGVyaW5nIGlzbid0IGNvbmZpZ3VyZWQuXG5cbiAgICB0aGlzLl9pbml0aWFsQWRkcmVzcyA9IGluaXRpYWxBZGRyZXNzO1xuICB9XG4gIC8qKlxuICAgKiBJbnZva2Ugcm91dGluZyBwcm9jZWR1cmUgdXNpbmcgdGhlIGdpdmVuIHNlc3Npb24uXG4gICAqIEBwYXJhbSB7U2Vzc2lvbn0gc2Vzc2lvbiB0aGUgc2Vzc2lvbiB0byB1c2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb3V0ZXJBZGRyZXNzIHRoZSBVUkwgb2YgdGhlIHJvdXRlci5cbiAgICogQHJldHVybiB7UHJvbWlzZTxSZWNvcmRbXT59IHByb21pc2UgcmVzb2x2ZWQgd2l0aCByZWNvcmRzIHJldHVybmVkIGJ5IHRoZSBwcm9jZWR1cmUgY2FsbCBvciBudWxsIGlmXG4gICAqIGNvbm5lY3Rpb24gZXJyb3IgaGFwcGVuZWQuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShSb3V0aW5nVXRpbCwgW3tcbiAgICBrZXk6IFwiY2FsbFJvdXRpbmdQcm9jZWR1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jYWxsUm91dGluZ1Byb2NlZHVyZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKHNlc3Npb24sIGRhdGFiYXNlLCByb3V0ZXJBZGRyZXNzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxBdmFpbGFibGVSb3V0aW5nUHJvY2VkdXJlKHNlc3Npb24sIGRhdGFiYXNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbi5jbG9zZSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdC5yZWNvcmRzKTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoX2NvbnRleHQudDAuY29kZSA9PT0gREFUQUJBU0VfTk9UX0ZPVU5EX0NPREUpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dC50MDtcblxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIGlmICghKF9jb250ZXh0LnQwLmNvZGUgPT09IFBST0NFRFVSRV9OT1RfRk9VTkRfQ09ERSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKFwiU2VydmVyIGF0IFwiLmNvbmNhdChyb3V0ZXJBZGRyZXNzLmFzSG9zdFBvcnQoKSwgXCIgY2FuJ3QgcGVyZm9ybSByb3V0aW5nLiBNYWtlIHN1cmUgeW91IGFyZSBjb25uZWN0aW5nIHRvIGEgY2F1c2FsIGNsdXN0ZXJcIiksIF9lcnJvci5TRVJWSUNFX1VOQVZBSUxBQkxFKTtcblxuICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzAsIDldXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGxSb3V0aW5nUHJvY2VkdXJlKF94LCBfeDIsIF94Mykge1xuICAgICAgICByZXR1cm4gX2NhbGxSb3V0aW5nUHJvY2VkdXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsUm91dGluZ1Byb2NlZHVyZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVR0bFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVR0bChyZWNvcmQsIHJvdXRlckFkZHJlc3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBub3cgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKERhdGUubm93KCkpO1xuICAgICAgICB2YXIgZXhwaXJlcyA9ICgwLCBfaW50ZWdlcltcImludFwiXSkocmVjb3JkLmdldCgndHRsJykpLm11bHRpcGx5KDEwMDApLmFkZChub3cpOyAvLyBpZiB0aGUgc2VydmVyIHVzZXMgYSByZWFsbHkgYmlnIGV4cGlyZSB0aW1lIGxpa2UgTG9uZy5NQVhfVkFMVUUgdGhpcyBtYXkgaGF2ZSBvdmVyZmxvd2VkXG5cbiAgICAgICAgaWYgKGV4cGlyZXMubGVzc1RoYW4obm93KSkge1xuICAgICAgICAgIHJldHVybiBfaW50ZWdlcltcImRlZmF1bHRcIl0uTUFYX1ZBTFVFO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cGlyZXM7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKShcIlVuYWJsZSB0byBwYXJzZSBUVEwgZW50cnkgZnJvbSByb3V0ZXIgXCIuY29uY2F0KHJvdXRlckFkZHJlc3MsIFwiIGZyb20gcmVjb3JkOlxcblwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkocmVjb3JkKSwgXCJcXG5FcnJvciBtZXNzYWdlOiBcIikuY29uY2F0KGVycm9yLm1lc3NhZ2UpLCBfZXJyb3IuUFJPVE9DT0xfRVJST1IpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVNlcnZlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VTZXJ2ZXJzKHJlY29yZCwgcm91dGVyQWRkcmVzcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNlcnZlcnMgPSByZWNvcmQuZ2V0KCdzZXJ2ZXJzJyk7XG4gICAgICAgIHZhciByb3V0ZXJzID0gW107XG4gICAgICAgIHZhciByZWFkZXJzID0gW107XG4gICAgICAgIHZhciB3cml0ZXJzID0gW107XG4gICAgICAgIHNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgICAgICAgdmFyIHJvbGUgPSBzZXJ2ZXIucm9sZTtcbiAgICAgICAgICB2YXIgYWRkcmVzc2VzID0gc2VydmVyLmFkZHJlc3NlcztcblxuICAgICAgICAgIGlmIChyb2xlID09PSAnUk9VVEUnKSB7XG4gICAgICAgICAgICByb3V0ZXJzID0gcGFyc2VBcnJheShhZGRyZXNzZXMpLm1hcChmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICByZXR1cm4gX3NlcnZlckFkZHJlc3NbXCJkZWZhdWx0XCJdLmZyb21VcmwoYWRkcmVzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJvbGUgPT09ICdXUklURScpIHtcbiAgICAgICAgICAgIHdyaXRlcnMgPSBwYXJzZUFycmF5KGFkZHJlc3NlcykubWFwKGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfc2VydmVyQWRkcmVzc1tcImRlZmF1bHRcIl0uZnJvbVVybChhZGRyZXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9sZSA9PT0gJ1JFQUQnKSB7XG4gICAgICAgICAgICByZWFkZXJzID0gcGFyc2VBcnJheShhZGRyZXNzZXMpLm1hcChmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICByZXR1cm4gX3NlcnZlckFkZHJlc3NbXCJkZWZhdWx0XCJdLmZyb21VcmwoYWRkcmVzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ1Vua25vd24gc2VydmVyIHJvbGUgXCInICsgcm9sZSArICdcIicsIF9lcnJvci5QUk9UT0NPTF9FUlJPUik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb3V0ZXJzOiByb3V0ZXJzLFxuICAgICAgICAgIHJlYWRlcnM6IHJlYWRlcnMsXG4gICAgICAgICAgd3JpdGVyczogd3JpdGVyc1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoXCJVbmFibGUgdG8gcGFyc2Ugc2VydmVycyBlbnRyeSBmcm9tIHJvdXRlciBcIi5jb25jYXQocm91dGVyQWRkcmVzcywgXCIgZnJvbSByZWNvcmQ6XFxuXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShyZWNvcmQpLCBcIlxcbkVycm9yIG1lc3NhZ2U6IFwiKS5jb25jYXQoZXJyb3IubWVzc2FnZSksIF9lcnJvci5QUk9UT0NPTF9FUlJPUik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxsQXZhaWxhYmxlUm91dGluZ1Byb2NlZHVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsbEF2YWlsYWJsZVJvdXRpbmdQcm9jZWR1cmUoc2Vzc2lvbiwgZGF0YWJhc2UpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBzZXNzaW9uLl9ydW4obnVsbCwgbnVsbCwgZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgdmFyIHF1ZXJ5O1xuICAgICAgICB2YXIgcGFyYW1zO1xuICAgICAgICB2YXIgcHJvdG9jb2xWZXJzaW9uID0gY29ubmVjdGlvbi5wcm90b2NvbCgpLnZlcnNpb247XG5cbiAgICAgICAgaWYgKHByb3RvY29sVmVyc2lvbiA+PSA0LjApIHtcbiAgICAgICAgICBxdWVyeSA9IENBTExfR0VUX1JPVVRJTkdfVEFCTEVfTVVMVElfREI7XG4gICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgY29udGV4dDogX3RoaXMuX3JvdXRpbmdDb250ZXh0IHx8IHt9LFxuICAgICAgICAgICAgZGF0YWJhc2U6IGRhdGFiYXNlIHx8IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHBhcmFtcy5jb250ZXh0LmFkZHJlc3MgPSBfdGhpcy5faW5pdGlhbEFkZHJlc3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVlcnkgPSBDQUxMX0dFVF9ST1VUSU5HX1RBQkxFO1xuICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGNvbnRleHQ6IF90aGlzLl9yb3V0aW5nQ29udGV4dFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5wcm90b2NvbCgpLnJ1bihxdWVyeSwgcGFyYW1zLCB7XG4gICAgICAgICAgYm9va21hcms6IHNlc3Npb24uX2xhc3RCb29rbWFyayxcbiAgICAgICAgICB0eENvbmZpZzogX3R4Q29uZmlnW1wiZGVmYXVsdFwiXS5lbXB0eSgpLFxuICAgICAgICAgIG1vZGU6IHNlc3Npb24uX21vZGUsXG4gICAgICAgICAgZGF0YWJhc2U6IHNlc3Npb24uX2RhdGFiYXNlLFxuICAgICAgICAgIGFmdGVyQ29tcGxldGU6IHNlc3Npb24uX29uQ29tcGxldGVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJvdXRpbmdVdGlsO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJvdXRpbmdVdGlsO1xuXG5mdW5jdGlvbiBwYXJzZUFycmF5KGFkZHJlc3Nlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYWRkcmVzc2VzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5IGV4cGVjdGVkIGJ1dCBnb3Q6ICcgKyBhZGRyZXNzZXMpO1xuICB9XG5cbiAgcmV0dXJuIEFycmF5LmZyb20oYWRkcmVzc2VzKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIF91cmxVdGlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91cmwtdXRpbFwiKSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIFNlcnZlckFkZHJlc3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZXJ2ZXJBZGRyZXNzKGhvc3QsIHJlc29sdmVkLCBwb3J0LCBob3N0UG9ydCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgU2VydmVyQWRkcmVzcyk7XG4gICAgdGhpcy5faG9zdCA9ICgwLCBfdXRpbC5hc3NlcnRTdHJpbmcpKGhvc3QsICdob3N0Jyk7XG4gICAgdGhpcy5fcmVzb2x2ZWQgPSByZXNvbHZlZCA/ICgwLCBfdXRpbC5hc3NlcnRTdHJpbmcpKHJlc29sdmVkLCAncmVzb2x2ZWQnKSA6IG51bGw7XG4gICAgdGhpcy5fcG9ydCA9ICgwLCBfdXRpbC5hc3NlcnROdW1iZXIpKHBvcnQsICdwb3J0Jyk7XG4gICAgdGhpcy5faG9zdFBvcnQgPSBob3N0UG9ydDtcbiAgICB0aGlzLl9zdHJpbmdWYWx1ZSA9IHJlc29sdmVkID8gXCJcIi5jb25jYXQoaG9zdFBvcnQsIFwiKFwiKS5jb25jYXQocmVzb2x2ZWQsIFwiKVwiKSA6IFwiXCIuY29uY2F0KGhvc3RQb3J0KTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoU2VydmVyQWRkcmVzcywgW3tcbiAgICBrZXk6IFwiaG9zdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBob3N0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hvc3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVkSG9zdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlZEhvc3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZWQgPyB0aGlzLl9yZXNvbHZlZCA6IHRoaXMuX2hvc3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9ydCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb3J0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNvbHZlV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlV2l0aChyZXNvbHZlZCkge1xuICAgICAgcmV0dXJuIG5ldyBTZXJ2ZXJBZGRyZXNzKHRoaXMuX2hvc3QsIHJlc29sdmVkLCB0aGlzLl9wb3J0LCB0aGlzLl9ob3N0UG9ydCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFzSG9zdFBvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNIb3N0UG9ydCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ob3N0UG9ydDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXNLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNLZXkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faG9zdFBvcnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0cmluZ1ZhbHVlO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21VcmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVVybCh1cmwpIHtcbiAgICAgIHZhciB1cmxQYXJzZWQgPSBfdXJsVXRpbFtcImRlZmF1bHRcIl0ucGFyc2VEYXRhYmFzZVVybCh1cmwpO1xuXG4gICAgICByZXR1cm4gbmV3IFNlcnZlckFkZHJlc3ModXJsUGFyc2VkLmhvc3QsIG51bGwsIHVybFBhcnNlZC5wb3J0LCB1cmxQYXJzZWQuaG9zdEFuZFBvcnQpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2VydmVyQWRkcmVzcztcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTZXJ2ZXJBZGRyZXNzOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVkVSU0lPTl9JTl9ERVYgPSBleHBvcnRzLlZFUlNJT05fNF8wXzAgPSBleHBvcnRzLlZFUlNJT05fM181XzAgPSBleHBvcnRzLlZFUlNJT05fM180XzAgPSBleHBvcnRzLlZFUlNJT05fM18yXzAgPSBleHBvcnRzLlNlcnZlclZlcnNpb24gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIFNFUlZFUl9WRVJTSU9OX1JFR0VYID0gbmV3IFJlZ0V4cCgnXihOZW80ai8pPyhcXFxcZCspXFxcXC4oXFxcXGQrKSg/OlxcXFwuKT8oXFxcXGQqKShcXFxcLnwtfFxcXFwrKT8oWzAtOUEtWmEtei0uXSopPyQnKTtcbnZhciBORU80Sl9JTl9ERVZfVkVSU0lPTl9TVFJJTkcgPSAnTmVvNGovZGV2JztcblxudmFyIFNlcnZlclZlcnNpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYWpvciB0aGUgbWFqb3IgdmVyc2lvbiBudW1iZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5vciB0aGUgbWlub3IgdmVyc2lvbiBudW1iZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYXRjaCB0aGUgcGF0Y2ggdmVyc2lvbiBudW1iZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aGUgb3JpZ2luYWwgdmVyc2lvbiBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIFNlcnZlclZlcnNpb24obWFqb3IsIG1pbm9yLCBwYXRjaCwgb3JpZ2luYWxWZXJzaW9uU3RyaW5nKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBTZXJ2ZXJWZXJzaW9uKTtcbiAgICB0aGlzLm1ham9yID0gbWFqb3I7XG4gICAgdGhpcy5taW5vciA9IG1pbm9yO1xuICAgIHRoaXMucGF0Y2ggPSBwYXRjaDtcbiAgICB0aGlzLl9vcmlnaW5hbFZlcnNpb25TdHJpbmcgPSBvcmlnaW5hbFZlcnNpb25TdHJpbmc7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIHNlcnZlciB2ZXJzaW9uIHVzaW5nIHRoZSBnaXZlbiBkcml2ZXIuXG4gICAqIEBwYXJhbSB7RHJpdmVyfSBkcml2ZXIgdGhlIGRyaXZlciB0byB1c2UuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8U2VydmVyVmVyc2lvbj59IHByb21pc2UgcmVzb2x2ZWQgd2l0aCBhIHtAbGluayBTZXJ2ZXJWZXJzaW9ufSBvYmplY3Qgb3IgcmVqZWN0ZWQgd2l0aCBlcnJvci5cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFNlcnZlclZlcnNpb24sIFt7XG4gICAga2V5OiBcImNvbXBhcmVUb1wiLFxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0aGlzIHZlcnNpb24gdG8gdGhlIGdpdmVuIG9uZS5cbiAgICAgKiBAcGFyYW0ge1NlcnZlclZlcnNpb259IG90aGVyIHRoZSB2ZXJzaW9uIHRvIGNvbXBhcmUgd2l0aC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHZhbHVlIDAgaWYgdGhpcyB2ZXJzaW9uIGlzIHRoZSBzYW1lIGFzIHRoZSBnaXZlbiBvbmUsIHZhbHVlIGxlc3MgdGhlbiAwIHdoZW4gdGhpcyB2ZXJzaW9uXG4gICAgICogd2FzIHJlbGVhc2VkIGVhcmxpZXIgdGhhbiB0aGUgZ2l2ZW4gb25lIGFuZCB2YWx1ZSBncmVhdGVyIHRoZW4gMCB3aGVuIHRoaXMgdmVyc2lvbiB3YXMgcmVsZWFzZWQgYWZ0ZXJcbiAgICAgKiB0aGFuIHRoZSBnaXZlbiBvbmUuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVJbnRzKHRoaXMubWFqb3IsIG90aGVyLm1ham9yKTtcblxuICAgICAgaWYgKHJlc3VsdCA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBjb21wYXJlSW50cyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcik7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IGNvbXBhcmVJbnRzKHRoaXMucGF0Y2gsIG90aGVyLnBhdGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIGlmICh0aGlzLl9vcmlnaW5hbFZlcnNpb25TdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsVmVyc2lvblN0cmluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMubWFqb3IsIFwiLlwiKS5jb25jYXQodGhpcy5taW5vciwgXCIuXCIpLmNvbmNhdCh0aGlzLnBhdGNoKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tRHJpdmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Ecml2ZXIoZHJpdmVyKSB7XG4gICAgICB2YXIgc2Vzc2lvbiA9IGRyaXZlci5zZXNzaW9uKCk7XG4gICAgICByZXR1cm4gc2Vzc2lvbi5ydW4oJ1JFVFVSTiAxJykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBzZXNzaW9uLmNsb3NlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFNlcnZlclZlcnNpb24uZnJvbVN0cmluZyhyZXN1bHQuc3VtbWFyeS5zZXJ2ZXIudmVyc2lvbik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGdpdmVuIHN0cmluZyB0byBhIHtAbGluayBTZXJ2ZXJWZXJzaW9ufSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb25TdHIgdGhlIHN0cmluZyB0byBwYXJzZS5cbiAgICAgKiBAcmV0dXJuIHtTZXJ2ZXJWZXJzaW9ufSB2ZXJzaW9uIGZvciB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgZ2l2ZW4gc3RyaW5nIGNhbid0IGJlIHBhcnNlZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZyb21TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVN0cmluZyh2ZXJzaW9uU3RyKSB7XG4gICAgICBpZiAoIXZlcnNpb25TdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXJ2ZXJWZXJzaW9uKDMsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0U3RyaW5nKSh2ZXJzaW9uU3RyLCAnTmVvNGogdmVyc2lvbiBzdHJpbmcnKTtcblxuICAgICAgaWYgKHZlcnNpb25TdHIudG9Mb3dlckNhc2UoKSA9PT0gTkVPNEpfSU5fREVWX1ZFUlNJT05fU1RSSU5HLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIFZFUlNJT05fSU5fREVWO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmVyc2lvbiA9IHZlcnNpb25TdHIubWF0Y2goU0VSVkVSX1ZFUlNJT05fUkVHRVgpO1xuXG4gICAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5wYXJzYWJsZSBOZW80aiB2ZXJzaW9uOiBcIi5jb25jYXQodmVyc2lvblN0cikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWFqb3IgPSBwYXJzZUludFN0cmljdCh2ZXJzaW9uWzJdKTtcbiAgICAgIHZhciBtaW5vciA9IHBhcnNlSW50U3RyaWN0KHZlcnNpb25bM10pO1xuICAgICAgdmFyIHBhdGNoID0gcGFyc2VJbnRTdHJpY3QodmVyc2lvbls0XSB8fCAwKTtcbiAgICAgIHJldHVybiBuZXcgU2VydmVyVmVyc2lvbihtYWpvciwgbWlub3IsIHBhdGNoLCB2ZXJzaW9uU3RyKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNlcnZlclZlcnNpb247XG59KCk7XG5cbmV4cG9ydHMuU2VydmVyVmVyc2lvbiA9IFNlcnZlclZlcnNpb247XG5cbmZ1bmN0aW9uIHBhcnNlSW50U3RyaWN0KHN0ciwgbmFtZSkge1xuICB2YXIgdmFsdWUgPSBwYXJzZUludChzdHIsIDEwKTtcblxuICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5wYXJzYWJsZSBudW1iZXIgXCIuY29uY2F0KG5hbWUsIFwiOiAnXCIpLmNvbmNhdChzdHIsIFwiJ1wiKSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVJbnRzKHgsIHkpIHtcbiAgcmV0dXJuIHggPCB5ID8gLTEgOiB4ID09PSB5ID8gMCA6IDE7XG59XG5cbnZhciBWRVJTSU9OXzNfMl8wID0gU2VydmVyVmVyc2lvbi5mcm9tU3RyaW5nKCdOZW80ai8zLjIuMCcpO1xuZXhwb3J0cy5WRVJTSU9OXzNfMl8wID0gVkVSU0lPTl8zXzJfMDtcbnZhciBWRVJTSU9OXzNfNF8wID0gU2VydmVyVmVyc2lvbi5mcm9tU3RyaW5nKCdOZW80ai8zLjQuMCcpO1xuZXhwb3J0cy5WRVJTSU9OXzNfNF8wID0gVkVSU0lPTl8zXzRfMDtcbnZhciBWRVJTSU9OXzNfNV8wID0gU2VydmVyVmVyc2lvbi5mcm9tU3RyaW5nKCdOZW80ai8zLjUuMCcpO1xuZXhwb3J0cy5WRVJTSU9OXzNfNV8wID0gVkVSU0lPTl8zXzVfMDtcbnZhciBWRVJTSU9OXzRfMF8wID0gU2VydmVyVmVyc2lvbi5mcm9tU3RyaW5nKCdOZW80ai80LjAuMCcpO1xuZXhwb3J0cy5WRVJTSU9OXzRfMF8wID0gVkVSU0lPTl80XzBfMDtcbnZhciBtYXhWZXIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbnZhciBWRVJTSU9OX0lOX0RFViA9IG5ldyBTZXJ2ZXJWZXJzaW9uKG1heFZlciwgbWF4VmVyLCBtYXhWZXIsIE5FTzRKX0lOX0RFVl9WRVJTSU9OX1NUUklORyk7XG5leHBvcnRzLlZFUlNJT05fSU5fREVWID0gVkVSU0lPTl9JTl9ERVY7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Db21wbGV0ZWRPYnNlcnZlciA9IGV4cG9ydHMuRmFpbGVkT2JzZXJ2ZXIgPSBleHBvcnRzLlJlc2V0T2JzZXJ2ZXIgPSBleHBvcnRzLkxvZ2luT2JzZXJ2ZXIgPSBleHBvcnRzLlJlc3VsdFN0cmVhbU9ic2VydmVyID0gZXhwb3J0cy5TdHJlYW1PYnNlcnZlciA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIikpO1xuXG52YXIgX2dldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3JlY29yZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3JlY29yZFwiKSk7XG5cbnZhciBfY29ubmVjdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29ubmVjdGlvblwiKSk7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG5cbnZhciBfaW50ZWdlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2ludGVnZXJcIikpO1xuXG52YXIgX3JlcXVlc3RNZXNzYWdlID0gcmVxdWlyZShcIi4vcmVxdWVzdC1tZXNzYWdlXCIpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgU3RyZWFtT2JzZXJ2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHJlYW1PYnNlcnZlcigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFN0cmVhbU9ic2VydmVyKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoU3RyZWFtT2JzZXJ2ZXIsIFt7XG4gICAga2V5OiBcIm9uTmV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk5leHQocmF3UmVjb3JkKSB7fVxuICB9LCB7XG4gICAga2V5OiBcIm9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25FcnJvcihlcnJvcikge31cbiAgfSwge1xuICAgIGtleTogXCJvbkNvbXBsZXRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNvbXBsZXRlZChtZXRhKSB7fVxuICB9XSk7XG4gIHJldHVybiBTdHJlYW1PYnNlcnZlcjtcbn0oKTtcbi8qKlxuICogSGFuZGxlcyBhIFJVTi9QVUxMX0FMTCwgb3IgUlVOL0RJU0NBUkRfQUxMIHJlcXVlc3RzLCBtYXBzIHRoZSByZXNwb25zZXNcbiAqIGluIGEgd2F5IHRoYXQgYSB1c2VyLXByb3ZpZGVkIG9ic2VydmVyIGNhbiBzZWUgdGhlc2UgYXMgYSBjbGVhbiBTdHJlYW1cbiAqIG9mIHJlY29yZHMuXG4gKiBUaGlzIGNsYXNzIHdpbGwgcXVldWUgdXAgaW5jb21pbmcgbWVzc2FnZXMgdW50aWwgYSB1c2VyLXByb3ZpZGVkIG9ic2VydmVyXG4gKiBmb3IgdGhlIGluY29taW5nIHN0cmVhbSBpcyByZWdpc3RlcmVkLiBUaHVzLCB3ZSBrZWVwIGZpZWxkcyBhcm91bmRcbiAqIGZvciB0cmFja2luZyBoZWFkL3JlY29yZHMvdGFpbC4gVGhlc2UgYXJlIG9ubHkgdXNlZCBpZiB0aGVyZSBpcyBub1xuICogb2JzZXJ2ZXIgcmVnaXN0ZXJlZC5cbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICovXG5cblxuZXhwb3J0cy5TdHJlYW1PYnNlcnZlciA9IFN0cmVhbU9ic2VydmVyO1xuXG52YXIgUmVzdWx0U3RyZWFtT2JzZXJ2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdHJlYW1PYnNlcnZlcikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKFJlc3VsdFN0cmVhbU9ic2VydmVyLCBfU3RyZWFtT2JzZXJ2ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUmVzdWx0U3RyZWFtT2JzZXJ2ZXIpO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBwYXJhbS5jb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW0ucmVhY3RpdmVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihjb25uZWN0aW9uOiBDb25uZWN0aW9uLCBzdG10SWQ6IG51bWJlcnxJbnRlZ2VyLCBuOiBudW1iZXJ8SW50ZWdlciwgb2JzZXJ2ZXI6IFN0cmVhbU9ic2VydmVyKX0gcGFyYW0ubW9yZUZ1bmN0aW9uIC1cbiAgICogQHBhcmFtIHtmdW5jdGlvbihjb25uZWN0aW9uOiBDb25uZWN0aW9uLCBzdG10SWQ6IG51bWJlcnxJbnRlZ2VyLCBvYnNlcnZlcjogU3RyZWFtT2JzZXJ2ZXIpfSBwYXJhbS5kaXNjYXJkRnVuY3Rpb24gLVxuICAgKiBAcGFyYW0ge251bWJlcnxJbnRlZ2VyfSBwYXJhbS5mZXRjaFNpemUgLVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycjogRXJyb3IpOiBQcm9taXNlfHZvaWR9IHBhcmFtLmJlZm9yZUVycm9yIC1cbiAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IEVycm9yKTogUHJvbWlzZXx2b2lkfSBwYXJhbS5hZnRlckVycm9yIC1cbiAgICogQHBhcmFtIHtmdW5jdGlvbihrZXlzOiBzdHJpbmdbXSk6IFByb21pc2V8dm9pZH0gcGFyYW0uYmVmb3JlS2V5cyAtXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oa2V5czogc3RyaW5nW10pOiBQcm9taXNlfHZvaWR9IHBhcmFtLmFmdGVyS2V5cyAtXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obWV0YWRhdGE6IE9iamVjdCk6IFByb21pc2V8dm9pZH0gcGFyYW0uYmVmb3JlQ29tcGxldGUgLVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG1ldGFkYXRhOiBPYmplY3QpOiBQcm9taXNlfHZvaWR9IHBhcmFtLmFmdGVyQ29tcGxldGUgLVxuICAgKi9cbiAgZnVuY3Rpb24gUmVzdWx0U3RyZWFtT2JzZXJ2ZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBjb25uZWN0aW9uID0gX3JlZi5jb25uZWN0aW9uLFxuICAgICAgICBfcmVmJHJlYWN0aXZlID0gX3JlZi5yZWFjdGl2ZSxcbiAgICAgICAgcmVhY3RpdmUgPSBfcmVmJHJlYWN0aXZlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkcmVhY3RpdmUsXG4gICAgICAgIG1vcmVGdW5jdGlvbiA9IF9yZWYubW9yZUZ1bmN0aW9uLFxuICAgICAgICBkaXNjYXJkRnVuY3Rpb24gPSBfcmVmLmRpc2NhcmRGdW5jdGlvbixcbiAgICAgICAgX3JlZiRmZXRjaFNpemUgPSBfcmVmLmZldGNoU2l6ZSxcbiAgICAgICAgZmV0Y2hTaXplID0gX3JlZiRmZXRjaFNpemUgPT09IHZvaWQgMCA/IF9yZXF1ZXN0TWVzc2FnZS5BTEwgOiBfcmVmJGZldGNoU2l6ZSxcbiAgICAgICAgYmVmb3JlRXJyb3IgPSBfcmVmLmJlZm9yZUVycm9yLFxuICAgICAgICBhZnRlckVycm9yID0gX3JlZi5hZnRlckVycm9yLFxuICAgICAgICBiZWZvcmVLZXlzID0gX3JlZi5iZWZvcmVLZXlzLFxuICAgICAgICBhZnRlcktleXMgPSBfcmVmLmFmdGVyS2V5cyxcbiAgICAgICAgYmVmb3JlQ29tcGxldGUgPSBfcmVmLmJlZm9yZUNvbXBsZXRlLFxuICAgICAgICBhZnRlckNvbXBsZXRlID0gX3JlZi5hZnRlckNvbXBsZXRlO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBSZXN1bHRTdHJlYW1PYnNlcnZlcik7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgX3RoaXMuX2ZpZWxkS2V5cyA9IG51bGw7XG4gICAgX3RoaXMuX2ZpZWxkTG9va3VwID0gbnVsbDtcbiAgICBfdGhpcy5faGVhZCA9IG51bGw7XG4gICAgX3RoaXMuX3F1ZXVlZFJlY29yZHMgPSBbXTtcbiAgICBfdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgX3RoaXMuX2Vycm9yID0gbnVsbDtcbiAgICBfdGhpcy5fb2JzZXJ2ZXJzID0gW107XG4gICAgX3RoaXMuX21ldGEgPSB7fTtcbiAgICBfdGhpcy5fYmVmb3JlRXJyb3IgPSBiZWZvcmVFcnJvcjtcbiAgICBfdGhpcy5fYWZ0ZXJFcnJvciA9IGFmdGVyRXJyb3I7XG4gICAgX3RoaXMuX2JlZm9yZUtleXMgPSBiZWZvcmVLZXlzO1xuICAgIF90aGlzLl9hZnRlcktleXMgPSBhZnRlcktleXM7XG4gICAgX3RoaXMuX2JlZm9yZUNvbXBsZXRlID0gYmVmb3JlQ29tcGxldGU7XG4gICAgX3RoaXMuX2FmdGVyQ29tcGxldGUgPSBhZnRlckNvbXBsZXRlO1xuICAgIF90aGlzLl9xdWVyeUlkID0gbnVsbDtcbiAgICBfdGhpcy5fbW9yZUZ1bmN0aW9uID0gbW9yZUZ1bmN0aW9uO1xuICAgIF90aGlzLl9kaXNjYXJkRnVuY3Rpb24gPSBkaXNjYXJkRnVuY3Rpb247XG4gICAgX3RoaXMuX2Rpc2NhcmQgPSBmYWxzZTtcbiAgICBfdGhpcy5fZmV0Y2hTaXplID0gZmV0Y2hTaXplO1xuXG4gICAgX3RoaXMuX3NldFN0YXRlKHJlYWN0aXZlID8gX3N0YXRlcy5SRUFEWSA6IF9zdGF0ZXMuUkVBRFlfU1RSRUFNSU5HKTtcblxuICAgIF90aGlzLl9zZXR1cEF1b1B1bGwoZmV0Y2hTaXplKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogV2lsbCBiZSBjYWxsZWQgb24gZXZlcnkgcmVjb3JkIHRoYXQgY29tZXMgaW4gYW5kIHRyYW5zZm9ybSBhIHJhdyByZWNvcmRcbiAgICogdG8gYSBPYmplY3QuIElmIHVzZXItcHJvdmlkZWQgb2JzZXJ2ZXIgaXMgcHJlc2VudCwgcGFzcyB0cmFuc2Zvcm1lZCByZWNvcmRcbiAgICogdG8gaXQncyBvbk5leHQgbWV0aG9kLCBvdGhlcndpc2UsIHB1c2ggdG8gcmVjb3JkIHF1ZS5cbiAgICogQHBhcmFtIHtBcnJheX0gcmF3UmVjb3JkIC0gQW4gYXJyYXkgd2l0aCB0aGUgcmF3IHJlY29yZFxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUmVzdWx0U3RyZWFtT2JzZXJ2ZXIsIFt7XG4gICAga2V5OiBcIm9uTmV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk5leHQocmF3UmVjb3JkKSB7XG4gICAgICB2YXIgcmVjb3JkID0gbmV3IF9yZWNvcmRbXCJkZWZhdWx0XCJdKHRoaXMuX2ZpZWxkS2V5cywgcmF3UmVjb3JkLCB0aGlzLl9maWVsZExvb2t1cCk7XG5cbiAgICAgIGlmICh0aGlzLl9vYnNlcnZlcnMuc29tZShmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gby5vbk5leHQ7XG4gICAgICB9KSkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAobykge1xuICAgICAgICAgIGlmIChvLm9uTmV4dCkge1xuICAgICAgICAgICAgby5vbk5leHQocmVjb3JkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcXVldWVkUmVjb3Jkcy5wdXNoKHJlY29yZCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlZFJlY29yZHMubGVuZ3RoID4gdGhpcy5faGlnaFJlY29yZFdhdGVybWFyaykge1xuICAgICAgICAgIHRoaXMuX2F1dG9QdWxsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25Db21wbGV0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Db21wbGV0ZWQobWV0YSkge1xuICAgICAgdGhpcy5fc3RhdGUub25TdWNjZXNzKHRoaXMsIG1ldGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIGJlIGNhbGxlZCBvbiBlcnJvcnMuXG4gICAgICogSWYgdXNlci1wcm92aWRlZCBvYnNlcnZlciBpcyBwcmVzZW50LCBwYXNzIHRoZSBlcnJvclxuICAgICAqIHRvIGl0J3Mgb25FcnJvciBtZXRob2QsIG90aGVyd2lzZSBzZXQgaW5zdGFuY2UgdmFyaWFibGUgX2Vycm9yLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvciAtIEFuIGVycm9yIG9iamVjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5vbkVycm9yKHRoaXMsIGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHBlbmRpbmcgcmVjb3JkIHN0cmVhbVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIHRoaXMuX2Rpc2NhcmQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gb2JzZXJ2ZXIgZGVmYXVsdHMgdG8gaGFuZGxpbmcgcmVzcG9uc2VzIGZvciB0d28gbWVzc2FnZXM6IFJVTiArIFBVTExfQUxMIG9yIFJVTiArIERJU0NBUkRfQUxMLlxuICAgICAqIFJlc3BvbnNlIGZvciBSVU4gaW5pdGlhbGl6ZXMgcXVlcnkga2V5cy4gUmVzcG9uc2UgZm9yIFBVTExfQUxMIC8gRElTQ0FSRF9BTEwgZXhwb3NlcyB0aGUgcmVzdWx0IHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIHNvbWUgb3BlcmF0aW9ucyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBzaW5nbGUgbWVzc2FnZSB3aGljaCByZWNlaXZlcyBmdWxsIG1ldGFkYXRhIGluIGEgc2luZ2xlIHJlc3BvbnNlLlxuICAgICAqIEZvciBleGFtcGxlLCBvcGVyYXRpb25zIHRvIGJlZ2luLCBjb21taXQgYW5kIHJvbGxiYWNrIGFuIGV4cGxpY2l0IHRyYW5zYWN0aW9uIHVzZSB0d28gbWVzc2FnZXMgaW4gQm9sdCBWMSBidXQgYSBzaW5nbGUgbWVzc2FnZSBpbiBCb2x0IFYzLlxuICAgICAqIE1lc3NhZ2VzIGFyZSBgUlVOIFwiQkVHSU5cIiB7fWAgKyBgUFVMTF9BTExgIGluIEJvbHQgVjEgYW5kIGBCRUdJTmAgaW4gQm9sdCBWMy5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcHJlcGFyZXMgdGhlIG9ic2VydmVyIHRvIG9ubHkgaGFuZGxlIGEgc2luZ2xlIHJlc3BvbnNlIG1lc3NhZ2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcmVwYXJlVG9IYW5kbGVTaW5nbGVSZXNwb25zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwYXJlVG9IYW5kbGVTaW5nbGVSZXNwb25zZSgpIHtcbiAgICAgIHRoaXMuX2hlYWQgPSBbXTtcbiAgICAgIHRoaXMuX2ZpZWxkS2V5cyA9IFtdO1xuXG4gICAgICB0aGlzLl9zZXRTdGF0ZShfc3RhdGVzLlNUUkVBTUlORyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmsgdGhpcyBvYnNlcnZlciBhcyBpZiBpdCBoYXMgY29tcGxldGVkIHdpdGggbm8gbWV0YWRhdGEuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXJrQ29tcGxldGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtDb21wbGV0ZWQoKSB7XG4gICAgICB0aGlzLl9oZWFkID0gW107XG4gICAgICB0aGlzLl9maWVsZEtleXMgPSBbXTtcbiAgICAgIHRoaXMuX3RhaWwgPSB7fTtcblxuICAgICAgdGhpcy5fc2V0U3RhdGUoX3N0YXRlcy5TVUNDRUVERUQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gZXZlbnRzIHdpdGggcHJvdmlkZWQgb2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihrZXlzOiBTdHJpbmdbXSl9IG9ic2VydmVyLm9uS2V5cyAtIEhhbmRsZSBzdHJlYW0gaGVhZGVyLCBmaWVsZCBrZXlzLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24ocmVjb3JkOiBPYmplY3QpfSBvYnNlcnZlci5vbk5leHQgLSBIYW5kbGUgcmVjb3Jkcywgb25lIGJ5IG9uZS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG1ldGFkYXRhOiBPYmplY3QpfSBvYnNlcnZlci5vbkNvbXBsZXRlZCAtIEhhbmRsZSBzdHJlYW0gdGFpbCwgdGhlIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyb3I6IE9iamVjdCl9IG9ic2VydmVyLm9uRXJyb3IgLSBIYW5kbGUgZXJyb3JzLCBzaG91bGQgYWx3YXlzIGJlIHByb3ZpZGVkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3Vic2NyaWJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgaWYgKHRoaXMuX2Vycm9yKSB7XG4gICAgICAgIG9ic2VydmVyLm9uRXJyb3IodGhpcy5fZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9oZWFkICYmIG9ic2VydmVyLm9uS2V5cykge1xuICAgICAgICBvYnNlcnZlci5vbktleXModGhpcy5faGVhZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9xdWV1ZWRSZWNvcmRzLmxlbmd0aCA+IDAgJiYgb2JzZXJ2ZXIub25OZXh0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcXVldWVkUmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9ic2VydmVyLm9uTmV4dCh0aGlzLl9xdWV1ZWRSZWNvcmRzW2ldKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9xdWV1ZWRSZWNvcmRzLmxlbmd0aCAtIGkgLSAxIDw9IHRoaXMuX2xvd1JlY29yZFdhdGVybWFyaykge1xuICAgICAgICAgICAgdGhpcy5fYXV0b1B1bGwgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IF9zdGF0ZXMuUkVBRFkpIHtcbiAgICAgICAgICAgICAgdGhpcy5faGFuZGxlU3RyZWFtaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl90YWlsICYmIG9ic2VydmVyLm9uQ29tcGxldGVkKSB7XG4gICAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkKHRoaXMuX3RhaWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG5cbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gX3N0YXRlcy5SRUFEWSkge1xuICAgICAgICB0aGlzLl9oYW5kbGVTdHJlYW1pbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZUhhc01vcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUhhc01vcmUobWV0YSkge1xuICAgICAgLy8gV2UndmUgY29uc3VtZWQgY3VycmVudCBiYXRjaCBhbmQgc2VydmVyIG5vdGlmaWVkIHVzIHRoYXQgdGhlcmUncmUgbW9yZVxuICAgICAgLy8gcmVjb3JkcyB0byBzdHJlYW0uIExldCdzIGludm9rZSBtb3JlIG9yIGRpc2NhcmQgZnVuY3Rpb24gYmFzZWQgb24gd2hldGhlclxuICAgICAgLy8gdGhlIHVzZXIgd2FudHMgdG8gZGlzY2FyZCBzdHJlYW1pbmcgb3Igbm90XG4gICAgICB0aGlzLl9zZXRTdGF0ZShfc3RhdGVzLlJFQURZKTsgLy8gd2UndmUgZG9uZSBzdHJlYW1pbmdcblxuXG4gICAgICB0aGlzLl9oYW5kbGVTdHJlYW1pbmcoKTtcblxuICAgICAgZGVsZXRlIG1ldGEuaGFzX21vcmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVQdWxsU3VjY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlUHVsbFN1Y2Nlc3MobWV0YSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX3NldFN0YXRlKF9zdGF0ZXMuU1VDQ0VFREVEKTtcblxuICAgICAgdmFyIGNvbXBsZXRpb25NZXRhZGF0YSA9IE9iamVjdC5hc3NpZ24odGhpcy5fY29ubmVjdGlvbiA/IHtcbiAgICAgICAgc2VydmVyOiB0aGlzLl9jb25uZWN0aW9uLnNlcnZlclxuICAgICAgfSA6IHt9LCB0aGlzLl9tZXRhLCBtZXRhKTtcbiAgICAgIHZhciBiZWZvcmVIYW5kbGVyUmVzdWx0ID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuX2JlZm9yZUNvbXBsZXRlKSB7XG4gICAgICAgIGJlZm9yZUhhbmRsZXJSZXN1bHQgPSB0aGlzLl9iZWZvcmVDb21wbGV0ZShjb21wbGV0aW9uTWV0YWRhdGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGludWF0aW9uID0gZnVuY3Rpb24gY29udGludWF0aW9uKCkge1xuICAgICAgICAvLyBFbmQgb2Ygc3RyZWFtXG4gICAgICAgIF90aGlzMi5fdGFpbCA9IGNvbXBsZXRpb25NZXRhZGF0YTtcblxuICAgICAgICBpZiAoX3RoaXMyLl9vYnNlcnZlcnMuc29tZShmdW5jdGlvbiAobykge1xuICAgICAgICAgIHJldHVybiBvLm9uQ29tcGxldGVkO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIF90aGlzMi5fb2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIGlmIChvLm9uQ29tcGxldGVkKSB7XG4gICAgICAgICAgICAgIG8ub25Db21wbGV0ZWQoY29tcGxldGlvbk1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpczIuX2FmdGVyQ29tcGxldGUpIHtcbiAgICAgICAgICBfdGhpczIuX2FmdGVyQ29tcGxldGUoY29tcGxldGlvbk1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGJlZm9yZUhhbmRsZXJSZXN1bHQpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGJlZm9yZUhhbmRsZXJSZXN1bHQpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250aW51YXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51YXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZVJ1blN1Y2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVJ1blN1Y2Nlc3MobWV0YSwgYWZ0ZXJTdWNjZXNzKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2ZpZWxkS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBTdHJlYW0gaGVhZGVyLCBidWlsZCBhIG5hbWUtPmluZGV4IGZpZWxkIGxvb2t1cCB0YWJsZVxuICAgICAgICAvLyB0byBiZSB1c2VkIGJ5IHJlY29yZHMuIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1ha2UgaXRcbiAgICAgICAgLy8gZmFzdGVyIHRvIGxvb2sgdXAgZmllbGRzIGluIGEgcmVjb3JkIGJ5IG5hbWUsIHJhdGhlciB0aGFuIGJ5IGluZGV4LlxuICAgICAgICAvLyBTaW5jZSB0aGUgcmVjb3JkcyB3ZSBnZXQgYmFjayB2aWEgQm9sdCBhcmUganVzdCBhcnJheXMgb2YgdmFsdWVzLlxuICAgICAgICB0aGlzLl9maWVsZEtleXMgPSBbXTtcbiAgICAgICAgdGhpcy5fZmllbGRMb29rdXAgPSB7fTtcblxuICAgICAgICBpZiAobWV0YS5maWVsZHMgJiYgbWV0YS5maWVsZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuX2ZpZWxkS2V5cyA9IG1ldGEuZmllbGRzO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fZmllbGRMb29rdXBbbWV0YS5maWVsZHNbaV1dID0gaTtcbiAgICAgICAgICB9IC8vIHJlbW92ZSBmaWVsZHMga2V5IGZyb20gbWV0YWRhdGEgb2JqZWN0XG5cblxuICAgICAgICAgIGRlbGV0ZSBtZXRhLmZpZWxkcztcbiAgICAgICAgfSAvLyBFeHRyYWN0IHNlcnZlciBnZW5lcmF0ZWQgcXVlcnkgaWQgZm9yIHVzZSBpbiByZXF1ZXN0TW9yZSBhbmQgZGlzY2FyZFxuICAgICAgICAvLyBmdW5jdGlvbnNcblxuXG4gICAgICAgIGlmIChtZXRhLnFpZCkge1xuICAgICAgICAgIHRoaXMuX3F1ZXJ5SWQgPSBtZXRhLnFpZDsgLy8gcmVtb3ZlIHFpZCBmcm9tIG1ldGFkYXRhIG9iamVjdFxuXG4gICAgICAgICAgZGVsZXRlIG1ldGEucWlkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RvcmVNZXRhZGF0YUZvckNvbXBsZXRpb24obWV0YSk7XG5cbiAgICAgICAgdmFyIGJlZm9yZUhhbmRsZXJSZXN1bHQgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLl9iZWZvcmVLZXlzKSB7XG4gICAgICAgICAgYmVmb3JlSGFuZGxlclJlc3VsdCA9IHRoaXMuX2JlZm9yZUtleXModGhpcy5fZmllbGRLZXlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250aW51YXRpb24gPSBmdW5jdGlvbiBjb250aW51YXRpb24oKSB7XG4gICAgICAgICAgX3RoaXMzLl9oZWFkID0gX3RoaXMzLl9maWVsZEtleXM7XG5cbiAgICAgICAgICBpZiAoX3RoaXMzLl9vYnNlcnZlcnMuc29tZShmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgcmV0dXJuIG8ub25LZXlzO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBfdGhpczMuX29ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgIGlmIChvLm9uS2V5cykge1xuICAgICAgICAgICAgICAgIG8ub25LZXlzKF90aGlzMy5fZmllbGRLZXlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF90aGlzMy5fYWZ0ZXJLZXlzKSB7XG4gICAgICAgICAgICBfdGhpczMuX2FmdGVyS2V5cyhfdGhpczMuX2ZpZWxkS2V5cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWZ0ZXJTdWNjZXNzKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGJlZm9yZUhhbmRsZXJSZXN1bHQpIHtcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoYmVmb3JlSGFuZGxlclJlc3VsdCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGludWF0aW9uKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGludWF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZUVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVFcnJvcihlcnJvcikge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX3NldFN0YXRlKF9zdGF0ZXMuRkFJTEVEKTtcblxuICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgIHZhciBiZWZvcmVIYW5kbGVyUmVzdWx0ID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuX2JlZm9yZUVycm9yKSB7XG4gICAgICAgIGJlZm9yZUhhbmRsZXJSZXN1bHQgPSB0aGlzLl9iZWZvcmVFcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250aW51YXRpb24gPSBmdW5jdGlvbiBjb250aW51YXRpb24oKSB7XG4gICAgICAgIGlmIChfdGhpczQuX29ic2VydmVycy5zb21lKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgcmV0dXJuIG8ub25FcnJvcjtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBfdGhpczQuX29ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICBpZiAoby5vbkVycm9yKSB7XG4gICAgICAgICAgICAgIG8ub25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXM0Ll9hZnRlckVycm9yKSB7XG4gICAgICAgICAgX3RoaXM0Ll9hZnRlckVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGJlZm9yZUhhbmRsZXJSZXN1bHQpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGJlZm9yZUhhbmRsZXJSZXN1bHQpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250aW51YXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51YXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZVN0cmVhbWluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlU3RyZWFtaW5nKCkge1xuICAgICAgaWYgKHRoaXMuX2hlYWQgJiYgdGhpcy5fb2JzZXJ2ZXJzLnNvbWUoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIG8ub25OZXh0IHx8IG8ub25Db21wbGV0ZWQ7XG4gICAgICB9KSkge1xuICAgICAgICBpZiAodGhpcy5fZGlzY2FyZCkge1xuICAgICAgICAgIHRoaXMuX2Rpc2NhcmRGdW5jdGlvbih0aGlzLl9jb25uZWN0aW9uLCB0aGlzLl9xdWVyeUlkLCB0aGlzKTtcblxuICAgICAgICAgIHRoaXMuX3NldFN0YXRlKF9zdGF0ZXMuU1RSRUFNSU5HKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9hdXRvUHVsbCkge1xuICAgICAgICAgIHRoaXMuX21vcmVGdW5jdGlvbih0aGlzLl9jb25uZWN0aW9uLCB0aGlzLl9xdWVyeUlkLCB0aGlzLl9mZXRjaFNpemUsIHRoaXMpO1xuXG4gICAgICAgICAgdGhpcy5fc2V0U3RhdGUoX3N0YXRlcy5TVFJFQU1JTkcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zdG9yZU1ldGFkYXRhRm9yQ29tcGxldGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RvcmVNZXRhZGF0YUZvckNvbXBsZXRpb24obWV0YSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhtZXRhKTtcbiAgICAgIHZhciBpbmRleCA9IGtleXMubGVuZ3RoO1xuICAgICAgdmFyIGtleSA9ICcnO1xuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgdGhpcy5fbWV0YVtrZXldID0gbWV0YVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0U3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFN0YXRlKHN0YXRlKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0dXBBdW9QdWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEF1b1B1bGwoZmV0Y2hTaXplKSB7XG4gICAgICB0aGlzLl9hdXRvUHVsbCA9IHRydWU7XG5cbiAgICAgIGlmIChmZXRjaFNpemUgPT09IF9yZXF1ZXN0TWVzc2FnZS5BTEwpIHtcbiAgICAgICAgdGhpcy5fbG93UmVjb3JkV2F0ZXJtYXJrID0gTnVtYmVyLk1BWF9WQUxVRTsgLy8gd2Ugc2hhbGwgYWx3YXlzIGxvd2VyIHRoYW4gdGhpcyBudW1iZXIgdG8gZW5hYmxlIGF1dG8gcHVsbFxuXG4gICAgICAgIHRoaXMuX2hpZ2hSZWNvcmRXYXRlcm1hcmsgPSBOdW1iZXIuTUFYX1ZBTFVFOyAvLyB3ZSBzaGFsbCBuZXZlciByZWFjaCB0aGlzIG51bWJlciB0byBkaXNhYmxlIGF1dG8gcHVsbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbG93UmVjb3JkV2F0ZXJtYXJrID0gMC4zICogZmV0Y2hTaXplO1xuICAgICAgICB0aGlzLl9oaWdoUmVjb3JkV2F0ZXJtYXJrID0gMC43ICogZmV0Y2hTaXplO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUmVzdWx0U3RyZWFtT2JzZXJ2ZXI7XG59KFN0cmVhbU9ic2VydmVyKTtcblxuZXhwb3J0cy5SZXN1bHRTdHJlYW1PYnNlcnZlciA9IFJlc3VsdFN0cmVhbU9ic2VydmVyO1xuXG52YXIgTG9naW5PYnNlcnZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N0cmVhbU9ic2VydmVyMikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKExvZ2luT2JzZXJ2ZXIsIF9TdHJlYW1PYnNlcnZlcjIpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKExvZ2luT2JzZXJ2ZXIpO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gLVxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IHBhcmFtLmNvbm5lY3Rpb25cbiAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IEVycm9yKX0gcGFyYW0uYmVmb3JlRXJyb3JcbiAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IEVycm9yKX0gcGFyYW0uYWZ0ZXJFcnJvclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG1ldGFkYXRhKX0gcGFyYW0uYmVmb3JlQ29tcGxldGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihtZXRhZGF0YSl9IHBhcmFtLmFmdGVyQ29tcGxldGVcbiAgICovXG4gIGZ1bmN0aW9uIExvZ2luT2JzZXJ2ZXIoKSB7XG4gICAgdmFyIF90aGlzNTtcblxuICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIGNvbm5lY3Rpb24gPSBfcmVmMi5jb25uZWN0aW9uLFxuICAgICAgICBiZWZvcmVFcnJvciA9IF9yZWYyLmJlZm9yZUVycm9yLFxuICAgICAgICBhZnRlckVycm9yID0gX3JlZjIuYWZ0ZXJFcnJvcixcbiAgICAgICAgYmVmb3JlQ29tcGxldGUgPSBfcmVmMi5iZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgYWZ0ZXJDb21wbGV0ZSA9IF9yZWYyLmFmdGVyQ29tcGxldGU7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIExvZ2luT2JzZXJ2ZXIpO1xuICAgIF90aGlzNSA9IF9zdXBlcjIuY2FsbCh0aGlzKTtcbiAgICBfdGhpczUuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIF90aGlzNS5fYmVmb3JlRXJyb3IgPSBiZWZvcmVFcnJvcjtcbiAgICBfdGhpczUuX2FmdGVyRXJyb3IgPSBhZnRlckVycm9yO1xuICAgIF90aGlzNS5fYmVmb3JlQ29tcGxldGUgPSBiZWZvcmVDb21wbGV0ZTtcbiAgICBfdGhpczUuX2FmdGVyQ29tcGxldGUgPSBhZnRlckNvbXBsZXRlO1xuICAgIHJldHVybiBfdGhpczU7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKExvZ2luT2JzZXJ2ZXIsIFt7XG4gICAga2V5OiBcIm9uTmV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk5leHQocmVjb3JkKSB7XG4gICAgICB0aGlzLm9uRXJyb3IoKDAsIF9lcnJvci5uZXdFcnJvcikoJ1JlY2VpdmVkIFJFQ09SRCB3aGVuIGluaXRpYWxpemluZyAnICsgSlNPTi5zdHJpbmdpZnkocmVjb3JkKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgIGlmICh0aGlzLl9iZWZvcmVFcnJvcikge1xuICAgICAgICB0aGlzLl9iZWZvcmVFcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uX3VwZGF0ZUN1cnJlbnRPYnNlcnZlcigpOyAvLyBtYWtlIHN1cmUgdGhpcyBleGFjdCBvYnNlcnZlciB3aWxsIG5vdCBiZSBjYWxsZWQgYWdhaW5cblxuXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLl9oYW5kbGVGYXRhbEVycm9yKGVycm9yKTsgLy8gaW5pdGlhbGl6YXRpb24gZXJyb3JzIGFyZSBmYXRhbFxuXG5cbiAgICAgIGlmICh0aGlzLl9hZnRlckVycm9yKSB7XG4gICAgICAgIHRoaXMuX2FmdGVyRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbkNvbXBsZXRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNvbXBsZXRlZChtZXRhZGF0YSkge1xuICAgICAgaWYgKHRoaXMuX2JlZm9yZUNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMuX2JlZm9yZUNvbXBsZXRlKG1ldGFkYXRhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgIC8vIHJlYWQgc2VydmVyIHZlcnNpb24gZnJvbSB0aGUgcmVzcG9uc2UgbWV0YWRhdGEsIGlmIGl0IGlzIGF2YWlsYWJsZVxuICAgICAgICB2YXIgc2VydmVyVmVyc2lvbiA9IG1ldGFkYXRhLnNlcnZlcjtcblxuICAgICAgICBpZiAoIXRoaXMuX2Nvbm5lY3Rpb24udmVyc2lvbikge1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24udmVyc2lvbiA9IHNlcnZlclZlcnNpb247XG4gICAgICAgIH0gLy8gcmVhZCBkYXRhYmFzZSBjb25uZWN0aW9uIGlkIGZyb20gdGhlIHJlc3BvbnNlIG1ldGFkYXRhLCBpZiBpdCBpcyBhdmFpbGFibGVcblxuXG4gICAgICAgIHZhciBkYkNvbm5lY3Rpb25JZCA9IG1ldGFkYXRhLmNvbm5lY3Rpb25faWQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jb25uZWN0aW9uLmRhdGFiYXNlSWQpIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uLmRhdGFiYXNlSWQgPSBkYkNvbm5lY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYWZ0ZXJDb21wbGV0ZSkge1xuICAgICAgICB0aGlzLl9hZnRlckNvbXBsZXRlKG1ldGFkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExvZ2luT2JzZXJ2ZXI7XG59KFN0cmVhbU9ic2VydmVyKTtcblxuZXhwb3J0cy5Mb2dpbk9ic2VydmVyID0gTG9naW5PYnNlcnZlcjtcblxudmFyIFJlc2V0T2JzZXJ2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdHJlYW1PYnNlcnZlcjMpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShSZXNldE9ic2VydmVyLCBfU3RyZWFtT2JzZXJ2ZXIzKTtcblxuICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlcihSZXNldE9ic2VydmVyKTtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIC1cbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBwYXJhbS5jb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBFcnJvcil9IHBhcmFtLm9uRXJyb3JcbiAgICogQHBhcmFtIHtmdW5jdGlvbihtZXRhZGF0YSl9IHBhcmFtLm9uQ29tcGxldGVcbiAgICovXG4gIGZ1bmN0aW9uIFJlc2V0T2JzZXJ2ZXIoKSB7XG4gICAgdmFyIF90aGlzNjtcblxuICAgIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIGNvbm5lY3Rpb24gPSBfcmVmMy5jb25uZWN0aW9uLFxuICAgICAgICBvbkVycm9yID0gX3JlZjMub25FcnJvcixcbiAgICAgICAgb25Db21wbGV0ZSA9IF9yZWYzLm9uQ29tcGxldGU7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFJlc2V0T2JzZXJ2ZXIpO1xuICAgIF90aGlzNiA9IF9zdXBlcjMuY2FsbCh0aGlzKTtcbiAgICBfdGhpczYuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIF90aGlzNi5fb25FcnJvciA9IG9uRXJyb3I7XG4gICAgX3RoaXM2Ll9vbkNvbXBsZXRlID0gb25Db21wbGV0ZTtcbiAgICByZXR1cm4gX3RoaXM2O1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShSZXNldE9ic2VydmVyLCBbe1xuICAgIGtleTogXCJvbk5leHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25OZXh0KHJlY29yZCkge1xuICAgICAgdGhpcy5vbkVycm9yKCgwLCBfZXJyb3IubmV3RXJyb3IpKCdSZWNlaXZlZCBSRUNPUkQgd2hlbiByZXNldHRpbmc6IHJlY2VpdmVkIHJlY29yZCBpczogJyArIEpTT04uc3RyaW5naWZ5KHJlY29yZCksIF9lcnJvci5QUk9UT0NPTF9FUlJPUikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSBfZXJyb3IuUFJPVE9DT0xfRVJST1IpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5faGFuZGxlUHJvdG9jb2xFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX29uRXJyb3IpIHtcbiAgICAgICAgdGhpcy5fb25FcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uQ29tcGxldGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ29tcGxldGVkKG1ldGFkYXRhKSB7XG4gICAgICBpZiAodGhpcy5fb25Db21wbGV0ZSkge1xuICAgICAgICB0aGlzLl9vbkNvbXBsZXRlKG1ldGFkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlc2V0T2JzZXJ2ZXI7XG59KFN0cmVhbU9ic2VydmVyKTtcblxuZXhwb3J0cy5SZXNldE9ic2VydmVyID0gUmVzZXRPYnNlcnZlcjtcblxudmFyIEZhaWxlZE9ic2VydmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVzdWx0U3RyZWFtT2JzZXJ2ZXIpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShGYWlsZWRPYnNlcnZlciwgX1Jlc3VsdFN0cmVhbU9ic2VydmVyKTtcblxuICB2YXIgX3N1cGVyNCA9IF9jcmVhdGVTdXBlcihGYWlsZWRPYnNlcnZlcik7XG5cbiAgZnVuY3Rpb24gRmFpbGVkT2JzZXJ2ZXIoX3JlZjQpIHtcbiAgICB2YXIgX3RoaXM3O1xuXG4gICAgdmFyIGVycm9yID0gX3JlZjQuZXJyb3IsXG4gICAgICAgIG9uRXJyb3IgPSBfcmVmNC5vbkVycm9yO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgRmFpbGVkT2JzZXJ2ZXIpO1xuICAgIF90aGlzNyA9IF9zdXBlcjQuY2FsbCh0aGlzLCB7XG4gICAgICBiZWZvcmVFcnJvcjogb25FcnJvclxuICAgIH0pO1xuXG4gICAgX3RoaXM3Lm9uRXJyb3IoZXJyb3IpO1xuXG4gICAgcmV0dXJuIF90aGlzNztcbiAgfVxuXG4gIHJldHVybiBGYWlsZWRPYnNlcnZlcjtcbn0oUmVzdWx0U3RyZWFtT2JzZXJ2ZXIpO1xuXG5leHBvcnRzLkZhaWxlZE9ic2VydmVyID0gRmFpbGVkT2JzZXJ2ZXI7XG5cbnZhciBDb21wbGV0ZWRPYnNlcnZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Jlc3VsdFN0cmVhbU9ic2VydmVyMikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKENvbXBsZXRlZE9ic2VydmVyLCBfUmVzdWx0U3RyZWFtT2JzZXJ2ZXIyKTtcblxuICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihDb21wbGV0ZWRPYnNlcnZlcik7XG5cbiAgZnVuY3Rpb24gQ29tcGxldGVkT2JzZXJ2ZXIoKSB7XG4gICAgdmFyIF90aGlzU3VwZXIsIF90aGlzODtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgQ29tcGxldGVkT2JzZXJ2ZXIpO1xuICAgIF90aGlzOCA9IF9zdXBlcjUuY2FsbCh0aGlzKTtcbiAgICAoMCwgX2dldDJbXCJkZWZhdWx0XCJdKSgoX3RoaXNTdXBlciA9ICgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMltcImRlZmF1bHRcIl0pKF90aGlzOCksICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoQ29tcGxldGVkT2JzZXJ2ZXIucHJvdG90eXBlKSksIFwibWFya0NvbXBsZXRlZFwiLCBfdGhpc1N1cGVyKS5jYWxsKF90aGlzU3VwZXIpO1xuICAgIHJldHVybiBfdGhpczg7XG4gIH1cblxuICByZXR1cm4gQ29tcGxldGVkT2JzZXJ2ZXI7XG59KFJlc3VsdFN0cmVhbU9ic2VydmVyKTtcblxuZXhwb3J0cy5Db21wbGV0ZWRPYnNlcnZlciA9IENvbXBsZXRlZE9ic2VydmVyO1xudmFyIF9zdGF0ZXMgPSB7XG4gIFJFQURZX1NUUkVBTUlORzoge1xuICAgIC8vIGFzeW5jIHN0YXJ0IHN0YXRlXG4gICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3Moc3RyZWFtT2JzZXJ2ZXIsIG1ldGEpIHtcbiAgICAgIHN0cmVhbU9ic2VydmVyLl9oYW5kbGVSdW5TdWNjZXNzKG1ldGEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RyZWFtT2JzZXJ2ZXIuX3NldFN0YXRlKF9zdGF0ZXMuU1RSRUFNSU5HKTtcbiAgICAgIH0gLy8gYWZ0ZXIgcnVuIHN1Y2NlZWRlZCwgYXN5bmMgZGlyZWN0bHkgbW92ZSB0byBzdHJlYW1pbmdcbiAgICAgIC8vIHN0YXRlXG4gICAgICApO1xuICAgIH0sXG4gICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihzdHJlYW1PYnNlcnZlciwgZXJyb3IpIHtcbiAgICAgIHN0cmVhbU9ic2VydmVyLl9oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgfSxcbiAgICBuYW1lOiBmdW5jdGlvbiBuYW1lKCkge1xuICAgICAgcmV0dXJuICdSRUFEWV9TVFJFQU1JTkcnO1xuICAgIH1cbiAgfSxcbiAgUkVBRFk6IHtcbiAgICAvLyByZWFjdGl2ZSBzdGFydCBzdGF0ZVxuICAgIG9uU3VjY2VzczogZnVuY3Rpb24gb25TdWNjZXNzKHN0cmVhbU9ic2VydmVyLCBtZXRhKSB7XG4gICAgICBzdHJlYW1PYnNlcnZlci5faGFuZGxlUnVuU3VjY2VzcyhtZXRhLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW1PYnNlcnZlci5faGFuZGxlU3RyZWFtaW5nKCk7XG4gICAgICB9IC8vIGFmdGVyIHJ1biBzdWNjZWVkZWQgcmVjZWl2ZWQsIHJlYWN0aXZlIHNoYWxsIHN0YXJ0IHB1bGxpbmdcbiAgICAgICk7XG4gICAgfSxcbiAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKHN0cmVhbU9ic2VydmVyLCBlcnJvcikge1xuICAgICAgc3RyZWFtT2JzZXJ2ZXIuX2hhbmRsZUVycm9yKGVycm9yKTtcbiAgICB9LFxuICAgIG5hbWU6IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgICByZXR1cm4gJ1JFQURZJztcbiAgICB9XG4gIH0sXG4gIFNUUkVBTUlORzoge1xuICAgIG9uU3VjY2VzczogZnVuY3Rpb24gb25TdWNjZXNzKHN0cmVhbU9ic2VydmVyLCBtZXRhKSB7XG4gICAgICBpZiAobWV0YS5oYXNfbW9yZSkge1xuICAgICAgICBzdHJlYW1PYnNlcnZlci5faGFuZGxlSGFzTW9yZShtZXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbU9ic2VydmVyLl9oYW5kbGVQdWxsU3VjY2VzcyhtZXRhKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3Ioc3RyZWFtT2JzZXJ2ZXIsIGVycm9yKSB7XG4gICAgICBzdHJlYW1PYnNlcnZlci5faGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIH0sXG4gICAgbmFtZTogZnVuY3Rpb24gbmFtZSgpIHtcbiAgICAgIHJldHVybiAnU1RSRUFNSU5HJztcbiAgICB9XG4gIH0sXG4gIEZBSUxFRDoge1xuICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHsvLyBtb3JlIGVycm9ycyBhcmUgaWdub3JlZFxuICAgIH0sXG4gICAgbmFtZTogZnVuY3Rpb24gbmFtZSgpIHtcbiAgICAgIHJldHVybiAnRkFJTEVEJztcbiAgICB9XG4gIH0sXG4gIFNVQ0NFRURFRDoge1xuICAgIG5hbWU6IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgICByZXR1cm4gJ1NVQ0NFRURFRCc7XG4gICAgfVxuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubm9ybWFsaXplU2Vjb25kc0ZvckR1cmF0aW9uID0gbm9ybWFsaXplU2Vjb25kc0ZvckR1cmF0aW9uO1xuZXhwb3J0cy5ub3JtYWxpemVOYW5vc2Vjb25kc0ZvckR1cmF0aW9uID0gbm9ybWFsaXplTmFub3NlY29uZHNGb3JEdXJhdGlvbjtcbmV4cG9ydHMubG9jYWxUaW1lVG9OYW5vT2ZEYXkgPSBsb2NhbFRpbWVUb05hbm9PZkRheTtcbmV4cG9ydHMubmFub09mRGF5VG9Mb2NhbFRpbWUgPSBuYW5vT2ZEYXlUb0xvY2FsVGltZTtcbmV4cG9ydHMubG9jYWxEYXRlVGltZVRvRXBvY2hTZWNvbmQgPSBsb2NhbERhdGVUaW1lVG9FcG9jaFNlY29uZDtcbmV4cG9ydHMuZXBvY2hTZWNvbmRBbmROYW5vVG9Mb2NhbERhdGVUaW1lID0gZXBvY2hTZWNvbmRBbmROYW5vVG9Mb2NhbERhdGVUaW1lO1xuZXhwb3J0cy5kYXRlVG9FcG9jaERheSA9IGRhdGVUb0Vwb2NoRGF5O1xuZXhwb3J0cy5lcG9jaERheVRvRGF0ZSA9IGVwb2NoRGF5VG9EYXRlO1xuZXhwb3J0cy5kdXJhdGlvblRvSXNvU3RyaW5nID0gZHVyYXRpb25Ub0lzb1N0cmluZztcbmV4cG9ydHMudGltZVRvSXNvU3RyaW5nID0gdGltZVRvSXNvU3RyaW5nO1xuZXhwb3J0cy50aW1lWm9uZU9mZnNldFRvSXNvU3RyaW5nID0gdGltZVpvbmVPZmZzZXRUb0lzb1N0cmluZztcbmV4cG9ydHMuZGF0ZVRvSXNvU3RyaW5nID0gZGF0ZVRvSXNvU3RyaW5nO1xuZXhwb3J0cy50b3RhbE5hbm9zZWNvbmRzID0gdG90YWxOYW5vc2Vjb25kcztcbmV4cG9ydHMudGltZVpvbmVPZmZzZXRJblNlY29uZHMgPSB0aW1lWm9uZU9mZnNldEluU2Vjb25kcztcbmV4cG9ydHMuYXNzZXJ0VmFsaWRZZWFyID0gYXNzZXJ0VmFsaWRZZWFyO1xuZXhwb3J0cy5hc3NlcnRWYWxpZE1vbnRoID0gYXNzZXJ0VmFsaWRNb250aDtcbmV4cG9ydHMuYXNzZXJ0VmFsaWREYXkgPSBhc3NlcnRWYWxpZERheTtcbmV4cG9ydHMuYXNzZXJ0VmFsaWRIb3VyID0gYXNzZXJ0VmFsaWRIb3VyO1xuZXhwb3J0cy5hc3NlcnRWYWxpZE1pbnV0ZSA9IGFzc2VydFZhbGlkTWludXRlO1xuZXhwb3J0cy5hc3NlcnRWYWxpZFNlY29uZCA9IGFzc2VydFZhbGlkU2Vjb25kO1xuZXhwb3J0cy5hc3NlcnRWYWxpZE5hbm9zZWNvbmQgPSBhc3NlcnRWYWxpZE5hbm9zZWNvbmQ7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW50ZWdlciA9IHJlcXVpcmUoXCIuLi9pbnRlZ2VyXCIpO1xuXG52YXIgX3RlbXBvcmFsVHlwZXMgPSByZXF1aXJlKFwiLi4vdGVtcG9yYWwtdHlwZXNcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKlxuICBDb2RlIGluIHRoaXMgdXRpbCBzaG91bGQgYmUgY29tcGF0aWJsZSB3aXRoIGNvZGUgaW4gdGhlIGRhdGFiYXNlIHRoYXQgdXNlcyBKU1ItMzEwIGphdmEudGltZSBBUElzLlxuXG4gIEl0IGlzIGJhc2VkIG9uIGEgbGlicmFyeSBjYWxsZWQgVGhyZWVUZW4gKGh0dHBzOi8vZ2l0aHViLmNvbS9UaHJlZVRlbi90aHJlZXRlbmJwKSB3aGljaCB3YXMgZGVyaXZlZFxuICBmcm9tIEpTUi0zMTAgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIHByZXZpb3VzbHkgaG9zdGVkIG9uIEdpdEh1Yi4gQ29kZSB1c2VzIGBJbnRlZ2VyYCB0eXBlIGV2ZXJ5d2hlcmVcbiAgdG8gY29ycmVjdGx5IGhhbmRsZSBsYXJnZSBpbnRlZ2VyIHZhbHVlcyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cblxuICBQbGVhc2UgY29uc3VsdCBlaXRoZXIgVGhyZWVUZW4gb3IganMtam9kYSAoaHR0cHM6Ly9naXRodWIuY29tL2pzLWpvZGEvanMtam9kYSkgd2hlbiB3b3JraW5nIHdpdGggdGhlXG4gIGNvbnZlcnNpb24gZnVuY3Rpb25zLlxuICovXG52YXIgVmFsdWVSYW5nZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZhbHVlUmFuZ2UobWluLCBtYXgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFZhbHVlUmFuZ2UpO1xuICAgIHRoaXMuX21pbk51bWJlciA9IG1pbjtcbiAgICB0aGlzLl9tYXhOdW1iZXIgPSBtYXg7XG4gICAgdGhpcy5fbWluSW50ZWdlciA9ICgwLCBfaW50ZWdlcltcImludFwiXSkobWluKTtcbiAgICB0aGlzLl9tYXhJbnRlZ2VyID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShtYXgpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShWYWx1ZVJhbmdlLCBbe1xuICAgIGtleTogXCJjb250YWluc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb250YWlucyh2YWx1ZSkge1xuICAgICAgaWYgKCgwLCBfaW50ZWdlci5pc0ludCkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5ncmVhdGVyVGhhbk9yRXF1YWwodGhpcy5fbWluSW50ZWdlcikgJiYgdmFsdWUubGVzc1RoYW5PckVxdWFsKHRoaXMuX21heEludGVnZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID49IHRoaXMuX21pbk51bWJlciAmJiB2YWx1ZSA8PSB0aGlzLl9tYXhOdW1iZXI7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiW1wiLmNvbmNhdCh0aGlzLl9taW5OdW1iZXIsIFwiLCBcIikuY29uY2F0KHRoaXMuX21heE51bWJlciwgXCJdXCIpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVmFsdWVSYW5nZTtcbn0oKTtcblxudmFyIFlFQVJfUkFOR0UgPSBuZXcgVmFsdWVSYW5nZSgtOTk5OTk5OTk5LCA5OTk5OTk5OTkpO1xudmFyIE1PTlRIX09GX1lFQVJfUkFOR0UgPSBuZXcgVmFsdWVSYW5nZSgxLCAxMik7XG52YXIgREFZX09GX01PTlRIX1JBTkdFID0gbmV3IFZhbHVlUmFuZ2UoMSwgMzEpO1xudmFyIEhPVVJfT0ZfREFZX1JBTkdFID0gbmV3IFZhbHVlUmFuZ2UoMCwgMjMpO1xudmFyIE1JTlVURV9PRl9IT1VSX1JBTkdFID0gbmV3IFZhbHVlUmFuZ2UoMCwgNTkpO1xudmFyIFNFQ09ORF9PRl9NSU5VVEVfUkFOR0UgPSBuZXcgVmFsdWVSYW5nZSgwLCA1OSk7XG52YXIgTkFOT1NFQ09ORF9PRl9TRUNPTkRfUkFOR0UgPSBuZXcgVmFsdWVSYW5nZSgwLCA5OTk5OTk5OTkpO1xudmFyIE1JTlVURVNfUEVSX0hPVVIgPSA2MDtcbnZhciBTRUNPTkRTX1BFUl9NSU5VVEUgPSA2MDtcbnZhciBTRUNPTkRTX1BFUl9IT1VSID0gU0VDT05EU19QRVJfTUlOVVRFICogTUlOVVRFU19QRVJfSE9VUjtcbnZhciBOQU5PU19QRVJfU0VDT05EID0gMTAwMDAwMDAwMDtcbnZhciBOQU5PU19QRVJfTUlMTElTRUNPTkQgPSAxMDAwMDAwO1xudmFyIE5BTk9TX1BFUl9NSU5VVEUgPSBOQU5PU19QRVJfU0VDT05EICogU0VDT05EU19QRVJfTUlOVVRFO1xudmFyIE5BTk9TX1BFUl9IT1VSID0gTkFOT1NfUEVSX01JTlVURSAqIE1JTlVURVNfUEVSX0hPVVI7XG52YXIgREFZU18wMDAwX1RPXzE5NzAgPSA3MTk1Mjg7XG52YXIgREFZU19QRVJfNDAwX1lFQVJfQ1lDTEUgPSAxNDYwOTc7XG52YXIgU0VDT05EU19QRVJfREFZID0gODY0MDA7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlY29uZHNGb3JEdXJhdGlvbihzZWNvbmRzLCBuYW5vc2Vjb25kcykge1xuICByZXR1cm4gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShzZWNvbmRzKS5hZGQoZmxvb3JEaXYobmFub3NlY29uZHMsIE5BTk9TX1BFUl9TRUNPTkQpKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmFub3NlY29uZHNGb3JEdXJhdGlvbihuYW5vc2Vjb25kcykge1xuICByZXR1cm4gZmxvb3JNb2QobmFub3NlY29uZHMsIE5BTk9TX1BFUl9TRUNPTkQpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBnaXZlbiBsb2NhbCB0aW1lIGludG8gYSBzaW5nbGUgaW50ZWdlciByZXByZXNlbnRpbmcgdGhpcyBzYW1lIHRpbWUgaW4gbmFub3NlY29uZHMgb2YgdGhlIGRheS5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBob3VyIHRoZSBob3VyIG9mIHRoZSBsb2NhbCB0aW1lIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gbWludXRlIHRoZSBtaW51dGUgb2YgdGhlIGxvY2FsIHRpbWUgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBzZWNvbmQgdGhlIHNlY29uZCBvZiB0aGUgbG9jYWwgdGltZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG5hbm9zZWNvbmQgdGhlIG5hbm9zZWNvbmQgb2YgdGhlIGxvY2FsIHRpbWUgdG8gY29udmVydC5cbiAqIEByZXR1cm4ge0ludGVnZXJ9IG5hbm9zZWNvbmRzIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gbG9jYWwgdGltZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGxvY2FsVGltZVRvTmFub09mRGF5KGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vc2Vjb25kKSB7XG4gIGhvdXIgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKGhvdXIpO1xuICBtaW51dGUgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKG1pbnV0ZSk7XG4gIHNlY29uZCA9ICgwLCBfaW50ZWdlcltcImludFwiXSkoc2Vjb25kKTtcbiAgbmFub3NlY29uZCA9ICgwLCBfaW50ZWdlcltcImludFwiXSkobmFub3NlY29uZCk7XG4gIHZhciB0b3RhbE5hbm9zID0gaG91ci5tdWx0aXBseShOQU5PU19QRVJfSE9VUik7XG4gIHRvdGFsTmFub3MgPSB0b3RhbE5hbm9zLmFkZChtaW51dGUubXVsdGlwbHkoTkFOT1NfUEVSX01JTlVURSkpO1xuICB0b3RhbE5hbm9zID0gdG90YWxOYW5vcy5hZGQoc2Vjb25kLm11bHRpcGx5KE5BTk9TX1BFUl9TRUNPTkQpKTtcbiAgcmV0dXJuIHRvdGFsTmFub3MuYWRkKG5hbm9zZWNvbmQpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBuYW5vc2Vjb25kcyBvZiB0aGUgZGF5IGludG8gbG9jYWwgdGltZS5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBuYW5vT2ZEYXkgdGhlIG5hbm9zZWNvbmRzIG9mIHRoZSBkYXkgdG8gY29udmVydC5cbiAqIEByZXR1cm4ge0xvY2FsVGltZX0gdGhlIGxvY2FsIHRpbWUgcmVwcmVzZW50aW5nIGdpdmVuIG5hbm9zZWNvbmRzIG9mIHRoZSBkYXkuXG4gKi9cblxuXG5mdW5jdGlvbiBuYW5vT2ZEYXlUb0xvY2FsVGltZShuYW5vT2ZEYXkpIHtcbiAgbmFub09mRGF5ID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShuYW5vT2ZEYXkpO1xuICB2YXIgaG91ciA9IG5hbm9PZkRheS5kaXYoTkFOT1NfUEVSX0hPVVIpO1xuICBuYW5vT2ZEYXkgPSBuYW5vT2ZEYXkuc3VidHJhY3QoaG91ci5tdWx0aXBseShOQU5PU19QRVJfSE9VUikpO1xuICB2YXIgbWludXRlID0gbmFub09mRGF5LmRpdihOQU5PU19QRVJfTUlOVVRFKTtcbiAgbmFub09mRGF5ID0gbmFub09mRGF5LnN1YnRyYWN0KG1pbnV0ZS5tdWx0aXBseShOQU5PU19QRVJfTUlOVVRFKSk7XG4gIHZhciBzZWNvbmQgPSBuYW5vT2ZEYXkuZGl2KE5BTk9TX1BFUl9TRUNPTkQpO1xuICB2YXIgbmFub3NlY29uZCA9IG5hbm9PZkRheS5zdWJ0cmFjdChzZWNvbmQubXVsdGlwbHkoTkFOT1NfUEVSX1NFQ09ORCkpO1xuICByZXR1cm4gbmV3IF90ZW1wb3JhbFR5cGVzLkxvY2FsVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub3NlY29uZCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGdpdmVuIGxvY2FsIGRhdGUgdGltZSBpbnRvIGEgc2luZ2xlIGludGVnZXIgcmVwcmVzZW50aW5nIHRoaXMgc2FtZSB0aW1lIGluIGVwb2NoIHNlY29uZHMgVVRDLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IHllYXIgdGhlIHllYXIgb2YgdGhlIGxvY2FsIGRhdGUtdGltZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG1vbnRoIHRoZSBtb250aCBvZiB0aGUgbG9jYWwgZGF0ZS10aW1lIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gZGF5IHRoZSBkYXkgb2YgdGhlIGxvY2FsIGRhdGUtdGltZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IGhvdXIgdGhlIGhvdXIgb2YgdGhlIGxvY2FsIGRhdGUtdGltZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG1pbnV0ZSB0aGUgbWludXRlIG9mIHRoZSBsb2NhbCBkYXRlLXRpbWUgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBzZWNvbmQgdGhlIHNlY29uZCBvZiB0aGUgbG9jYWwgZGF0ZS10aW1lIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gbmFub3NlY29uZCB0aGUgbmFub3NlY29uZCBvZiB0aGUgbG9jYWwgZGF0ZS10aW1lIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfSBlcG9jaCBzZWNvbmQgaW4gVVRDIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gbG9jYWwgZGF0ZSB0aW1lLlxuICovXG5cblxuZnVuY3Rpb24gbG9jYWxEYXRlVGltZVRvRXBvY2hTZWNvbmQoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9zZWNvbmQpIHtcbiAgdmFyIGVwb2NoRGF5ID0gZGF0ZVRvRXBvY2hEYXkoeWVhciwgbW9udGgsIGRheSk7XG4gIHZhciBsb2NhbFRpbWVTZWNvbmRzID0gbG9jYWxUaW1lVG9TZWNvbmRPZkRheShob3VyLCBtaW51dGUsIHNlY29uZCk7XG4gIHJldHVybiBlcG9jaERheS5tdWx0aXBseShTRUNPTkRTX1BFUl9EQVkpLmFkZChsb2NhbFRpbWVTZWNvbmRzKTtcbn1cbi8qKlxuICogQ29udmVydHMgZ2l2ZW4gZXBvY2ggc2Vjb25kIGFuZCBuYW5vc2Vjb25kIGFkanVzdG1lbnQgaW50byBhIGxvY2FsIGRhdGUgdGltZSBvYmplY3QuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gZXBvY2hTZWNvbmQgdGhlIGVwb2NoIHNlY29uZCB0byB1c2UuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gbmFubyB0aGUgbmFub3NlY29uZCB0byB1c2UuXG4gKiBAcmV0dXJuIHtMb2NhbERhdGVUaW1lfSB0aGUgbG9jYWwgZGF0ZSB0aW1lIHJlcHJlc2VudGluZyBnaXZlbiBlcG9jaCBzZWNvbmQgYW5kIG5hbm8uXG4gKi9cblxuXG5mdW5jdGlvbiBlcG9jaFNlY29uZEFuZE5hbm9Ub0xvY2FsRGF0ZVRpbWUoZXBvY2hTZWNvbmQsIG5hbm8pIHtcbiAgdmFyIGVwb2NoRGF5ID0gZmxvb3JEaXYoZXBvY2hTZWNvbmQsIFNFQ09ORFNfUEVSX0RBWSk7XG4gIHZhciBzZWNvbmRzT2ZEYXkgPSBmbG9vck1vZChlcG9jaFNlY29uZCwgU0VDT05EU19QRVJfREFZKTtcbiAgdmFyIG5hbm9PZkRheSA9IHNlY29uZHNPZkRheS5tdWx0aXBseShOQU5PU19QRVJfU0VDT05EKS5hZGQobmFubyk7XG4gIHZhciBsb2NhbERhdGUgPSBlcG9jaERheVRvRGF0ZShlcG9jaERheSk7XG4gIHZhciBsb2NhbFRpbWUgPSBuYW5vT2ZEYXlUb0xvY2FsVGltZShuYW5vT2ZEYXkpO1xuICByZXR1cm4gbmV3IF90ZW1wb3JhbFR5cGVzLkxvY2FsRGF0ZVRpbWUobG9jYWxEYXRlLnllYXIsIGxvY2FsRGF0ZS5tb250aCwgbG9jYWxEYXRlLmRheSwgbG9jYWxUaW1lLmhvdXIsIGxvY2FsVGltZS5taW51dGUsIGxvY2FsVGltZS5zZWNvbmQsIGxvY2FsVGltZS5uYW5vc2Vjb25kKTtcbn1cbi8qKlxuICogQ29udmVydHMgZ2l2ZW4gbG9jYWwgZGF0ZSBpbnRvIGEgc2luZ2xlIGludGVnZXIgcmVwcmVzZW50aW5nIGl0J3MgZXBvY2ggZGF5LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IHllYXIgdGhlIHllYXIgb2YgdGhlIGxvY2FsIGRhdGUgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBtb250aCB0aGUgbW9udGggb2YgdGhlIGxvY2FsIGRhdGUgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBkYXkgdGhlIGRheSBvZiB0aGUgbG9jYWwgZGF0ZSB0byBjb252ZXJ0LlxuICogQHJldHVybiB7SW50ZWdlcn0gZXBvY2ggZGF5IHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gZGF0ZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRhdGVUb0Vwb2NoRGF5KHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgeWVhciA9ICgwLCBfaW50ZWdlcltcImludFwiXSkoeWVhcik7XG4gIG1vbnRoID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShtb250aCk7XG4gIGRheSA9ICgwLCBfaW50ZWdlcltcImludFwiXSkoZGF5KTtcbiAgdmFyIGVwb2NoRGF5ID0geWVhci5tdWx0aXBseSgzNjUpO1xuXG4gIGlmICh5ZWFyLmdyZWF0ZXJUaGFuT3JFcXVhbCgwKSkge1xuICAgIGVwb2NoRGF5ID0gZXBvY2hEYXkuYWRkKHllYXIuYWRkKDMpLmRpdig0KS5zdWJ0cmFjdCh5ZWFyLmFkZCg5OSkuZGl2KDEwMCkpLmFkZCh5ZWFyLmFkZCgzOTkpLmRpdig0MDApKSk7XG4gIH0gZWxzZSB7XG4gICAgZXBvY2hEYXkgPSBlcG9jaERheS5zdWJ0cmFjdCh5ZWFyLmRpdigtNCkuc3VidHJhY3QoeWVhci5kaXYoLTEwMCkpLmFkZCh5ZWFyLmRpdigtNDAwKSkpO1xuICB9XG5cbiAgZXBvY2hEYXkgPSBlcG9jaERheS5hZGQobW9udGgubXVsdGlwbHkoMzY3KS5zdWJ0cmFjdCgzNjIpLmRpdigxMikpO1xuICBlcG9jaERheSA9IGVwb2NoRGF5LmFkZChkYXkuc3VidHJhY3QoMSkpO1xuXG4gIGlmIChtb250aC5ncmVhdGVyVGhhbigyKSkge1xuICAgIGVwb2NoRGF5ID0gZXBvY2hEYXkuc3VidHJhY3QoMSk7XG5cbiAgICBpZiAoIWlzTGVhcFllYXIoeWVhcikpIHtcbiAgICAgIGVwb2NoRGF5ID0gZXBvY2hEYXkuc3VidHJhY3QoMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVwb2NoRGF5LnN1YnRyYWN0KERBWVNfMDAwMF9UT18xOTcwKTtcbn1cbi8qKlxuICogQ29udmVydHMgZ2l2ZW4gZXBvY2ggZGF5IHRvIGEgbG9jYWwgZGF0ZS5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBlcG9jaERheSB0aGUgZXBvY2ggZGF5IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJuIHtEYXRlfSB0aGUgZGF0ZSByZXByZXNlbnRpbmcgdGhlIGVwb2NoIGRheSBpbiB5ZWFycywgbW9udGhzIGFuZCBkYXlzLlxuICovXG5cblxuZnVuY3Rpb24gZXBvY2hEYXlUb0RhdGUoZXBvY2hEYXkpIHtcbiAgZXBvY2hEYXkgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKGVwb2NoRGF5KTtcbiAgdmFyIHplcm9EYXkgPSBlcG9jaERheS5hZGQoREFZU18wMDAwX1RPXzE5NzApLnN1YnRyYWN0KDYwKTtcbiAgdmFyIGFkanVzdCA9ICgwLCBfaW50ZWdlcltcImludFwiXSkoMCk7XG5cbiAgaWYgKHplcm9EYXkubGVzc1RoYW4oMCkpIHtcbiAgICB2YXIgYWRqdXN0Q3ljbGVzID0gemVyb0RheS5hZGQoMSkuZGl2KERBWVNfUEVSXzQwMF9ZRUFSX0NZQ0xFKS5zdWJ0cmFjdCgxKTtcbiAgICBhZGp1c3QgPSBhZGp1c3RDeWNsZXMubXVsdGlwbHkoNDAwKTtcbiAgICB6ZXJvRGF5ID0gemVyb0RheS5hZGQoYWRqdXN0Q3ljbGVzLm11bHRpcGx5KC1EQVlTX1BFUl80MDBfWUVBUl9DWUNMRSkpO1xuICB9XG5cbiAgdmFyIHllYXIgPSB6ZXJvRGF5Lm11bHRpcGx5KDQwMCkuYWRkKDU5MSkuZGl2KERBWVNfUEVSXzQwMF9ZRUFSX0NZQ0xFKTtcbiAgdmFyIGRheU9mWWVhckVzdCA9IHplcm9EYXkuc3VidHJhY3QoeWVhci5tdWx0aXBseSgzNjUpLmFkZCh5ZWFyLmRpdig0KSkuc3VidHJhY3QoeWVhci5kaXYoMTAwKSkuYWRkKHllYXIuZGl2KDQwMCkpKTtcblxuICBpZiAoZGF5T2ZZZWFyRXN0Lmxlc3NUaGFuKDApKSB7XG4gICAgeWVhciA9IHllYXIuc3VidHJhY3QoMSk7XG4gICAgZGF5T2ZZZWFyRXN0ID0gemVyb0RheS5zdWJ0cmFjdCh5ZWFyLm11bHRpcGx5KDM2NSkuYWRkKHllYXIuZGl2KDQpKS5zdWJ0cmFjdCh5ZWFyLmRpdigxMDApKS5hZGQoeWVhci5kaXYoNDAwKSkpO1xuICB9XG5cbiAgeWVhciA9IHllYXIuYWRkKGFkanVzdCk7XG4gIHZhciBtYXJjaERheU9mWWVhciA9IGRheU9mWWVhckVzdDtcbiAgdmFyIG1hcmNoTW9udGggPSBtYXJjaERheU9mWWVhci5tdWx0aXBseSg1KS5hZGQoMikuZGl2KDE1Myk7XG4gIHZhciBtb250aCA9IG1hcmNoTW9udGguYWRkKDIpLm1vZHVsbygxMikuYWRkKDEpO1xuICB2YXIgZGF5ID0gbWFyY2hEYXlPZlllYXIuc3VidHJhY3QobWFyY2hNb250aC5tdWx0aXBseSgzMDYpLmFkZCg1KS5kaXYoMTApKS5hZGQoMSk7XG4gIHllYXIgPSB5ZWFyLmFkZChtYXJjaE1vbnRoLmRpdigxMCkpO1xuICByZXR1cm4gbmV3IF90ZW1wb3JhbFR5cGVzLkRhdGUoeWVhciwgbW9udGgsIGRheSk7XG59XG4vKipcbiAqIEZvcm1hdCBnaXZlbiBkdXJhdGlvbiB0byBhbiBJU08gODYwMSBzdHJpbmcuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gbW9udGhzIHRoZSBudW1iZXIgb2YgbW9udGhzLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IGRheXMgdGhlIG51bWJlciBvZiBkYXlzLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IHNlY29uZHMgdGhlIG51bWJlciBvZiBzZWNvbmRzLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG5hbm9zZWNvbmRzIHRoZSBudW1iZXIgb2YgbmFub3NlY29uZHMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElTTyBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGdpdmVuIGR1cmF0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gZHVyYXRpb25Ub0lzb1N0cmluZyhtb250aHMsIGRheXMsIHNlY29uZHMsIG5hbm9zZWNvbmRzKSB7XG4gIHZhciBtb250aHNTdHJpbmcgPSBmb3JtYXROdW1iZXIobW9udGhzKTtcbiAgdmFyIGRheXNTdHJpbmcgPSBmb3JtYXROdW1iZXIoZGF5cyk7XG4gIHZhciBzZWNvbmRzQW5kTmFub3NlY29uZHNTdHJpbmcgPSBmb3JtYXRTZWNvbmRzQW5kTmFub3NlY29uZHNGb3JEdXJhdGlvbihzZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gIHJldHVybiBcIlBcIi5jb25jYXQobW9udGhzU3RyaW5nLCBcIk1cIikuY29uY2F0KGRheXNTdHJpbmcsIFwiRFRcIikuY29uY2F0KHNlY29uZHNBbmROYW5vc2Vjb25kc1N0cmluZywgXCJTXCIpO1xufVxuLyoqXG4gKiBGb3JtYXRzIGdpdmVuIHRpbWUgdG8gYW4gSVNPIDg2MDEgc3RyaW5nLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IGhvdXIgdGhlIGhvdXIgdmFsdWUuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gbWludXRlIHRoZSBtaW51dGUgdmFsdWUuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gc2Vjb25kIHRoZSBzZWNvbmQgdmFsdWUuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gbmFub3NlY29uZCB0aGUgbmFub3NlY29uZCB2YWx1ZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gSVNPIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgZ2l2ZW4gdGltZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHRpbWVUb0lzb1N0cmluZyhob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub3NlY29uZCkge1xuICB2YXIgaG91clN0cmluZyA9IGZvcm1hdE51bWJlcihob3VyLCAyKTtcbiAgdmFyIG1pbnV0ZVN0cmluZyA9IGZvcm1hdE51bWJlcihtaW51dGUsIDIpO1xuICB2YXIgc2Vjb25kU3RyaW5nID0gZm9ybWF0TnVtYmVyKHNlY29uZCwgMik7XG4gIHZhciBuYW5vc2Vjb25kU3RyaW5nID0gZm9ybWF0TmFub3NlY29uZChuYW5vc2Vjb25kKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGhvdXJTdHJpbmcsIFwiOlwiKS5jb25jYXQobWludXRlU3RyaW5nLCBcIjpcIikuY29uY2F0KHNlY29uZFN0cmluZykuY29uY2F0KG5hbm9zZWNvbmRTdHJpbmcpO1xufVxuLyoqXG4gKiBGb3JtYXRzIGdpdmVuIHRpbWUgem9uZSBvZmZzZXQgaW4gc2Vjb25kcyB0byBzdHJpbmcgcmVwcmVzZW50YXRpb24gbGlrZSAnwrFISDpNTScsICfCsUhIOk1NOlNTJyBvciAnWicgZm9yIFVUQy5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBvZmZzZXRTZWNvbmRzIHRoZSBvZmZzZXQgaW4gc2Vjb25kcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gSVNPIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgZ2l2ZW4gb2Zmc2V0LlxuICovXG5cblxuZnVuY3Rpb24gdGltZVpvbmVPZmZzZXRUb0lzb1N0cmluZyhvZmZzZXRTZWNvbmRzKSB7XG4gIG9mZnNldFNlY29uZHMgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKG9mZnNldFNlY29uZHMpO1xuXG4gIGlmIChvZmZzZXRTZWNvbmRzLmVxdWFscygwKSkge1xuICAgIHJldHVybiAnWic7XG4gIH1cblxuICB2YXIgaXNOZWdhdGl2ZSA9IG9mZnNldFNlY29uZHMuaXNOZWdhdGl2ZSgpO1xuXG4gIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgb2Zmc2V0U2Vjb25kcyA9IG9mZnNldFNlY29uZHMubXVsdGlwbHkoLTEpO1xuICB9XG5cbiAgdmFyIHNpZ25QcmVmaXggPSBpc05lZ2F0aXZlID8gJy0nIDogJysnO1xuICB2YXIgaG91cnMgPSBmb3JtYXROdW1iZXIob2Zmc2V0U2Vjb25kcy5kaXYoU0VDT05EU19QRVJfSE9VUiksIDIpO1xuICB2YXIgbWludXRlcyA9IGZvcm1hdE51bWJlcihvZmZzZXRTZWNvbmRzLmRpdihTRUNPTkRTX1BFUl9NSU5VVEUpLm1vZHVsbyhNSU5VVEVTX1BFUl9IT1VSKSwgMik7XG4gIHZhciBzZWNvbmRzVmFsdWUgPSBvZmZzZXRTZWNvbmRzLm1vZHVsbyhTRUNPTkRTX1BFUl9NSU5VVEUpO1xuICB2YXIgc2Vjb25kcyA9IHNlY29uZHNWYWx1ZS5lcXVhbHMoMCkgPyBudWxsIDogZm9ybWF0TnVtYmVyKHNlY29uZHNWYWx1ZSwgMik7XG4gIHJldHVybiBzZWNvbmRzID8gXCJcIi5jb25jYXQoc2lnblByZWZpeCkuY29uY2F0KGhvdXJzLCBcIjpcIikuY29uY2F0KG1pbnV0ZXMsIFwiOlwiKS5jb25jYXQoc2Vjb25kcykgOiBcIlwiLmNvbmNhdChzaWduUHJlZml4KS5jb25jYXQoaG91cnMsIFwiOlwiKS5jb25jYXQobWludXRlcyk7XG59XG4vKipcbiAqIEZvcm1hdHMgZ2l2ZW4gZGF0ZSB0byBhbiBJU08gODYwMSBzdHJpbmcuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30geWVhciB0aGUgZGF0ZSB5ZWFyLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG1vbnRoIHRoZSBkYXRlIG1vbnRoLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IGRheSB0aGUgZGF0ZSBkYXkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElTTyBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGdpdmVuIGRhdGUuXG4gKi9cblxuXG5mdW5jdGlvbiBkYXRlVG9Jc29TdHJpbmcoeWVhciwgbW9udGgsIGRheSkge1xuICB5ZWFyID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKSh5ZWFyKTtcbiAgdmFyIGlzTmVnYXRpdmUgPSB5ZWFyLmlzTmVnYXRpdmUoKTtcblxuICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgIHllYXIgPSB5ZWFyLm11bHRpcGx5KC0xKTtcbiAgfVxuXG4gIHZhciB5ZWFyU3RyaW5nID0gZm9ybWF0TnVtYmVyKHllYXIsIDQpO1xuXG4gIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgeWVhclN0cmluZyA9ICctJyArIHllYXJTdHJpbmc7XG4gIH1cblxuICB2YXIgbW9udGhTdHJpbmcgPSBmb3JtYXROdW1iZXIobW9udGgsIDIpO1xuICB2YXIgZGF5U3RyaW5nID0gZm9ybWF0TnVtYmVyKGRheSwgMik7XG4gIHJldHVybiBcIlwiLmNvbmNhdCh5ZWFyU3RyaW5nLCBcIi1cIikuY29uY2F0KG1vbnRoU3RyaW5nLCBcIi1cIikuY29uY2F0KGRheVN0cmluZyk7XG59XG4vKipcbiAqIEdldCB0aGUgdG90YWwgbnVtYmVyIG9mIG5hbm9zZWNvbmRzIGZyb20gdGhlIG1pbGxpc2Vjb25kcyBvZiB0aGUgZ2l2ZW4gc3RhbmRhcmQgSmF2YVNjcmlwdCBkYXRlIGFuZCBvcHRpb25hbCBuYW5vc2Vjb25kIHBhcnQuXG4gKiBAcGFyYW0ge2dsb2JhbC5EYXRlfSBzdGFuZGFyZERhdGUgdGhlIHN0YW5kYXJkIEphdmFTY3JpcHQgZGF0ZS5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8dW5kZWZpbmVkfSBuYW5vc2Vjb25kcyB0aGUgb3B0aW9uYWwgbnVtYmVyIG9mIG5hbm9zZWNvbmRzLlxuICogQHJldHVybiB7SW50ZWdlcnxudW1iZXJ9IHRoZSB0b3RhbCBhbW91bnQgb2YgbmFub3NlY29uZHMuXG4gKi9cblxuXG5mdW5jdGlvbiB0b3RhbE5hbm9zZWNvbmRzKHN0YW5kYXJkRGF0ZSwgbmFub3NlY29uZHMpIHtcbiAgbmFub3NlY29uZHMgPSBuYW5vc2Vjb25kcyB8fCAwO1xuICB2YXIgbmFub3NGcm9tTWlsbGlzID0gc3RhbmRhcmREYXRlLmdldE1pbGxpc2Vjb25kcygpICogTkFOT1NfUEVSX01JTExJU0VDT05EO1xuICByZXR1cm4gKDAsIF9pbnRlZ2VyLmlzSW50KShuYW5vc2Vjb25kcykgPyBuYW5vc2Vjb25kcy5hZGQobmFub3NGcm9tTWlsbGlzKSA6IG5hbm9zZWNvbmRzICsgbmFub3NGcm9tTWlsbGlzO1xufVxuLyoqXG4gKiBHZXQgdGhlIHRpbWUgem9uZSBvZmZzZXQgaW4gc2Vjb25kcyBmcm9tIHRoZSBnaXZlbiBzdGFuZGFyZCBKYXZhU2NyaXB0IGRhdGUuXG4gKlxuICogPGI+SW1wbGVtZW50YXRpb24gbm90ZTo8L2I+XG4gKiBUaW1lIHpvbmUgb2Zmc2V0IHJldHVybmVkIGJ5IHRoZSBzdGFuZGFyZCBKYXZhU2NyaXB0IGRhdGUgaXMgdGhlIGRpZmZlcmVuY2UsIGluIG1pbnV0ZXMsIGZyb20gbG9jYWwgdGltZSB0byBVVEMuXG4gKiBTbyBwb3NpdGl2ZSB2YWx1ZSBtZWFucyBvZmZzZXQgaXMgYmVoaW5kIFVUQyBhbmQgbmVnYXRpdmUgdmFsdWUgbWVhbnMgaXQgaXMgYWhlYWQuXG4gKiBGb3IgTmVvNGogdGVtcG9yYWwgdHlwZXMsIGxpa2UgYFRpbWVgIG9yIGBEYXRlVGltZWAgb2Zmc2V0IGlzIGluIHNlY29uZHMgYW5kIHJlcHJlc2VudHMgZGlmZmVyZW5jZSBmcm9tIFVUQyB0byBsb2NhbCB0aW1lLlxuICogVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBzdGFuZGFyZCBKYXZhU2NyaXB0IGRhdGVzIGFuZCB0aGF0J3Mgd2h5IGltcGxlbWVudGF0aW9uIG5lZ2F0ZXMgdGhlIHJldHVybmVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7Z2xvYmFsLkRhdGV9IHN0YW5kYXJkRGF0ZSB0aGUgc3RhbmRhcmQgSmF2YVNjcmlwdCBkYXRlLlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgdGltZSB6b25lIG9mZnNldCBpbiBzZWNvbmRzLlxuICovXG5cblxuZnVuY3Rpb24gdGltZVpvbmVPZmZzZXRJblNlY29uZHMoc3RhbmRhcmREYXRlKSB7XG4gIHZhciBvZmZzZXRJbk1pbnV0ZXMgPSBzdGFuZGFyZERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICBpZiAob2Zmc2V0SW5NaW51dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gLTEgKiBvZmZzZXRJbk1pbnV0ZXMgKiBTRUNPTkRTX1BFUl9NSU5VVEU7XG59XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB5ZWFyIHZhbHVlIGlzIHZhbGlkLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0geWVhciB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfG51bWJlcn0gdGhlIHZhbHVlIG9mIHRoZSB5ZWFyIGlmIGl0IGlzIHZhbGlkLiBFeGNlcHRpb24gaXMgdGhyb3duIG90aGVyd2lzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkWWVhcih5ZWFyKSB7XG4gIHJldHVybiBhc3NlcnRWYWxpZFRlbXBvcmFsVmFsdWUoeWVhciwgWUVBUl9SQU5HRSwgJ1llYXInKTtcbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIG1vbnRoIHZhbHVlIGlzIHZhbGlkLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gbW9udGggdGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybiB7SW50ZWdlcnxudW1iZXJ9IHRoZSB2YWx1ZSBvZiB0aGUgbW9udGggaWYgaXQgaXMgdmFsaWQuIEV4Y2VwdGlvbiBpcyB0aHJvd24gb3RoZXJ3aXNlLlxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRNb250aChtb250aCkge1xuICByZXR1cm4gYXNzZXJ0VmFsaWRUZW1wb3JhbFZhbHVlKG1vbnRoLCBNT05USF9PRl9ZRUFSX1JBTkdFLCAnTW9udGgnKTtcbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGRheSB2YWx1ZSBpcyB2YWxpZC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IGRheSB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfG51bWJlcn0gdGhlIHZhbHVlIG9mIHRoZSBkYXkgaWYgaXQgaXMgdmFsaWQuIEV4Y2VwdGlvbiBpcyB0aHJvd24gb3RoZXJ3aXNlLlxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWREYXkoZGF5KSB7XG4gIHJldHVybiBhc3NlcnRWYWxpZFRlbXBvcmFsVmFsdWUoZGF5LCBEQVlfT0ZfTU9OVEhfUkFOR0UsICdEYXknKTtcbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGhvdXIgdmFsdWUgaXMgdmFsaWQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBob3VyIHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge0ludGVnZXJ8bnVtYmVyfSB0aGUgdmFsdWUgb2YgdGhlIGhvdXIgaWYgaXQgaXMgdmFsaWQuIEV4Y2VwdGlvbiBpcyB0aHJvd24gb3RoZXJ3aXNlLlxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRIb3VyKGhvdXIpIHtcbiAgcmV0dXJuIGFzc2VydFZhbGlkVGVtcG9yYWxWYWx1ZShob3VyLCBIT1VSX09GX0RBWV9SQU5HRSwgJ0hvdXInKTtcbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIG1pbnV0ZSB2YWx1ZSBpcyB2YWxpZC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IG1pbnV0ZSB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfG51bWJlcn0gdGhlIHZhbHVlIG9mIHRoZSBtaW51dGUgaWYgaXQgaXMgdmFsaWQuIEV4Y2VwdGlvbiBpcyB0aHJvd24gb3RoZXJ3aXNlLlxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRNaW51dGUobWludXRlKSB7XG4gIHJldHVybiBhc3NlcnRWYWxpZFRlbXBvcmFsVmFsdWUobWludXRlLCBNSU5VVEVfT0ZfSE9VUl9SQU5HRSwgJ01pbnV0ZScpO1xufVxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgc2Vjb25kIHZhbHVlIGlzIHZhbGlkLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gc2Vjb25kIHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge0ludGVnZXJ8bnVtYmVyfSB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBpZiBpdCBpcyB2YWxpZC4gRXhjZXB0aW9uIGlzIHRocm93biBvdGhlcndpc2UuXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFNlY29uZChzZWNvbmQpIHtcbiAgcmV0dXJuIGFzc2VydFZhbGlkVGVtcG9yYWxWYWx1ZShzZWNvbmQsIFNFQ09ORF9PRl9NSU5VVEVfUkFOR0UsICdTZWNvbmQnKTtcbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIG5hbm9zZWNvbmQgdmFsdWUgaXMgdmFsaWQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBuYW5vc2Vjb25kIHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge0ludGVnZXJ8bnVtYmVyfSB0aGUgdmFsdWUgb2YgdGhlIG5hbm9zZWNvbmQgaWYgaXQgaXMgdmFsaWQuIEV4Y2VwdGlvbiBpcyB0aHJvd24gb3RoZXJ3aXNlLlxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWROYW5vc2Vjb25kKG5hbm9zZWNvbmQpIHtcbiAgcmV0dXJuIGFzc2VydFZhbGlkVGVtcG9yYWxWYWx1ZShuYW5vc2Vjb25kLCBOQU5PU0VDT05EX09GX1NFQ09ORF9SQU5HRSwgJ05hbm9zZWNvbmQnKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG9mIGV4cGVjdGVkIHR5cGUgYW5kIGlzIGluIHRoZSBleHBlY3RlZCByYW5nZS5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IHZhbHVlIHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7VmFsdWVSYW5nZX0gcmFuZ2UgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHZhbHVlLlxuICogQHJldHVybiB7SW50ZWdlcnxudW1iZXJ9IHRoZSB2YWx1ZSBpZiB2YWxpZC4gRXhjZXB0aW9uIGlzIHRocm93biBvdGhlcndpc2UuXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFRlbXBvcmFsVmFsdWUodmFsdWUsIHJhbmdlLCBuYW1lKSB7XG4gICgwLCBfdXRpbC5hc3NlcnROdW1iZXJPckludGVnZXIpKHZhbHVlLCBuYW1lKTtcblxuICBpZiAoIXJhbmdlLmNvbnRhaW5zKHZhbHVlKSkge1xuICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKFwiXCIuY29uY2F0KG5hbWUsIFwiIGlzIGV4cGVjdGVkIHRvIGJlIGluIHJhbmdlIFwiKS5jb25jYXQocmFuZ2UsIFwiIGJ1dCB3YXM6IFwiKS5jb25jYXQodmFsdWUpKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogQ29udmVydHMgZ2l2ZW4gbG9jYWwgdGltZSBpbnRvIGEgc2luZ2xlIGludGVnZXIgcmVwcmVzZW50aW5nIHRoaXMgc2FtZSB0aW1lIGluIHNlY29uZHMgb2YgdGhlIGRheS4gTmFub3NlY29uZHMgYXJlIHNraXBwZWQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gaG91ciB0aGUgaG91ciBvZiB0aGUgbG9jYWwgdGltZS5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBtaW51dGUgdGhlIG1pbnV0ZSBvZiB0aGUgbG9jYWwgdGltZS5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBzZWNvbmQgdGhlIHNlY29uZCBvZiB0aGUgbG9jYWwgdGltZS5cbiAqIEByZXR1cm4ge0ludGVnZXJ9IHNlY29uZHMgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBsb2NhbCB0aW1lLlxuICovXG5cblxuZnVuY3Rpb24gbG9jYWxUaW1lVG9TZWNvbmRPZkRheShob3VyLCBtaW51dGUsIHNlY29uZCkge1xuICBob3VyID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShob3VyKTtcbiAgbWludXRlID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShtaW51dGUpO1xuICBzZWNvbmQgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHNlY29uZCk7XG4gIHZhciB0b3RhbFNlY29uZHMgPSBob3VyLm11bHRpcGx5KFNFQ09ORFNfUEVSX0hPVVIpO1xuICB0b3RhbFNlY29uZHMgPSB0b3RhbFNlY29uZHMuYWRkKG1pbnV0ZS5tdWx0aXBseShTRUNPTkRTX1BFUl9NSU5VVEUpKTtcbiAgcmV0dXJuIHRvdGFsU2Vjb25kcy5hZGQoc2Vjb25kKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgZ2l2ZW4geWVhciBpcyBhIGxlYXAgeWVhci4gVXNlcyBhbGdvcml0aG0gZGVzY3JpYmVkIGhlcmUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xlYXBfeWVhciNBbGdvcml0aG19LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IHllYXIgdGhlIHllYXIgdG8gY2hlY2suIFdpbGwgYmUgY29udmVydGVkIHRvIHtAbGluayBJbnRlZ2VyfSBmb3IgYWxsIGNhbGN1bGF0aW9ucy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiB5ZWFyIGlzIGEgbGVhcCB5ZWFyLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICB5ZWFyID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKSh5ZWFyKTtcblxuICBpZiAoIXllYXIubW9kdWxvKDQpLmVxdWFscygwKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmICgheWVhci5tb2R1bG8oMTAwKS5lcXVhbHMoMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICgheWVhci5tb2R1bG8oNDAwKS5lcXVhbHMoMCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IHggdGhlIGRpdmlkZW50LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IHkgdGhlIGRpdmlzb3IuXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfSB0aGUgcmVzdWx0LlxuICovXG5cblxuZnVuY3Rpb24gZmxvb3JEaXYoeCwgeSkge1xuICB4ID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKSh4KTtcbiAgeSA9ICgwLCBfaW50ZWdlcltcImludFwiXSkoeSk7XG4gIHZhciByZXN1bHQgPSB4LmRpdih5KTtcblxuICBpZiAoeC5pc1Bvc2l0aXZlKCkgIT09IHkuaXNQb3NpdGl2ZSgpICYmIHJlc3VsdC5tdWx0aXBseSh5KS5ub3RFcXVhbHMoeCkpIHtcbiAgICByZXN1bHQgPSByZXN1bHQuc3VidHJhY3QoMSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30geCB0aGUgZGl2aWRlbnQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30geSB0aGUgZGl2aXNvci5cbiAqIEByZXR1cm4ge0ludGVnZXJ9IHRoZSByZXN1bHQuXG4gKi9cblxuXG5mdW5jdGlvbiBmbG9vck1vZCh4LCB5KSB7XG4gIHggPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHgpO1xuICB5ID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKSh5KTtcbiAgcmV0dXJuIHguc3VidHJhY3QoZmxvb3JEaXYoeCwgeSkubXVsdGlwbHkoeSkpO1xufVxuLyoqXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gc2Vjb25kcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gZm9ybWF0LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG5hbm9zZWNvbmRzIHRoZSBudW1iZXIgb2YgbmFub3NlY29uZHMgdG8gZm9ybWF0LlxuICogQHJldHVybiB7c3RyaW5nfSBmb3JtYXR0ZWQgdmFsdWUuXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRTZWNvbmRzQW5kTmFub3NlY29uZHNGb3JEdXJhdGlvbihzZWNvbmRzLCBuYW5vc2Vjb25kcykge1xuICBzZWNvbmRzID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShzZWNvbmRzKTtcbiAgbmFub3NlY29uZHMgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKG5hbm9zZWNvbmRzKTtcbiAgdmFyIHNlY29uZHNTdHJpbmc7XG4gIHZhciBuYW5vc2Vjb25kc1N0cmluZztcbiAgdmFyIHNlY29uZHNOZWdhdGl2ZSA9IHNlY29uZHMuaXNOZWdhdGl2ZSgpO1xuICB2YXIgbmFub3NlY29uZHNHcmVhdGVyVGhhblplcm8gPSBuYW5vc2Vjb25kcy5ncmVhdGVyVGhhbigwKTtcblxuICBpZiAoc2Vjb25kc05lZ2F0aXZlICYmIG5hbm9zZWNvbmRzR3JlYXRlclRoYW5aZXJvKSB7XG4gICAgaWYgKHNlY29uZHMuZXF1YWxzKC0xKSkge1xuICAgICAgc2Vjb25kc1N0cmluZyA9ICctMCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlY29uZHNTdHJpbmcgPSBzZWNvbmRzLmFkZCgxKS50b1N0cmluZygpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWNvbmRzU3RyaW5nID0gc2Vjb25kcy50b1N0cmluZygpO1xuICB9XG5cbiAgaWYgKG5hbm9zZWNvbmRzR3JlYXRlclRoYW5aZXJvKSB7XG4gICAgaWYgKHNlY29uZHNOZWdhdGl2ZSkge1xuICAgICAgbmFub3NlY29uZHNTdHJpbmcgPSBmb3JtYXROYW5vc2Vjb25kKG5hbm9zZWNvbmRzLm5lZ2F0ZSgpLmFkZCgyICogTkFOT1NfUEVSX1NFQ09ORCkubW9kdWxvKE5BTk9TX1BFUl9TRUNPTkQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFub3NlY29uZHNTdHJpbmcgPSBmb3JtYXROYW5vc2Vjb25kKG5hbm9zZWNvbmRzLmFkZChOQU5PU19QRVJfU0VDT05EKS5tb2R1bG8oTkFOT1NfUEVSX1NFQ09ORCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW5vc2Vjb25kc1N0cmluZyA/IHNlY29uZHNTdHJpbmcgKyBuYW5vc2Vjb25kc1N0cmluZyA6IHNlY29uZHNTdHJpbmc7XG59XG4vKipcbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSB2YWx1ZSB0aGUgbnVtYmVyIG9mIG5hbm9zZWNvbmRzIHRvIGZvcm1hdC5cbiAqIEByZXR1cm4ge3N0cmluZ30gZm9ybWF0dGVkIGFuZCBwb3NzaWJseSBsZWZ0LXBhZGRlZCBuYW5vc2Vjb25kcyBwYXJ0IGFzIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdE5hbm9zZWNvbmQodmFsdWUpIHtcbiAgdmFsdWUgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlLmVxdWFscygwKSA/ICcnIDogJy4nICsgZm9ybWF0TnVtYmVyKHZhbHVlLCA5KTtcbn1cbi8qKlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG51bSB0aGUgbnVtYmVyIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RyaW5nTGVuZ3RoPXVuZGVmaW5lZF0gdGhlIHN0cmluZyBsZW5ndGggdG8gbGVmdC1wYWQgdG8uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGZvcm1hdHRlZCBhbmQgcG9zc2libHkgbGVmdC1wYWRkZWQgbnVtYmVyIGFzIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW0pIHtcbiAgdmFyIHN0cmluZ0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICBudW0gPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKG51bSk7XG4gIHZhciBpc05lZ2F0aXZlID0gbnVtLmlzTmVnYXRpdmUoKTtcblxuICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgIG51bSA9IG51bS5uZWdhdGUoKTtcbiAgfVxuXG4gIHZhciBudW1TdHJpbmcgPSBudW0udG9TdHJpbmcoKTtcblxuICBpZiAoc3RyaW5nTGVuZ3RoKSB7XG4gICAgLy8gbGVmdCBwYWQgdGhlIHN0cmluZyB3aXRoIHplcm9lc1xuICAgIHdoaWxlIChudW1TdHJpbmcubGVuZ3RoIDwgc3RyaW5nTGVuZ3RoKSB7XG4gICAgICBudW1TdHJpbmcgPSAnMCcgKyBudW1TdHJpbmc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzTmVnYXRpdmUgPyAnLScgKyBudW1TdHJpbmcgOiBudW1TdHJpbmc7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIERFRkFVTFRfTUFYX1JFVFJZX1RJTUVfTVMgPSAzMCAqIDEwMDA7IC8vIDMwIHNlY29uZHNcblxudmFyIERFRkFVTFRfSU5JVElBTF9SRVRSWV9ERUxBWV9NUyA9IDEwMDA7IC8vIDEgc2Vjb25kc1xuXG52YXIgREVGQVVMVF9SRVRSWV9ERUxBWV9NVUxUSVBMSUVSID0gMi4wO1xudmFyIERFRkFVTFRfUkVUUllfREVMQVlfSklUVEVSX0ZBQ1RPUiA9IDAuMjtcblxudmFyIFRyYW5zYWN0aW9uRXhlY3V0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFuc2FjdGlvbkV4ZWN1dG9yKG1heFJldHJ5VGltZU1zLCBpbml0aWFsUmV0cnlEZWxheU1zLCBtdWx0aXBsaWVyLCBqaXR0ZXJGYWN0b3IpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFRyYW5zYWN0aW9uRXhlY3V0b3IpO1xuICAgIHRoaXMuX21heFJldHJ5VGltZU1zID0gX3ZhbHVlT3JEZWZhdWx0KG1heFJldHJ5VGltZU1zLCBERUZBVUxUX01BWF9SRVRSWV9USU1FX01TKTtcbiAgICB0aGlzLl9pbml0aWFsUmV0cnlEZWxheU1zID0gX3ZhbHVlT3JEZWZhdWx0KGluaXRpYWxSZXRyeURlbGF5TXMsIERFRkFVTFRfSU5JVElBTF9SRVRSWV9ERUxBWV9NUyk7XG4gICAgdGhpcy5fbXVsdGlwbGllciA9IF92YWx1ZU9yRGVmYXVsdChtdWx0aXBsaWVyLCBERUZBVUxUX1JFVFJZX0RFTEFZX01VTFRJUExJRVIpO1xuICAgIHRoaXMuX2ppdHRlckZhY3RvciA9IF92YWx1ZU9yRGVmYXVsdChqaXR0ZXJGYWN0b3IsIERFRkFVTFRfUkVUUllfREVMQVlfSklUVEVSX0ZBQ1RPUik7XG4gICAgdGhpcy5faW5GbGlnaHRUaW1lb3V0SWRzID0gW107XG5cbiAgICB0aGlzLl92ZXJpZnlBZnRlckNvbnN0cnVjdGlvbigpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShUcmFuc2FjdGlvbkV4ZWN1dG9yLCBbe1xuICAgIGtleTogXCJleGVjdXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4ZWN1dGUodHJhbnNhY3Rpb25DcmVhdG9yLCB0cmFuc2FjdGlvbldvcmspIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF90aGlzLl9leGVjdXRlVHJhbnNhY3Rpb25JbnNpZGVQcm9taXNlKHRyYW5zYWN0aW9uQ3JlYXRvciwgdHJhbnNhY3Rpb25Xb3JrLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdmFyIHJldHJ5U3RhcnRUaW1lTXMgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgcmV0cnlEZWxheU1zID0gX3RoaXMuX2luaXRpYWxSZXRyeURlbGF5TXM7XG4gICAgICAgIHJldHVybiBfdGhpcy5fcmV0cnlUcmFuc2FjdGlvblByb21pc2UodHJhbnNhY3Rpb25DcmVhdG9yLCB0cmFuc2FjdGlvbldvcmssIGVycm9yLCByZXRyeVN0YXJ0VGltZU1zLCByZXRyeURlbGF5TXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgLy8gY2FuY2VsIGFsbCBleGlzdGluZyB0aW1lb3V0cyB0byBwcmV2ZW50IGZ1cnRoZXIgcmV0cmllc1xuICAgICAgdGhpcy5faW5GbGlnaHRUaW1lb3V0SWRzLmZvckVhY2goZnVuY3Rpb24gKHRpbWVvdXRJZCkge1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5faW5GbGlnaHRUaW1lb3V0SWRzID0gW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZXRyeVRyYW5zYWN0aW9uUHJvbWlzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmV0cnlUcmFuc2FjdGlvblByb21pc2UodHJhbnNhY3Rpb25DcmVhdG9yLCB0cmFuc2FjdGlvbldvcmssIGVycm9yLCByZXRyeVN0YXJ0VGltZSwgcmV0cnlEZWxheU1zKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGVsYXBzZWRUaW1lTXMgPSBEYXRlLm5vdygpIC0gcmV0cnlTdGFydFRpbWU7XG5cbiAgICAgIGlmIChlbGFwc2VkVGltZU1zID4gdGhpcy5fbWF4UmV0cnlUaW1lTXMgfHwgIVRyYW5zYWN0aW9uRXhlY3V0b3IuX2NhblJldHJ5T24oZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBuZXh0UmV0cnlUaW1lID0gX3RoaXMyLl9jb21wdXRlRGVsYXlXaXRoSml0dGVyKHJldHJ5RGVsYXlNcyk7XG5cbiAgICAgICAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIGZpbHRlciBvdXQgdGhpcyB0aW1lb3V0SWQgd2hlbiB0aW1lIGhhcyBjb21lIGFuZCBmdW5jdGlvbiBpcyBiZWluZyBleGVjdXRlZFxuICAgICAgICAgIF90aGlzMi5faW5GbGlnaHRUaW1lb3V0SWRzID0gX3RoaXMyLl9pbkZsaWdodFRpbWVvdXRJZHMuZmlsdGVyKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkICE9PSB0aW1lb3V0SWQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBfdGhpczIuX2V4ZWN1dGVUcmFuc2FjdGlvbkluc2lkZVByb21pc2UodHJhbnNhY3Rpb25DcmVhdG9yLCB0cmFuc2FjdGlvbldvcmssIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0sIG5leHRSZXRyeVRpbWUpOyAvLyBhZGQgbmV3bHkgY3JlYXRlZCB0aW1lb3V0SWQgdG8gdGhlIGxpc3Qgb2YgYWxsIGluLWZsaWdodCB0aW1lb3V0c1xuXG4gICAgICAgIF90aGlzMi5faW5GbGlnaHRUaW1lb3V0SWRzLnB1c2godGltZW91dElkKTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHZhciBuZXh0UmV0cnlEZWxheU1zID0gcmV0cnlEZWxheU1zICogX3RoaXMyLl9tdWx0aXBsaWVyO1xuICAgICAgICByZXR1cm4gX3RoaXMyLl9yZXRyeVRyYW5zYWN0aW9uUHJvbWlzZSh0cmFuc2FjdGlvbkNyZWF0b3IsIHRyYW5zYWN0aW9uV29yaywgZXJyb3IsIHJldHJ5U3RhcnRUaW1lLCBuZXh0UmV0cnlEZWxheU1zKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXhlY3V0ZVRyYW5zYWN0aW9uSW5zaWRlUHJvbWlzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXhlY3V0ZVRyYW5zYWN0aW9uSW5zaWRlUHJvbWlzZSh0cmFuc2FjdGlvbkNyZWF0b3IsIHRyYW5zYWN0aW9uV29yaywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHR4O1xuXG4gICAgICB0cnkge1xuICAgICAgICB0eCA9IHRyYW5zYWN0aW9uQ3JlYXRvcigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gZmFpbGVkIHRvIGNyZWF0ZSBhIHRyYW5zYWN0aW9uXG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdFByb21pc2UgPSB0aGlzLl9zYWZlRXhlY3V0ZVRyYW5zYWN0aW9uV29yayh0eCwgdHJhbnNhY3Rpb25Xb3JrKTtcblxuICAgICAgcmVzdWx0UHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5faGFuZGxlVHJhbnNhY3Rpb25Xb3JrU3VjY2VzcyhyZXN1bHQsIHR4LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5faGFuZGxlVHJhbnNhY3Rpb25Xb3JrRmFpbHVyZShlcnJvciwgdHgsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NhZmVFeGVjdXRlVHJhbnNhY3Rpb25Xb3JrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zYWZlRXhlY3V0ZVRyYW5zYWN0aW9uV29yayh0eCwgdHJhbnNhY3Rpb25Xb3JrKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJhbnNhY3Rpb25Xb3JrKHR4KTsgLy8gdXNlciBkZWZpbmVkIGNhbGxiYWNrIGlzIHN1cHBvc2VkIHRvIHJldHVybiBhIHByb21pc2UsIGJ1dCBpdCBtaWdodCBub3Q7IHNvIHRvIHByb3RlY3QgYWdhaW5zdCBhblxuICAgICAgICAvLyBpbmNvcnJlY3QgQVBJIHVzYWdlIHdlIHdyYXAgdGhlIHJldHVybmVkIHZhbHVlIHdpdGggYSByZXNvbHZlZCBwcm9taXNlOyB0aGlzIGlzIGVmZmVjdGl2ZWx5IGFcbiAgICAgICAgLy8gdmFsaWRhdGlvbiBzdGVwIHdpdGhvdXQgdHlwZSBjaGVja3NcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlVHJhbnNhY3Rpb25Xb3JrU3VjY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVHJhbnNhY3Rpb25Xb3JrU3VjY2VzcyhyZXN1bHQsIHR4LCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmICh0eC5pc09wZW4oKSkge1xuICAgICAgICAvLyB0cmFuc2FjdGlvbiB3b3JrIHJldHVybmVkIHJlc29sdmVkIHByb21pc2UgYW5kIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBjb21taXR0ZWQvcm9sbGVkIGJhY2tcbiAgICAgICAgLy8gdHJ5IHRvIGNvbW1pdCB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgdHguY29tbWl0KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gdHJhbnNhY3Rpb24gd2FzIGNvbW1pdHRlZCwgcmV0dXJuIHJlc3VsdCB0byB0aGUgdXNlclxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAvLyB0cmFuc2FjdGlvbiBmYWlsZWQgdG8gY29tbWl0LCBwcm9wYWdhdGUgdGhlIGZhaWx1cmVcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIHdvcmsgcmV0dXJuZWQgcmVzb2x2ZWQgcHJvbWlzZSBhbmQgdHJhbnNhY3Rpb24gaXMgYWxyZWFkeSBjb21taXR0ZWQvcm9sbGVkIGJhY2tcbiAgICAgICAgLy8gcmV0dXJuIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgZ2l2ZW4gdHJhbnNhY3Rpb24gd29ya1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVUcmFuc2FjdGlvbldvcmtGYWlsdXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVUcmFuc2FjdGlvbldvcmtGYWlsdXJlKGVycm9yLCB0eCwgcmVqZWN0KSB7XG4gICAgICBpZiAodHguaXNPcGVuKCkpIHtcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gd29yayBmYWlsZWQgYW5kIHRoZSB0cmFuc2FjdGlvbiBpcyBzdGlsbCBvcGVuLCByb2xsIGl0IGJhY2sgYW5kIHByb3BhZ2F0ZSB0aGUgZmFpbHVyZVxuICAgICAgICB0eC5yb2xsYmFjaygpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGlnbm9yZSkgey8vIGlnbm9yZSB0aGUgcm9sbGJhY2sgZXJyb3JcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0pOyAvLyBwcm9wYWdhdGUgdGhlIG9yaWdpbmFsIGVycm9yIHdlIGdvdCBmcm9tIHRoZSB0cmFuc2FjdGlvbiB3b3JrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0cmFuc2FjdGlvbiBpcyBhbHJlYWR5IHJvbGxlZCBiYWNrLCBwcm9wYWdhdGUgdGhlIGVycm9yXG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jb21wdXRlRGVsYXlXaXRoSml0dGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21wdXRlRGVsYXlXaXRoSml0dGVyKGRlbGF5TXMpIHtcbiAgICAgIHZhciBqaXR0ZXIgPSBkZWxheU1zICogdGhpcy5faml0dGVyRmFjdG9yO1xuICAgICAgdmFyIG1pbiA9IGRlbGF5TXMgLSBqaXR0ZXI7XG4gICAgICB2YXIgbWF4ID0gZGVsYXlNcyArIGppdHRlcjtcbiAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl92ZXJpZnlBZnRlckNvbnN0cnVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdmVyaWZ5QWZ0ZXJDb25zdHJ1Y3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fbWF4UmV0cnlUaW1lTXMgPCAwKSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdNYXggcmV0cnkgdGltZSBzaG91bGQgYmUgPj0gMDogJyArIHRoaXMuX21heFJldHJ5VGltZU1zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2luaXRpYWxSZXRyeURlbGF5TXMgPCAwKSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdJbml0aWFsIHJldHJ5IGRlbGF5IHNob3VsZCA+PSAwOiAnICsgdGhpcy5faW5pdGlhbFJldHJ5RGVsYXlNcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9tdWx0aXBsaWVyIDwgMS4wKSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdNdWx0aXBsaWVyIHNob3VsZCBiZSA+PSAxLjA6ICcgKyB0aGlzLl9tdWx0aXBsaWVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2ppdHRlckZhY3RvciA8IDAgfHwgdGhpcy5faml0dGVyRmFjdG9yID4gMSkge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnSml0dGVyIGZhY3RvciBzaG91bGQgYmUgaW4gWzAuMCwgMS4wXTogJyArIHRoaXMuX2ppdHRlckZhY3Rvcik7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiX2NhblJldHJ5T25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhblJldHJ5T24oZXJyb3IpIHtcbiAgICAgIHJldHVybiBlcnJvciAmJiBlcnJvciBpbnN0YW5jZW9mIF9lcnJvci5OZW80akVycm9yICYmIGVycm9yLmNvZGUgJiYgKGVycm9yLmNvZGUgPT09IF9lcnJvci5TRVJWSUNFX1VOQVZBSUxBQkxFIHx8IGVycm9yLmNvZGUgPT09IF9lcnJvci5TRVNTSU9OX0VYUElSRUQgfHwgdGhpcy5faXNUcmFuc2llbnRFcnJvcihlcnJvcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNUcmFuc2llbnRFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNUcmFuc2llbnRFcnJvcihlcnJvcikge1xuICAgICAgLy8gUmV0cmllcyBzaG91bGQgbm90IGhhcHBlbiB3aGVuIHRyYW5zYWN0aW9uIHdhcyBleHBsaWNpdGx5IHRlcm1pbmF0ZWQgYnkgdGhlIHVzZXIuXG4gICAgICAvLyBUZXJtaW5hdGlvbiBvZiB0cmFuc2FjdGlvbiBtaWdodCByZXN1bHQgaW4gdHdvIGRpZmZlcmVudCBlcnJvciBjb2RlcyBkZXBlbmRpbmcgb24gd2hlcmUgaXQgd2FzXG4gICAgICAvLyB0ZXJtaW5hdGVkLiBUaGVzZSBhcmUgcmVhbGx5IGNsaWVudCBlcnJvcnMgYnV0IGNsYXNzaWZpY2F0aW9uIG9uIHRoZSBzZXJ2ZXIgaXMgbm90IGVudGlyZWx5IGNvcnJlY3QgYW5kXG4gICAgICAvLyB0aGV5IGFyZSBjbGFzc2lmaWVkIGFzIHRyYW5zaWVudC5cbiAgICAgIHZhciBjb2RlID0gZXJyb3IuY29kZTtcblxuICAgICAgaWYgKGNvZGUuaW5kZXhPZignVHJhbnNpZW50RXJyb3InKSA+PSAwKSB7XG4gICAgICAgIGlmIChjb2RlID09PSAnTmVvLlRyYW5zaWVudEVycm9yLlRyYW5zYWN0aW9uLlRlcm1pbmF0ZWQnIHx8IGNvZGUgPT09ICdOZW8uVHJhbnNpZW50RXJyb3IuVHJhbnNhY3Rpb24uTG9ja0NsaWVudFN0b3BwZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uRXhlY3V0b3I7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVHJhbnNhY3Rpb25FeGVjdXRvcjtcblxuZnVuY3Rpb24gX3ZhbHVlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHZhbHVlIHx8IHZhbHVlID09PSAwKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZFwiKTtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIHV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi91dGlsXCIpKTtcblxudmFyIF9pbnRlZ2VyID0gcmVxdWlyZShcIi4uL2ludGVnZXJcIik7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEludGVybmFsIGhvbGRlciBvZiB0aGUgdHJhbnNhY3Rpb24gY29uZmlndXJhdGlvbi5cbiAqIEl0IHBlcmZvcm1zIGlucHV0IHZhbGlkYXRpb24gYW5kIHZhbHVlIGNvbnZlcnNpb24gZm9yIGZ1cnRoZXIgc2VyaWFsaXphdGlvbiBieSB0aGUgQm9sdCBwcm90b2NvbCBsYXllci5cbiAqIFVzZXJzIG9mIHRoZSBkcml2ZXIgcHJvdmlkZSB0cmFuc2FjdGlvbiBjb25maWd1cmF0aW9uIGFzIHJlZ3VsYXIgb2JqZWN0cyBge3RpbWVvdXQ6IDEwLCBtZXRhZGF0YToge2tleTogJ3ZhbHVlJ319YC5cbiAqIERyaXZlciBjb252ZXJ0cyBzdWNoIG9iamVjdHMgdG8ge0BsaW5rIFR4Q29uZmlnfSBpbW1lZGlhdGVseSBhbmQgdXNlcyBjb252ZXJ0ZWQgdmFsdWVzIGV2ZXJ5d2hlcmUuXG4gKi9cbnZhciBUeENvbmZpZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgcmF3IGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gVHhDb25maWcoY29uZmlnKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBUeENvbmZpZyk7XG4gICAgYXNzZXJ0VmFsaWRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLnRpbWVvdXQgPSBleHRyYWN0VGltZW91dChjb25maWcpO1xuICAgIHRoaXMubWV0YWRhdGEgPSBleHRyYWN0TWV0YWRhdGEoY29uZmlnKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFuIGVtcHR5IGNvbmZpZyBvYmplY3QuXG4gICAqIEByZXR1cm4ge1R4Q29uZmlnfSBhbiBlbXB0eSBjb25maWcuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShUeENvbmZpZywgW3tcbiAgICBrZXk6IFwiaXNFbXB0eVwiLFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBjb25maWcgb2JqZWN0IGlzIGVtcHR5LiBJLmUuIGhhcyBubyBjb25maWd1cmF0aW9uIHZhbHVlcyBzcGVjaWZpZWQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoaXMgb2JqZWN0IGlzIGVtcHR5LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMpLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImVtcHR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtcHR5KCkge1xuICAgICAgcmV0dXJuIEVNUFRZX0NPTkZJRztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFR4Q29uZmlnO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFR4Q29uZmlnO1xudmFyIEVNUFRZX0NPTkZJRyA9IG5ldyBUeENvbmZpZyh7fSk7XG4vKipcbiAqIEByZXR1cm4ge0ludGVnZXJ8bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0VGltZW91dChjb25maWcpIHtcbiAgaWYgKHV0aWwuaXNPYmplY3QoY29uZmlnKSAmJiAoY29uZmlnLnRpbWVvdXQgfHwgY29uZmlnLnRpbWVvdXQgPT09IDApKSB7XG4gICAgdXRpbC5hc3NlcnROdW1iZXJPckludGVnZXIoY29uZmlnLnRpbWVvdXQsICdUcmFuc2FjdGlvbiB0aW1lb3V0Jyk7XG4gICAgdmFyIHRpbWVvdXQgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKGNvbmZpZy50aW1lb3V0KTtcblxuICAgIGlmICh0aW1lb3V0LmlzWmVybygpKSB7XG4gICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnVHJhbnNhY3Rpb24gdGltZW91dCBzaG91bGQgbm90IGJlIHplcm8nKTtcbiAgICB9XG5cbiAgICBpZiAodGltZW91dC5pc05lZ2F0aXZlKCkpIHtcbiAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdUcmFuc2FjdGlvbiB0aW1lb3V0IHNob3VsZCBub3QgYmUgbmVnYXRpdmUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGltZW91dDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBAcmV0dXJuIHtvYmplY3R8bnVsbH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dHJhY3RNZXRhZGF0YShjb25maWcpIHtcbiAgaWYgKHV0aWwuaXNPYmplY3QoY29uZmlnKSAmJiBjb25maWcubWV0YWRhdGEpIHtcbiAgICB2YXIgbWV0YWRhdGEgPSBjb25maWcubWV0YWRhdGE7XG4gICAgdXRpbC5hc3NlcnRPYmplY3QobWV0YWRhdGEpO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKG1ldGFkYXRhKS5sZW5ndGggIT09IDApIHtcbiAgICAgIC8vIG5vdCBhbiBlbXB0eSBvYmplY3RcbiAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRDb25maWcoY29uZmlnKSB7XG4gIGlmIChjb25maWcpIHtcbiAgICB1dGlsLmFzc2VydE9iamVjdChjb25maWcsICdUcmFuc2FjdGlvbiBjb25maWcnKTtcbiAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX3VyaUpzID0gcmVxdWlyZShcInVyaS1qc1wiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgREVGQVVMVF9CT0xUX1BPUlQgPSA3Njg3O1xudmFyIERFRkFVTFRfSFRUUF9QT1JUID0gNzQ3NDtcbnZhciBERUZBVUxUX0hUVFBTX1BPUlQgPSA3NDczO1xuXG52YXIgVXJsID0gZnVuY3Rpb24gVXJsKHNjaGVtZSwgaG9zdCwgcG9ydCwgaG9zdEFuZFBvcnQsIHF1ZXJ5KSB7XG4gICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgVXJsKTtcblxuICAvKipcbiAgICogTnVsbGFibGUgc2NoZW1lIChwcm90b2NvbCkgb2YgdGhlIFVSTC5cbiAgICogRXhhbXBsZTogJ2JvbHQnLCAnbmVvNGonLCAnaHR0cCcsICdodHRwcycsIGV0Yy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMuc2NoZW1lID0gc2NoZW1lO1xuICAvKipcbiAgICogTm9ubnVsbCBob3N0IG5hbWUgb3IgSVAgYWRkcmVzcy4gSVB2NiBub3Qgd3JhcHBlZCBpbiBzcXVhcmUgYnJhY2tldHMuXG4gICAqIEV4YW1wbGU6ICduZW80ai5jb20nLCAnbG9jYWxob3N0JywgJzEyNy4wLjAuMScsICcxOTIuMTY4LjEwLjE1JywgJzo6MScsICcyMDAxOjQ4NjA6NDg2MDo6ODg0NCcsIGV0Yy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG5cbiAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgLyoqXG4gICAqIE5vbm51bGwgbnVtYmVyIHJlcHJlc2VudGluZyBwb3J0LiBEZWZhdWx0IHBvcnQgZm9yIHRoZSBnaXZlbiBzY2hlbWUgaXMgdXNlZCBpZiBnaXZlbiBVUkwgc3RyaW5nXG4gICAqIGRvZXMgbm90IGNvbnRhaW4gcG9ydC4gRXhhbXBsZTogNzY4NyBmb3IgYm9sdCwgNzQ3NCBmb3IgSFRUUCBhbmQgNzQ3MyBmb3IgSFRUUFMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMucG9ydCA9IHBvcnQ7XG4gIC8qKlxuICAgKiBOb25udWxsIGhvc3QgbmFtZSBvciBJUCBhZGRyZXNzIHBsdXMgcG9ydCwgc2VwYXJhdGVkIGJ5ICc6Jy4gSVB2NiB3cmFwcGVkIGluIHNxdWFyZSBicmFja2V0cy5cbiAgICogRXhhbXBsZTogJ25lbzRqLmNvbScsICduZW80ai5jb206NzY4NycsICcxMjcuMC4wLjEnLCAnMTI3LjAuMC4xOjgwODAnLCAnWzIwMDE6NDg2MDo0ODYwOjo4ODQ0XScsXG4gICAqICdbMjAwMTo0ODYwOjQ4NjA6Ojg4NDRdOjkwOTAnLCBldGMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuXG4gIHRoaXMuaG9zdEFuZFBvcnQgPSBob3N0QW5kUG9ydDtcbiAgLyoqXG4gICAqIE5vbm51bGwgb2JqZWN0IHJlcHJlc2VudGluZyBwYXJzZWQgcXVlcnkgc3RyaW5nIGtleS12YWx1ZSBwYWlycy4gRHVwbGljYXRlZCBrZXlzIG5vdCBzdXBwb3J0ZWQuXG4gICAqIEV4YW1wbGU6ICd7fScsICd7J2tleTEnOiAndmFsdWUxJywgJ2tleTInOiAndmFsdWUyJ30nLCBldGMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMucXVlcnkgPSBxdWVyeTtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlRGF0YWJhc2VVcmwodXJsKSB7XG4gICgwLCBfdXRpbC5hc3NlcnRTdHJpbmcpKHVybCwgJ1VSTCcpO1xuICB2YXIgc2FuaXRpemVkID0gc2FuaXRpemVVcmwodXJsKTtcbiAgdmFyIHBhcnNlZFVybCA9ICgwLCBfdXJpSnMucGFyc2UpKHNhbml0aXplZC51cmwpO1xuICB2YXIgc2NoZW1lID0gc2FuaXRpemVkLnNjaGVtZU1pc3NpbmcgPyBudWxsIDogZXh0cmFjdFNjaGVtZShwYXJzZWRVcmwuc2NoZW1lKTtcbiAgdmFyIGhvc3QgPSBleHRyYWN0SG9zdChwYXJzZWRVcmwuaG9zdCk7IC8vIG5vIHNxdWFyZSBicmFja2V0cyBmb3IgSVB2NlxuXG4gIHZhciBmb3JtYXR0ZWRIb3N0ID0gZm9ybWF0SG9zdChob3N0KTsgLy8gaGFzIHNxdWFyZSBicmFja2V0cyBmb3IgSVB2NlxuXG4gIHZhciBwb3J0ID0gZXh0cmFjdFBvcnQocGFyc2VkVXJsLnBvcnQsIHNjaGVtZSk7XG4gIHZhciBob3N0QW5kUG9ydCA9IFwiXCIuY29uY2F0KGZvcm1hdHRlZEhvc3QsIFwiOlwiKS5jb25jYXQocG9ydCk7XG4gIHZhciBxdWVyeSA9IGV4dHJhY3RRdWVyeShwYXJzZWRVcmwucXVlcnksIHVybCk7XG4gIHJldHVybiBuZXcgVXJsKHNjaGVtZSwgaG9zdCwgcG9ydCwgaG9zdEFuZFBvcnQsIHF1ZXJ5KTtcbn1cblxuZnVuY3Rpb24gc2FuaXRpemVVcmwodXJsKSB7XG4gIHVybCA9IHVybC50cmltKCk7XG5cbiAgaWYgKHVybC5pbmRleE9mKCc6Ly8nKSA9PT0gLTEpIHtcbiAgICAvLyB1cmwgZG9lcyBub3QgY29udGFpbiBzY2hlbWUsIGFkZCBkdW1teSAnbm9uZTovLycgdG8gbWFrZSBwYXJzZXIgd29yayBjb3JyZWN0bHlcbiAgICByZXR1cm4ge1xuICAgICAgc2NoZW1lTWlzc2luZzogdHJ1ZSxcbiAgICAgIHVybDogXCJub25lOi8vXCIuY29uY2F0KHVybClcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWVNaXNzaW5nOiBmYWxzZSxcbiAgICB1cmw6IHVybFxuICB9O1xufVxuXG5mdW5jdGlvbiBleHRyYWN0U2NoZW1lKHNjaGVtZSkge1xuICBpZiAoc2NoZW1lKSB7XG4gICAgc2NoZW1lID0gc2NoZW1lLnRyaW0oKTtcblxuICAgIGlmIChzY2hlbWUuY2hhckF0KHNjaGVtZS5sZW5ndGggLSAxKSA9PT0gJzonKSB7XG4gICAgICBzY2hlbWUgPSBzY2hlbWUuc3Vic3RyaW5nKDAsIHNjaGVtZS5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RIb3N0KGhvc3QsIHVybCkge1xuICBpZiAoIWhvc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZXh0cmFjdCBob3N0IGZyb20gXCIuY29uY2F0KHVybCkpO1xuICB9XG5cbiAgcmV0dXJuIGhvc3QudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0UG9ydChwb3J0U3RyaW5nLCBzY2hlbWUpIHtcbiAgdmFyIHBvcnQgPSBwYXJzZUludChwb3J0U3RyaW5nLCAxMCk7XG4gIHJldHVybiBwb3J0ID09PSAwIHx8IHBvcnQgPyBwb3J0IDogZGVmYXVsdFBvcnRGb3JTY2hlbWUoc2NoZW1lKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFF1ZXJ5KHF1ZXJ5U3RyaW5nLCB1cmwpIHtcbiAgdmFyIHF1ZXJ5ID0gdHJpbUFuZFNhbml0aXplUXVlcnkocXVlcnlTdHJpbmcpO1xuICB2YXIgY29udGV4dCA9IHt9O1xuXG4gIGlmIChxdWVyeSkge1xuICAgIHF1ZXJ5LnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFpcikge1xuICAgICAgdmFyIGtleVZhbHVlID0gcGFpci5zcGxpdCgnPScpO1xuXG4gICAgICBpZiAoa2V5VmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFyYW1ldGVyczogJ1wiLmNvbmNhdChrZXlWYWx1ZSwgXCInIGluIFVSTCAnXCIpLmNvbmNhdCh1cmwsIFwiJy5cIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5ID0gdHJpbUFuZFZlcmlmeVF1ZXJ5RWxlbWVudChrZXlWYWx1ZVswXSwgJ2tleScsIHVybCk7XG4gICAgICB2YXIgdmFsdWUgPSB0cmltQW5kVmVyaWZ5UXVlcnlFbGVtZW50KGtleVZhbHVlWzFdLCAndmFsdWUnLCB1cmwpO1xuXG4gICAgICBpZiAoY29udGV4dFtrZXldKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZWQgcXVlcnkgcGFyYW1ldGVycyB3aXRoIGtleSAnXCIuY29uY2F0KGtleSwgXCInIGluIFVSTCAnXCIpLmNvbmNhdCh1cmwsIFwiJ1wiKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHRba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHRyaW1BbmRTYW5pdGl6ZVF1ZXJ5KHF1ZXJ5KSB7XG4gIHF1ZXJ5ID0gKHF1ZXJ5IHx8ICcnKS50cmltKCk7XG5cbiAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5LmNoYXJBdCgwKSA9PT0gJz8nKSB7XG4gICAgcXVlcnkgPSBxdWVyeS5zdWJzdHJpbmcoMSwgcXVlcnkubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiBxdWVyeTtcbn1cblxuZnVuY3Rpb24gdHJpbUFuZFZlcmlmeVF1ZXJ5RWxlbWVudChlbGVtZW50LCBuYW1lLCB1cmwpIHtcbiAgZWxlbWVudCA9IChlbGVtZW50IHx8ICcnKS50cmltKCk7XG5cbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBlbXB0eSBcIi5jb25jYXQobmFtZSwgXCIgaW4gVVJMIHF1ZXJ5ICdcIikuY29uY2F0KHVybCwgXCInXCIpKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBlc2NhcGVJUHY2QWRkcmVzcyhhZGRyZXNzKSB7XG4gIHZhciBzdGFydHNXaXRoU3F1YXJlQnJhY2tldCA9IGFkZHJlc3MuY2hhckF0KDApID09PSAnWyc7XG4gIHZhciBlbmRzV2l0aFNxdWFyZUJyYWNrZXQgPSBhZGRyZXNzLmNoYXJBdChhZGRyZXNzLmxlbmd0aCAtIDEpID09PSAnXSc7XG5cbiAgaWYgKCFzdGFydHNXaXRoU3F1YXJlQnJhY2tldCAmJiAhZW5kc1dpdGhTcXVhcmVCcmFja2V0KSB7XG4gICAgcmV0dXJuIFwiW1wiLmNvbmNhdChhZGRyZXNzLCBcIl1cIik7XG4gIH0gZWxzZSBpZiAoc3RhcnRzV2l0aFNxdWFyZUJyYWNrZXQgJiYgZW5kc1dpdGhTcXVhcmVCcmFja2V0KSB7XG4gICAgcmV0dXJuIGFkZHJlc3M7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBJUHY2IGFkZHJlc3MgXCIuY29uY2F0KGFkZHJlc3MpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRIb3N0KGhvc3QpIHtcbiAgaWYgKCFob3N0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBob3N0IFwiLmNvbmNhdChob3N0KSk7XG4gIH1cblxuICB2YXIgaXNJUHY2QWRkcmVzcyA9IGhvc3QuaW5kZXhPZignOicpID49IDA7XG4gIHJldHVybiBpc0lQdjZBZGRyZXNzID8gZXNjYXBlSVB2NkFkZHJlc3MoaG9zdCkgOiBob3N0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRJUHY0QWRkcmVzcyhhZGRyZXNzLCBwb3J0KSB7XG4gIHJldHVybiBcIlwiLmNvbmNhdChhZGRyZXNzLCBcIjpcIikuY29uY2F0KHBvcnQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRJUHY2QWRkcmVzcyhhZGRyZXNzLCBwb3J0KSB7XG4gIHZhciBlc2NhcGVkQWRkcmVzcyA9IGVzY2FwZUlQdjZBZGRyZXNzKGFkZHJlc3MpO1xuICByZXR1cm4gXCJcIi5jb25jYXQoZXNjYXBlZEFkZHJlc3MsIFwiOlwiKS5jb25jYXQocG9ydCk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQb3J0Rm9yU2NoZW1lKHNjaGVtZSkge1xuICBpZiAoc2NoZW1lID09PSAnaHR0cCcpIHtcbiAgICByZXR1cm4gREVGQVVMVF9IVFRQX1BPUlQ7XG4gIH0gZWxzZSBpZiAoc2NoZW1lID09PSAnaHR0cHMnKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfSFRUUFNfUE9SVDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gREVGQVVMVF9CT0xUX1BPUlQ7XG4gIH1cbn1cblxudmFyIF9kZWZhdWx0ID0ge1xuICBwYXJzZURhdGFiYXNlVXJsOiBwYXJzZURhdGFiYXNlVXJsLFxuICBkZWZhdWx0UG9ydEZvclNjaGVtZTogZGVmYXVsdFBvcnRGb3JTY2hlbWUsXG4gIGZvcm1hdElQdjRBZGRyZXNzOiBmb3JtYXRJUHY0QWRkcmVzcyxcbiAgZm9ybWF0SVB2NkFkZHJlc3M6IGZvcm1hdElQdjZBZGRyZXNzXG59O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzRW1wdHlPYmplY3RPck51bGwgPSBpc0VtcHR5T2JqZWN0T3JOdWxsO1xuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZXhwb3J0cy5hc3NlcnRPYmplY3QgPSBhc3NlcnRPYmplY3Q7XG5leHBvcnRzLmFzc2VydFN0cmluZyA9IGFzc2VydFN0cmluZztcbmV4cG9ydHMuYXNzZXJ0TnVtYmVyID0gYXNzZXJ0TnVtYmVyO1xuZXhwb3J0cy5hc3NlcnROdW1iZXJPckludGVnZXIgPSBhc3NlcnROdW1iZXJPckludGVnZXI7XG5leHBvcnRzLmFzc2VydFZhbGlkRGF0ZSA9IGFzc2VydFZhbGlkRGF0ZTtcbmV4cG9ydHMudmFsaWRhdGVRdWVyeUFuZFBhcmFtZXRlcnMgPSB2YWxpZGF0ZVF1ZXJ5QW5kUGFyYW1ldGVycztcbmV4cG9ydHMuRU5DUllQVElPTl9PRkYgPSBleHBvcnRzLkVOQ1JZUFRJT05fT04gPSB2b2lkIDA7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIF9pbnRlZ2VyID0gcmVxdWlyZShcIi4uL2ludGVnZXJcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEVOQ1JZUFRJT05fT04gPSAnRU5DUllQVElPTl9PTic7XG5leHBvcnRzLkVOQ1JZUFRJT05fT04gPSBFTkNSWVBUSU9OX09OO1xudmFyIEVOQ1JZUFRJT05fT0ZGID0gJ0VOQ1JZUFRJT05fT0ZGJztcbmV4cG9ydHMuRU5DUllQVElPTl9PRkYgPSBFTkNSWVBUSU9OX09GRjtcblxuZnVuY3Rpb24gaXNFbXB0eU9iamVjdE9yTnVsbChvYmopIHtcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gKDAsIF90eXBlb2YyW1wiZGVmYXVsdFwiXSkob2JqKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqKSAmJiBvYmogIT09IG51bGw7XG59XG4vKipcbiAqIENoZWNrIGFuZCBub3JtYWxpemUgZ2l2ZW4gcXVlcnkgYW5kIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge3N0cmluZ3x7dGV4dDogc3RyaW5nLCBwYXJhbWV0ZXJzOiBvYmplY3R9fSBxdWVyeSB0aGUgcXVlcnkgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVyc1xuICogQHJldHVybiB7e3F1ZXJ5OiBzdHJpbmcsIHBhcmFtczogb2JqZWN0fX0gdGhlIG5vcm1hbGl6ZWQgcXVlcnkgd2l0aCBwYXJhbWV0ZXJzLlxuICogQHRocm93cyBUeXBlRXJyb3Igd2hlbiBlaXRoZXIgZ2l2ZW4gcXVlcnkgb3IgcGFyYW1ldGVycyBhcmUgaW52YWxpZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUXVlcnlBbmRQYXJhbWV0ZXJzKHF1ZXJ5LCBwYXJhbWV0ZXJzKSB7XG4gIHZhciB2YWxpZGF0ZWRRdWVyeSA9IHF1ZXJ5O1xuICB2YXIgcGFyYW1zID0gcGFyYW1ldGVycyB8fCB7fTtcblxuICBpZiAoKDAsIF90eXBlb2YyW1wiZGVmYXVsdFwiXSkocXVlcnkpID09PSAnb2JqZWN0JyAmJiBxdWVyeS50ZXh0KSB7XG4gICAgdmFsaWRhdGVkUXVlcnkgPSBxdWVyeS50ZXh0O1xuICAgIHBhcmFtcyA9IHF1ZXJ5LnBhcmFtZXRlcnMgfHwge307XG4gIH1cblxuICBhc3NlcnRDeXBoZXJRdWVyeSh2YWxpZGF0ZWRRdWVyeSk7XG4gIGFzc2VydFF1ZXJ5UGFyYW1ldGVycyhwYXJhbXMpO1xuICByZXR1cm4ge1xuICAgIHZhbGlkYXRlZFF1ZXJ5OiB2YWxpZGF0ZWRRdWVyeSxcbiAgICBwYXJhbXM6IHBhcmFtc1xuICB9O1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3Qob2JqLCBvYmpOYW1lKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3Iob2JqTmFtZSArICcgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0IGJ1dCB3YXM6ICcgKyBKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN0cmluZyhvYmosIG9iak5hbWUpIHtcbiAgaWYgKCFpc1N0cmluZyhvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihvYmpOYW1lICsgJyBleHBlY3RlZCB0byBiZSBzdHJpbmcgYnV0IHdhczogJyArIEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKG9iaiwgb2JqTmFtZSkge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG9iak5hbWUgKyAnIGV4cGVjdGVkIHRvIGJlIGEgbnVtYmVyIGJ1dCB3YXM6ICcgKyBKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE51bWJlck9ySW50ZWdlcihvYmosIG9iak5hbWUpIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdudW1iZXInICYmICEoMCwgX2ludGVnZXIuaXNJbnQpKG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG9iak5hbWUgKyAnIGV4cGVjdGVkIHRvIGJlIGVpdGhlciBhIG51bWJlciBvciBhbiBJbnRlZ2VyIG9iamVjdCBidXQgd2FzOiAnICsgSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZERhdGUob2JqLCBvYmpOYW1lKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSAhPT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihvYmpOYW1lICsgJyBleHBlY3RlZCB0byBiZSBhIHN0YW5kYXJkIEphdmFTY3JpcHQgRGF0ZSBidXQgd2FzOiAnICsgSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH1cblxuICBpZiAoTnVtYmVyLmlzTmFOKG9iai5nZXRUaW1lKCkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihvYmpOYW1lICsgJyBleHBlY3RlZCB0byBiZSB2YWxpZCBKYXZhU2NyaXB0IERhdGUgYnV0IGl0cyB0aW1lIHdhcyBOYU46ICcgKyBKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEN5cGhlclF1ZXJ5KG9iaikge1xuICBhc3NlcnRTdHJpbmcob2JqLCAnQ3lwaGVyIHF1ZXJ5Jyk7XG5cbiAgaWYgKG9iai50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ3lwaGVyIHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZy4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRRdWVyeVBhcmFtZXRlcnMob2JqKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgIC8vIG9iamVjdHMgY3JlYXRlZCB3aXRoIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkbyBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yIHByb3BlcnR5XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvciA/ICcgJyArIG9iai5jb25zdHJ1Y3Rvci5uYW1lIDogJyc7XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUXVlcnkgcGFyYW1ldGVycyBhcmUgZXhwZWN0ZWQgdG8gZWl0aGVyIGJlIHVuZGVmaW5lZC9udWxsIG9yIGFuIG9iamVjdCwgZ2l2ZW46XCIuY29uY2F0KF9jb25zdHJ1Y3RvciwgXCIgXCIpLmNvbmNhdChvYmopKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0cmluZyhzdHIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdHIpID09PSAnW29iamVjdCBTdHJpbmddJztcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9zbGljZWRUb0FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheVwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobykgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAobyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkpIHsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgaXQsIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUZpZWxkTG9va3VwKGtleXMpIHtcbiAgdmFyIGxvb2t1cCA9IHt9O1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUsIGlkeCkge1xuICAgIGxvb2t1cFtuYW1lXSA9IGlkeDtcbiAgfSk7XG4gIHJldHVybiBsb29rdXA7XG59XG4vKipcbiAqIFJlY29yZHMgbWFrZSB1cCB0aGUgY29udGVudHMgb2YgdGhlIHtAbGluayBSZXN1bHR9LCBhbmQgaXMgaG93IHlvdSBhY2Nlc3NcbiAqIHRoZSBvdXRwdXQgb2YgYSBxdWVyeS4gQSBzaW1wbGUgcXVlcnkgbWlnaHQgeWllbGQgYSByZXN1bHQgc3RyZWFtXG4gKiB3aXRoIGEgc2luZ2xlIHJlY29yZCwgZm9yIGluc3RhbmNlOlxuICpcbiAqICAgICBNQVRDSCAodTpVc2VyKSBSRVRVUk4gdS5uYW1lLCB1LmFnZVxuICpcbiAqIFRoaXMgcmV0dXJucyBhIHN0cmVhbSBvZiByZWNvcmRzIHdpdGggdHdvIGZpZWxkcywgbmFtZWQgYHUubmFtZWAgYW5kIGB1LmFnZWAsXG4gKiBlYWNoIHJlY29yZCByZXByZXNlbnRzIG9uZSB1c2VyIGZvdW5kIGJ5IHRoZSBxdWVyeSBhYm92ZS4gWW91IGNhbiBhY2Nlc3NcbiAqIHRoZSB2YWx1ZXMgb2YgZWFjaCBmaWVsZCBlaXRoZXIgYnkgbmFtZTpcbiAqXG4gKiAgICAgcmVjb3JkLmdldChcInUubmFtZVwiKVxuICpcbiAqIE9yIGJ5IGl0J3MgcG9zaXRpb246XG4gKlxuICogICAgIHJlY29yZC5nZXQoMClcbiAqXG4gKiBAYWNjZXNzIHB1YmxpY1xuICovXG5cblxudmFyIFJlY29yZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcmVjb3JkIG9iamVjdC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0ga2V5cyBBbiBhcnJheSBvZiBmaWVsZCBrZXlzLCBpbiB0aGUgb3JkZXIgdGhlIGZpZWxkcyBhcHBlYXIgaW4gdGhlIHJlY29yZFxuICAgKiBAcGFyYW0ge0FycmF5fSBmaWVsZHMgQW4gYXJyYXkgb2YgZmllbGQgdmFsdWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZExvb2t1cCBBbiBvYmplY3Qgb2YgZmllbGROYW1lIC0+IHZhbHVlIGluZGV4LCB1c2VkIHRvIG1hcFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCBuYW1lcyB0byB2YWx1ZXMuIElmIHRoaXMgaXMgbnVsbCwgb25lIHdpbGwgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUmVjb3JkKGtleXMsIGZpZWxkcykge1xuICAgIHZhciBmaWVsZExvb2t1cCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFJlY29yZCk7XG5cbiAgICAvKipcbiAgICAgKiBGaWVsZCBrZXlzLCBpbiB0aGUgb3JkZXIgdGhlIGZpZWxkcyBhcHBlYXIgaW4gdGhlIHJlY29yZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICovXG4gICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgZmllbGRzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMubGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdGhpcy5fZmllbGRzID0gZmllbGRzO1xuICAgIHRoaXMuX2ZpZWxkTG9va3VwID0gZmllbGRMb29rdXAgfHwgZ2VuZXJhdGVGaWVsZExvb2t1cChrZXlzKTtcbiAgfVxuICAvKipcbiAgICogUnVuIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBmaWVsZCBpbiB0aGlzIHJlY29yZC4gVGhlIGZ1bmN0aW9uXG4gICAqIHdpbGwgZ2V0IHRocmVlIGFyZ3VtZW50cyAtIHRoZSB2YWx1ZSwgdGhlIGtleSBhbmQgdGhpcyByZWNvcmQsIGluIHRoYXRcbiAgICogb3JkZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IE9iamVjdCwga2V5OiBzdHJpbmcsIHJlY29yZDogUmVjb3JkKX0gdmlzaXRvciB0aGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBmaWVsZC5cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFJlY29yZCwgW3tcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKHZpc2l0b3IpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmVudHJpZXMoKSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwJHZhbHVlID0gKDAsIF9zbGljZWRUb0FycmF5MltcImRlZmF1bHRcIl0pKF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAga2V5ID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIHZhbHVlID0gX3N0ZXAkdmFsdWVbMV07XG5cbiAgICAgICAgICB2aXNpdG9yKHZhbHVlLCBrZXksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggZmllbGQgaW4gdGhpcyByZWNvcmQuIFRoZSBmdW5jdGlvblxuICAgICAqIHdpbGwgZ2V0IHRocmVlIGFyZ3VtZW50cyAtIHRoZSB2YWx1ZSwgdGhlIGtleSBhbmQgdGhpcyByZWNvcmQsIGluIHRoYXRcbiAgICAgKiBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IE9iamVjdCwga2V5OiBzdHJpbmcsIHJlY29yZDogUmVjb3JkKX0gdmlzaXRvciB0aGUgZnVuY3Rpb24gdG8gYXBwbHkgb24gZWFjaCBmaWVsZFxuICAgICAqIGFuZCByZXR1cm4gYSB2YWx1ZSB0aGF0IGlzIHNhdmVkIHRvIHRoZSByZXR1cm5lZCBBcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAodmlzaXRvcikge1xuICAgICAgdmFyIHJlc3VsdEFycmF5ID0gW107XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5lbnRyaWVzKCkpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAyJHZhbHVlID0gKDAsIF9zbGljZWRUb0FycmF5MltcImRlZmF1bHRcIl0pKF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIGtleSA9IF9zdGVwMiR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBfc3RlcDIkdmFsdWVbMV07XG5cbiAgICAgICAgICByZXN1bHRBcnJheS5wdXNoKHZpc2l0b3IodmFsdWUsIGtleSwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdEFycmF5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlIG92ZXIgcmVzdWx0cy4gRWFjaCBpdGVyYXRpb24gd2lsbCB5aWVsZCBhbiBhcnJheVxuICAgICAqIG9mIGV4YWN0bHkgdHdvIGl0ZW1zIC0gdGhlIGtleSwgYW5kIHRoZSB2YWx1ZSAoaW4gb3JkZXIpLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRvclxuICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPEFycmF5Pn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVudHJpZXNcIixcbiAgICB2YWx1ZTogLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgdmFyIGk7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIGVudHJpZXMkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBpZiAoIShpIDwgdGhpcy5rZXlzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gW3RoaXMua2V5c1tpXSwgdGhpcy5fZmllbGRzW2ldXTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgZW50cmllcywgdGhpcyk7XG4gICAgfSlcbiAgICAvKipcbiAgICAgKiBJdGVyYXRlIG92ZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRvclxuICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPE9iamVjdD59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZXNcIixcbiAgICB2YWx1ZTogLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gdmFsdWVzJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgaWYgKCEoaSA8IHRoaXMua2V5cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmllbGRzW2ldO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHZhbHVlcywgdGhpcyk7XG4gICAgfSlcbiAgICAvKipcbiAgICAgKiBJdGVyYXRlIG92ZXIgdmFsdWVzLiBEZWxlZ2F0ZXMgdG8ge0BsaW5rIFJlY29yZCN2YWx1ZXN9XG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdG9yXG4gICAgICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3I8T2JqZWN0Pn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBTeW1ib2wuaXRlcmF0b3IsXG4gICAgdmFsdWU6IC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIHZhbHVlJChfY29udGV4dDMpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5kZWxlZ2F0ZVlpZWxkKHRoaXMudmFsdWVzKCksIFwidDBcIiwgMSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB2YWx1ZSwgdGhpcyk7XG4gICAgfSlcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gb2JqZWN0IG91dCBvZiB0aGUgY3VycmVudCBSZWNvcmRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b09iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgICAgIHZhciBvYmplY3QgPSB7fTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmVudHJpZXMoKSksXG4gICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDMkdmFsdWUgPSAoMCwgX3NsaWNlZFRvQXJyYXkyW1wiZGVmYXVsdFwiXSkoX3N0ZXAzLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAga2V5ID0gX3N0ZXAzJHZhbHVlWzBdLFxuICAgICAgICAgICAgICBfdmFsdWUgPSBfc3RlcDMkdmFsdWVbMV07XG5cbiAgICAgICAgICBvYmplY3Rba2V5XSA9IF92YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHZhbHVlIGZyb20gdGhpcyByZWNvcmQsIGVpdGhlciBieSBpbmRleCBvciBieSBmaWVsZCBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xOdW1iZXJ9IGtleSBGaWVsZCBrZXksIG9yIHRoZSBpbmRleCBvZiB0aGUgZmllbGQuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgdmFyIGluZGV4O1xuXG4gICAgICBpZiAoISh0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgaW5kZXggPSB0aGlzLl9maWVsZExvb2t1cFtrZXldO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoXCJUaGlzIHJlY29yZCBoYXMgbm8gZmllbGQgd2l0aCBrZXkgJ1wiICsga2V5ICsgXCInLCBhdmFpbGFibGUga2V5IGFyZTogW1wiICsgdGhpcy5rZXlzICsgJ10uJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ID0ga2V5O1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPiB0aGlzLl9maWVsZHMubGVuZ3RoIC0gMSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoXCJUaGlzIHJlY29yZCBoYXMgbm8gZmllbGQgd2l0aCBpbmRleCAnXCIgKyBpbmRleCArIFwiJy4gUmVtZW1iZXIgdGhhdCBpbmRleGVzIHN0YXJ0IGF0IGAwYCwgXCIgKyAnYW5kIG1ha2Ugc3VyZSB5b3VyIHF1ZXJ5IHJldHVybnMgcmVjb3JkcyBpbiB0aGUgc2hhcGUgeW91IG1lYW50IGl0IHRvLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fZmllbGRzW2luZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBmcm9tIHRoaXMgcmVjb3JkLCBlaXRoZXIgYnkgaW5kZXggb3IgYnkgZmllbGQga2V5LCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xOdW1iZXJ9IGtleSBGaWVsZCBrZXksIG9yIHRoZSBpbmRleCBvZiB0aGUgZmllbGQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgLy8gaWYga2V5IGlzIGEgbnVtYmVyLCB3ZSBjaGVjayBpZiBpdCBpcyBpbiB0aGUgX2ZpZWxkcyBhcnJheVxuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBrZXkgPj0gMCAmJiBrZXkgPCB0aGlzLl9maWVsZHMubGVuZ3RoO1xuICAgICAgfSAvLyBpZiBpdCdzIG5vdCBhIG51bWJlciwgd2UgY2hlY2sgX2ZpZWxkTG9va3VwIGRpY3Rpb25hcnkgZGlyZWN0bHlcblxuXG4gICAgICByZXR1cm4gdGhpcy5fZmllbGRMb29rdXBba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUmVjb3JkO1xufSgpO1xuXG52YXIgX2RlZmF1bHQgPSBSZWNvcmQ7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5cbnZhciBfcmVzdWx0U3VtbWFyeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVzdWx0LXN1bW1hcnlcIikpO1xuXG52YXIgX3J4anMgPSByZXF1aXJlKFwicnhqc1wiKTtcblxudmFyIF9vcGVyYXRvcnMgPSByZXF1aXJlKFwicnhqcy9vcGVyYXRvcnNcIik7XG5cbnZhciBfcmVjb3JkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZWNvcmRcIikpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBTdGF0ZXMgPSB7XG4gIFJFQURZOiAwLFxuICBTVFJFQU1JTkc6IDEsXG4gIENPTVBMRVRFRDogMlxufTtcbi8qKlxuICogVGhlIHJlYWN0aXZlIHJlc3VsdCBpbnRlcmZhY2UuXG4gKi9cblxudmFyIFJ4UmVzdWx0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7T2JzZXJ2YWJsZTxSZXN1bHQ+fSByZXN1bHQgLSBBbiBvYnNlcnZhYmxlIG9mIHNpbmdsZSBSZXN1bHQgaW5zdGFuY2UgdG8gcmVsYXkgcmVxdWVzdHMuXG4gICAqL1xuICBmdW5jdGlvbiBSeFJlc3VsdChyZXN1bHQpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFJ4UmVzdWx0KTtcbiAgICB2YXIgcmVwbGF5ZWRSZXN1bHQgPSByZXN1bHQucGlwZSgoMCwgX29wZXJhdG9ycy5wdWJsaXNoUmVwbGF5KSgxKSwgKDAsIF9vcGVyYXRvcnMucmVmQ291bnQpKCkpO1xuICAgIHRoaXMuX3Jlc3VsdCA9IHJlcGxheWVkUmVzdWx0O1xuICAgIHRoaXMuX2tleXMgPSByZXBsYXllZFJlc3VsdC5waXBlKCgwLCBfb3BlcmF0b3JzLmZsYXRNYXApKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gKDAsIF9yeGpzLmZyb20pKHIua2V5cygpKTtcbiAgICB9KSwgKDAsIF9vcGVyYXRvcnMucHVibGlzaFJlcGxheSkoMSksICgwLCBfb3BlcmF0b3JzLnJlZkNvdW50KSgpKTtcbiAgICB0aGlzLl9yZWNvcmRzID0gbmV3IF9yeGpzLlN1YmplY3QoKTtcbiAgICB0aGlzLl9zdW1tYXJ5ID0gbmV3IF9yeGpzLlJlcGxheVN1YmplY3QoKTtcbiAgICB0aGlzLl9zdGF0ZSA9IFN0YXRlcy5SRUFEWTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgZXhwb3NlcyBhIHNpbmdsZSBpdGVtIGNvbnRhaW5pbmcgZmllbGQgbmFtZXNcbiAgICogcmV0dXJuZWQgYnkgdGhlIGV4ZWN1dGluZyBxdWVyeS5cbiAgICpcbiAgICogRXJyb3JzIHJhaXNlZCBieSBhY3R1YWwgcXVlcnkgZXhlY3V0aW9uIGNhbiBzdXJmYWNlIG9uIHRoZSByZXR1cm5lZFxuICAgKiBvYnNlcnZhYmxlIHN0cmVhbS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTxzdHJpbmdbXT59IC0gQW4gb2JzZXJ2YWJsZSBzdHJlYW0gKHdpdGggZXhhY3RseSBvbmUgZWxlbWVudCkgb2YgZmllbGQgbmFtZXMuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShSeFJlc3VsdCwgW3tcbiAgICBrZXk6IFwia2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2tleXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IGV4cG9zZXMgZWFjaCByZWNvcmQgcmV0dXJuZWQgYnkgdGhlIGV4ZWN1dGluZyBxdWVyeS5cbiAgICAgKlxuICAgICAqIEVycm9ycyByYWlzZWQgZHVyaW5nIHRoZSBzdHJlYW1pbmcgcGhhc2UgY2FuIHN1cmZhY2Ugb24gdGhlIHJldHVybmVkIG9ic2VydmFibGUgc3RyZWFtLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlPFJlY29yZD59IC0gQW4gb2JzZXJ2YWJsZSBzdHJlYW0gb2YgcmVjb3Jkcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlY29yZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb3JkcygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXN1bHQucGlwZSgoMCwgX29wZXJhdG9ycy5mbGF0TWFwKShmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBuZXcgX3J4anMuT2JzZXJ2YWJsZShmdW5jdGlvbiAocmVjb3Jkc09ic2VydmVyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9zdGFydFN0cmVhbWluZyh7XG4gICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgIHJlY29yZHNPYnNlcnZlcjogcmVjb3Jkc09ic2VydmVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgdGhhdCBleHBvc2VzIGEgc2luZ2xlIGl0ZW0gb2Yge0BsaW5rIFJlc3VsdFN1bW1hcnl9IHRoYXQgaXMgZ2VuZXJhdGVkIGJ5XG4gICAgICogdGhlIHNlcnZlciBhZnRlciB0aGUgc3RyZWFtaW5nIG9mIHRoZSBleGVjdXRpbmcgcXVlcnkgaXMgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogKlN1YnNjcmliaW5nIHRvIHRoaXMgc3RyZWFtIGJlZm9yZSBzdWJzY3JpYmluZyB0byByZWNvcmRzKCkgc3RyZWFtIGNhdXNlcyB0aGUgcmVzdWx0cyB0byBiZSBkaXNjYXJkZWQgb24gdGhlIHNlcnZlci4qXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHJldHVybnMge09ic2VydmFibGU8UmVzdWx0U3VtbWFyeT59IC0gQW4gb2JzZXJ2YWJsZSBzdHJlYW0gKHdpdGggZXhhY3RseSBvbmUgZWxlbWVudCkgb2YgcmVzdWx0IHN1bW1hcnkuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25zdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnN1bWUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VsdC5waXBlKCgwLCBfb3BlcmF0b3JzLmZsYXRNYXApKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfcnhqcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChzdW1tYXJ5T2JzZXJ2ZXIpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLl9zdGFydFN0cmVhbWluZyh7XG4gICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgIHN1bW1hcnlPYnNlcnZlcjogc3VtbWFyeU9ic2VydmVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc3RhcnRTdHJlYW1pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0U3RyZWFtaW5nKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICByZXN1bHQgPSBfcmVmLnJlc3VsdCxcbiAgICAgICAgICBfcmVmJHJlY29yZHNPYnNlcnZlciA9IF9yZWYucmVjb3Jkc09ic2VydmVyLFxuICAgICAgICAgIHJlY29yZHNPYnNlcnZlciA9IF9yZWYkcmVjb3Jkc09ic2VydmVyID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRyZWNvcmRzT2JzZXJ2ZXIsXG4gICAgICAgICAgX3JlZiRzdW1tYXJ5T2JzZXJ2ZXIgPSBfcmVmLnN1bW1hcnlPYnNlcnZlcixcbiAgICAgICAgICBzdW1tYXJ5T2JzZXJ2ZXIgPSBfcmVmJHN1bW1hcnlPYnNlcnZlciA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkc3VtbWFyeU9ic2VydmVyO1xuXG4gICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IFtdO1xuXG4gICAgICBpZiAoc3VtbWFyeU9ic2VydmVyKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLl9zdW1tYXJ5LnN1YnNjcmliZShzdW1tYXJ5T2JzZXJ2ZXIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3N0YXRlIDwgU3RhdGVzLlNUUkVBTUlORykge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IFN0YXRlcy5TVFJFQU1JTkc7XG5cbiAgICAgICAgaWYgKHJlY29yZHNPYnNlcnZlcikge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLl9yZWNvcmRzLnN1YnNjcmliZShyZWNvcmRzT2JzZXJ2ZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1YnNjcmlwdGlvbnMucHVzaCh7XG4gICAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5fY2FuY2VsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5fY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5fcmVjb3Jkcy5vYnNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVzdWx0Ll9jYW5jZWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5zdWJzY3JpYmUoe1xuICAgICAgICAgIG9uTmV4dDogZnVuY3Rpb24gb25OZXh0KHJlY29yZCkge1xuICAgICAgICAgICAgX3RoaXMzLl9yZWNvcmRzLm5leHQocmVjb3JkKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiBvbkNvbXBsZXRlZChzdW1tYXJ5KSB7XG4gICAgICAgICAgICBfdGhpczMuX3JlY29yZHMuY29tcGxldGUoKTtcblxuICAgICAgICAgICAgX3RoaXMzLl9zdW1tYXJ5Lm5leHQoc3VtbWFyeSk7XG5cbiAgICAgICAgICAgIF90aGlzMy5fc3VtbWFyeS5jb21wbGV0ZSgpO1xuXG4gICAgICAgICAgICBfdGhpczMuX3N0YXRlID0gU3RhdGVzLkNPTVBMRVRFRDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgICAgICBfdGhpczMuX3JlY29yZHMuZXJyb3IoZXJyKTtcblxuICAgICAgICAgICAgX3RoaXMzLl9zdW1tYXJ5LmVycm9yKGVycik7XG5cbiAgICAgICAgICAgIF90aGlzMy5fc3RhdGUgPSBTdGF0ZXMuQ09NUExFVEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZHNPYnNlcnZlcikge1xuICAgICAgICByZWNvcmRzT2JzZXJ2ZXIuZXJyb3IoKDAsIF9lcnJvci5uZXdFcnJvcikoJ1N0cmVhbWluZyBoYXMgYWxyZWFkeSBzdGFydGVkL2NvbnN1bWVkIHdpdGggYSBwcmV2aW91cyByZWNvcmRzIG9yIHN1bW1hcnkgc3Vic2NyaXB0aW9uLicpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgcmV0dXJuIHMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUnhSZXN1bHQ7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUnhSZXN1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBleHBvcnRzLnF1ZXJ5VHlwZSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9pbnRlZ2VyID0gcmVxdWlyZShcIi4vaW50ZWdlclwiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQSBSZXN1bHRTdW1tYXJ5IGluc3RhbmNlIGNvbnRhaW5zIHN0cnVjdHVyZWQgbWV0YWRhdGEgZm9yIGEge0BsaW5rIFJlc3VsdH0uXG4gKiBAYWNjZXNzIHB1YmxpY1xuICovXG52YXIgUmVzdWx0U3VtbWFyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRoaXMgc3VtbWFyeSBpcyBmb3JcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgcXVlcnlcbiAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFkYXRhIC0gUXVlcnkgbWV0YWRhdGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByb3RvY29sVmVyc2lvbiAtIEJvbHQgcHJvdG9jb2wgdmVyc2lvblxuICAgKi9cbiAgZnVuY3Rpb24gUmVzdWx0U3VtbWFyeShxdWVyeSwgcGFyYW1ldGVycywgbWV0YWRhdGEsIHByb3RvY29sVmVyc2lvbikge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUmVzdWx0U3VtbWFyeSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgYW5kIHBhcmFtZXRlcnMgdGhpcyBzdW1tYXJ5IGlzIGZvci5cbiAgICAgKiBAdHlwZSB7e3RleHQ6IHN0cmluZywgcGFyYW1ldGVyczogT2JqZWN0fX1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGhpcy5xdWVyeSA9IHtcbiAgICAgIHRleHQ6IHF1ZXJ5LFxuICAgICAgcGFyYW1ldGVyczogcGFyYW1ldGVyc1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgcXVlcnkgZXhlY3V0ZWQuIENhbiBiZSBcInJcIiBmb3IgcmVhZC1vbmx5IHF1ZXJ5LCBcInJ3XCIgZm9yIHJlYWQtd3JpdGUgcXVlcnksXG4gICAgICogXCJ3XCIgZm9yIHdyaXRlLW9ubHkgcXVlcnkgYW5kIFwic1wiIGZvciBzY2hlbWEtd3JpdGUgcXVlcnkuXG4gICAgICogU3RyaW5nIGNvbnN0YW50cyBhcmUgYXZhaWxhYmxlIGluIHtAbGluayBxdWVyeVR5cGV9IG9iamVjdC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cblxuICAgIHRoaXMucXVlcnlUeXBlID0gbWV0YWRhdGEudHlwZTtcbiAgICAvKipcbiAgICAgKiBDb3VudGVycyBmb3Igb3BlcmF0aW9ucyB0aGUgcXVlcnkgdHJpZ2dlcmVkLlxuICAgICAqIEB0eXBlIHtRdWVyeVN0YXRpc3RpY3N9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuXG4gICAgdGhpcy5jb3VudGVycyA9IG5ldyBRdWVyeVN0YXRpc3RpY3MobWV0YWRhdGEuc3RhdHMgfHwge30pOyAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHJlbW92ZSBpbiBmdXR1cmUgdmVyc2lvblxuXG4gICAgLyoqXG4gICAgICogVXNlIHtAbGluayBSZXN1bHRTdW1tYXJ5LmNvdW50ZXJzfSBpbnN0ZWFkLlxuICAgICAqIEB0eXBlIHtRdWVyeVN0YXRpc3RpY3N9XG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cblxuICAgIHRoaXMudXBkYXRlU3RhdGlzdGljcyA9IHRoaXMuY291bnRlcnM7XG4gICAgLyoqXG4gICAgICogVGhpcyBkZXNjcmliZXMgaG93IHRoZSBkYXRhYmFzZSB3aWxsIGV4ZWN1dGUgdGhlIHF1ZXJ5LlxuICAgICAqIFF1ZXJ5IHBsYW4gZm9yIHRoZSBleGVjdXRlZCBxdWVyeSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAgICogV2lsbCBvbmx5IGJlIHBvcHVsYXRlZCBmb3IgcXVlcmllcyB0aGF0IHN0YXJ0IHdpdGggXCJFWFBMQUlOXCIuXG4gICAgICogQHR5cGUge1BsYW59XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuXG4gICAgdGhpcy5wbGFuID0gbWV0YWRhdGEucGxhbiB8fCBtZXRhZGF0YS5wcm9maWxlID8gbmV3IFBsYW4obWV0YWRhdGEucGxhbiB8fCBtZXRhZGF0YS5wcm9maWxlKSA6IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZGVzY3JpYmVzIGhvdyB0aGUgZGF0YWJhc2UgZGlkIGV4ZWN1dGUgeW91ciBxdWVyeS4gVGhpcyB3aWxsIGNvbnRhaW4gZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgd2hhdFxuICAgICAqIGVhY2ggc3RlcCBvZiB0aGUgcGxhbiBkaWQuIFByb2ZpbGVkIHF1ZXJ5IHBsYW4gZm9yIHRoZSBleGVjdXRlZCBxdWVyeSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAgICogV2lsbCBvbmx5IGJlIHBvcHVsYXRlZCBmb3IgcXVlcmllcyB0aGF0IHN0YXJ0IHdpdGggXCJQUk9GSUxFXCIuXG4gICAgICogQHR5cGUge1Byb2ZpbGVkUGxhbn1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG5cbiAgICB0aGlzLnByb2ZpbGUgPSBtZXRhZGF0YS5wcm9maWxlID8gbmV3IFByb2ZpbGVkUGxhbihtZXRhZGF0YS5wcm9maWxlKSA6IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIG5vdGlmaWNhdGlvbnMgdGhhdCBtaWdodCBhcmlzZSB3aGVuIGV4ZWN1dGluZyB0aGUgcXVlcnkuIE5vdGlmaWNhdGlvbnMgY2FuIGJlIHdhcm5pbmdzIGFib3V0XG4gICAgICogcHJvYmxlbWF0aWMgcXVlcmllcyBvciBvdGhlciB2YWx1YWJsZSBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSBwcmVzZW50ZWQgaW4gYSBjbGllbnQuIFVubGlrZSBmYWlsdXJlc1xuICAgICAqIG9yIGVycm9ycywgbm90aWZpY2F0aW9ucyBkbyBub3QgYWZmZWN0IHRoZSBleGVjdXRpb24gb2YgYSBxdWVyeS5cbiAgICAgKiBAdHlwZSB7QXJyYXk8Tm90aWZpY2F0aW9uPn1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG5cbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSB0aGlzLl9idWlsZE5vdGlmaWNhdGlvbnMobWV0YWRhdGEubm90aWZpY2F0aW9ucyk7XG4gICAgLyoqXG4gICAgICogVGhlIGJhc2ljIGluZm9ybWF0aW9uIG9mIHRoZSBzZXJ2ZXIgd2hlcmUgdGhlIHJlc3VsdCBpcyBvYnRhaW5lZCBmcm9tLlxuICAgICAqIEB0eXBlIHtTZXJ2ZXJJbmZvfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cblxuICAgIHRoaXMuc2VydmVyID0gbmV3IFNlcnZlckluZm8obWV0YWRhdGEuc2VydmVyLCBwcm90b2NvbFZlcnNpb24pO1xuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lIGl0IHRvb2sgdGhlIHNlcnZlciB0byBjb25zdW1lIHRoZSByZXN1bHQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG5cbiAgICB0aGlzLnJlc3VsdENvbnN1bWVkQWZ0ZXIgPSBtZXRhZGF0YS5yZXN1bHRfY29uc3VtZWRfYWZ0ZXI7XG4gICAgLyoqXG4gICAgICogVGhlIHRpbWUgaXQgdG9vayB0aGUgc2VydmVyIHRvIG1ha2UgdGhlIHJlc3VsdCBhdmFpbGFibGUgZm9yIGNvbnN1bXB0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cblxuICAgIHRoaXMucmVzdWx0QXZhaWxhYmxlQWZ0ZXIgPSBtZXRhZGF0YS5yZXN1bHRfYXZhaWxhYmxlX2FmdGVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhYmFzZSBuYW1lIHdoZXJlIHRoaXMgc3VtbWFyeSBpcyBvYnRhaW5lZCBmcm9tLlxuICAgICAqIEB0eXBlIHt7bmFtZTogc3RyaW5nfX1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG5cbiAgICB0aGlzLmRhdGFiYXNlID0ge1xuICAgICAgbmFtZTogbWV0YWRhdGEuZGIgfHwgbnVsbFxuICAgIH07XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFJlc3VsdFN1bW1hcnksIFt7XG4gICAga2V5OiBcIl9idWlsZE5vdGlmaWNhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2J1aWxkTm90aWZpY2F0aW9ucyhub3RpZmljYXRpb25zKSB7XG4gICAgICBpZiAoIW5vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm90aWZpY2F0aW9ucy5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RpZmljYXRpb24obik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHJlc3VsdCBzdW1tYXJ5IGhhcyBhIHBsYW5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzUGxhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNQbGFuKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGxhbiBpbnN0YW5jZW9mIFBsYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSByZXN1bHQgc3VtbWFyeSBoYXMgYSBwcm9maWxlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhhc1Byb2ZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUHJvZmlsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2ZpbGUgaW5zdGFuY2VvZiBQcm9maWxlZFBsYW47XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSZXN1bHRTdW1tYXJ5O1xufSgpO1xuLyoqXG4gKiBDbGFzcyBmb3IgZXhlY3V0aW9uIHBsYW4gcmVjZWl2ZWQgYnkgcHJlcGVuZGluZyBDeXBoZXIgd2l0aCBFWFBMQUlOLlxuICogQGFjY2VzcyBwdWJsaWNcbiAqL1xuXG5cbnZhciBQbGFuID1cbi8qKlxuICogQ3JlYXRlIGEgUGxhbiBpbnN0YW5jZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gcGxhbiAtIE9iamVjdCB3aXRoIHBsYW4gZGF0YVxuICovXG5mdW5jdGlvbiBQbGFuKHBsYW4pIHtcbiAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBQbGFuKTtcbiAgdGhpcy5vcGVyYXRvclR5cGUgPSBwbGFuLm9wZXJhdG9yVHlwZTtcbiAgdGhpcy5pZGVudGlmaWVycyA9IHBsYW4uaWRlbnRpZmllcnM7XG4gIHRoaXMuYXJndW1lbnRzID0gcGxhbi5hcmdzO1xuICB0aGlzLmNoaWxkcmVuID0gcGxhbi5jaGlsZHJlbiA/IHBsYW4uY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBuZXcgUGxhbihjaGlsZCk7XG4gIH0pIDogW107XG59O1xuLyoqXG4gKiBDbGFzcyBmb3IgZXhlY3V0aW9uIHBsYW4gcmVjZWl2ZWQgYnkgcHJlcGVuZGluZyBDeXBoZXIgd2l0aCBQUk9GSUxFLlxuICogQGFjY2VzcyBwdWJsaWNcbiAqL1xuXG5cbnZhciBQcm9maWxlZFBsYW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgUHJvZmlsZWRQbGFuIGluc3RhbmNlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvZmlsZSAtIE9iamVjdCB3aXRoIHByb2ZpbGUgZGF0YVxuICAgKi9cbiAgZnVuY3Rpb24gUHJvZmlsZWRQbGFuKHByb2ZpbGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFByb2ZpbGVkUGxhbik7XG4gICAgdGhpcy5vcGVyYXRvclR5cGUgPSBwcm9maWxlLm9wZXJhdG9yVHlwZTtcbiAgICB0aGlzLmlkZW50aWZpZXJzID0gcHJvZmlsZS5pZGVudGlmaWVycztcbiAgICB0aGlzLmFyZ3VtZW50cyA9IHByb2ZpbGUuYXJncztcbiAgICB0aGlzLmRiSGl0cyA9IHZhbHVlT3JEZWZhdWx0KCdkYkhpdHMnLCBwcm9maWxlKTtcbiAgICB0aGlzLnJvd3MgPSB2YWx1ZU9yRGVmYXVsdCgncm93cycsIHByb2ZpbGUpO1xuICAgIHRoaXMucGFnZUNhY2hlTWlzc2VzID0gdmFsdWVPckRlZmF1bHQoJ3BhZ2VDYWNoZU1pc3NlcycsIHByb2ZpbGUpO1xuICAgIHRoaXMucGFnZUNhY2hlSGl0cyA9IHZhbHVlT3JEZWZhdWx0KCdwYWdlQ2FjaGVIaXRzJywgcHJvZmlsZSk7XG4gICAgdGhpcy5wYWdlQ2FjaGVIaXRSYXRpbyA9IHZhbHVlT3JEZWZhdWx0KCdwYWdlQ2FjaGVIaXRSYXRpbycsIHByb2ZpbGUpO1xuICAgIHRoaXMudGltZSA9IHZhbHVlT3JEZWZhdWx0KCd0aW1lJywgcHJvZmlsZSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IHByb2ZpbGUuY2hpbGRyZW4gPyBwcm9maWxlLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvZmlsZWRQbGFuKGNoaWxkKTtcbiAgICB9KSA6IFtdO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShQcm9maWxlZFBsYW4sIFt7XG4gICAga2V5OiBcImhhc1BhZ2VDYWNoZVN0YXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1BhZ2VDYWNoZVN0YXRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFnZUNhY2hlTWlzc2VzID4gMCB8fCB0aGlzLnBhZ2VDYWNoZUhpdHMgPiAwIHx8IHRoaXMucGFnZUNhY2hlSGl0UmF0aW8gPiAwO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUHJvZmlsZWRQbGFuO1xufSgpO1xuLyoqXG4gKiBHZXQgc3RhdGlzdGljYWwgaW5mb3JtYXRpb24gZm9yIGEge0BsaW5rIFJlc3VsdH0uXG4gKiBAYWNjZXNzIHB1YmxpY1xuICovXG5cblxudmFyIFF1ZXJ5U3RhdGlzdGljcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBTdHJ1Y3R1cml6ZSB0aGUgc3RhdGlzdGljc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRpc3RpY3MgLSBSZXN1bHQgc3RhdGlzdGljc1xuICAgKi9cbiAgZnVuY3Rpb24gUXVlcnlTdGF0aXN0aWNzKHN0YXRpc3RpY3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBRdWVyeVN0YXRpc3RpY3MpO1xuICAgIHRoaXMuX3N0YXRzID0ge1xuICAgICAgbm9kZXNDcmVhdGVkOiAwLFxuICAgICAgbm9kZXNEZWxldGVkOiAwLFxuICAgICAgcmVsYXRpb25zaGlwc0NyZWF0ZWQ6IDAsXG4gICAgICByZWxhdGlvbnNoaXBzRGVsZXRlZDogMCxcbiAgICAgIHByb3BlcnRpZXNTZXQ6IDAsXG4gICAgICBsYWJlbHNBZGRlZDogMCxcbiAgICAgIGxhYmVsc1JlbW92ZWQ6IDAsXG4gICAgICBpbmRleGVzQWRkZWQ6IDAsXG4gICAgICBpbmRleGVzUmVtb3ZlZDogMCxcbiAgICAgIGNvbnN0cmFpbnRzQWRkZWQ6IDAsXG4gICAgICBjb25zdHJhaW50c1JlbW92ZWQ6IDBcbiAgICB9O1xuICAgIHRoaXMuX3N5c3RlbVVwZGF0ZXMgPSAwO1xuICAgIE9iamVjdC5rZXlzKHN0YXRpc3RpY3MpLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAvLyBUbyBjYW1lbENhc2VcbiAgICAgIHZhciBjYW1lbENhc2VJbmRleCA9IGluZGV4LnJlcGxhY2UoLygtXFx3KS9nLCBmdW5jdGlvbiAobSkge1xuICAgICAgICByZXR1cm4gbVsxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChjYW1lbENhc2VJbmRleCBpbiBfdGhpcy5fc3RhdHMpIHtcbiAgICAgICAgX3RoaXMuX3N0YXRzW2NhbWVsQ2FzZUluZGV4XSA9IGludFZhbHVlKHN0YXRpc3RpY3NbaW5kZXhdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtZWxDYXNlSW5kZXggPT09ICdzeXN0ZW1VcGRhdGVzJykge1xuICAgICAgICBfdGhpcy5fc3lzdGVtVXBkYXRlcyA9IGludFZhbHVlKHN0YXRpc3RpY3NbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9zdGF0cyA9IE9iamVjdC5mcmVlemUodGhpcy5fc3RhdHMpO1xuICB9XG4gIC8qKlxuICAgKiBEaWQgdGhlIGRhdGFiYXNlIGdldCB1cGRhdGVkP1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUXVlcnlTdGF0aXN0aWNzLCBbe1xuICAgIGtleTogXCJjb250YWluc1VwZGF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNVcGRhdGVzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zdGF0cykucmVkdWNlKGZ1bmN0aW9uIChsYXN0LCBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiBsYXN0ICsgX3RoaXMyLl9zdGF0c1tjdXJyZW50XTtcbiAgICAgIH0sIDApID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcXVlcnkgc3RhdGlzdGljcyB1cGRhdGVzIGluIGEgZGljdGlvbmFyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHN5c3RlbSBkYXRhYmFzZSBnZXQgdXBkYXRlZCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gSWYgdGhlIHN5c3RlbSBkYXRhYmFzZSBnZXQgdXBkYXRlZCBvciBub3QuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb250YWluc1N5c3RlbVVwZGF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNTeXN0ZW1VcGRhdGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N5c3RlbVVwZGF0ZXMgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIE51bWJlciBvZiBzeXN0ZW0gdXBkYXRlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3lzdGVtVXBkYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeXN0ZW1VcGRhdGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N5c3RlbVVwZGF0ZXM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBRdWVyeVN0YXRpc3RpY3M7XG59KCk7XG4vKipcbiAqIENsYXNzIGZvciBDeXBoZXIgbm90aWZpY2F0aW9uc1xuICogQGFjY2VzcyBwdWJsaWNcbiAqL1xuXG5cbnZhciBOb3RpZmljYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgTm90aWZpY2F0aW9uIGluc3RhbmNlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gbm90aWZpY2F0aW9uIC0gT2JqZWN0IHdpdGggbm90aWZpY2F0aW9uIGRhdGFcbiAgICovXG4gIGZ1bmN0aW9uIE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIE5vdGlmaWNhdGlvbik7XG4gICAgdGhpcy5jb2RlID0gbm90aWZpY2F0aW9uLmNvZGU7XG4gICAgdGhpcy50aXRsZSA9IG5vdGlmaWNhdGlvbi50aXRsZTtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gbm90aWZpY2F0aW9uLmRlc2NyaXB0aW9uO1xuICAgIHRoaXMuc2V2ZXJpdHkgPSBub3RpZmljYXRpb24uc2V2ZXJpdHk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IE5vdGlmaWNhdGlvbi5fY29uc3RydWN0UG9zaXRpb24obm90aWZpY2F0aW9uLnBvc2l0aW9uKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoTm90aWZpY2F0aW9uLCBudWxsLCBbe1xuICAgIGtleTogXCJfY29uc3RydWN0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnN0cnVjdFBvc2l0aW9uKHBvcykge1xuICAgICAgaWYgKCFwb3MpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXQ6IGludFZhbHVlKHBvcy5vZmZzZXQpLFxuICAgICAgICBsaW5lOiBpbnRWYWx1ZShwb3MubGluZSksXG4gICAgICAgIGNvbHVtbjogaW50VmFsdWUocG9zLmNvbHVtbilcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOb3RpZmljYXRpb247XG59KCk7XG4vKipcbiAqIENsYXNzIGZvciBleHBvc2luZyBzZXJ2ZXIgaW5mbyBmcm9tIGEgcmVzdWx0LlxuICogQGFjY2VzcyBwdWJsaWNcbiAqL1xuXG5cbnZhciBTZXJ2ZXJJbmZvID1cbi8qKlxuICogQ3JlYXRlIGEgU2VydmVySW5mbyBpbnN0YW5jZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gc2VydmVyTWV0YSAtIE9iamVjdCB3aXRoIHNlcnZlck1ldGEgZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IHByb3RvY29sVmVyc2lvbiAtIEJvbHQgcHJvdG9jb2wgdmVyc2lvblxuICovXG5mdW5jdGlvbiBTZXJ2ZXJJbmZvKHNlcnZlck1ldGEsIHByb3RvY29sVmVyc2lvbikge1xuICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFNlcnZlckluZm8pO1xuXG4gIGlmIChzZXJ2ZXJNZXRhKSB7XG4gICAgdGhpcy5hZGRyZXNzID0gc2VydmVyTWV0YS5hZGRyZXNzO1xuICAgIHRoaXMudmVyc2lvbiA9IHNlcnZlck1ldGEudmVyc2lvbjtcbiAgfVxuXG4gIHRoaXMucHJvdG9jb2xWZXJzaW9uID0gcHJvdG9jb2xWZXJzaW9uO1xufTtcblxuZnVuY3Rpb24gaW50VmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuICgwLCBfaW50ZWdlci5pc0ludCkodmFsdWUpID8gdmFsdWUudG9JbnQoKSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiB2YWx1ZU9yRGVmYXVsdChrZXksIHZhbHVlcykge1xuICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuXG4gIGlmIChrZXkgaW4gdmFsdWVzKSB7XG4gICAgdmFyIHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgcmV0dXJuICgwLCBfaW50ZWdlci5pc0ludCkodmFsdWUpID8gdmFsdWUudG9JbnQoKSA6IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIH1cbn1cbi8qKlxuICogVGhlIGNvbnN0YW50cyBmb3IgcXVlcnkgdHlwZXNcbiAqIEB0eXBlIHt7U0NIRU1BX1dSSVRFOiBzdHJpbmcsIFdSSVRFX09OTFk6IHN0cmluZywgUkVBRF9PTkxZOiBzdHJpbmcsIFJFQURfV1JJVEU6IHN0cmluZ319XG4gKi9cblxuXG52YXIgcXVlcnlUeXBlID0ge1xuICBSRUFEX09OTFk6ICdyJyxcbiAgUkVBRF9XUklURTogJ3J3JyxcbiAgV1JJVEVfT05MWTogJ3cnLFxuICBTQ0hFTUFfV1JJVEU6ICdzJ1xufTtcbmV4cG9ydHMucXVlcnlUeXBlID0gcXVlcnlUeXBlO1xudmFyIF9kZWZhdWx0ID0gUmVzdWx0U3VtbWFyeTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcmVzdWx0U3VtbWFyeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVzdWx0LXN1bW1hcnlcIikpO1xuXG52YXIgX2Nvbm5lY3Rpb25Ib2xkZXIgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9jb25uZWN0aW9uLWhvbGRlclwiKTtcblxudmFyIF9zdHJlYW1PYnNlcnZlcnMgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9zdHJlYW0tb2JzZXJ2ZXJzXCIpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBERUZBVUxUX09OX0VSUk9SID0gZnVuY3Rpb24gREVGQVVMVF9PTl9FUlJPUihlcnJvcikge1xuICBjb25zb2xlLmxvZygnVW5jYXVnaHQgZXJyb3Igd2hlbiBwcm9jZXNzaW5nIHJlc3VsdDogJyArIGVycm9yKTtcbn07XG5cbnZhciBERUZBVUxUX09OX0NPTVBMRVRFRCA9IGZ1bmN0aW9uIERFRkFVTFRfT05fQ09NUExFVEVEKHN1bW1hcnkpIHt9O1xuXG52YXIgREVGQVVMVF9NRVRBREFUQV9TVVBQTElFUiA9IGZ1bmN0aW9uIERFRkFVTFRfTUVUQURBVEFfU1VQUExJRVIobWV0YWRhdGEpIHt9O1xuLyoqXG4gKiBBIHN0cmVhbSBvZiB7QGxpbmsgUmVjb3JkfSByZXByZXNlbnRpbmcgdGhlIHJlc3VsdCBvZiBhIHF1ZXJ5LlxuICogQ2FuIGJlIGNvbnN1bWVkIGVhZ2VybHkgYXMge0BsaW5rIFByb21pc2V9IHJlc29sdmVkIHdpdGggYXJyYXkgb2YgcmVjb3JkcyBhbmQge0BsaW5rIFJlc3VsdFN1bW1hcnl9XG4gKiBzdW1tYXJ5LCBvciByZWplY3RlZCB3aXRoIGVycm9yIHRoYXQgY29udGFpbnMge0BsaW5rIHN0cmluZ30gY29kZSBhbmQge0BsaW5rIHN0cmluZ30gbWVzc2FnZS5cbiAqIEFsdGVybmF0aXZlbHkgY2FuIGJlIGNvbnN1bWVkIGxhemlseSB1c2luZyB7QGxpbmsgUmVzdWx0I3N1YnNjcmliZX0gZnVuY3Rpb24uXG4gKiBAYWNjZXNzIHB1YmxpY1xuICovXG5cblxudmFyIFJlc3VsdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBJbmplY3QgdGhlIG9ic2VydmVyIHRvIGJlIHVzZWQuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICogQHBhcmFtIHtQcm9taXNlPFJlc3VsdFN0cmVhbU9ic2VydmVyPn0gc3RyZWFtT2JzZXJ2ZXJQcm9taXNlXG4gICAqIEBwYXJhbSB7bWl4ZWR9IHF1ZXJ5IC0gQ3lwaGVyIHF1ZXJ5IHRvIGV4ZWN1dGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBNYXAgd2l0aCBwYXJhbWV0ZXJzIHRvIHVzZSBpbiBxdWVyeVxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25Ib2xkZXJ9IGNvbm5lY3Rpb25Ib2xkZXIgLSB0byBiZSBub3RpZmllZCB3aGVuIHJlc3VsdCBpcyBlaXRoZXIgZnVsbHkgY29uc3VtZWQgb3IgZXJyb3IgaGFwcGVuZWQuXG4gICAqL1xuICBmdW5jdGlvbiBSZXN1bHQoc3RyZWFtT2JzZXJ2ZXJQcm9taXNlLCBxdWVyeSwgcGFyYW1ldGVycywgY29ubmVjdGlvbkhvbGRlcikge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUmVzdWx0KTtcbiAgICB0aGlzLl9zdGFjayA9IGNhcHR1cmVTdGFja3RyYWNlKCk7XG4gICAgdGhpcy5fc3RyZWFtT2JzZXJ2ZXJQcm9taXNlID0gc3RyZWFtT2JzZXJ2ZXJQcm9taXNlO1xuICAgIHRoaXMuX3AgPSBudWxsO1xuICAgIHRoaXMuX3F1ZXJ5ID0gcXVlcnk7XG4gICAgdGhpcy5fcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG4gICAgdGhpcy5fY29ubmVjdGlvbkhvbGRlciA9IGNvbm5lY3Rpb25Ib2xkZXIgfHwgX2Nvbm5lY3Rpb25Ib2xkZXIuRU1QVFlfQ09OTkVDVElPTl9IT0xERVI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZmllbGQga2V5cy5cbiAgICpcbiAgICogKlNob3VsZCBub3QgYmUgY29tYmluZWQgd2l0aCB7QGxpbmsgUmVzdWx0I3N1YnNjcmliZX0gZnVuY3Rpb24uKlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn0gLSBGaWVsZCBrZXlzLCBpbiB0aGUgb3JkZXIgdGhleSB3aWxsIGFwcGVhciBpbiByZWNvcmRzLlxuICAgfVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUmVzdWx0LCBbe1xuICAgIGtleTogXCJrZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfdGhpcy5fc3RyZWFtT2JzZXJ2ZXJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgcmV0dXJuIG9ic2VydmVyLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBvbktleXM6IGZ1bmN0aW9uIG9uS2V5cyhrZXlzKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGtleXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXN1bHQgc3VtbWFyeS5cbiAgICAgKlxuICAgICAqICpTaG91bGQgbm90IGJlIGNvbWJpbmVkIHdpdGgge0BsaW5rIFJlc3VsdCNzdWJzY3JpYmV9IGZ1bmN0aW9uLipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHRTdW1tYXJ5Pn0gLSBSZXN1bHQgc3VtbWFyeS5cbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3VtbWFyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdW1tYXJ5KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF90aGlzMi5fc3RyZWFtT2JzZXJ2ZXJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICBvLmNhbmNlbCgpO1xuICAgICAgICAgIG8uc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiBvbkNvbXBsZXRlZChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBuZXcgUHJvbWlzZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBuZXcgUHJvbWlzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRPckNyZWF0ZVByb21pc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE9yQ3JlYXRlUHJvbWlzZSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuX3ApIHtcbiAgICAgICAgdGhpcy5fcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkcyA9IFtdO1xuICAgICAgICAgIHZhciBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgIG9uTmV4dDogZnVuY3Rpb24gb25OZXh0KHJlY29yZCkge1xuICAgICAgICAgICAgICByZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gb25Db21wbGV0ZWQoc3VtbWFyeSkge1xuICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICByZWNvcmRzOiByZWNvcmRzLFxuICAgICAgICAgICAgICAgIHN1bW1hcnk6IHN1bW1hcnlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBfdGhpczMuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgYWxsIHJlc3VsdHMgYW5kIGNhbGxzIHRoZSBwYXNzZWQgaW4gZnVuY3Rpb24gd2l0aCB0aGUgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqICpTaG91bGQgbm90IGJlIGNvbWJpbmVkIHdpdGgge0BsaW5rIFJlc3VsdCNzdWJzY3JpYmV9IGZ1bmN0aW9uLipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24ocmVzdWx0OiB7cmVjb3JkczpBcnJheTxSZWNvcmQ+LCBzdW1tYXJ5OiBSZXN1bHRTdW1tYXJ5fSl9IG9uRnVsZmlsbGVkIC0gZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAgICogd2hlbiBmaW5pc2hlZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycm9yOiB7bWVzc2FnZTpzdHJpbmcsIGNvZGU6c3RyaW5nfSl9IG9uUmVqZWN0ZWQgLSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgdXBvbiBlcnJvcnMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRoZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlUHJvbWlzZSgpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYXRjaCBlcnJvcnMgd2hlbiB1c2luZyBwcm9taXNlcy5cbiAgICAgKlxuICAgICAqICpTaG91bGQgbm90IGJlIGNvbWJpbmVkIHdpdGgge0BsaW5rIFJlc3VsdCNzdWJzY3JpYmV9IGZ1bmN0aW9uLipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyb3I6IE5lbzRqRXJyb3IpfSBvblJlamVjdGVkIC0gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHVwb24gZXJyb3JzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlUHJvbWlzZSgpW1wiY2F0Y2hcIl0ob25SZWplY3RlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmVhbSByZWNvcmRzIHRvIG9ic2VydmVyIGFzIHRoZXkgY29tZSBpbiwgdGhpcyBpcyBhIG1vcmUgZWZmaWNpZW50IG1ldGhvZFxuICAgICAqIG9mIGhhbmRsaW5nIHRoZSByZXN1bHRzLCBhbmQgYWxsb3dzIHlvdSB0byBoYW5kbGUgYXJiaXRyYXJpbHkgbGFyZ2UgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciAtIE9ic2VydmVyIG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oa2V5czogc3RyaW5nW10pfSBvYnNlcnZlci5vbktleXMgLSBoYW5kbGUgc3RyZWFtIGhlYWQsIHRoZSBmaWVsZCBrZXlzLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24ocmVjb3JkOiBSZWNvcmQpfSBvYnNlcnZlci5vbk5leHQgLSBoYW5kbGUgcmVjb3Jkcywgb25lIGJ5IG9uZS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN1bW1hcnk6IFJlc3VsdFN1bW1hcnkpfSBvYnNlcnZlci5vbkNvbXBsZXRlZCAtIGhhbmRsZSBzdHJlYW0gdGFpbCwgdGhlIHJlc3VsdCBzdW1tYXJ5LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyb3I6IHttZXNzYWdlOnN0cmluZywgY29kZTpzdHJpbmd9KX0gb2JzZXJ2ZXIub25FcnJvciAtIGhhbmRsZSBlcnJvcnMuXG4gICAgICogQHJldHVyblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3Vic2NyaWJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBvbkNvbXBsZXRlZE9yaWdpbmFsID0gb2JzZXJ2ZXIub25Db21wbGV0ZWQgfHwgREVGQVVMVF9PTl9DT01QTEVURUQ7XG5cbiAgICAgIHZhciBvbkNvbXBsZXRlZFdyYXBwZXIgPSBmdW5jdGlvbiBvbkNvbXBsZXRlZFdyYXBwZXIobWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfdGhpczQuX2Nvbm5lY3Rpb25Ib2xkZXI7XG4gICAgICAgIHZhciBxdWVyeSA9IF90aGlzNC5fcXVlcnk7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0gX3RoaXM0Ll9wYXJhbWV0ZXJzO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlbGVhc2UocHJvdG9jb2xWZXJzaW9uKSB7XG4gICAgICAgICAgLy8gbm90aWZ5IGNvbm5lY3Rpb24gaG9sZGVyIHRoYXQgdGhlIHVzZWQgY29ubmVjdGlvbiBpcyBub3QgbmVlZGVkIGFueSBtb3JlIGJlY2F1c2UgcmVzdWx0IGhhc1xuICAgICAgICAgIC8vIGJlZW4gZnVsbHkgY29uc3VtZWQ7IGNhbGwgdGhlIG9yaWdpbmFsIG9uQ29tcGxldGVkIGNhbGxiYWNrIGFmdGVyIHRoYXRcbiAgICAgICAgICBjb25uZWN0aW9uSG9sZGVyLnJlbGVhc2VDb25uZWN0aW9uKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvbkNvbXBsZXRlZE9yaWdpbmFsLmNhbGwob2JzZXJ2ZXIsIG5ldyBfcmVzdWx0U3VtbWFyeVtcImRlZmF1bHRcIl0ocXVlcnksIHBhcmFtZXRlcnMsIG1ldGFkYXRhLCBwcm90b2NvbFZlcnNpb24pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbm5lY3Rpb25Ib2xkZXIuZ2V0Q29ubmVjdGlvbigpLnRoZW4oIC8vIG9uRnVsZmlsbGVkOlxuICAgICAgICBmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgICAgICAgIHJlbGVhc2UoY29ubmVjdGlvbiA/IGNvbm5lY3Rpb24ucHJvdG9jb2woKS52ZXJzaW9uIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfSwgLy8gb25SZWplY3RlZDpcbiAgICAgICAgZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgb2JzZXJ2ZXIub25Db21wbGV0ZWQgPSBvbkNvbXBsZXRlZFdyYXBwZXI7XG4gICAgICB2YXIgb25FcnJvck9yaWdpbmFsID0gb2JzZXJ2ZXIub25FcnJvciB8fCBERUZBVUxUX09OX0VSUk9SO1xuXG4gICAgICB2YXIgb25FcnJvcldyYXBwZXIgPSBmdW5jdGlvbiBvbkVycm9yV3JhcHBlcihlcnJvcikge1xuICAgICAgICAvLyBub3RpZnkgY29ubmVjdGlvbiBob2xkZXIgdGhhdCB0aGUgdXNlZCBjb25uZWN0aW9uIGlzIG5vdCBuZWVkZWQgYW55IG1vcmUgYmVjYXVzZSBlcnJvciBoYXBwZW5lZFxuICAgICAgICAvLyBhbmQgcmVzdWx0IGNhbid0IGJlZSBjb25zdW1lZCBhbnkgZnVydGhlcjsgY2FsbCB0aGUgb3JpZ2luYWwgb25FcnJvciBjYWxsYmFjayBhZnRlciB0aGF0XG4gICAgICAgIF90aGlzNC5fY29ubmVjdGlvbkhvbGRlci5yZWxlYXNlQ29ubmVjdGlvbigpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlcGxhY2VTdGFja3RyYWNlKGVycm9yLCBfdGhpczQuX3N0YWNrKTtcbiAgICAgICAgICBvbkVycm9yT3JpZ2luYWwuY2FsbChvYnNlcnZlciwgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIG9ic2VydmVyLm9uRXJyb3IgPSBvbkVycm9yV3JhcHBlcjtcblxuICAgICAgdGhpcy5fc3RyZWFtT2JzZXJ2ZXJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduYWxzIHRoZSBzdHJlYW0gb2JzZXJ2ZXIgdGhhdCB0aGUgZnV0dXJlIHJlY29yZHMgc2hvdWxkIGJlIGRpc2NhcmRlZCBvbiB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbmNlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FuY2VsKCkge1xuICAgICAgdGhpcy5fc3RyZWFtT2JzZXJ2ZXJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uY2FuY2VsKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlc3VsdDtcbn0oKTtcblxuZnVuY3Rpb24gY2FwdHVyZVN0YWNrdHJhY2UoKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcignJyk7XG5cbiAgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgcmV0dXJuIGVycm9yLnN0YWNrLnJlcGxhY2UoL15FcnJvcihcXG5cXHIpKi8sICcnKTsgLy8gd2UgZG9uJ3QgbmVlZCB0aGUgJ0Vycm9yXFxuJyBwYXJ0LCBpZiBvbmx5IGl0IGV4aXN0c1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VTdGFja3RyYWNlKGVycm9yLCBuZXdTdGFjaykge1xuICBpZiAobmV3U3RhY2spIHtcbiAgICAvLyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcoKSBjb25jYXRlbmF0ZXMgZXJyb3IubmFtZSBhbmQgZXJyb3IubWVzc2FnZSBuaWNlbHlcbiAgICAvLyB0aGVuIHdlIGFkZCB0aGUgcmVzdCBvZiB0aGUgc3RhY2sgdHJhY2VcbiAgICBlcnJvci5zdGFjayA9IGVycm9yLnRvU3RyaW5nKCkgKyAnXFxuJyArIG5ld1N0YWNrO1xuICB9XG59XG5cbnZhciBfZGVmYXVsdCA9IFJlc3VsdDtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2RyaXZlciA9IHJlcXVpcmUoXCIuL2RyaXZlclwiKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuXG52YXIgX2Nvbm5lY3Rpb25Qcm92aWRlclJvdXRpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL2Nvbm5lY3Rpb24tcHJvdmlkZXItcm91dGluZ1wiKSk7XG5cbnZhciBfbGVhc3RDb25uZWN0ZWRMb2FkQmFsYW5jaW5nU3RyYXRlZ3kgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL2xlYXN0LWNvbm5lY3RlZC1sb2FkLWJhbGFuY2luZy1zdHJhdGVneVwiKSk7XG5cbnZhciBfY29ubmVjdGlvbkVycm9ySGFuZGxlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW50ZXJuYWwvY29ubmVjdGlvbi1lcnJvci1oYW5kbGVyXCIpKTtcblxudmFyIF9jb25maWd1cmVkQ3VzdG9tUmVzb2x2ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL3Jlc29sdmVyL2NvbmZpZ3VyZWQtY3VzdG9tLXJlc29sdmVyXCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBBIGRyaXZlciB0aGF0IHN1cHBvcnRzIHJvdXRpbmcgaW4gYSBjYXVzYWwgY2x1c3Rlci5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBSb3V0aW5nRHJpdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRHJpdmVyKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoUm91dGluZ0RyaXZlciwgX0RyaXZlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSb3V0aW5nRHJpdmVyKTtcblxuICBmdW5jdGlvbiBSb3V0aW5nRHJpdmVyKGFkZHJlc3MsIHJvdXRpbmdDb250ZXh0LCB1c2VyQWdlbnQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgdG9rZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIHZhciBjb25maWcgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUm91dGluZ0RyaXZlcik7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBhZGRyZXNzLCB1c2VyQWdlbnQsIHRva2VuLCB2YWxpZGF0ZUNvbmZpZyhjb25maWcpKTtcbiAgICBfdGhpcy5fcm91dGluZ0NvbnRleHQgPSByb3V0aW5nQ29udGV4dDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFJvdXRpbmdEcml2ZXIsIFt7XG4gICAga2V5OiBcIl9hZnRlckNvbnN0cnVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWZ0ZXJDb25zdHJ1Y3Rpb24oKSB7XG4gICAgICB0aGlzLl9sb2cuaW5mbyhcIlJvdXRpbmcgZHJpdmVyIFwiLmNvbmNhdCh0aGlzLl9pZCwgXCIgY3JlYXRlZCBmb3Igc2VydmVyIGFkZHJlc3MgXCIpLmNvbmNhdCh0aGlzLl9hZGRyZXNzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVDb25uZWN0aW9uUHJvdmlkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUNvbm5lY3Rpb25Qcm92aWRlcihhZGRyZXNzLCB1c2VyQWdlbnQsIGF1dGhUb2tlbikge1xuICAgICAgcmV0dXJuIG5ldyBfY29ubmVjdGlvblByb3ZpZGVyUm91dGluZ1tcImRlZmF1bHRcIl0oe1xuICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgIHJvdXRpbmdDb250ZXh0OiB0aGlzLl9yb3V0aW5nQ29udGV4dCxcbiAgICAgICAgaG9zdE5hbWVSZXNvbHZlcjogY3JlYXRlSG9zdE5hbWVSZXNvbHZlcih0aGlzLl9jb25maWcpLFxuICAgICAgICBjb25maWc6IHRoaXMuX2NvbmZpZyxcbiAgICAgICAgbG9nOiB0aGlzLl9sb2csXG4gICAgICAgIHVzZXJBZ2VudDogdXNlckFnZW50LFxuICAgICAgICBhdXRoVG9rZW46IGF1dGhUb2tlblxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zdXBwb3J0c1JvdXRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N1cHBvcnRzUm91dGluZygpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUm91dGluZ0RyaXZlcjtcbn0oX2RyaXZlci5Ecml2ZXIpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge0NvbmZpZ3VyZWRDdXN0b21SZXNvbHZlcn0gbmV3IGN1c3RvbSByZXNvbHZlciB0aGF0IHdyYXBzIHRoZSBwYXNzZWQtaW4gcmVzb2x2ZXIgZnVuY3Rpb24uXG4gKiAgICAgICAgICAgICAgSWYgcmVzb2x2ZWQgZnVuY3Rpb24gaXMgbm90IHNwZWNpZmllZCwgaXQgZGVmYXVsdHMgdG8gYW4gaWRlbnRpdHkgcmVzb2x2ZXIuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVIb3N0TmFtZVJlc29sdmVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IF9jb25maWd1cmVkQ3VzdG9tUmVzb2x2ZXJbXCJkZWZhdWx0XCJdKGNvbmZpZy5yZXNvbHZlcik7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgZ2l2ZW4gY29uZmlnLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDb25maWcoY29uZmlnKSB7XG4gIHZhciByZXNvbHZlciA9IGNvbmZpZy5yZXNvbHZlcjtcblxuICBpZiAocmVzb2x2ZXIgJiYgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbmZpZ3VyZWQgcmVzb2x2ZXIgc2hvdWxkIGJlIGEgZnVuY3Rpb24uIEdvdDogXCIuY29uY2F0KHJlc29sdmVyKSk7XG4gIH1cblxuICByZXR1cm4gY29uZmlnO1xufVxuXG52YXIgX2RlZmF1bHQgPSBSb3V0aW5nRHJpdmVyO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9yeGpzID0gcmVxdWlyZShcInJ4anNcIik7XG5cbnZhciBfb3BlcmF0b3JzID0gcmVxdWlyZShcInJ4anMvb3BlcmF0b3JzXCIpO1xuXG52YXIgX3Jlc3VsdFJ4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZXN1bHQtcnhcIikpO1xuXG52YXIgX3Nlc3Npb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Nlc3Npb25cIikpO1xuXG52YXIgX3RyYW5zYWN0aW9uUnggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uLXJ4XCIpKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9jb25zdGFudHNcIik7XG5cbnZhciBfdHhDb25maWcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL3R4LWNvbmZpZ1wiKSk7XG5cbnZhciBfcmV0cnlMb2dpY1J4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC9yZXRyeS1sb2dpYy1yeFwiKSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEEgUmVhY3RpdmUgc2Vzc2lvbiwgd2hpY2ggcHJvdmlkZXMgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSBhcyB7QGxpbmsgU2Vzc2lvbn0gYnV0IHRocm91Z2ggYSBSZWFjdGl2ZSBBUEkuXG4gKi9cbnZhciBSeFNlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIHJlYWN0aXZlIHNlc3Npb24gd2l0aCBnaXZlbiBkZWZhdWx0IHNlc3Npb24gaW5zdGFuY2UgYW5kIHByb3ZpZGVkIGRyaXZlciBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSAtIE9iamVjdCBwYXJhbWV0ZXJcbiAgICogQHBhcmFtIHtTZXNzaW9ufSBwYXJhbS5zZXNzaW9uIC0gVGhlIHVuZGVybHlpbmcgc2Vzc2lvbiBpbnN0YW5jZSB0byByZWxheSByZXF1ZXN0c1xuICAgKi9cbiAgZnVuY3Rpb24gUnhTZXNzaW9uKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgc2Vzc2lvbiA9IF9yZWYuc2Vzc2lvbixcbiAgICAgICAgY29uZmlnID0gX3JlZi5jb25maWc7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFJ4U2Vzc2lvbik7XG4gICAgdGhpcy5fc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgdGhpcy5fcmV0cnlMb2dpYyA9IF9jcmVhdGVSZXRyeUxvZ2ljKGNvbmZpZyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZWFjdGl2ZSByZXN1bHQgdGhhdCB3aWxsIGV4ZWN1dGUgdGhlICBxdWVyeSB3aXRoIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXJzIGFuZCB0aGUgcHJvdmlkZWRcbiAgICogdHJhbnNhY3Rpb24gY29uZmlndXJhdGlvbiB0aGF0IGFwcGxpZXMgdG8gdGhlIHVuZGVybHlpbmcgYXV0by1jb21taXQgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gUXVlcnkgdG8gYmUgZXhlY3V0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gUGFyYW1ldGVyIHZhbHVlcyB0byB1c2UgaW4gcXVlcnkgZXhlY3V0aW9uLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlnfSB0cmFuc2FjdGlvbkNvbmZpZyAtIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBuZXcgYXV0by1jb21taXQgdHJhbnNhY3Rpb24uXG4gICAqIEByZXR1cm5zIHtSeFJlc3VsdH0gLSBBIHJlYWN0aXZlIHJlc3VsdFxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUnhTZXNzaW9uLCBbe1xuICAgIGtleTogXCJydW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuKHF1ZXJ5LCBwYXJhbWV0ZXJzLCB0cmFuc2FjdGlvbkNvbmZpZykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBfcmVzdWx0UnhbXCJkZWZhdWx0XCJdKG5ldyBfcnhqcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9ic2VydmVyLm5leHQoX3RoaXMuX3Nlc3Npb24ucnVuKHF1ZXJ5LCBwYXJhbWV0ZXJzLCB0cmFuc2FjdGlvbkNvbmZpZykpO1xuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIG5ldyBleHBsaWNpdCB0cmFuc2FjdGlvbiB3aXRoIHRoZSBwcm92aWRlZCB0cmFuc2FjdGlvbiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maWd9IHRyYW5zYWN0aW9uQ29uZmlnIC0gQ29uZmlndXJhdGlvbiBmb3IgdGhlIG5ldyB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTxSeFRyYW5zYWN0aW9uPn0gLSBBIHJlYWN0aXZlIHN0cmVhbSB0aGF0IHdpbGwgZ2VuZXJhdGUgYXQgbW9zdCAqKm9uZSoqIFJ4VHJhbnNhY3Rpb24gaW5zdGFuY2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJiZWdpblRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZ2luVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25Db25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9iZWdpblRyYW5zYWN0aW9uKHRoaXMuX3Nlc3Npb24uX21vZGUsIHRyYW5zYWN0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIHVuaXQgb2Ygd29yayBpbiBhIHtAbGluayBSRUFEfSByZWFjdGl2ZSB0cmFuc2FjdGlvbiB3aGljaCBpcyBjcmVhdGVkIHdpdGggdGhlIHByb3ZpZGVkXG4gICAgICogdHJhbnNhY3Rpb24gY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih0eGM6IFJ4VHJhbnNhY3Rpb24pOiBPYnNlcnZhYmxlfSB3b3JrIC0gQSB1bml0IG9mIHdvcmsgdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpZ30gdHJhbnNhY3Rpb25Db25maWcgLSBDb25maWd1cmF0aW9uIGZvciB0aGUgZW5jbG9zaW5nIHRyYW5zYWN0aW9uIGNyZWF0ZWQgYnkgdGhlIGRyaXZlci5cbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gLSBBIHJlYWN0aXZlIHN0cmVhbSByZXR1cm5lZCBieSB0aGUgdW5pdCBvZiB3b3JrLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRUcmFuc2FjdGlvbih3b3JrLCB0cmFuc2FjdGlvbkNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRyYW5zYWN0aW9uKF9jb25zdGFudHMuQUNDRVNTX01PREVfUkVBRCwgd29yaywgdHJhbnNhY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgcHJvdmlkZWQgdW5pdCBvZiB3b3JrIGluIGEge0BsaW5rIFdSSVRFfSByZWFjdGl2ZSB0cmFuc2FjdGlvbiB3aGljaCBpcyBjcmVhdGVkIHdpdGggdGhlIHByb3ZpZGVkXG4gICAgICogdHJhbnNhY3Rpb24gY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih0eGM6IFJ4VHJhbnNhY3Rpb24pOiBPYnNlcnZhYmxlfSB3b3JrIC0gQSB1bml0IG9mIHdvcmsgdG8gYmUgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpZ30gdHJhbnNhY3Rpb25Db25maWcgLSBDb25maWd1cmF0aW9uIGZvciB0aGUgZW5jbG9zaW5nIHRyYW5zYWN0aW9uIGNyZWF0ZWQgYnkgdGhlIGRyaXZlci5cbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gLSBBIHJlYWN0aXZlIHN0cmVhbSByZXR1cm5lZCBieSB0aGUgdW5pdCBvZiB3b3JrLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVUcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZVRyYW5zYWN0aW9uKHdvcmssIHRyYW5zYWN0aW9uQ29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVHJhbnNhY3Rpb24oX2NvbnN0YW50cy5BQ0NFU1NfTU9ERV9XUklURSwgd29yaywgdHJhbnNhY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhpcyByZWFjdGl2ZSBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSAtIEFuIGVtcHR5IHJlYWN0aXZlIHN0cmVhbVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBfcnhqcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBfdGhpczIuX3Nlc3Npb24uY2xvc2UoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYm9va21hcmsgcmVjZWl2ZWQgZm9sbG93aW5nIHRoZSBsYXN0IHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgcXVlcnksIHdoaWNoIGlzIGV4ZWN1dGVkXG4gICAgICogZWl0aGVyIGluIGFuIHtAbGluayBSeFRyYW5zYWN0aW9ufSBvYnRhaW5lZCBmcm9tIHRoaXMgc2Vzc2lvbiBpbnN0YW5jZSBvciBkaXJlY3RseSB0aHJvdWdoIG9uZSBvZlxuICAgICAqIHRoZSB7QGxpbmsgUnhTZXNzaW9uI3J1bn0gbWV0aG9kIG9mIHRoaXMgc2Vzc2lvbiBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIElmIG5vIGJvb2ttYXJrIHdhcyByZWNlaXZlZCBvciBpZiB0aGlzIHRyYW5zYWN0aW9uIHdhcyByb2xsZWQgYmFjaywgdGhlIGJvb2ttYXJrIHZhbHVlIHdpbGwgbm90IGJlXG4gICAgICogY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGFzdEJvb2ttYXJrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxhc3RCb29rbWFyaygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXNzaW9uLmxhc3RCb29rbWFyaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2JlZ2luVHJhbnNhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JlZ2luVHJhbnNhY3Rpb24oYWNjZXNzTW9kZSwgdHJhbnNhY3Rpb25Db25maWcpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgdHhDb25maWcgPSBfdHhDb25maWdbXCJkZWZhdWx0XCJdLmVtcHR5KCk7XG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbkNvbmZpZykge1xuICAgICAgICB0eENvbmZpZyA9IG5ldyBfdHhDb25maWdbXCJkZWZhdWx0XCJdKHRyYW5zYWN0aW9uQ29uZmlnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBfcnhqcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9ic2VydmVyLm5leHQobmV3IF90cmFuc2FjdGlvblJ4W1wiZGVmYXVsdFwiXShfdGhpczMuX3Nlc3Npb24uX2JlZ2luVHJhbnNhY3Rpb24oYWNjZXNzTW9kZSwgdHhDb25maWcpKSk7XG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3J1blRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ydW5UcmFuc2FjdGlvbihhY2Nlc3NNb2RlLCB3b3JrLCB0cmFuc2FjdGlvbkNvbmZpZykge1xuICAgICAgdmFyIHR4Q29uZmlnID0gX3R4Q29uZmlnW1wiZGVmYXVsdFwiXS5lbXB0eSgpO1xuXG4gICAgICBpZiAodHJhbnNhY3Rpb25Db25maWcpIHtcbiAgICAgICAgdHhDb25maWcgPSBuZXcgX3R4Q29uZmlnW1wiZGVmYXVsdFwiXSh0cmFuc2FjdGlvbkNvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXRyeUxvZ2ljLnJldHJ5KHRoaXMuX2JlZ2luVHJhbnNhY3Rpb24oYWNjZXNzTW9kZSwgdHJhbnNhY3Rpb25Db25maWcpLnBpcGUoKDAsIF9vcGVyYXRvcnMuZmxhdE1hcCkoZnVuY3Rpb24gKHR4Yykge1xuICAgICAgICByZXR1cm4gKDAsIF9yeGpzLmRlZmVyKShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB3b3JrKHR4Yyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9yeGpzLnRocm93RXJyb3IpKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5waXBlKCgwLCBfb3BlcmF0b3JzLmNhdGNoRXJyb3IpKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gdHhjLnJvbGxiYWNrKCkucGlwZSgoMCwgX29wZXJhdG9ycy5jb25jYXQpKCgwLCBfcnhqcy50aHJvd0Vycm9yKShlcnIpKSk7XG4gICAgICAgIH0pLCAoMCwgX29wZXJhdG9ycy5jb25jYXQpKHR4Yy5jb21taXQoKSkpO1xuICAgICAgfSkpKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJ4U2Vzc2lvbjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSeFNlc3Npb247XG5cbmZ1bmN0aW9uIF9jcmVhdGVSZXRyeUxvZ2ljKGNvbmZpZykge1xuICB2YXIgbWF4UmV0cnlUaW1lb3V0ID0gY29uZmlnICYmIGNvbmZpZy5tYXhUcmFuc2FjdGlvblJldHJ5VGltZSA/IGNvbmZpZy5tYXhUcmFuc2FjdGlvblJldHJ5VGltZSA6IG51bGw7XG4gIHJldHVybiBuZXcgX3JldHJ5TG9naWNSeFtcImRlZmF1bHRcIl0oe1xuICAgIG1heFJldHJ5VGltZW91dDogbWF4UmV0cnlUaW1lb3V0XG4gIH0pO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9zdHJlYW1PYnNlcnZlcnMgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9zdHJlYW0tb2JzZXJ2ZXJzXCIpO1xuXG52YXIgX3Jlc3VsdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVzdWx0XCIpKTtcblxudmFyIF90cmFuc2FjdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIikpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL2ludGVybmFsL3V0aWxcIik7XG5cbnZhciBfY29ubmVjdGlvbkhvbGRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW50ZXJuYWwvY29ubmVjdGlvbi1ob2xkZXJcIikpO1xuXG52YXIgX2RyaXZlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZHJpdmVyXCIpKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9jb25zdGFudHNcIik7XG5cbnZhciBfdHJhbnNhY3Rpb25FeGVjdXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW50ZXJuYWwvdHJhbnNhY3Rpb24tZXhlY3V0b3JcIikpO1xuXG52YXIgX2Jvb2ttYXJrID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC9ib29rbWFya1wiKSk7XG5cbnZhciBfdHhDb25maWcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL3R4LWNvbmZpZ1wiKSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEEgU2Vzc2lvbiBpbnN0YW5jZSBpcyB1c2VkIGZvciBoYW5kbGluZyB0aGUgY29ubmVjdGlvbiBhbmRcbiAqIHNlbmRpbmcgcXVlcmllcyB0aHJvdWdoIHRoZSBjb25uZWN0aW9uLlxuICogSW4gYSBzaW5nbGUgc2Vzc2lvbiwgbXVsdGlwbGUgcXVlcmllcyB3aWxsIGJlIGV4ZWN1dGVkIHNlcmlhbGx5LlxuICogSW4gb3JkZXIgdG8gZXhlY3V0ZSBwYXJhbGxlbCBxdWVyaWVzLCBtdWx0aXBsZSBzZXNzaW9ucyBhcmUgcmVxdWlyZWQuXG4gKiBAYWNjZXNzIHB1YmxpY1xuICovXG52YXIgU2Vzc2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gYXJncy5tb2RlIHRoZSBkZWZhdWx0IGFjY2VzcyBtb2RlIGZvciB0aGlzIHNlc3Npb24uXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvblByb3ZpZGVyfSBhcmdzLmNvbm5lY3Rpb25Qcm92aWRlciAtIFRoZSBjb25uZWN0aW9uIHByb3ZpZGVyIHRvIGFjcXVpcmUgY29ubmVjdGlvbnMgZnJvbS5cbiAgICogQHBhcmFtIHtCb29rbWFya30gYXJncy5ib29rbWFyayAtIFRoZSBpbml0aWFsIGJvb2ttYXJrIGZvciB0aGlzIHNlc3Npb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmRhdGFiYXNlIHRoZSBkYXRhYmFzZSBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzLmNvbmZpZz17fSAtIFRoaXMgZHJpdmVyIGNvbmZpZ3VyYXRpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJncy5yZWFjdGl2ZSAtIFdoZXRoZXIgdGhpcyBzZXNzaW9uIHNob3VsZCBjcmVhdGUgcmVhY3RpdmUgc3RyZWFtc1xuICAgKiBAcGFyYW0ge251bWJlcn0gYXJncy5mZXRjaFNpemUgLSBEZWZpbmVzIGhvdyBtYW55IHJlY29yZHMgaXMgcHVsbGVkIGluIGVhY2ggcHVsbGluZyBiYXRjaFxuICAgKi9cbiAgZnVuY3Rpb24gU2Vzc2lvbihfcmVmKSB7XG4gICAgdmFyIG1vZGUgPSBfcmVmLm1vZGUsXG4gICAgICAgIGNvbm5lY3Rpb25Qcm92aWRlciA9IF9yZWYuY29ubmVjdGlvblByb3ZpZGVyLFxuICAgICAgICBib29rbWFyayA9IF9yZWYuYm9va21hcmssXG4gICAgICAgIGRhdGFiYXNlID0gX3JlZi5kYXRhYmFzZSxcbiAgICAgICAgY29uZmlnID0gX3JlZi5jb25maWcsXG4gICAgICAgIHJlYWN0aXZlID0gX3JlZi5yZWFjdGl2ZSxcbiAgICAgICAgZmV0Y2hTaXplID0gX3JlZi5mZXRjaFNpemU7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBTZXNzaW9uKTtcbiAgICB0aGlzLl9tb2RlID0gbW9kZTtcbiAgICB0aGlzLl9kYXRhYmFzZSA9IGRhdGFiYXNlO1xuICAgIHRoaXMuX3JlYWN0aXZlID0gcmVhY3RpdmU7XG4gICAgdGhpcy5fZmV0Y2hTaXplID0gZmV0Y2hTaXplO1xuICAgIHRoaXMuX3JlYWRDb25uZWN0aW9uSG9sZGVyID0gbmV3IF9jb25uZWN0aW9uSG9sZGVyW1wiZGVmYXVsdFwiXSh7XG4gICAgICBtb2RlOiBfY29uc3RhbnRzLkFDQ0VTU19NT0RFX1JFQUQsXG4gICAgICBkYXRhYmFzZTogZGF0YWJhc2UsXG4gICAgICBib29rbWFyazogYm9va21hcmssXG4gICAgICBjb25uZWN0aW9uUHJvdmlkZXI6IGNvbm5lY3Rpb25Qcm92aWRlclxuICAgIH0pO1xuICAgIHRoaXMuX3dyaXRlQ29ubmVjdGlvbkhvbGRlciA9IG5ldyBfY29ubmVjdGlvbkhvbGRlcltcImRlZmF1bHRcIl0oe1xuICAgICAgbW9kZTogX2NvbnN0YW50cy5BQ0NFU1NfTU9ERV9XUklURSxcbiAgICAgIGRhdGFiYXNlOiBkYXRhYmFzZSxcbiAgICAgIGJvb2ttYXJrOiBib29rbWFyayxcbiAgICAgIGNvbm5lY3Rpb25Qcm92aWRlcjogY29ubmVjdGlvblByb3ZpZGVyXG4gICAgfSk7XG4gICAgdGhpcy5fb3BlbiA9IHRydWU7XG4gICAgdGhpcy5faGFzVHggPSBmYWxzZTtcbiAgICB0aGlzLl9sYXN0Qm9va21hcmsgPSBib29rbWFyaztcbiAgICB0aGlzLl90cmFuc2FjdGlvbkV4ZWN1dG9yID0gX2NyZWF0ZVRyYW5zYWN0aW9uRXhlY3V0b3IoY29uZmlnKTtcbiAgICB0aGlzLl9vbkNvbXBsZXRlID0gdGhpcy5fb25Db21wbGV0ZUNhbGxiYWNrLmJpbmQodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJ1biBDeXBoZXIgcXVlcnlcbiAgICogQ291bGQgYmUgY2FsbGVkIHdpdGggYSBxdWVyeSBvYmplY3QgaS5lLjogYHt0ZXh0OiBcIk1BVENIIC4uLlwiLCBwcmFtZXRlcnM6IHtwYXJhbTogMX19YFxuICAgKiBvciB3aXRoIHRoZSBxdWVyeSBhbmQgcGFyYW1ldGVycyBhcyBzZXBhcmF0ZSBhcmd1bWVudHMuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHttaXhlZH0gcXVlcnkgLSBDeXBoZXIgcXVlcnkgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyAtIE1hcCB3aXRoIHBhcmFtZXRlcnMgdG8gdXNlIGluIHF1ZXJ5XG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maWd9IFt0cmFuc2FjdGlvbkNvbmZpZ10gLSBDb25maWd1cmF0aW9uIGZvciB0aGUgbmV3IGF1dG8tY29tbWl0IHRyYW5zYWN0aW9uLlxuICAgKiBAcmV0dXJuIHtSZXN1bHR9IE5ldyBSZXN1bHQuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShTZXNzaW9uLCBbe1xuICAgIGtleTogXCJydW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuKHF1ZXJ5LCBwYXJhbWV0ZXJzLCB0cmFuc2FjdGlvbkNvbmZpZykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIF92YWxpZGF0ZVF1ZXJ5QW5kUGFyYSA9ICgwLCBfdXRpbC52YWxpZGF0ZVF1ZXJ5QW5kUGFyYW1ldGVycykocXVlcnksIHBhcmFtZXRlcnMpLFxuICAgICAgICAgIHZhbGlkYXRlZFF1ZXJ5ID0gX3ZhbGlkYXRlUXVlcnlBbmRQYXJhLnZhbGlkYXRlZFF1ZXJ5LFxuICAgICAgICAgIHBhcmFtcyA9IF92YWxpZGF0ZVF1ZXJ5QW5kUGFyYS5wYXJhbXM7XG5cbiAgICAgIHZhciBhdXRvQ29tbWl0VHhDb25maWcgPSB0cmFuc2FjdGlvbkNvbmZpZyA/IG5ldyBfdHhDb25maWdbXCJkZWZhdWx0XCJdKHRyYW5zYWN0aW9uQ29uZmlnKSA6IF90eENvbmZpZ1tcImRlZmF1bHRcIl0uZW1wdHkoKTtcbiAgICAgIHJldHVybiB0aGlzLl9ydW4odmFsaWRhdGVkUXVlcnksIHBhcmFtcywgZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgX3RoaXMuX2Fzc2VydFNlc3Npb25Jc09wZW4oKTtcblxuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5wcm90b2NvbCgpLnJ1bih2YWxpZGF0ZWRRdWVyeSwgcGFyYW1zLCB7XG4gICAgICAgICAgYm9va21hcms6IF90aGlzLl9sYXN0Qm9va21hcmssXG4gICAgICAgICAgdHhDb25maWc6IGF1dG9Db21taXRUeENvbmZpZyxcbiAgICAgICAgICBtb2RlOiBfdGhpcy5fbW9kZSxcbiAgICAgICAgICBkYXRhYmFzZTogX3RoaXMuX2RhdGFiYXNlLFxuICAgICAgICAgIGFmdGVyQ29tcGxldGU6IF90aGlzLl9vbkNvbXBsZXRlLFxuICAgICAgICAgIHJlYWN0aXZlOiBfdGhpcy5fcmVhY3RpdmUsXG4gICAgICAgICAgZmV0Y2hTaXplOiBfdGhpcy5fZmV0Y2hTaXplXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9ydW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3J1bihxdWVyeSwgcGFyYW1ldGVycywgY3VzdG9tUnVubmVyKSB7XG4gICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IHRoaXMuX2Nvbm5lY3Rpb25Ib2xkZXJXaXRoTW9kZSh0aGlzLl9tb2RlKTtcblxuICAgICAgdmFyIG9ic2VydmVyUHJvbWlzZTtcblxuICAgICAgaWYgKCF0aGlzLl9vcGVuKSB7XG4gICAgICAgIG9ic2VydmVyUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShuZXcgX3N0cmVhbU9ic2VydmVycy5GYWlsZWRPYnNlcnZlcih7XG4gICAgICAgICAgZXJyb3I6ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdDYW5ub3QgcnVuIHF1ZXJ5IGluIGEgY2xvc2VkIHNlc3Npb24uJylcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5faGFzVHggJiYgY29ubmVjdGlvbkhvbGRlci5pbml0aWFsaXplQ29ubmVjdGlvbigpKSB7XG4gICAgICAgIG9ic2VydmVyUHJvbWlzZSA9IGNvbm5lY3Rpb25Ib2xkZXIuZ2V0Q29ubmVjdGlvbigpLnRoZW4oZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gY3VzdG9tUnVubmVyKGNvbm5lY3Rpb24pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IF9zdHJlYW1PYnNlcnZlcnMuRmFpbGVkT2JzZXJ2ZXIoe1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ic2VydmVyUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShuZXcgX3N0cmVhbU9ic2VydmVycy5GYWlsZWRPYnNlcnZlcih7XG4gICAgICAgICAgZXJyb3I6ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdRdWVyaWVzIGNhbm5vdCBiZSBydW4gZGlyZWN0bHkgb24gYSAnICsgJ3Nlc3Npb24gd2l0aCBhbiBvcGVuIHRyYW5zYWN0aW9uOyBlaXRoZXIgcnVuIGZyb20gd2l0aGluIHRoZSAnICsgJ3RyYW5zYWN0aW9uIG9yIHVzZSBhIGRpZmZlcmVudCBzZXNzaW9uLicpXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBfcmVzdWx0W1wiZGVmYXVsdFwiXShvYnNlcnZlclByb21pc2UsIHF1ZXJ5LCBwYXJhbWV0ZXJzLCBjb25uZWN0aW9uSG9sZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmVnaW4gYSBuZXcgdHJhbnNhY3Rpb24gaW4gdGhpcyBzZXNzaW9uLiBBIHNlc3Npb24gY2FuIGhhdmUgYXQgbW9zdCBvbmUgdHJhbnNhY3Rpb24gcnVubmluZyBhdCBhIHRpbWUsIGlmIHlvdVxuICAgICAqIHdhbnQgdG8gcnVuIG11bHRpcGxlIGNvbmN1cnJlbnQgdHJhbnNhY3Rpb25zLCB5b3Ugc2hvdWxkIHVzZSBtdWx0aXBsZSBjb25jdXJyZW50IHNlc3Npb25zLlxuICAgICAqXG4gICAgICogV2hpbGUgYSB0cmFuc2FjdGlvbiBpcyBvcGVuIHRoZSBzZXNzaW9uIGNhbm5vdCBiZSB1c2VkIHRvIHJ1biBxdWVyaWVzIG91dHNpZGUgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpZ30gW3RyYW5zYWN0aW9uQ29uZmlnXSAtIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBuZXcgYXV0by1jb21taXQgdHJhbnNhY3Rpb24uXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSBOZXcgVHJhbnNhY3Rpb24uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJiZWdpblRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZ2luVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25Db25maWcpIHtcbiAgICAgIC8vIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gc3VwcG9ydCBib29rbWFya3MgcGFyYW1ldGVyIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgLy8gcGFyYW1ldGVyIHdhcyBvZiB0eXBlIHtzdHJpbmd8c3RyaW5nW119IGFuZCByZXByZXNlbnRlZCBlaXRoZXIgYSBzaW5nbGUgb3IgbXVsdGlwbGUgYm9va21hcmtzXG4gICAgICAvLyB0aGF0J3Mgd2h5IHdlIG5lZWQgdG8gY2hlY2sgcGFyYW1ldGVyIHR5cGUgYW5kIGRlY2lkZSBob3cgdG8gaW50ZXJwcmV0IHRoZSB2YWx1ZVxuICAgICAgdmFyIGFyZyA9IHRyYW5zYWN0aW9uQ29uZmlnO1xuXG4gICAgICB2YXIgdHhDb25maWcgPSBfdHhDb25maWdbXCJkZWZhdWx0XCJdLmVtcHR5KCk7XG5cbiAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgdHhDb25maWcgPSBuZXcgX3R4Q29uZmlnW1wiZGVmYXVsdFwiXShhcmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fYmVnaW5UcmFuc2FjdGlvbih0aGlzLl9tb2RlLCB0eENvbmZpZyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9iZWdpblRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iZWdpblRyYW5zYWN0aW9uKGFjY2Vzc01vZGUsIHR4Q29uZmlnKSB7XG4gICAgICBpZiAoIXRoaXMuX29wZW4pIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ0Nhbm5vdCBiZWdpbiBhIHRyYW5zYWN0aW9uIG9uIGEgY2xvc2VkIHNlc3Npb24uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9oYXNUeCkge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnWW91IGNhbm5vdCBiZWdpbiBhIHRyYW5zYWN0aW9uIG9uIGEgc2Vzc2lvbiB3aXRoIGFuIG9wZW4gdHJhbnNhY3Rpb247ICcgKyAnZWl0aGVyIHJ1biBmcm9tIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gb3IgdXNlIGEgZGlmZmVyZW50IHNlc3Npb24uJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtb2RlID0gX2RyaXZlcltcImRlZmF1bHRcIl0uX3ZhbGlkYXRlU2Vzc2lvbk1vZGUoYWNjZXNzTW9kZSk7XG5cbiAgICAgIHZhciBjb25uZWN0aW9uSG9sZGVyID0gdGhpcy5fY29ubmVjdGlvbkhvbGRlcldpdGhNb2RlKG1vZGUpO1xuXG4gICAgICBjb25uZWN0aW9uSG9sZGVyLmluaXRpYWxpemVDb25uZWN0aW9uKCk7XG4gICAgICB0aGlzLl9oYXNUeCA9IHRydWU7XG4gICAgICB2YXIgdHggPSBuZXcgX3RyYW5zYWN0aW9uW1wiZGVmYXVsdFwiXSh7XG4gICAgICAgIGNvbm5lY3Rpb25Ib2xkZXI6IGNvbm5lY3Rpb25Ib2xkZXIsXG4gICAgICAgIG9uQ2xvc2U6IHRoaXMuX3RyYW5zYWN0aW9uQ2xvc2VkLmJpbmQodGhpcyksXG4gICAgICAgIG9uQm9va21hcms6IHRoaXMuX3VwZGF0ZUJvb2ttYXJrLmJpbmQodGhpcyksXG4gICAgICAgIG9uQ29ubmVjdGlvbjogdGhpcy5fYXNzZXJ0U2Vzc2lvbklzT3Blbi5iaW5kKHRoaXMpLFxuICAgICAgICByZWFjdGl2ZTogdGhpcy5fcmVhY3RpdmUsXG4gICAgICAgIGZldGNoU2l6ZTogdGhpcy5fZmV0Y2hTaXplXG4gICAgICB9KTtcblxuICAgICAgdHguX2JlZ2luKHRoaXMuX2xhc3RCb29rbWFyaywgdHhDb25maWcpO1xuXG4gICAgICByZXR1cm4gdHg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hc3NlcnRTZXNzaW9uSXNPcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hc3NlcnRTZXNzaW9uSXNPcGVuKCkge1xuICAgICAgaWYgKCF0aGlzLl9vcGVuKSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdZb3UgY2Fubm90IHJ1biBtb3JlIHRyYW5zYWN0aW9ucyBvbiBhIGNsb3NlZCBzZXNzaW9uLicpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdHJhbnNhY3Rpb25DbG9zZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zYWN0aW9uQ2xvc2VkKCkge1xuICAgICAgdGhpcy5faGFzVHggPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBib29rbWFyayByZWNlaXZlZCBmb2xsb3dpbmcgdGhlIGxhc3QgY29tcGxldGVkIHtAbGluayBUcmFuc2FjdGlvbn0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gQSByZWZlcmVuY2UgdG8gYSBwcmV2aW91cyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxhc3RCb29rbWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0Qm9va21hcmsoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGFzdEJvb2ttYXJrLnZhbHVlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGdpdmVuIHVuaXQgb2Ygd29yayBpbiBhIHtAbGluayBSRUFEfSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIFRyYW5zYWN0aW9uIHdpbGwgYXV0b21hdGljYWxseSBiZSBjb21taXR0ZWQgdW5sZXNzIHRoZSBnaXZlbiBmdW5jdGlvbiB0aHJvd3Mgb3IgcmV0dXJucyBhIHJlamVjdGVkIHByb21pc2UuXG4gICAgICogU29tZSBmYWlsdXJlcyBvZiB0aGUgZ2l2ZW4gZnVuY3Rpb24gb3IgdGhlIGNvbW1pdCBpdHNlbGYgd2lsbCBiZSByZXRyaWVkIHdpdGggZXhwb25lbnRpYWwgYmFja29mZiB3aXRoIGluaXRpYWxcbiAgICAgKiBkZWxheSBvZiAxIHNlY29uZCBhbmQgbWF4aW11bSByZXRyeSB0aW1lIG9mIDMwIHNlY29uZHMuIE1heGltdW0gcmV0cnkgdGltZSBpcyBjb25maWd1cmFibGUgdmlhIGRyaXZlciBjb25maWcnc1xuICAgICAqIGBtYXhUcmFuc2FjdGlvblJldHJ5VGltZWAgcHJvcGVydHkgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih0eDogVHJhbnNhY3Rpb24pOiBQcm9taXNlfSB0cmFuc2FjdGlvbldvcmsgLSBDYWxsYmFjayB0aGF0IGV4ZWN1dGVzIG9wZXJhdGlvbnMgYWdhaW5zdFxuICAgICAqIGEgZ2l2ZW4ge0BsaW5rIFRyYW5zYWN0aW9ufS5cbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlnfSBbdHJhbnNhY3Rpb25Db25maWddIC0gQ29uZmlndXJhdGlvbiBmb3IgYWxsIHRyYW5zYWN0aW9ucyBzdGFydGVkIHRvIGV4ZWN1dGUgdGhlIHVuaXQgb2Ygd29yay5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCBwcm9taXNlIGFzIHJldHVybmVkIGJ5IHRoZSBnaXZlbiBmdW5jdGlvbiBvciByZWplY3RlZCBwcm9taXNlIHdoZW4gZ2l2ZW5cbiAgICAgKiBmdW5jdGlvbiBvciBjb21taXQgZmFpbHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWFkVHJhbnNhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uV29yaywgdHJhbnNhY3Rpb25Db25maWcpIHtcbiAgICAgIHZhciBjb25maWcgPSBuZXcgX3R4Q29uZmlnW1wiZGVmYXVsdFwiXSh0cmFuc2FjdGlvbkNvbmZpZyk7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVHJhbnNhY3Rpb24oX2NvbnN0YW50cy5BQ0NFU1NfTU9ERV9SRUFELCBjb25maWcsIHRyYW5zYWN0aW9uV29yayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgZ2l2ZW4gdW5pdCBvZiB3b3JrIGluIGEge0BsaW5rIFdSSVRFfSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIFRyYW5zYWN0aW9uIHdpbGwgYXV0b21hdGljYWxseSBiZSBjb21taXR0ZWQgdW5sZXNzIHRoZSBnaXZlbiBmdW5jdGlvbiB0aHJvd3Mgb3IgcmV0dXJucyBhIHJlamVjdGVkIHByb21pc2UuXG4gICAgICogU29tZSBmYWlsdXJlcyBvZiB0aGUgZ2l2ZW4gZnVuY3Rpb24gb3IgdGhlIGNvbW1pdCBpdHNlbGYgd2lsbCBiZSByZXRyaWVkIHdpdGggZXhwb25lbnRpYWwgYmFja29mZiB3aXRoIGluaXRpYWxcbiAgICAgKiBkZWxheSBvZiAxIHNlY29uZCBhbmQgbWF4aW11bSByZXRyeSB0aW1lIG9mIDMwIHNlY29uZHMuIE1heGltdW0gcmV0cnkgdGltZSBpcyBjb25maWd1cmFibGUgdmlhIGRyaXZlciBjb25maWcnc1xuICAgICAqIGBtYXhUcmFuc2FjdGlvblJldHJ5VGltZWAgcHJvcGVydHkgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih0eDogVHJhbnNhY3Rpb24pOiBQcm9taXNlfSB0cmFuc2FjdGlvbldvcmsgLSBDYWxsYmFjayB0aGF0IGV4ZWN1dGVzIG9wZXJhdGlvbnMgYWdhaW5zdFxuICAgICAqIGEgZ2l2ZW4ge0BsaW5rIFRyYW5zYWN0aW9ufS5cbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlnfSBbdHJhbnNhY3Rpb25Db25maWddIC0gQ29uZmlndXJhdGlvbiBmb3IgYWxsIHRyYW5zYWN0aW9ucyBzdGFydGVkIHRvIGV4ZWN1dGUgdGhlIHVuaXQgb2Ygd29yay5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCBwcm9taXNlIGFzIHJldHVybmVkIGJ5IHRoZSBnaXZlbiBmdW5jdGlvbiBvciByZWplY3RlZCBwcm9taXNlIHdoZW4gZ2l2ZW5cbiAgICAgKiBmdW5jdGlvbiBvciBjb21taXQgZmFpbHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZVRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25Xb3JrLCB0cmFuc2FjdGlvbkNvbmZpZykge1xuICAgICAgdmFyIGNvbmZpZyA9IG5ldyBfdHhDb25maWdbXCJkZWZhdWx0XCJdKHRyYW5zYWN0aW9uQ29uZmlnKTtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UcmFuc2FjdGlvbihfY29uc3RhbnRzLkFDQ0VTU19NT0RFX1dSSVRFLCBjb25maWcsIHRyYW5zYWN0aW9uV29yayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9ydW5UcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcnVuVHJhbnNhY3Rpb24oYWNjZXNzTW9kZSwgdHJhbnNhY3Rpb25Db25maWcsIHRyYW5zYWN0aW9uV29yaykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbkV4ZWN1dG9yLmV4ZWN1dGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLl9iZWdpblRyYW5zYWN0aW9uKGFjY2Vzc01vZGUsIHRyYW5zYWN0aW9uQ29uZmlnKTtcbiAgICAgIH0sIHRyYW5zYWN0aW9uV29yayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB2YWx1ZSBvZiB0aGUgbGFzdCBib29rbWFyay5cbiAgICAgKiBAcGFyYW0ge0Jvb2ttYXJrfSBuZXdCb29rbWFyayAtIFRoZSBuZXcgYm9va21hcmsuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlQm9va21hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUJvb2ttYXJrKG5ld0Jvb2ttYXJrKSB7XG4gICAgICBpZiAobmV3Qm9va21hcmsgJiYgIW5ld0Jvb2ttYXJrLmlzRW1wdHkoKSkge1xuICAgICAgICB0aGlzLl9sYXN0Qm9va21hcmsgPSBuZXdCb29rbWFyaztcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhpcyBzZXNzaW9uLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2Nsb3NlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vcGVuKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uRXhlY3V0b3IuY2xvc2UoKTtcblxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkQ29ubmVjdGlvbkhvbGRlci5jbG9zZSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVDb25uZWN0aW9uSG9sZGVyLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIF9jbG9zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvc2U7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Nvbm5lY3Rpb25Ib2xkZXJXaXRoTW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29ubmVjdGlvbkhvbGRlcldpdGhNb2RlKG1vZGUpIHtcbiAgICAgIGlmIChtb2RlID09PSBfY29uc3RhbnRzLkFDQ0VTU19NT0RFX1JFQUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRDb25uZWN0aW9uSG9sZGVyO1xuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBfY29uc3RhbnRzLkFDQ0VTU19NT0RFX1dSSVRFKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZUNvbm5lY3Rpb25Ib2xkZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnVW5rbm93biBhY2Nlc3MgbW9kZTogJyArIG1vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25Db21wbGV0ZUNhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkNvbXBsZXRlQ2FsbGJhY2sobWV0YSkge1xuICAgICAgdGhpcy5fdXBkYXRlQm9va21hcmsobmV3IF9ib29rbWFya1tcImRlZmF1bHRcIl0obWV0YS5ib29rbWFyaykpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2Vzc2lvbjtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVRyYW5zYWN0aW9uRXhlY3V0b3IoY29uZmlnKSB7XG4gIHZhciBtYXhSZXRyeVRpbWVNcyA9IGNvbmZpZyAmJiBjb25maWcubWF4VHJhbnNhY3Rpb25SZXRyeVRpbWUgPyBjb25maWcubWF4VHJhbnNhY3Rpb25SZXRyeVRpbWUgOiBudWxsO1xuICByZXR1cm4gbmV3IF90cmFuc2FjdGlvbkV4ZWN1dG9yW1wiZGVmYXVsdFwiXShtYXhSZXRyeVRpbWVNcyk7XG59XG5cbnZhciBfZGVmYXVsdCA9IFNlc3Npb247XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNQb2ludCA9IGlzUG9pbnQ7XG5leHBvcnRzLlBvaW50ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC91dGlsXCIpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBQT0lOVF9JREVOVElGSUVSX1BST1BFUlRZID0gJ19faXNQb2ludF9fJztcbi8qKlxuICogUmVwcmVzZW50cyBhIHNpbmdsZSB0d28gb3IgdGhyZWUtZGltZW5zaW9uYWwgcG9pbnQgaW4gYSBwYXJ0aWN1bGFyIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbS5cbiAqIENyZWF0ZWQgYFBvaW50YCBvYmplY3RzIGFyZSBmcm96ZW4gd2l0aCBgT2JqZWN0LmZyZWV6ZSgpYCBpbiBjb25zdHJ1Y3RvciBhbmQgdGh1cyBpbW11dGFibGUuXG4gKi9cblxudmFyIFBvaW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBzcmlkIC0gVGhlIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbSBpZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt6PXVuZGVmaW5lZF0gLSBUaGUgYHpgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IG9yIGB1bmRlZmluZWRgIGlmIHBvaW50IGhhcyAyIGRpbWVuc2lvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBQb2ludChzcmlkLCB4LCB5LCB6KSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBQb2ludCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtIGlkZW50aWZpZXIuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3JpZCA9ICgwLCBfdXRpbC5hc3NlcnROdW1iZXJPckludGVnZXIpKHNyaWQsICdTUklEJyk7XG4gICAgLyoqXG4gICAgICogVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy54ID0gKDAsIF91dGlsLmFzc2VydE51bWJlcikoeCwgJ1ggY29vcmRpbmF0ZScpO1xuICAgIC8qKlxuICAgICAqIFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMueSA9ICgwLCBfdXRpbC5hc3NlcnROdW1iZXIpKHksICdZIGNvb3JkaW5hdGUnKTtcbiAgICAvKipcbiAgICAgKiBUaGUgYHpgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IG9yIGB1bmRlZmluZWRgIGlmIHBvaW50IGlzIDItZGltZW5zaW9uYWwuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMueiA9IHogPT09IG51bGwgfHwgeiA9PT0gdW5kZWZpbmVkID8geiA6ICgwLCBfdXRpbC5hc3NlcnROdW1iZXIpKHosICdaIGNvb3JkaW5hdGUnKTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShQb2ludCwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy56IHx8IHRoaXMueiA9PT0gMCA/IFwiUG9pbnR7c3JpZD1cIi5jb25jYXQoZm9ybWF0QXNGbG9hdCh0aGlzLnNyaWQpLCBcIiwgeD1cIikuY29uY2F0KGZvcm1hdEFzRmxvYXQodGhpcy54KSwgXCIsIHk9XCIpLmNvbmNhdChmb3JtYXRBc0Zsb2F0KHRoaXMueSksIFwiLCB6PVwiKS5jb25jYXQoZm9ybWF0QXNGbG9hdCh0aGlzLnopLCBcIn1cIikgOiBcIlBvaW50e3NyaWQ9XCIuY29uY2F0KGZvcm1hdEFzRmxvYXQodGhpcy5zcmlkKSwgXCIsIHg9XCIpLmNvbmNhdChmb3JtYXRBc0Zsb2F0KHRoaXMueCksIFwiLCB5PVwiKS5jb25jYXQoZm9ybWF0QXNGbG9hdCh0aGlzLnkpLCBcIn1cIik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQb2ludDtcbn0oKTtcblxuZXhwb3J0cy5Qb2ludCA9IFBvaW50O1xuXG5mdW5jdGlvbiBmb3JtYXRBc0Zsb2F0KG51bWJlcikge1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpID8gbnVtYmVyICsgJy4wJyA6IG51bWJlci50b1N0cmluZygpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUG9pbnQucHJvdG90eXBlLCBQT0lOVF9JREVOVElGSUVSX1BST1BFUlRZLCB7XG4gIHZhbHVlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlXG59KTtcbi8qKlxuICogVGVzdCBpZiBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFBvaW50fSBjbGFzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIG9iamVjdCBpcyBhIHtAbGluayBQb2ludH0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzUG9pbnQob2JqKSB7XG4gIHJldHVybiAob2JqICYmIG9ialtQT0lOVF9JREVOVElGSUVSX1BST1BFUlRZXSkgPT09IHRydWU7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc0R1cmF0aW9uID0gaXNEdXJhdGlvbjtcbmV4cG9ydHMuaXNMb2NhbFRpbWUgPSBpc0xvY2FsVGltZTtcbmV4cG9ydHMuaXNUaW1lID0gaXNUaW1lO1xuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5leHBvcnRzLmlzTG9jYWxEYXRlVGltZSA9IGlzTG9jYWxEYXRlVGltZTtcbmV4cG9ydHMuaXNEYXRlVGltZSA9IGlzRGF0ZVRpbWU7XG5leHBvcnRzLkRhdGVUaW1lID0gZXhwb3J0cy5Mb2NhbERhdGVUaW1lID0gZXhwb3J0cy5EYXRlID0gZXhwb3J0cy5UaW1lID0gZXhwb3J0cy5Mb2NhbFRpbWUgPSBleHBvcnRzLkR1cmF0aW9uID0gdm9pZCAwO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5XCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIHV0aWwgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9pbnRlcm5hbC90ZW1wb3JhbC11dGlsXCIpKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvdXRpbFwiKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMgPSB7XG4gIHZhbHVlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlXG59O1xudmFyIERVUkFUSU9OX0lERU5USUZJRVJfUFJPUEVSVFkgPSAnX19pc0R1cmF0aW9uX18nO1xudmFyIExPQ0FMX1RJTUVfSURFTlRJRklFUl9QUk9QRVJUWSA9ICdfX2lzTG9jYWxUaW1lX18nO1xudmFyIFRJTUVfSURFTlRJRklFUl9QUk9QRVJUWSA9ICdfX2lzVGltZV9fJztcbnZhciBEQVRFX0lERU5USUZJRVJfUFJPUEVSVFkgPSAnX19pc0RhdGVfXyc7XG52YXIgTE9DQUxfREFURV9USU1FX0lERU5USUZJRVJfUFJPUEVSVFkgPSAnX19pc0xvY2FsRGF0ZVRpbWVfXyc7XG52YXIgREFURV9USU1FX0lERU5USUZJRVJfUFJPUEVSVFkgPSAnX19pc0RhdGVUaW1lX18nO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElTTyA4NjAxIGR1cmF0aW9uLiBDb250YWlucyBib3RoIGRhdGUtYmFzZWQgdmFsdWVzICh5ZWFycywgbW9udGhzLCBkYXlzKSBhbmQgdGltZS1iYXNlZCB2YWx1ZXMgKHNlY29uZHMsIG5hbm9zZWNvbmRzKS5cbiAqIENyZWF0ZWQgYER1cmF0aW9uYCBvYmplY3RzIGFyZSBmcm96ZW4gd2l0aCBgT2JqZWN0LmZyZWV6ZSgpYCBpbiBjb25zdHJ1Y3RvciBhbmQgdGh1cyBpbW11dGFibGUuXG4gKi9cblxudmFyIER1cmF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBtb250aHMgLSBUaGUgbnVtYmVyIG9mIG1vbnRocyBmb3IgdGhlIG5ldyBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gZGF5cyAtIFRoZSBudW1iZXIgb2YgZGF5cyBmb3IgdGhlIG5ldyBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gc2Vjb25kcyAtIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBmb3IgdGhlIG5ldyBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gbmFub3NlY29uZHMgLSBUaGUgbnVtYmVyIG9mIG5hbm9zZWNvbmRzIGZvciB0aGUgbmV3IGR1cmF0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gRHVyYXRpb24obW9udGhzLCBkYXlzLCBzZWNvbmRzLCBuYW5vc2Vjb25kcykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgRHVyYXRpb24pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtb250aHMuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubW9udGhzID0gKDAsIF91dGlsLmFzc2VydE51bWJlck9ySW50ZWdlcikobW9udGhzLCAnTW9udGhzJyk7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBkYXlzLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuZGF5cyA9ICgwLCBfdXRpbC5hc3NlcnROdW1iZXJPckludGVnZXIpKGRheXMsICdEYXlzJyk7XG4gICAgKDAsIF91dGlsLmFzc2VydE51bWJlck9ySW50ZWdlcikoc2Vjb25kcywgJ1NlY29uZHMnKTtcbiAgICAoMCwgX3V0aWwuYXNzZXJ0TnVtYmVyT3JJbnRlZ2VyKShuYW5vc2Vjb25kcywgJ05hbm9zZWNvbmRzJyk7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBzZWNvbmRzLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuc2Vjb25kcyA9IHV0aWwubm9ybWFsaXplU2Vjb25kc0ZvckR1cmF0aW9uKHNlY29uZHMsIG5hbm9zZWNvbmRzKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG5hbm9zZWNvbmRzLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMubmFub3NlY29uZHMgPSB1dGlsLm5vcm1hbGl6ZU5hbm9zZWNvbmRzRm9yRHVyYXRpb24obmFub3NlY29uZHMpO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKER1cmF0aW9uLCBbe1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB1dGlsLmR1cmF0aW9uVG9Jc29TdHJpbmcodGhpcy5tb250aHMsIHRoaXMuZGF5cywgdGhpcy5zZWNvbmRzLCB0aGlzLm5hbm9zZWNvbmRzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIER1cmF0aW9uO1xufSgpO1xuXG5leHBvcnRzLkR1cmF0aW9uID0gRHVyYXRpb247XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVyYXRpb24ucHJvdG90eXBlLCBEVVJBVElPTl9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgRHVyYXRpb259IGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgZ2l2ZW4gb2JqZWN0IGlzIGEge0BsaW5rIER1cmF0aW9ufSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNEdXJhdGlvbihvYmopIHtcbiAgcmV0dXJuIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIERVUkFUSU9OX0lERU5USUZJRVJfUFJPUEVSVFkpO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGluc3RhbnQgY2FwdHVyaW5nIHRoZSB0aW1lIG9mIGRheSwgYnV0IG5vdCB0aGUgZGF0ZSwgbm9yIHRoZSB0aW1lem9uZS5cbiAqIENyZWF0ZWQge0BsaW5rIExvY2FsVGltZX0gb2JqZWN0cyBhcmUgZnJvemVuIHdpdGggYE9iamVjdC5mcmVlemUoKWAgaW4gY29uc3RydWN0b3IgYW5kIHRodXMgaW1tdXRhYmxlLlxuICovXG5cblxudmFyIExvY2FsVGltZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gaG91ciAtIFRoZSBob3VyIGZvciB0aGUgbmV3IGxvY2FsIHRpbWUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IG1pbnV0ZSAtIFRoZSBtaW51dGUgZm9yIHRoZSBuZXcgbG9jYWwgdGltZS5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gc2Vjb25kIC0gVGhlIHNlY29uZCBmb3IgdGhlIG5ldyBsb2NhbCB0aW1lLlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBuYW5vc2Vjb25kIC0gVGhlIG5hbm9zZWNvbmQgZm9yIHRoZSBuZXcgbG9jYWwgdGltZS5cbiAgICovXG4gIGZ1bmN0aW9uIExvY2FsVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub3NlY29uZCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgTG9jYWxUaW1lKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBob3VyLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhvdXIgPSB1dGlsLmFzc2VydFZhbGlkSG91cihob3VyKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWludXRlLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMubWludXRlID0gdXRpbC5hc3NlcnRWYWxpZE1pbnV0ZShtaW51dGUpO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZWNvbmQuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5zZWNvbmQgPSB1dGlsLmFzc2VydFZhbGlkU2Vjb25kKHNlY29uZCk7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbm9zZWNvbmQuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5uYW5vc2Vjb25kID0gdXRpbC5hc3NlcnRWYWxpZE5hbm9zZWNvbmQobmFub3NlY29uZCk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEge0BsaW5rIExvY2FsVGltZX0gb2JqZWN0IGZyb20gdGhlIGdpdmVuIHN0YW5kYXJkIEphdmFTY3JpcHQgYERhdGVgIGFuZCBvcHRpb25hbCBuYW5vc2Vjb25kcy5cbiAgICogWWVhciwgbW9udGgsIGRheSBhbmQgdGltZSB6b25lIG9mZnNldCBjb21wb25lbnRzIG9mIHRoZSBnaXZlbiBkYXRlIGFyZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge2dsb2JhbC5EYXRlfSBzdGFuZGFyZERhdGUgLSBUaGUgc3RhbmRhcmQgSmF2YVNjcmlwdCBkYXRlIHRvIGNvbnZlcnQuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8dW5kZWZpbmVkfSBuYW5vc2Vjb25kIC0gVGhlIG9wdGlvbmFsIGFtb3VudCBvZiBuYW5vc2Vjb25kcy5cbiAgICogQHJldHVybiB7TG9jYWxUaW1lfSBOZXcgTG9jYWxUaW1lLlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoTG9jYWxUaW1lLCBbe1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuXG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB1dGlsLnRpbWVUb0lzb1N0cmluZyh0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5uYW5vc2Vjb25kKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tU3RhbmRhcmREYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TdGFuZGFyZERhdGUoc3RhbmRhcmREYXRlLCBuYW5vc2Vjb25kKSB7XG4gICAgICB2ZXJpZnlTdGFuZGFyZERhdGVBbmROYW5vcyhzdGFuZGFyZERhdGUsIG5hbm9zZWNvbmQpO1xuICAgICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUoc3RhbmRhcmREYXRlLmdldEhvdXJzKCksIHN0YW5kYXJkRGF0ZS5nZXRNaW51dGVzKCksIHN0YW5kYXJkRGF0ZS5nZXRTZWNvbmRzKCksIHV0aWwudG90YWxOYW5vc2Vjb25kcyhzdGFuZGFyZERhdGUsIG5hbm9zZWNvbmQpKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExvY2FsVGltZTtcbn0oKTtcblxuZXhwb3J0cy5Mb2NhbFRpbWUgPSBMb2NhbFRpbWU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTG9jYWxUaW1lLnByb3RvdHlwZSwgTE9DQUxfVElNRV9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgTG9jYWxUaW1lfSBjbGFzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIG9iamVjdCBpcyBhIHtAbGluayBMb2NhbFRpbWV9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc0xvY2FsVGltZShvYmopIHtcbiAgcmV0dXJuIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIExPQ0FMX1RJTUVfSURFTlRJRklFUl9QUk9QRVJUWSk7XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gaW5zdGFudCBjYXB0dXJpbmcgdGhlIHRpbWUgb2YgZGF5LCBhbmQgdGhlIHRpbWV6b25lIG9mZnNldCBpbiBzZWNvbmRzLCBidXQgbm90IHRoZSBkYXRlLlxuICogQ3JlYXRlZCB7QGxpbmsgVGltZX0gb2JqZWN0cyBhcmUgZnJvemVuIHdpdGggYE9iamVjdC5mcmVlemUoKWAgaW4gY29uc3RydWN0b3IgYW5kIHRodXMgaW1tdXRhYmxlLlxuICovXG5cblxudmFyIFRpbWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IGhvdXIgLSBUaGUgaG91ciBmb3IgdGhlIG5ldyBsb2NhbCB0aW1lLlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBtaW51dGUgLSBUaGUgbWludXRlIGZvciB0aGUgbmV3IGxvY2FsIHRpbWUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IHNlY29uZCAtIFRoZSBzZWNvbmQgZm9yIHRoZSBuZXcgbG9jYWwgdGltZS5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gbmFub3NlY29uZCAtIFRoZSBuYW5vc2Vjb25kIGZvciB0aGUgbmV3IGxvY2FsIHRpbWUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IHRpbWVab25lT2Zmc2V0U2Vjb25kcyAtIFRoZSB0aW1lIHpvbmUgb2Zmc2V0IGluIHNlY29uZHMuIFZhbHVlIHJlcHJlc2VudHMgdGhlIGRpZmZlcmVuY2UsIGluIHNlY29uZHMsIGZyb20gVVRDIHRvIGxvY2FsIHRpbWUuXG4gICAqIFRoaXMgaXMgZGlmZmVyZW50IGZyb20gc3RhbmRhcmQgSmF2YVNjcmlwdCBgRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpYCB3aGljaCBpcyB0aGUgZGlmZmVyZW5jZSwgaW4gbWludXRlcywgZnJvbSBsb2NhbCB0aW1lIHRvIFVUQy5cbiAgICovXG4gIGZ1bmN0aW9uIFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9zZWNvbmQsIHRpbWVab25lT2Zmc2V0U2Vjb25kcykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgVGltZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaG91ci5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ob3VyID0gdXRpbC5hc3NlcnRWYWxpZEhvdXIoaG91cik7XG4gICAgLyoqXG4gICAgICogVGhlIG1pbnV0ZS5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLm1pbnV0ZSA9IHV0aWwuYXNzZXJ0VmFsaWRNaW51dGUobWludXRlKTtcbiAgICAvKipcbiAgICAgKiBUaGUgc2Vjb25kLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuc2Vjb25kID0gdXRpbC5hc3NlcnRWYWxpZFNlY29uZChzZWNvbmQpO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW5vc2Vjb25kLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMubmFub3NlY29uZCA9IHV0aWwuYXNzZXJ0VmFsaWROYW5vc2Vjb25kKG5hbm9zZWNvbmQpO1xuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lIHpvbmUgb2Zmc2V0IGluIHNlY29uZHMuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy50aW1lWm9uZU9mZnNldFNlY29uZHMgPSAoMCwgX3V0aWwuYXNzZXJ0TnVtYmVyT3JJbnRlZ2VyKSh0aW1lWm9uZU9mZnNldFNlY29uZHMsICdUaW1lIHpvbmUgb2Zmc2V0IGluIHNlY29uZHMnKTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB7QGxpbmsgVGltZX0gb2JqZWN0IGZyb20gdGhlIGdpdmVuIHN0YW5kYXJkIEphdmFTY3JpcHQgYERhdGVgIGFuZCBvcHRpb25hbCBuYW5vc2Vjb25kcy5cbiAgICogWWVhciwgbW9udGggYW5kIGRheSBjb21wb25lbnRzIG9mIHRoZSBnaXZlbiBkYXRlIGFyZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge2dsb2JhbC5EYXRlfSBzdGFuZGFyZERhdGUgLSBUaGUgc3RhbmRhcmQgSmF2YVNjcmlwdCBkYXRlIHRvIGNvbnZlcnQuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8dW5kZWZpbmVkfSBuYW5vc2Vjb25kIC0gVGhlIG9wdGlvbmFsIGFtb3VudCBvZiBuYW5vc2Vjb25kcy5cbiAgICogQHJldHVybiB7VGltZX0gTmV3IFRpbWUuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShUaW1lLCBbe1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuXG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB1dGlsLnRpbWVUb0lzb1N0cmluZyh0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5uYW5vc2Vjb25kKSArIHV0aWwudGltZVpvbmVPZmZzZXRUb0lzb1N0cmluZyh0aGlzLnRpbWVab25lT2Zmc2V0U2Vjb25kcyk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbVN0YW5kYXJkRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU3RhbmRhcmREYXRlKHN0YW5kYXJkRGF0ZSwgbmFub3NlY29uZCkge1xuICAgICAgdmVyaWZ5U3RhbmRhcmREYXRlQW5kTmFub3Moc3RhbmRhcmREYXRlLCBuYW5vc2Vjb25kKTtcbiAgICAgIHJldHVybiBuZXcgVGltZShzdGFuZGFyZERhdGUuZ2V0SG91cnMoKSwgc3RhbmRhcmREYXRlLmdldE1pbnV0ZXMoKSwgc3RhbmRhcmREYXRlLmdldFNlY29uZHMoKSwgdXRpbC50b3RhbE5hbm9zZWNvbmRzKHN0YW5kYXJkRGF0ZSwgbmFub3NlY29uZCksIHV0aWwudGltZVpvbmVPZmZzZXRJblNlY29uZHMoc3RhbmRhcmREYXRlKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUaW1lO1xufSgpO1xuXG5leHBvcnRzLlRpbWUgPSBUaW1lO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWUucHJvdG90eXBlLCBUSU1FX0lERU5USUZJRVJfUFJPUEVSVFksIElERU5USUZJRVJfUFJPUEVSVFlfQVRUUklCVVRFUyk7XG4vKipcbiAqIFRlc3QgaWYgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIHtAbGluayBUaW1lfSBjbGFzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIG9iamVjdCBpcyBhIHtAbGluayBUaW1lfSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNUaW1lKG9iaikge1xuICByZXR1cm4gaGFzSWRlbnRpZmllclByb3BlcnR5KG9iaiwgVElNRV9JREVOVElGSUVSX1BST1BFUlRZKTtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBpbnN0YW50IGNhcHR1cmluZyB0aGUgZGF0ZSwgYnV0IG5vdCB0aGUgdGltZSwgbm9yIHRoZSB0aW1lem9uZS5cbiAqIENyZWF0ZWQge0BsaW5rIERhdGV9IG9iamVjdHMgYXJlIGZyb3plbiB3aXRoIGBPYmplY3QuZnJlZXplKClgIGluIGNvbnN0cnVjdG9yIGFuZCB0aHVzIGltbXV0YWJsZS5cbiAqL1xuXG5cbnZhciBEYXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSB5ZWFyIC0gVGhlIHllYXIgZm9yIHRoZSBuZXcgbG9jYWwgZGF0ZS5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gbW9udGggLSBUaGUgbW9udGggZm9yIHRoZSBuZXcgbG9jYWwgZGF0ZS5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gZGF5IC0gVGhlIGRheSBmb3IgdGhlIG5ldyBsb2NhbCBkYXRlLlxuICAgKi9cbiAgZnVuY3Rpb24gRGF0ZSh5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBEYXRlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB5ZWFyLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnllYXIgPSB1dGlsLmFzc2VydFZhbGlkWWVhcih5ZWFyKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9udGguXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5tb250aCA9IHV0aWwuYXNzZXJ0VmFsaWRNb250aChtb250aCk7XG4gICAgLyoqXG4gICAgICogVGhlIGRheS5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLmRheSA9IHV0aWwuYXNzZXJ0VmFsaWREYXkoZGF5KTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB7QGxpbmsgRGF0ZX0gb2JqZWN0IGZyb20gdGhlIGdpdmVuIHN0YW5kYXJkIEphdmFTY3JpcHQgYERhdGVgLlxuICAgKiBIb3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgYW5kIHRpbWUgem9uZSBvZmZzZXQgY29tcG9uZW50cyBvZiB0aGUgZ2l2ZW4gZGF0ZSBhcmUgaWdub3JlZC5cbiAgICogQHBhcmFtIHtnbG9iYWwuRGF0ZX0gc3RhbmRhcmREYXRlIC0gVGhlIHN0YW5kYXJkIEphdmFTY3JpcHQgZGF0ZSB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJuIHtEYXRlfSBOZXcgRGF0ZS5cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKERhdGUsIFt7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG5cbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHV0aWwuZGF0ZVRvSXNvU3RyaW5nKHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXkpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21TdGFuZGFyZERhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVN0YW5kYXJkRGF0ZShzdGFuZGFyZERhdGUpIHtcbiAgICAgIHZlcmlmeVN0YW5kYXJkRGF0ZUFuZE5hbm9zKHN0YW5kYXJkRGF0ZSwgbnVsbCk7XG4gICAgICByZXR1cm4gbmV3IERhdGUoc3RhbmRhcmREYXRlLmdldEZ1bGxZZWFyKCksIHN0YW5kYXJkRGF0ZS5nZXRNb250aCgpICsgMSwgc3RhbmRhcmREYXRlLmdldERhdGUoKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEYXRlO1xufSgpO1xuXG5leHBvcnRzLkRhdGUgPSBEYXRlO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGUucHJvdG90eXBlLCBEQVRFX0lERU5USUZJRVJfUFJPUEVSVFksIElERU5USUZJRVJfUFJPUEVSVFlfQVRUUklCVVRFUyk7XG4vKipcbiAqIFRlc3QgaWYgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIHtAbGluayBEYXRlfSBjbGFzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgZ2l2ZW4gb2JqZWN0IGlzIGEge0BsaW5rIERhdGV9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc0RhdGUob2JqKSB7XG4gIHJldHVybiBoYXNJZGVudGlmaWVyUHJvcGVydHkob2JqLCBEQVRFX0lERU5USUZJRVJfUFJPUEVSVFkpO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGluc3RhbnQgY2FwdHVyaW5nIHRoZSBkYXRlIGFuZCB0aGUgdGltZSwgYnV0IG5vdCB0aGUgdGltZXpvbmUuXG4gKiBDcmVhdGVkIHtAbGluayBMb2NhbERhdGVUaW1lfSBvYmplY3RzIGFyZSBmcm96ZW4gd2l0aCBgT2JqZWN0LmZyZWV6ZSgpYCBpbiBjb25zdHJ1Y3RvciBhbmQgdGh1cyBpbW11dGFibGUuXG4gKi9cblxuXG52YXIgTG9jYWxEYXRlVGltZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0geWVhciAtIFRoZSB5ZWFyIGZvciB0aGUgbmV3IGxvY2FsIGRhdGUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IG1vbnRoIC0gVGhlIG1vbnRoIGZvciB0aGUgbmV3IGxvY2FsIGRhdGUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IGRheSAtIFRoZSBkYXkgZm9yIHRoZSBuZXcgbG9jYWwgZGF0ZS5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gaG91ciAtIFRoZSBob3VyIGZvciB0aGUgbmV3IGxvY2FsIHRpbWUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IG1pbnV0ZSAtIFRoZSBtaW51dGUgZm9yIHRoZSBuZXcgbG9jYWwgdGltZS5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gc2Vjb25kIC0gVGhlIHNlY29uZCBmb3IgdGhlIG5ldyBsb2NhbCB0aW1lLlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBuYW5vc2Vjb25kIC0gVGhlIG5hbm9zZWNvbmQgZm9yIHRoZSBuZXcgbG9jYWwgdGltZS5cbiAgICovXG4gIGZ1bmN0aW9uIExvY2FsRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9zZWNvbmQpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIExvY2FsRGF0ZVRpbWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHllYXIuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMueWVhciA9IHV0aWwuYXNzZXJ0VmFsaWRZZWFyKHllYXIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb250aC5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLm1vbnRoID0gdXRpbC5hc3NlcnRWYWxpZE1vbnRoKG1vbnRoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGF5LlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuZGF5ID0gdXRpbC5hc3NlcnRWYWxpZERheShkYXkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBob3VyLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuaG91ciA9IHV0aWwuYXNzZXJ0VmFsaWRIb3VyKGhvdXIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtaW51dGUuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5taW51dGUgPSB1dGlsLmFzc2VydFZhbGlkTWludXRlKG1pbnV0ZSk7XG4gICAgLyoqXG4gICAgICogVGhlIHNlY29uZC5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLnNlY29uZCA9IHV0aWwuYXNzZXJ0VmFsaWRTZWNvbmQoc2Vjb25kKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFub3NlY29uZC5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLm5hbm9zZWNvbmQgPSB1dGlsLmFzc2VydFZhbGlkTmFub3NlY29uZChuYW5vc2Vjb25kKTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB7QGxpbmsgTG9jYWxEYXRlVGltZX0gb2JqZWN0IGZyb20gdGhlIGdpdmVuIHN0YW5kYXJkIEphdmFTY3JpcHQgYERhdGVgIGFuZCBvcHRpb25hbCBuYW5vc2Vjb25kcy5cbiAgICogVGltZSB6b25lIG9mZnNldCBjb21wb25lbnQgb2YgdGhlIGdpdmVuIGRhdGUgaXMgaWdub3JlZC5cbiAgICogQHBhcmFtIHtnbG9iYWwuRGF0ZX0gc3RhbmRhcmREYXRlIC0gVGhlIHN0YW5kYXJkIEphdmFTY3JpcHQgZGF0ZSB0byBjb252ZXJ0LlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHVuZGVmaW5lZH0gbmFub3NlY29uZCAtIFRoZSBvcHRpb25hbCBhbW91bnQgb2YgbmFub3NlY29uZHMuXG4gICAqIEByZXR1cm4ge0xvY2FsRGF0ZVRpbWV9IE5ldyBMb2NhbERhdGVUaW1lLlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoTG9jYWxEYXRlVGltZSwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcblxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gbG9jYWxEYXRlVGltZVRvU3RyaW5nKHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXksIHRoaXMuaG91ciwgdGhpcy5taW51dGUsIHRoaXMuc2Vjb25kLCB0aGlzLm5hbm9zZWNvbmQpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21TdGFuZGFyZERhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVN0YW5kYXJkRGF0ZShzdGFuZGFyZERhdGUsIG5hbm9zZWNvbmQpIHtcbiAgICAgIHZlcmlmeVN0YW5kYXJkRGF0ZUFuZE5hbm9zKHN0YW5kYXJkRGF0ZSwgbmFub3NlY29uZCk7XG4gICAgICByZXR1cm4gbmV3IExvY2FsRGF0ZVRpbWUoc3RhbmRhcmREYXRlLmdldEZ1bGxZZWFyKCksIHN0YW5kYXJkRGF0ZS5nZXRNb250aCgpICsgMSwgc3RhbmRhcmREYXRlLmdldERhdGUoKSwgc3RhbmRhcmREYXRlLmdldEhvdXJzKCksIHN0YW5kYXJkRGF0ZS5nZXRNaW51dGVzKCksIHN0YW5kYXJkRGF0ZS5nZXRTZWNvbmRzKCksIHV0aWwudG90YWxOYW5vc2Vjb25kcyhzdGFuZGFyZERhdGUsIG5hbm9zZWNvbmQpKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExvY2FsRGF0ZVRpbWU7XG59KCk7XG5cbmV4cG9ydHMuTG9jYWxEYXRlVGltZSA9IExvY2FsRGF0ZVRpbWU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTG9jYWxEYXRlVGltZS5wcm90b3R5cGUsIExPQ0FMX0RBVEVfVElNRV9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgTG9jYWxEYXRlVGltZX0gY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIG9iamVjdCBpcyBhIHtAbGluayBMb2NhbERhdGVUaW1lfSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNMb2NhbERhdGVUaW1lKG9iaikge1xuICByZXR1cm4gaGFzSWRlbnRpZmllclByb3BlcnR5KG9iaiwgTE9DQUxfREFURV9USU1FX0lERU5USUZJRVJfUFJPUEVSVFkpO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGluc3RhbnQgY2FwdHVyaW5nIHRoZSBkYXRlLCB0aGUgdGltZSBhbmQgdGhlIHRpbWV6b25lIGlkZW50aWZpZXIuXG4gKiBDcmVhdGVkIHtAIERhdGVUaW1lfSBvYmplY3RzIGFyZSBmcm96ZW4gd2l0aCBgT2JqZWN0LmZyZWV6ZSgpYCBpbiBjb25zdHJ1Y3RvciBhbmQgdGh1cyBpbW11dGFibGUuXG4gKi9cblxuXG52YXIgRGF0ZVRpbWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IHllYXIgLSBUaGUgeWVhciBmb3IgdGhlIG5ldyBkYXRlLXRpbWUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IG1vbnRoIC0gVGhlIG1vbnRoIGZvciB0aGUgbmV3IGRhdGUtdGltZS5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gZGF5IC0gVGhlIGRheSBmb3IgdGhlIG5ldyBkYXRlLXRpbWUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IGhvdXIgLSBUaGUgaG91ciBmb3IgdGhlIG5ldyBkYXRlLXRpbWUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IG1pbnV0ZSAtIFRoZSBtaW51dGUgZm9yIHRoZSBuZXcgZGF0ZS10aW1lLlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBzZWNvbmQgLSBUaGUgc2Vjb25kIGZvciB0aGUgbmV3IGRhdGUtdGltZS5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gbmFub3NlY29uZCAtIFRoZSBuYW5vc2Vjb25kIGZvciB0aGUgbmV3IGRhdGUtdGltZS5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gdGltZVpvbmVPZmZzZXRTZWNvbmRzIC0gVGhlIHRpbWUgem9uZSBvZmZzZXQgaW4gc2Vjb25kcy4gRWl0aGVyIHRoaXMgYXJndW1lbnQgb3IgYHRpbWVab25lSWRgIHNob3VsZCBiZSBkZWZpbmVkLlxuICAgKiBWYWx1ZSByZXByZXNlbnRzIHRoZSBkaWZmZXJlbmNlLCBpbiBzZWNvbmRzLCBmcm9tIFVUQyB0byBsb2NhbCB0aW1lLlxuICAgKiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIHN0YW5kYXJkIEphdmFTY3JpcHQgYERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKWAgd2hpY2ggaXMgdGhlIGRpZmZlcmVuY2UsIGluIG1pbnV0ZXMsIGZyb20gbG9jYWwgdGltZSB0byBVVEMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHRpbWVab25lSWQgLSBUaGUgdGltZSB6b25lIGlkIGZvciB0aGUgbmV3IGRhdGUtdGltZS4gRWl0aGVyIHRoaXMgYXJndW1lbnQgb3IgYHRpbWVab25lT2Zmc2V0U2Vjb25kc2Agc2hvdWxkIGJlIGRlZmluZWQuXG4gICAqL1xuICBmdW5jdGlvbiBEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub3NlY29uZCwgdGltZVpvbmVPZmZzZXRTZWNvbmRzLCB0aW1lWm9uZUlkKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBEYXRlVGltZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgeWVhci5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy55ZWFyID0gdXRpbC5hc3NlcnRWYWxpZFllYXIoeWVhcik7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbnRoLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMubW9udGggPSB1dGlsLmFzc2VydFZhbGlkTW9udGgobW9udGgpO1xuICAgIC8qKlxuICAgICAqIFRoZSBkYXkuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5kYXkgPSB1dGlsLmFzc2VydFZhbGlkRGF5KGRheSk7XG4gICAgLyoqXG4gICAgICogVGhlIGhvdXIuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5ob3VyID0gdXRpbC5hc3NlcnRWYWxpZEhvdXIoaG91cik7XG4gICAgLyoqXG4gICAgICogVGhlIG1pbnV0ZS5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLm1pbnV0ZSA9IHV0aWwuYXNzZXJ0VmFsaWRNaW51dGUobWludXRlKTtcbiAgICAvKipcbiAgICAgKiBUaGUgc2Vjb25kLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuc2Vjb25kID0gdXRpbC5hc3NlcnRWYWxpZFNlY29uZChzZWNvbmQpO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW5vc2Vjb25kLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMubmFub3NlY29uZCA9IHV0aWwuYXNzZXJ0VmFsaWROYW5vc2Vjb25kKG5hbm9zZWNvbmQpO1xuXG4gICAgdmFyIF92ZXJpZnlUaW1lWm9uZUFyZ3VtZSA9IHZlcmlmeVRpbWVab25lQXJndW1lbnRzKHRpbWVab25lT2Zmc2V0U2Vjb25kcywgdGltZVpvbmVJZCksXG4gICAgICAgIF92ZXJpZnlUaW1lWm9uZUFyZ3VtZTIgPSAoMCwgX3NsaWNlZFRvQXJyYXkyW1wiZGVmYXVsdFwiXSkoX3ZlcmlmeVRpbWVab25lQXJndW1lLCAyKSxcbiAgICAgICAgb2Zmc2V0ID0gX3ZlcmlmeVRpbWVab25lQXJndW1lMlswXSxcbiAgICAgICAgaWQgPSBfdmVyaWZ5VGltZVpvbmVBcmd1bWUyWzFdO1xuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lIHpvbmUgb2Zmc2V0IGluIHNlY29uZHMuXG4gICAgICpcbiAgICAgKiAqRWl0aGVyIHRoaXMgb3Ige0BsaW5rIHRpbWVab25lSWR9IGlzIGRlZmluZWQuKlxuICAgICAqXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuXG5cbiAgICB0aGlzLnRpbWVab25lT2Zmc2V0U2Vjb25kcyA9IG9mZnNldDtcbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSB6b25lIGlkLlxuICAgICAqXG4gICAgICogKkVpdGhlciB0aGlzIG9yIHtAbGluayB0aW1lWm9uZU9mZnNldFNlY29uZHN9IGlzIGRlZmluZWQuKlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICAgIHRoaXMudGltZVpvbmVJZCA9IGlkO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHtAbGluayBEYXRlVGltZX0gb2JqZWN0IGZyb20gdGhlIGdpdmVuIHN0YW5kYXJkIEphdmFTY3JpcHQgYERhdGVgIGFuZCBvcHRpb25hbCBuYW5vc2Vjb25kcy5cbiAgICogQHBhcmFtIHtnbG9iYWwuRGF0ZX0gc3RhbmRhcmREYXRlIC0gVGhlIHN0YW5kYXJkIEphdmFTY3JpcHQgZGF0ZSB0byBjb252ZXJ0LlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHVuZGVmaW5lZH0gbmFub3NlY29uZCAtIFRoZSBvcHRpb25hbCBhbW91bnQgb2YgbmFub3NlY29uZHMuXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSBOZXcgRGF0ZVRpbWUuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShEYXRlVGltZSwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcblxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgbG9jYWxEYXRlVGltZVN0ciA9IGxvY2FsRGF0ZVRpbWVUb1N0cmluZyh0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF5LCB0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5uYW5vc2Vjb25kKTtcbiAgICAgIHZhciB0aW1lWm9uZVN0ciA9IHRoaXMudGltZVpvbmVJZCA/IFwiW1wiLmNvbmNhdCh0aGlzLnRpbWVab25lSWQsIFwiXVwiKSA6IHV0aWwudGltZVpvbmVPZmZzZXRUb0lzb1N0cmluZyh0aGlzLnRpbWVab25lT2Zmc2V0U2Vjb25kcyk7XG4gICAgICByZXR1cm4gbG9jYWxEYXRlVGltZVN0ciArIHRpbWVab25lU3RyO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21TdGFuZGFyZERhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVN0YW5kYXJkRGF0ZShzdGFuZGFyZERhdGUsIG5hbm9zZWNvbmQpIHtcbiAgICAgIHZlcmlmeVN0YW5kYXJkRGF0ZUFuZE5hbm9zKHN0YW5kYXJkRGF0ZSwgbmFub3NlY29uZCk7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHN0YW5kYXJkRGF0ZS5nZXRGdWxsWWVhcigpLCBzdGFuZGFyZERhdGUuZ2V0TW9udGgoKSArIDEsIHN0YW5kYXJkRGF0ZS5nZXREYXRlKCksIHN0YW5kYXJkRGF0ZS5nZXRIb3VycygpLCBzdGFuZGFyZERhdGUuZ2V0TWludXRlcygpLCBzdGFuZGFyZERhdGUuZ2V0U2Vjb25kcygpLCB1dGlsLnRvdGFsTmFub3NlY29uZHMoc3RhbmRhcmREYXRlLCBuYW5vc2Vjb25kKSwgdXRpbC50aW1lWm9uZU9mZnNldEluU2Vjb25kcyhzdGFuZGFyZERhdGUpLCBudWxsXG4gICAgICAvKiBubyB0aW1lIHpvbmUgaWQgKi9cbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEYXRlVGltZTtcbn0oKTtcblxuZXhwb3J0cy5EYXRlVGltZSA9IERhdGVUaW1lO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGVUaW1lLnByb3RvdHlwZSwgREFURV9USU1FX0lERU5USUZJRVJfUFJPUEVSVFksIElERU5USUZJRVJfUFJPUEVSVFlfQVRUUklCVVRFUyk7XG4vKipcbiAqIFRlc3QgaWYgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIHtAbGluayBEYXRlVGltZX0gY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIG9iamVjdCBpcyBhIHtAbGluayBEYXRlVGltZX0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzRGF0ZVRpbWUob2JqKSB7XG4gIHJldHVybiBoYXNJZGVudGlmaWVyUHJvcGVydHkob2JqLCBEQVRFX1RJTUVfSURFTlRJRklFUl9QUk9QRVJUWSk7XG59XG5cbmZ1bmN0aW9uIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIHByb3BlcnR5KSB7XG4gIHJldHVybiAob2JqICYmIG9ialtwcm9wZXJ0eV0pID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBsb2NhbERhdGVUaW1lVG9TdHJpbmcoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9zZWNvbmQpIHtcbiAgcmV0dXJuIHV0aWwuZGF0ZVRvSXNvU3RyaW5nKHllYXIsIG1vbnRoLCBkYXkpICsgJ1QnICsgdXRpbC50aW1lVG9Jc29TdHJpbmcoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9zZWNvbmQpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlUaW1lWm9uZUFyZ3VtZW50cyh0aW1lWm9uZU9mZnNldFNlY29uZHMsIHRpbWVab25lSWQpIHtcbiAgdmFyIG9mZnNldERlZmluZWQgPSB0aW1lWm9uZU9mZnNldFNlY29uZHMgfHwgdGltZVpvbmVPZmZzZXRTZWNvbmRzID09PSAwO1xuICB2YXIgaWREZWZpbmVkID0gdGltZVpvbmVJZCAmJiB0aW1lWm9uZUlkICE9PSAnJztcblxuICBpZiAob2Zmc2V0RGVmaW5lZCAmJiAhaWREZWZpbmVkKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydE51bWJlck9ySW50ZWdlcikodGltZVpvbmVPZmZzZXRTZWNvbmRzLCAnVGltZSB6b25lIG9mZnNldCBpbiBzZWNvbmRzJyk7XG4gICAgcmV0dXJuIFt0aW1lWm9uZU9mZnNldFNlY29uZHMsIG51bGxdO1xuICB9IGVsc2UgaWYgKCFvZmZzZXREZWZpbmVkICYmIGlkRGVmaW5lZCkge1xuICAgICgwLCBfdXRpbC5hc3NlcnRTdHJpbmcpKHRpbWVab25lSWQsICdUaW1lIHpvbmUgSUQnKTtcbiAgICByZXR1cm4gW251bGwsIHRpbWVab25lSWRdO1xuICB9IGVsc2UgaWYgKG9mZnNldERlZmluZWQgJiYgaWREZWZpbmVkKSB7XG4gICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoXCJVbmFibGUgdG8gY3JlYXRlIERhdGVUaW1lIHdpdGggYm90aCB0aW1lIHpvbmUgb2Zmc2V0IGFuZCBpZC4gUGxlYXNlIHNwZWNpZnkgZWl0aGVyIG9mIHRoZW0uIEdpdmVuIG9mZnNldDogXCIuY29uY2F0KHRpbWVab25lT2Zmc2V0U2Vjb25kcywgXCIgYW5kIGlkOiBcIikuY29uY2F0KHRpbWVab25lSWQpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKShcIlVuYWJsZSB0byBjcmVhdGUgRGF0ZVRpbWUgd2l0aG91dCBlaXRoZXIgdGltZSB6b25lIG9mZnNldCBvciBpZC4gUGxlYXNlIHNwZWNpZnkgZWl0aGVyIG9mIHRoZW0uIEdpdmVuIG9mZnNldDogXCIuY29uY2F0KHRpbWVab25lT2Zmc2V0U2Vjb25kcywgXCIgYW5kIGlkOiBcIikuY29uY2F0KHRpbWVab25lSWQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2ZXJpZnlTdGFuZGFyZERhdGVBbmROYW5vcyhzdGFuZGFyZERhdGUsIG5hbm9zZWNvbmQpIHtcbiAgKDAsIF91dGlsLmFzc2VydFZhbGlkRGF0ZSkoc3RhbmRhcmREYXRlLCAnU3RhbmRhcmQgZGF0ZScpO1xuXG4gIGlmIChuYW5vc2Vjb25kICE9PSBudWxsICYmIG5hbm9zZWNvbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICgwLCBfdXRpbC5hc3NlcnROdW1iZXJPckludGVnZXIpKG5hbm9zZWNvbmQsICdOYW5vc2Vjb25kJyk7XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9yeGpzID0gcmVxdWlyZShcInJ4anNcIik7XG5cbnZhciBfcmVzdWx0UnggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Jlc3VsdC1yeFwiKSk7XG5cbnZhciBfdHJhbnNhY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQSByZWFjdGl2ZSB0cmFuc2FjdGlvbiwgd2hpY2ggcHJvdmlkZXMgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSBhcyB7QGxpbmsgVHJhbnNhY3Rpb259IGJ1dCB0aHJvdWdoIGEgUmVhY3RpdmUgQVBJLlxuICovXG52YXIgUnhUcmFuc2FjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0eGMgLSBUaGUgdW5kZXJseWluZyB0cmFuc2FjdGlvbiBpbnN0YW5jZSB0byByZWxheSByZXF1ZXN0c1xuICAgKi9cbiAgZnVuY3Rpb24gUnhUcmFuc2FjdGlvbih0eGMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFJ4VHJhbnNhY3Rpb24pO1xuICAgIHRoaXMuX3R4YyA9IHR4YztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJlYWN0aXZlIHJlc3VsdCB0aGF0IHdpbGwgZXhlY3V0ZSB0aGUgcXVlcnkgaW4gdGhpcyB0cmFuc2FjdGlvbiwgd2l0aCB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgLSBRdWVyeSB0byBiZSBleGVjdXRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBQYXJhbWV0ZXIgdmFsdWVzIHRvIHVzZSBpbiBxdWVyeSBleGVjdXRpb24uXG4gICAqIEByZXR1cm5zIHtSeFJlc3VsdH0gLSBBIHJlYWN0aXZlIHJlc3VsdFxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUnhUcmFuc2FjdGlvbiwgW3tcbiAgICBrZXk6IFwicnVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bihxdWVyeSwgcGFyYW1ldGVycykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBfcmVzdWx0UnhbXCJkZWZhdWx0XCJdKG5ldyBfcnhqcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9ic2VydmVyLm5leHQoX3RoaXMuX3R4Yy5ydW4ocXVlcnksIHBhcmFtZXRlcnMpKTtcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tbWl0cyB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IC0gQW4gZW1wdHkgb2JzZXJ2YWJsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbW1pdCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gbmV3IF9yeGpzLk9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIF90aGlzMi5fdHhjLmNvbW1pdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUm9sbHMgYmFjayB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IC0gQW4gZW1wdHkgb2JzZXJ2YWJsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicm9sbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm9sbGJhY2soKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBfcnhqcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBfdGhpczMuX3R4Yy5yb2xsYmFjaygpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUnhUcmFuc2FjdGlvbjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSeFRyYW5zYWN0aW9uOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkXCIpO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Jlc3VsdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVzdWx0XCIpKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvdXRpbFwiKTtcblxudmFyIF9jb25uZWN0aW9uSG9sZGVyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vaW50ZXJuYWwvY29ubmVjdGlvbi1ob2xkZXJcIikpO1xuXG52YXIgX2Jvb2ttYXJrID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC9ib29rbWFya1wiKSk7XG5cbnZhciBfdHhDb25maWcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL3R4LWNvbmZpZ1wiKSk7XG5cbnZhciBfc3RyZWFtT2JzZXJ2ZXJzID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvc3RyZWFtLW9ic2VydmVyc1wiKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNhY3Rpb24gaW4gdGhlIE5lbzRqIGRhdGFiYXNlLlxuICpcbiAqIEBhY2Nlc3MgcHVibGljXG4gKi9cbnZhciBUcmFuc2FjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtDb25uZWN0aW9uSG9sZGVyfSBjb25uZWN0aW9uSG9sZGVyIC0gdGhlIGNvbm5lY3Rpb24gaG9sZGVyIHRvIGdldCBjb25uZWN0aW9uIGZyb20uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gb25DbG9zZSAtIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRyYW5zYWN0aW9uIGlzIGNvbW1pdHRlZCBvciByb2xsZWQgYmFjay5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihib29rbWFyazogQm9va21hcmspfSBvbkJvb2ttYXJrIGNhbGxiYWNrIGludm9rZWQgd2hlbiBuZXcgYm9va21hcmsgaXMgcHJvZHVjZWQuXG4gICAqICogQHBhcmFtIHtmdW5jdGlvbigpfSBvbkNvbm5lY3Rpb24gLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBhIGNvbm5lY3Rpb24gaXMgb2J0YWluZWQgdG8gZW5zdXJlIHRoZSBjb25uZWNpdG9uXG4gICAqIGlzIG5vdCB5ZXQgcmVsZWFzZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhY3RpdmUgd2hldGhlciB0aGlzIHRyYW5zYWN0aW9uIGdlbmVyYXRlcyByZWFjdGl2ZSBzdHJlYW1zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmZXRjaFNpemUgLSB0aGUgcmVjb3JkIGZldGNoIHNpemUgaW4gZWFjaCBwdWxsaW5nIGJhdGNoLlxuICAgKi9cbiAgZnVuY3Rpb24gVHJhbnNhY3Rpb24oX3JlZikge1xuICAgIHZhciBjb25uZWN0aW9uSG9sZGVyID0gX3JlZi5jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICBvbkNsb3NlID0gX3JlZi5vbkNsb3NlLFxuICAgICAgICBvbkJvb2ttYXJrID0gX3JlZi5vbkJvb2ttYXJrLFxuICAgICAgICBvbkNvbm5lY3Rpb24gPSBfcmVmLm9uQ29ubmVjdGlvbixcbiAgICAgICAgcmVhY3RpdmUgPSBfcmVmLnJlYWN0aXZlLFxuICAgICAgICBmZXRjaFNpemUgPSBfcmVmLmZldGNoU2l6ZTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLl9jb25uZWN0aW9uSG9sZGVyID0gY29ubmVjdGlvbkhvbGRlcjtcbiAgICB0aGlzLl9yZWFjdGl2ZSA9IHJlYWN0aXZlO1xuICAgIHRoaXMuX3N0YXRlID0gX3N0YXRlcy5BQ1RJVkU7XG4gICAgdGhpcy5fb25DbG9zZSA9IG9uQ2xvc2U7XG4gICAgdGhpcy5fb25Cb29rbWFyayA9IG9uQm9va21hcms7XG4gICAgdGhpcy5fb25Db25uZWN0aW9uID0gb25Db25uZWN0aW9uO1xuICAgIHRoaXMuX29uRXJyb3IgPSB0aGlzLl9vbkVycm9yQ2FsbGJhY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNvbXBsZXRlID0gdGhpcy5fb25Db21wbGV0ZUNhbGxiYWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fZmV0Y2hTaXplID0gZmV0Y2hTaXplO1xuICAgIHRoaXMuX3Jlc3VsdHMgPSBbXTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoVHJhbnNhY3Rpb24sIFt7XG4gICAga2V5OiBcIl9iZWdpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmVnaW4oYm9va21hcmssIHR4Q29uZmlnKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9jb25uZWN0aW9uSG9sZGVyLmdldENvbm5lY3Rpb24oKS50aGVuKGZ1bmN0aW9uIChjb25uKSB7XG4gICAgICAgIF90aGlzLl9vbkNvbm5lY3Rpb24oKTtcblxuICAgICAgICByZXR1cm4gY29ubi5wcm90b2NvbCgpLmJlZ2luVHJhbnNhY3Rpb24oe1xuICAgICAgICAgIGJvb2ttYXJrOiBib29rbWFyayxcbiAgICAgICAgICB0eENvbmZpZzogdHhDb25maWcsXG4gICAgICAgICAgbW9kZTogX3RoaXMuX2Nvbm5lY3Rpb25Ib2xkZXIubW9kZSgpLFxuICAgICAgICAgIGRhdGFiYXNlOiBfdGhpcy5fY29ubmVjdGlvbkhvbGRlci5kYXRhYmFzZSgpLFxuICAgICAgICAgIGJlZm9yZUVycm9yOiBfdGhpcy5fb25FcnJvcixcbiAgICAgICAgICBhZnRlckNvbXBsZXRlOiBfdGhpcy5fb25Db21wbGV0ZVxuICAgICAgICB9KTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5fb25FcnJvcihlcnJvcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVuIEN5cGhlciBxdWVyeVxuICAgICAqIENvdWxkIGJlIGNhbGxlZCB3aXRoIGEgcXVlcnkgb2JqZWN0IGkuZS46IGB7dGV4dDogXCJNQVRDSCAuLi5cIiwgcGFyYW1ldGVyczoge3BhcmFtOiAxfX1gXG4gICAgICogb3Igd2l0aCB0aGUgcXVlcnkgYW5kIHBhcmFtZXRlcnMgYXMgc2VwYXJhdGUgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IHF1ZXJ5IC0gQ3lwaGVyIHF1ZXJ5IHRvIGV4ZWN1dGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyAtIE1hcCB3aXRoIHBhcmFtZXRlcnMgdG8gdXNlIGluIHF1ZXJ5XG4gICAgICogQHJldHVybiB7UmVzdWx0fSBOZXcgUmVzdWx0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJydW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuKHF1ZXJ5LCBwYXJhbWV0ZXJzKSB7XG4gICAgICB2YXIgX3ZhbGlkYXRlUXVlcnlBbmRQYXJhID0gKDAsIF91dGlsLnZhbGlkYXRlUXVlcnlBbmRQYXJhbWV0ZXJzKShxdWVyeSwgcGFyYW1ldGVycyksXG4gICAgICAgICAgdmFsaWRhdGVkUXVlcnkgPSBfdmFsaWRhdGVRdWVyeUFuZFBhcmEudmFsaWRhdGVkUXVlcnksXG4gICAgICAgICAgcGFyYW1zID0gX3ZhbGlkYXRlUXVlcnlBbmRQYXJhLnBhcmFtcztcblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3N0YXRlLnJ1bih2YWxpZGF0ZWRRdWVyeSwgcGFyYW1zLCB7XG4gICAgICAgIGNvbm5lY3Rpb25Ib2xkZXI6IHRoaXMuX2Nvbm5lY3Rpb25Ib2xkZXIsXG4gICAgICAgIG9uRXJyb3I6IHRoaXMuX29uRXJyb3IsXG4gICAgICAgIG9uQ29tcGxldGU6IHRoaXMuX29uQ29tcGxldGUsXG4gICAgICAgIG9uQ29ubmVjdGlvbjogdGhpcy5fb25Db25uZWN0aW9uLFxuICAgICAgICByZWFjdGl2ZTogdGhpcy5fcmVhY3RpdmUsXG4gICAgICAgIGZldGNoU2l6ZTogdGhpcy5fZmV0Y2hTaXplXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbW1pdHMgdGhlIHRyYW5zYWN0aW9uIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXG4gICAgICpcbiAgICAgKiBBZnRlciBjb21taXR0aW5nIHRoZSB0cmFuc2FjdGlvbiBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQW4gZW1wdHkgcHJvbWlzZSBpZiBjb21taXR0ZWQgc3VjY2Vzc2Z1bGx5IG9yIGVycm9yIGlmIGFueSBlcnJvciBoYXBwZW5lZCBkdXJpbmcgY29tbWl0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbW1pdCgpIHtcbiAgICAgIHZhciBjb21taXR0ZWQgPSB0aGlzLl9zdGF0ZS5jb21taXQoe1xuICAgICAgICBjb25uZWN0aW9uSG9sZGVyOiB0aGlzLl9jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLFxuICAgICAgICBvbkNvbXBsZXRlOiB0aGlzLl9vbkNvbXBsZXRlLFxuICAgICAgICBvbkNvbm5lY3Rpb246IHRoaXMuX29uQ29ubmVjdGlvbixcbiAgICAgICAgcGVuZGluZ1Jlc3VsdHM6IHRoaXMuX3Jlc3VsdHNcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9zdGF0ZSA9IGNvbW1pdHRlZC5zdGF0ZTsgLy8gY2xlYW4gdXBcblxuICAgICAgdGhpcy5fb25DbG9zZSgpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBjb21taXR0ZWQucmVzdWx0LnN1YnNjcmliZSh7XG4gICAgICAgICAgb25Db21wbGV0ZWQ6IGZ1bmN0aW9uIG9uQ29tcGxldGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm9sbGJhY2tzIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEFmdGVyIHJvbGxpbmcgYmFjaywgdGhlIHRyYW5zYWN0aW9uIGNhbiBubyBsb25nZXIgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBbiBlbXB0eSBwcm9taXNlIGlmIHJvbGxlZCBiYWNrIHN1Y2Nlc3NmdWxseSBvciBlcnJvciBpZiBhbnkgZXJyb3IgaGFwcGVuZWQgZHVyaW5nXG4gICAgICogcm9sbGJhY2suXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyb2xsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb2xsYmFjaygpIHtcbiAgICAgIHZhciByb2xsZWRiYWNrID0gdGhpcy5fc3RhdGUucm9sbGJhY2soe1xuICAgICAgICBjb25uZWN0aW9uSG9sZGVyOiB0aGlzLl9jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLFxuICAgICAgICBvbkNvbXBsZXRlOiB0aGlzLl9vbkNvbXBsZXRlLFxuICAgICAgICBvbkNvbm5lY3Rpb246IHRoaXMuX29uQ29ubmVjdGlvbixcbiAgICAgICAgcGVuZGluZ1Jlc3VsdHM6IHRoaXMuX3Jlc3VsdHNcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9zdGF0ZSA9IHJvbGxlZGJhY2suc3RhdGU7IC8vIGNsZWFuIHVwXG5cbiAgICAgIHRoaXMuX29uQ2xvc2UoKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcm9sbGVkYmFjay5yZXN1bHQuc3Vic2NyaWJlKHtcbiAgICAgICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gb25Db21wbGV0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGFjdGl2ZSwgd2hpY2ggbWVhbnMgY29tbWl0IGFuZCByb2xsYmFjayBkaWQgbm90IGhhcHBlbi5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgd2hlbiBub3QgY29tbWl0dGVkIGFuZCBub3Qgcm9sbGVkIGJhY2ssIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNPcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3BlbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZSA9PT0gX3N0YXRlcy5BQ1RJVkU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbkVycm9yQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRXJyb3JDYWxsYmFjayhlcnIpIHtcbiAgICAgIC8vIGVycm9yIHdpbGwgYmUgXCJhY2tub3dsZWRnZWRcIiBieSBzZW5kaW5nIGEgUkVTRVQgbWVzc2FnZVxuICAgICAgLy8gZGF0YWJhc2Ugd2lsbCB0aGVuIGZvcmdldCBhYm91dCB0aGlzIHRyYW5zYWN0aW9uIGFuZCBjbGVhbnVwIGFsbCBjb3JyZXNwb25kaW5nIHJlc291cmNlc1xuICAgICAgLy8gaXQgaXMgdGh1cyBzYWZlIHRvIG1vdmUgdGhpcyB0cmFuc2FjdGlvbiB0byBhIEZBSUxFRCBzdGF0ZSBhbmQgZGlzYWxsb3cgYW55IGZ1cnRoZXIgaW50ZXJhY3Rpb25zIHdpdGggaXRcbiAgICAgIHRoaXMuX3N0YXRlID0gX3N0YXRlcy5GQUlMRUQ7XG5cbiAgICAgIHRoaXMuX29uQ2xvc2UoKTsgLy8gcmVsZWFzZSBjb25uZWN0aW9uIGJhY2sgdG8gdGhlIHBvb2xcblxuXG4gICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbkhvbGRlci5yZWxlYXNlQ29ubmVjdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25Db21wbGV0ZUNhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkNvbXBsZXRlQ2FsbGJhY2sobWV0YSkge1xuICAgICAgdGhpcy5fb25Cb29rbWFyayhuZXcgX2Jvb2ttYXJrW1wiZGVmYXVsdFwiXShtZXRhLmJvb2ttYXJrKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUcmFuc2FjdGlvbjtcbn0oKTtcblxudmFyIF9zdGF0ZXMgPSB7XG4gIC8vIFRoZSB0cmFuc2FjdGlvbiBpcyBydW5uaW5nIHdpdGggbm8gZXhwbGljaXQgc3VjY2VzcyBvciBmYWlsdXJlIG1hcmtlZFxuICBBQ1RJVkU6IHtcbiAgICBjb21taXQ6IGZ1bmN0aW9uIGNvbW1pdChfcmVmMikge1xuICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfcmVmMi5jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICAgIG9uRXJyb3IgPSBfcmVmMi5vbkVycm9yLFxuICAgICAgICAgIG9uQ29tcGxldGUgPSBfcmVmMi5vbkNvbXBsZXRlLFxuICAgICAgICAgIG9uQ29ubmVjdGlvbiA9IF9yZWYyLm9uQ29ubmVjdGlvbixcbiAgICAgICAgICBwZW5kaW5nUmVzdWx0cyA9IF9yZWYyLnBlbmRpbmdSZXN1bHRzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBmaW5pc2hUcmFuc2FjdGlvbih0cnVlLCBjb25uZWN0aW9uSG9sZGVyLCBvbkVycm9yLCBvbkNvbXBsZXRlLCBvbkNvbm5lY3Rpb24sIHBlbmRpbmdSZXN1bHRzKSxcbiAgICAgICAgc3RhdGU6IF9zdGF0ZXMuU1VDQ0VFREVEXG4gICAgICB9O1xuICAgIH0sXG4gICAgcm9sbGJhY2s6IGZ1bmN0aW9uIHJvbGxiYWNrKF9yZWYzKSB7XG4gICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9yZWYzLmNvbm5lY3Rpb25Ib2xkZXIsXG4gICAgICAgICAgb25FcnJvciA9IF9yZWYzLm9uRXJyb3IsXG4gICAgICAgICAgb25Db21wbGV0ZSA9IF9yZWYzLm9uQ29tcGxldGUsXG4gICAgICAgICAgb25Db25uZWN0aW9uID0gX3JlZjMub25Db25uZWN0aW9uLFxuICAgICAgICAgIHBlbmRpbmdSZXN1bHRzID0gX3JlZjMucGVuZGluZ1Jlc3VsdHM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IGZpbmlzaFRyYW5zYWN0aW9uKGZhbHNlLCBjb25uZWN0aW9uSG9sZGVyLCBvbkVycm9yLCBvbkNvbXBsZXRlLCBvbkNvbm5lY3Rpb24sIHBlbmRpbmdSZXN1bHRzKSxcbiAgICAgICAgc3RhdGU6IF9zdGF0ZXMuUk9MTEVEX0JBQ0tcbiAgICAgIH07XG4gICAgfSxcbiAgICBydW46IGZ1bmN0aW9uIHJ1bihxdWVyeSwgcGFyYW1ldGVycywgX3JlZjQpIHtcbiAgICAgIHZhciBjb25uZWN0aW9uSG9sZGVyID0gX3JlZjQuY29ubmVjdGlvbkhvbGRlcixcbiAgICAgICAgICBvbkVycm9yID0gX3JlZjQub25FcnJvcixcbiAgICAgICAgICBvbkNvbXBsZXRlID0gX3JlZjQub25Db21wbGV0ZSxcbiAgICAgICAgICBvbkNvbm5lY3Rpb24gPSBfcmVmNC5vbkNvbm5lY3Rpb24sXG4gICAgICAgICAgcmVhY3RpdmUgPSBfcmVmNC5yZWFjdGl2ZSxcbiAgICAgICAgICBmZXRjaFNpemUgPSBfcmVmNC5mZXRjaFNpemU7XG4gICAgICAvLyBSVU4gaW4gZXhwbGljaXQgdHJhbnNhY3Rpb24gY2FuJ3QgY29udGFpbiBib29rbWFya3MgYW5kIHRyYW5zYWN0aW9uIGNvbmZpZ3VyYXRpb25cbiAgICAgIC8vIE5vIG5lZWQgdG8gaW5jbHVkZSBtb2RlIGFuZCBkYXRhYmFzZSBuYW1lIGFzIGl0IHNoYWxsIGJlIGluY2x1ZWQgaW4gYmVnaW5cbiAgICAgIHZhciBvYnNlcnZlclByb21pc2UgPSBjb25uZWN0aW9uSG9sZGVyLmdldENvbm5lY3Rpb24oKS50aGVuKGZ1bmN0aW9uIChjb25uKSB7XG4gICAgICAgIG9uQ29ubmVjdGlvbigpO1xuICAgICAgICByZXR1cm4gY29ubi5wcm90b2NvbCgpLnJ1bihxdWVyeSwgcGFyYW1ldGVycywge1xuICAgICAgICAgIGJvb2ttYXJrOiBfYm9va21hcmtbXCJkZWZhdWx0XCJdLmVtcHR5KCksXG4gICAgICAgICAgdHhDb25maWc6IF90eENvbmZpZ1tcImRlZmF1bHRcIl0uZW1wdHkoKSxcbiAgICAgICAgICBiZWZvcmVFcnJvcjogb25FcnJvcixcbiAgICAgICAgICBhZnRlckNvbXBsZXRlOiBvbkNvbXBsZXRlLFxuICAgICAgICAgIHJlYWN0aXZlOiByZWFjdGl2ZSxcbiAgICAgICAgICBmZXRjaFNpemU6IGZldGNoU2l6ZVxuICAgICAgICB9KTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgX3N0cmVhbU9ic2VydmVycy5GYWlsZWRPYnNlcnZlcih7XG4gICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXdDb21wbGV0ZWRSZXN1bHQob2JzZXJ2ZXJQcm9taXNlLCBxdWVyeSwgcGFyYW1ldGVycyk7XG4gICAgfVxuICB9LFxuICAvLyBBbiBlcnJvciBoYXMgb2NjdXJyZWQsIHRyYW5zYWN0aW9uIGNhbiBubyBsb25nZXIgYmUgdXNlZCBhbmQgbm8gbW9yZSBtZXNzYWdlcyB3aWxsXG4gIC8vIGJlIHNlbnQgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gIEZBSUxFRDoge1xuICAgIGNvbW1pdDogZnVuY3Rpb24gY29tbWl0KF9yZWY1KSB7XG4gICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9yZWY1LmNvbm5lY3Rpb25Ib2xkZXIsXG4gICAgICAgICAgb25FcnJvciA9IF9yZWY1Lm9uRXJyb3IsXG4gICAgICAgICAgb25Db21wbGV0ZSA9IF9yZWY1Lm9uQ29tcGxldGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IG5ld0NvbXBsZXRlZFJlc3VsdChuZXcgX3N0cmVhbU9ic2VydmVycy5GYWlsZWRPYnNlcnZlcih7XG4gICAgICAgICAgZXJyb3I6ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdDYW5ub3QgY29tbWl0IHRoaXMgdHJhbnNhY3Rpb24sIGJlY2F1c2UgaXQgaGFzIGJlZW4gcm9sbGVkIGJhY2sgZWl0aGVyIGJlY2F1c2Ugb2YgYW4gZXJyb3Igb3IgZXhwbGljaXQgdGVybWluYXRpb24uJyksXG4gICAgICAgICAgb25FcnJvcjogb25FcnJvclxuICAgICAgICB9KSwgJ0NPTU1JVCcsIHt9KSxcbiAgICAgICAgc3RhdGU6IF9zdGF0ZXMuRkFJTEVEXG4gICAgICB9O1xuICAgIH0sXG4gICAgcm9sbGJhY2s6IGZ1bmN0aW9uIHJvbGxiYWNrKF9yZWY2KSB7XG4gICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9yZWY2LmNvbm5lY3Rpb25Ib2xkZXIsXG4gICAgICAgICAgb25FcnJvciA9IF9yZWY2Lm9uRXJyb3IsXG4gICAgICAgICAgb25Db21wbGV0ZSA9IF9yZWY2Lm9uQ29tcGxldGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IG5ld0NvbXBsZXRlZFJlc3VsdChuZXcgX3N0cmVhbU9ic2VydmVycy5Db21wbGV0ZWRPYnNlcnZlcigpLCAnUk9MTEJBQ0snLCB7fSksXG4gICAgICAgIHN0YXRlOiBfc3RhdGVzLkZBSUxFRFxuICAgICAgfTtcbiAgICB9LFxuICAgIHJ1bjogZnVuY3Rpb24gcnVuKHF1ZXJ5LCBwYXJhbWV0ZXJzLCBfcmVmNykge1xuICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfcmVmNy5jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICAgIG9uRXJyb3IgPSBfcmVmNy5vbkVycm9yLFxuICAgICAgICAgIG9uQ29tcGxldGUgPSBfcmVmNy5vbkNvbXBsZXRlO1xuICAgICAgcmV0dXJuIG5ld0NvbXBsZXRlZFJlc3VsdChuZXcgX3N0cmVhbU9ic2VydmVycy5GYWlsZWRPYnNlcnZlcih7XG4gICAgICAgIGVycm9yOiAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnQ2Fubm90IHJ1biBxdWVyeSBpbiB0aGlzIHRyYW5zYWN0aW9uLCBiZWNhdXNlIGl0IGhhcyBiZWVuIHJvbGxlZCBiYWNrIGVpdGhlciBiZWNhdXNlIG9mIGFuIGVycm9yIG9yIGV4cGxpY2l0IHRlcm1pbmF0aW9uLicpLFxuICAgICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgICB9KSwgcXVlcnksIHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgfSxcbiAgLy8gVGhpcyB0cmFuc2FjdGlvbiBoYXMgc3VjY2Vzc2Z1bGx5IGNvbW1pdHRlZFxuICBTVUNDRUVERUQ6IHtcbiAgICBjb21taXQ6IGZ1bmN0aW9uIGNvbW1pdChfcmVmOCkge1xuICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfcmVmOC5jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICAgIG9uRXJyb3IgPSBfcmVmOC5vbkVycm9yLFxuICAgICAgICAgIG9uQ29tcGxldGUgPSBfcmVmOC5vbkNvbXBsZXRlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBuZXdDb21wbGV0ZWRSZXN1bHQobmV3IF9zdHJlYW1PYnNlcnZlcnMuRmFpbGVkT2JzZXJ2ZXIoe1xuICAgICAgICAgIGVycm9yOiAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnQ2Fubm90IGNvbW1pdCB0aGlzIHRyYW5zYWN0aW9uLCBiZWNhdXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gY29tbWl0dGVkLicpLFxuICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICAgICAgfSksICdDT01NSVQnLCB7fSksXG4gICAgICAgIHN0YXRlOiBfc3RhdGVzLlNVQ0NFRURFRFxuICAgICAgfTtcbiAgICB9LFxuICAgIHJvbGxiYWNrOiBmdW5jdGlvbiByb2xsYmFjayhfcmVmOSkge1xuICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfcmVmOS5jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICAgIG9uRXJyb3IgPSBfcmVmOS5vbkVycm9yLFxuICAgICAgICAgIG9uQ29tcGxldGUgPSBfcmVmOS5vbkNvbXBsZXRlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBuZXdDb21wbGV0ZWRSZXN1bHQobmV3IF9zdHJlYW1PYnNlcnZlcnMuRmFpbGVkT2JzZXJ2ZXIoe1xuICAgICAgICAgIGVycm9yOiAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnQ2Fubm90IHJvbGxiYWNrIHRoaXMgdHJhbnNhY3Rpb24sIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiBjb21taXR0ZWQuJyksXG4gICAgICAgICAgb25FcnJvcjogb25FcnJvclxuICAgICAgICB9KSwgJ1JPTExCQUNLJywge30pLFxuICAgICAgICBzdGF0ZTogX3N0YXRlcy5TVUNDRUVERURcbiAgICAgIH07XG4gICAgfSxcbiAgICBydW46IGZ1bmN0aW9uIHJ1bihxdWVyeSwgcGFyYW1ldGVycywgX3JlZjEwKSB7XG4gICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9yZWYxMC5jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICAgIG9uRXJyb3IgPSBfcmVmMTAub25FcnJvcixcbiAgICAgICAgICBvbkNvbXBsZXRlID0gX3JlZjEwLm9uQ29tcGxldGU7XG4gICAgICByZXR1cm4gbmV3Q29tcGxldGVkUmVzdWx0KG5ldyBfc3RyZWFtT2JzZXJ2ZXJzLkZhaWxlZE9ic2VydmVyKHtcbiAgICAgICAgZXJyb3I6ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdDYW5ub3QgcnVuIHF1ZXJ5IGluIHRoaXMgdHJhbnNhY3Rpb24sIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiBjb21taXR0ZWQuJyksXG4gICAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICAgIH0pLCBxdWVyeSwgcGFyYW1ldGVycyk7XG4gICAgfVxuICB9LFxuICAvLyBUaGlzIHRyYW5zYWN0aW9uIGhhcyBiZWVuIHJvbGxlZCBiYWNrXG4gIFJPTExFRF9CQUNLOiB7XG4gICAgY29tbWl0OiBmdW5jdGlvbiBjb21taXQoX3JlZjExKSB7XG4gICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9yZWYxMS5jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICAgIG9uRXJyb3IgPSBfcmVmMTEub25FcnJvcixcbiAgICAgICAgICBvbkNvbXBsZXRlID0gX3JlZjExLm9uQ29tcGxldGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IG5ld0NvbXBsZXRlZFJlc3VsdChuZXcgX3N0cmVhbU9ic2VydmVycy5GYWlsZWRPYnNlcnZlcih7XG4gICAgICAgICAgZXJyb3I6ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdDYW5ub3QgY29tbWl0IHRoaXMgdHJhbnNhY3Rpb24sIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiByb2xsZWQgYmFjay4nKSxcbiAgICAgICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgICAgIH0pLCAnQ09NTUlUJywge30pLFxuICAgICAgICBzdGF0ZTogX3N0YXRlcy5ST0xMRURfQkFDS1xuICAgICAgfTtcbiAgICB9LFxuICAgIHJvbGxiYWNrOiBmdW5jdGlvbiByb2xsYmFjayhfcmVmMTIpIHtcbiAgICAgIHZhciBjb25uZWN0aW9uSG9sZGVyID0gX3JlZjEyLmNvbm5lY3Rpb25Ib2xkZXIsXG4gICAgICAgICAgb25FcnJvciA9IF9yZWYxMi5vbkVycm9yLFxuICAgICAgICAgIG9uQ29tcGxldGUgPSBfcmVmMTIub25Db21wbGV0ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogbmV3Q29tcGxldGVkUmVzdWx0KG5ldyBfc3RyZWFtT2JzZXJ2ZXJzLkZhaWxlZE9ic2VydmVyKHtcbiAgICAgICAgICBlcnJvcjogKDAsIF9lcnJvci5uZXdFcnJvcikoJ0Nhbm5vdCByb2xsYmFjayB0aGlzIHRyYW5zYWN0aW9uLCBiZWNhdXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gcm9sbGVkIGJhY2suJylcbiAgICAgICAgfSksICdST0xMQkFDSycsIHt9KSxcbiAgICAgICAgc3RhdGU6IF9zdGF0ZXMuUk9MTEVEX0JBQ0tcbiAgICAgIH07XG4gICAgfSxcbiAgICBydW46IGZ1bmN0aW9uIHJ1bihxdWVyeSwgcGFyYW1ldGVycywgX3JlZjEzKSB7XG4gICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9yZWYxMy5jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICAgIG9uRXJyb3IgPSBfcmVmMTMub25FcnJvcixcbiAgICAgICAgICBvbkNvbXBsZXRlID0gX3JlZjEzLm9uQ29tcGxldGU7XG4gICAgICByZXR1cm4gbmV3Q29tcGxldGVkUmVzdWx0KG5ldyBfc3RyZWFtT2JzZXJ2ZXJzLkZhaWxlZE9ic2VydmVyKHtcbiAgICAgICAgZXJyb3I6ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdDYW5ub3QgcnVuIHF1ZXJ5IGluIHRoaXMgdHJhbnNhY3Rpb24sIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiByb2xsZWQgYmFjay4nKSxcbiAgICAgICAgb25FcnJvcjogb25FcnJvclxuICAgICAgfSksIHF1ZXJ5LCBwYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbW1pdFxuICogQHBhcmFtIHtDb25uZWN0aW9uSG9sZGVyfSBjb25uZWN0aW9uSG9sZGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGVycjpFcnJvcik6IGFueX0gb25FcnJvclxuICogQHBhcmFtIHtmdW5jdGlvbihtZXRhZGF0YTpvYmplY3QpOiBhbnl9IG9uQ29tcGxldGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKSA6IGFueX0gb25Db25uZWN0aW9uXG4gKiBAcGFyYW0ge2xpc3Q8UmVzdWx0Pj59cGVuZGluZ1Jlc3VsdHMgYWxsIHJ1biByZXN1bHRzIGluIHRoaXMgdHJhbnNhY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBmaW5pc2hUcmFuc2FjdGlvbihjb21taXQsIGNvbm5lY3Rpb25Ib2xkZXIsIG9uRXJyb3IsIG9uQ29tcGxldGUsIG9uQ29ubmVjdGlvbiwgcGVuZGluZ1Jlc3VsdHMpIHtcbiAgdmFyIG9ic2VydmVyUHJvbWlzZSA9IGNvbm5lY3Rpb25Ib2xkZXIuZ2V0Q29ubmVjdGlvbigpLnRoZW4oZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICBvbkNvbm5lY3Rpb24oKTtcbiAgICBwZW5kaW5nUmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gci5fY2FuY2VsKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmdSZXN1bHRzKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICBpZiAoY29tbWl0KSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uLnByb3RvY29sKCkuY29tbWl0VHJhbnNhY3Rpb24oe1xuICAgICAgICAgIGJlZm9yZUVycm9yOiBvbkVycm9yLFxuICAgICAgICAgIGFmdGVyQ29tcGxldGU6IG9uQ29tcGxldGVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5wcm90b2NvbCgpLnJvbGxiYWNrVHJhbnNhY3Rpb24oe1xuICAgICAgICAgIGJlZm9yZUVycm9yOiBvbkVycm9yLFxuICAgICAgICAgIGFmdGVyQ29tcGxldGU6IG9uQ29tcGxldGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgcmV0dXJuIG5ldyBfc3RyZWFtT2JzZXJ2ZXJzLkZhaWxlZE9ic2VydmVyKHtcbiAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICB9KTtcbiAgfSk7IC8vIGZvciBjb21taXQgJiByb2xsYmFjayB3ZSBuZWVkIHJlc3VsdCB0aGF0IHVzZXMgcmVhbCBjb25uZWN0aW9uIGhvbGRlciBhbmQgbm90aWZpZXMgaXQgd2hlblxuICAvLyBjb25uZWN0aW9uIGlzIG5vdCBuZWVkZWQgYW5kIGNhbiBiZSBzYWZlbHkgcmVsZWFzZWQgdG8gdGhlIHBvb2xcblxuICByZXR1cm4gbmV3IF9yZXN1bHRbXCJkZWZhdWx0XCJdKG9ic2VydmVyUHJvbWlzZSwgY29tbWl0ID8gJ0NPTU1JVCcgOiAnUk9MTEJBQ0snLCB7fSwgY29ubmVjdGlvbkhvbGRlcik7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUmVzdWx0fSB3aXRoIGVtcHR5IGNvbm5lY3Rpb24gaG9sZGVyLlxuICogRm9yIGNhc2VzIHdoZW4gcmVzdWx0IHJlcHJlc2VudHMgYW4gaW50ZXJtZWRpYXRlIG9yIGZhaWxlZCBhY3Rpb24sIGRvZXMgbm90IHJlcXVpcmUgYW55IG1ldGFkYXRhIGFuZCBkb2VzIG5vdFxuICogbmVlZCB0byBpbmZsdWVuY2UgcmVhbCBjb25uZWN0aW9uIGhvbGRlciB0byByZWxlYXNlIGNvbm5lY3Rpb25zLlxuICogQHBhcmFtIHtSZXN1bHRTdHJlYW1PYnNlcnZlcn0gb2JzZXJ2ZXIgLSBhbiBvYnNlcnZlciBmb3IgdGhlIGNyZWF0ZWQgcmVzdWx0LlxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gdGhlIGN5cGhlciBxdWVyeSB0aGF0IHByb2R1Y2VkIHRoZSByZXN1bHQuXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyAtIHRoZSBwYXJhbWV0ZXJzIGZvciBjeXBoZXIgcXVlcnkgdGhhdCBwcm9kdWNlZCB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7UmVzdWx0fSBuZXcgcmVzdWx0LlxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIG5ld0NvbXBsZXRlZFJlc3VsdChvYnNlcnZlclByb21pc2UsIHF1ZXJ5LCBwYXJhbWV0ZXJzKSB7XG4gIHJldHVybiBuZXcgX3Jlc3VsdFtcImRlZmF1bHRcIl0oUHJvbWlzZS5yZXNvbHZlKG9ic2VydmVyUHJvbWlzZSksIHF1ZXJ5LCBwYXJhbWV0ZXJzLCBfY29ubmVjdGlvbkhvbGRlci5FTVBUWV9DT05ORUNUSU9OX0hPTERFUik7XG59XG5cbnZhciBfZGVmYXVsdCA9IFRyYW5zYWN0aW9uO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIERPIE5PVCBDSEFOR0UgVEhFIFZFUlNJT04gQkVMT1cgSEVSRVxuLy8gVGhpcyBpcyBzZXQgYnkgdGhlIGJ1aWxkIHN5c3RlbSBhdCByZWxlYXNlIHRpbWUsIHVzaW5nXG4vLyAgIGd1bHAgc2V0IC0tdmVyc2lvbiA8cmVsZWFzZXZlcnNpb24+XG4vL1xuLy8gVGhpcyBpcyBzZXQgdXAgdGhpcyB3YXkgdG8ga2VlcCB0aGUgdmVyc2lvbiBpbiB0aGUgY29kZSBpblxuLy8gc3luYyB3aXRoIHRoZSBucG0gcGFja2FnZSB2ZXJzaW9uLCBhbmQgdG8gYWxsb3cgdGhlIGJ1aWxkXG4vLyBzeXN0ZW0gdG8gY29udHJvbCB2ZXJzaW9uIG5hbWVzIGF0IHBhY2thZ2luZyB0aW1lLlxudmFyIF9kZWZhdWx0ID0gJzAuMC4wLWRldic7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyJdLCJzb3VyY2VSb290IjoiIn0=