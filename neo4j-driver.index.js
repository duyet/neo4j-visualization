(window["webpackJsonpNeo4jVisualization"] = window["webpackJsonpNeo4jVisualization"] || []).push([["neo4j-driver"],{

/***/ "./node_modules/neo4j-driver/lib/driver.js":
/*!*************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/driver.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.WRITE = exports.READ = exports.Driver = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

var _connectionProvider = _interopRequireDefault(__webpack_require__(/*! ./internal/connection-provider */ "./node_modules/neo4j-driver/lib/internal/connection-provider.js"));

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./internal/bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

var _connectionProviderDirect = _interopRequireDefault(__webpack_require__(/*! ./internal/connection-provider-direct */ "./node_modules/neo4j-driver/lib/internal/connection-provider-direct.js"));

var _connectivityVerifier = _interopRequireDefault(__webpack_require__(/*! ./internal/connectivity-verifier */ "./node_modules/neo4j-driver/lib/internal/connectivity-verifier.js"));

var _constants = __webpack_require__(/*! ./internal/constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

var _logger = _interopRequireDefault(__webpack_require__(/*! ./internal/logger */ "./node_modules/neo4j-driver/lib/internal/logger.js"));

var _poolConfig = __webpack_require__(/*! ./internal/pool-config */ "./node_modules/neo4j-driver/lib/internal/pool-config.js");

var _session = _interopRequireDefault(__webpack_require__(/*! ./session */ "./node_modules/neo4j-driver/lib/session.js"));

var _sessionRx = _interopRequireDefault(__webpack_require__(/*! ./session-rx */ "./node_modules/neo4j-driver/lib/session-rx.js"));

var _requestMessage = __webpack_require__(/*! ./internal/request-message */ "./node_modules/neo4j-driver/lib/internal/request-message.js");

var _util = __webpack_require__(/*! ./internal/util */ "./node_modules/neo4j-driver/lib/internal/util.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_MAX_CONNECTION_LIFETIME = 60 * 60 * 1000; // 1 hour

/**
 * The default record fetch size. This is used in Bolt V4 protocol to pull query execution result in batches.
 * @type {number}
 */

var DEFAULT_FETCH_SIZE = 1000;
/**
 * Constant that represents read session access mode.
 * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.READ })`.
 * @type {string}
 */

var READ = _constants.ACCESS_MODE_READ;
/**
 * Constant that represents write session access mode.
 * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.WRITE })`.
 * @type {string}
 */

exports.READ = READ;
var WRITE = _constants.ACCESS_MODE_WRITE;
exports.WRITE = WRITE;
var idGenerator = 0;
/**
 * A driver maintains one or more {@link Session}s with a remote
 * Neo4j instance. Through the {@link Session}s you can send queries
 * and retrieve results from the database.
 *
 * Drivers are reasonably expensive to create - you should strive to keep one
 * driver instance around per Neo4j Instance you connect to.
 *
 * @access public
 */

var Driver = /*#__PURE__*/function () {
  /**
   * You should not be calling this directly, instead use {@link driver}.
   * @constructor
   * @protected
   * @param {ServerAddress} address
   * @param {string} userAgent
   * @param {Object} authToken
   * @param {Object} config
   */
  function Driver(address, userAgent) {
    var authToken = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck2["default"])(this, Driver);
    sanitizeConfig(config);
    this._id = idGenerator++;
    this._address = address;
    this._userAgent = userAgent;
    this._authToken = authToken;
    this._config = config;
    this._log = _logger["default"].create(config);
    /**
     * Reference to the connection provider. Initialized lazily by {@link _getOrCreateConnectionProvider}.
     * @type {ConnectionProvider}
     * @protected
     */

    this._connectionProvider = null;

    this._afterConstruction();
  }
  /**
   * Verifies connectivity of this driver by trying to open a connection with the provided driver options.
   *
   * @public
   * @param {Object} param - The object parameter
   * @param {string} param.database - The target database to verify connectivity for.
   * @returns {Promise<void>} promise resolved with server info or rejected with error.
   */


  (0, _createClass2["default"])(Driver, [{
    key: "verifyConnectivity",
    value: function verifyConnectivity() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$database = _ref.database,
          database = _ref$database === void 0 ? '' : _ref$database;

      var connectionProvider = this._getOrCreateConnectionProvider();

      var connectivityVerifier = new _connectivityVerifier["default"](connectionProvider);
      return connectivityVerifier.verify({
        database: database
      });
    }
    /**
     * Returns whether the server supports multi database capabilities based on the protocol
     * version negotiated via handshake.
     *
     * Note that this function call _always_ causes a round-trip to the server.
     *
     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.
     */

  }, {
    key: "supportsMultiDb",
    value: function supportsMultiDb() {
      var connectionProvider = this._getOrCreateConnectionProvider();

      return connectionProvider.supportsMultiDb();
    }
    /**
     * Returns whether the server supports transaction config capabilities based on the protocol
     * version negotiated via handshake.
     *
     * Note that this function call _always_ causes a round-trip to the server.
     *
     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.
     */

  }, {
    key: "supportsTransactionConfig",
    value: function supportsTransactionConfig() {
      var connectionProvider = this._getOrCreateConnectionProvider();

      return connectionProvider.supportsTransactionConfig();
    }
    /**
     * @protected
     * @returns {boolean}
     */

  }, {
    key: "_supportsRouting",
    value: function _supportsRouting() {
      return false;
    }
    /**
     * Returns boolean to indicate if driver has been configured with encryption enabled.
     *
     * @protected
     * @returns {boolean}
     */

  }, {
    key: "_isEncrypted",
    value: function _isEncrypted() {
      return this._config.encrypted === _util.ENCRYPTION_ON;
    }
    /**
     * Returns the configured trust strategy that the driver has been configured with.
     *
     * @protected
     * @returns {TrustStrategy}
     */

  }, {
    key: "_getTrust",
    value: function _getTrust() {
      return this._config.trust;
    }
    /**
     * Acquire a session to communicate with the database. The session will
     * borrow connections from the underlying connection pool as required and
     * should be considered lightweight and disposable.
     *
     * This comes with some responsibility - make sure you always call
     * {@link close} when you are done using a session, and likewise,
     * make sure you don't close your session before you are done using it. Once
     * it is closed, the underlying connection will be released to the connection
     * pool and made available for others to use.
     *
     * @public
     * @param {Object} param - The object parameter
     * @param {string} param.defaultAccessMode=WRITE - The access mode of this session, allowed values are {@link READ} and {@link WRITE}.
     * @param {string|string[]} param.bookmarks - The initial reference or references to some previous
     * transactions. Value is optional and absence indicates that that the bookmarks do not exist or are unknown.
     * @param {number} param.fetchSize - The record fetch size of each batch of this session.
     * Use {@link ALL} to always pull all records in one batch. This will override the config value set on driver config.
     * @param {string} param.database - The database this session will operate on.
     * @return {Session} new session.
     */

  }, {
    key: "session",
    value: function session() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$defaultAccessMo = _ref2.defaultAccessMode,
          defaultAccessMode = _ref2$defaultAccessMo === void 0 ? WRITE : _ref2$defaultAccessMo,
          bookmarkOrBookmarks = _ref2.bookmarks,
          _ref2$database = _ref2.database,
          database = _ref2$database === void 0 ? '' : _ref2$database,
          fetchSize = _ref2.fetchSize;

      return this._newSession({
        defaultAccessMode: defaultAccessMode,
        bookmarkOrBookmarks: bookmarkOrBookmarks,
        database: database,
        reactive: false,
        fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize)
      });
    }
    /**
     * Acquire a reactive session to communicate with the database. The session will
     * borrow connections from the underlying connection pool as required and
     * should be considered lightweight and disposable.
     *
     * This comes with some responsibility - make sure you always call
     * {@link close} when you are done using a session, and likewise,
     * make sure you don't close your session before you are done using it. Once
     * it is closed, the underlying connection will be released to the connection
     * pool and made available for others to use.
     *
     * @public
     * @param {Object} param
     * @param {string} param.defaultAccessMode=WRITE - The access mode of this session, allowed values are {@link READ} and {@link WRITE}.
     * @param {string|string[]} param.bookmarks - The initial reference or references to some previous transactions. Value is optional and
     * absence indicates that the bookmarks do not exist or are unknown.
     * @param {string} param.database - The database this session will operate on.
     * @returns {RxSession} new reactive session.
     */

  }, {
    key: "rxSession",
    value: function rxSession() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$defaultAccessMo = _ref3.defaultAccessMode,
          defaultAccessMode = _ref3$defaultAccessMo === void 0 ? WRITE : _ref3$defaultAccessMo,
          bookmarks = _ref3.bookmarks,
          _ref3$database = _ref3.database,
          database = _ref3$database === void 0 ? '' : _ref3$database,
          fetchSize = _ref3.fetchSize;

      return new _sessionRx["default"]({
        session: this._newSession({
          defaultAccessMode: defaultAccessMode,
          bookmarks: bookmarks,
          database: database,
          reactive: true,
          fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize)
        }),
        config: this._config
      });
    }
    /**
     * Close all open sessions and other associated resources. You should
     * make sure to use this when you are done with this driver instance.
     * @public
     * @return {Promise<void>} promise resolved when the driver is closed.
     */

  }, {
    key: "close",
    value: function close() {
      this._log.info("Driver ".concat(this._id, " closing"));

      if (this._connectionProvider) {
        return this._connectionProvider.close();
      }

      return Promise.resolve();
    }
    /**
     * @protected
     */

  }, {
    key: "_afterConstruction",
    value: function _afterConstruction() {
      this._log.info("Direct driver ".concat(this._id, " created for server address ").concat(this._address));
    }
    /**
     * @protected
     */

  }, {
    key: "_createConnectionProvider",
    value: function _createConnectionProvider(address, userAgent, authToken) {
      return new _connectionProviderDirect["default"]({
        id: this._id,
        config: this._config,
        log: this._log,
        address: address,
        userAgent: userAgent,
        authToken: authToken
      });
    }
    /**
     * @protected
     */

  }, {
    key: "_newSession",

    /**
     * @private
     */
    value: function _newSession(_ref4) {
      var defaultAccessMode = _ref4.defaultAccessMode,
          bookmarkOrBookmarks = _ref4.bookmarkOrBookmarks,
          database = _ref4.database,
          reactive = _ref4.reactive,
          fetchSize = _ref4.fetchSize;

      var sessionMode = Driver._validateSessionMode(defaultAccessMode);

      var connectionProvider = this._getOrCreateConnectionProvider();

      var bookmark = bookmarkOrBookmarks ? new _bookmark["default"](bookmarkOrBookmarks) : _bookmark["default"].empty();
      return new _session["default"]({
        mode: sessionMode,
        database: database,
        connectionProvider: connectionProvider,
        bookmark: bookmark,
        config: this._config,
        reactive: reactive,
        fetchSize: fetchSize
      });
    }
    /**
     * @private
     */

  }, {
    key: "_getOrCreateConnectionProvider",
    value: function _getOrCreateConnectionProvider() {
      if (!this._connectionProvider) {
        this._connectionProvider = this._createConnectionProvider(this._address, this._userAgent, this._authToken);
      }

      return this._connectionProvider;
    }
  }], [{
    key: "_validateSessionMode",
    value: function _validateSessionMode(rawMode) {
      var mode = rawMode || WRITE;

      if (mode !== _constants.ACCESS_MODE_READ && mode !== _constants.ACCESS_MODE_WRITE) {
        throw (0, _error.newError)('Illegal session mode ' + mode);
      }

      return mode;
    }
  }]);
  return Driver;
}();
/**
 * @private
 */


exports.Driver = Driver;

function sanitizeConfig(config) {
  config.maxConnectionLifetime = sanitizeIntValue(config.maxConnectionLifetime, DEFAULT_MAX_CONNECTION_LIFETIME);
  config.maxConnectionPoolSize = sanitizeIntValue(config.maxConnectionPoolSize, _poolConfig.DEFAULT_MAX_SIZE);
  config.connectionAcquisitionTimeout = sanitizeIntValue(config.connectionAcquisitionTimeout, _poolConfig.DEFAULT_ACQUISITION_TIMEOUT);
  config.fetchSize = validateFetchSizeValue(config.fetchSize, DEFAULT_FETCH_SIZE);
}
/**
 * @private
 */


function sanitizeIntValue(rawValue, defaultWhenAbsent) {
  var sanitizedValue = parseInt(rawValue, 10);

  if (sanitizedValue > 0 || sanitizedValue === 0) {
    return sanitizedValue;
  } else if (sanitizedValue < 0) {
    return Number.MAX_SAFE_INTEGER;
  } else {
    return defaultWhenAbsent;
  }
}
/**
 * @private
 */


function validateFetchSizeValue(rawValue, defaultWhenAbsent) {
  var fetchSize = parseInt(rawValue, 10);

  if (fetchSize > 0 || fetchSize === _requestMessage.ALL) {
    return fetchSize;
  } else if (fetchSize === 0 || fetchSize < 0) {
    throw new Error('The fetch size can only be a positive value or -1 for ALL. However fetchSize = ' + fetchSize);
  } else {
    return defaultWhenAbsent;
  }
}

var _default = Driver;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/error.js":
/*!************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/error.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.newError = newError;
exports.PROTOCOL_ERROR = exports.SESSION_EXPIRED = exports.SERVICE_UNAVAILABLE = exports.Neo4jError = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _wrapNativeSuper2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ "./node_modules/@babel/runtime/helpers/wrapNativeSuper.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// A common place for constructing error objects, to keep them
// uniform across the driver surface.

/**
 * Error code representing complete loss of service. Used by {@link Neo4jError#code}.
 * @type {string}
 */
var SERVICE_UNAVAILABLE = 'ServiceUnavailable';
/**
 * Error code representing transient loss of service. Used by {@link Neo4jError#code}.
 * @type {string}
 */

exports.SERVICE_UNAVAILABLE = SERVICE_UNAVAILABLE;
var SESSION_EXPIRED = 'SessionExpired';
/**
 * Error code representing serialization/deserialization issue in the Bolt protocol. Used by {@link Neo4jError#code}.
 * @type {string}
 */

exports.SESSION_EXPIRED = SESSION_EXPIRED;
var PROTOCOL_ERROR = 'ProtocolError';
/**
 * Create a new error from a message and error code
 * @param message the error message
 * @param code the error code
 * @return {Neo4jError} an {@link Neo4jError}
 * @private
 */

exports.PROTOCOL_ERROR = PROTOCOL_ERROR;

function newError(message) {
  var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'N/A';
  // TODO: Idea is that we can check the code here and throw sub-classes
  // of Neo4jError as appropriate
  return new Neo4jError(message, code);
}
/**
 * Class for all errors thrown/returned by the driver.
 */


var Neo4jError = /*#__PURE__*/function (_Error) {
  (0, _inherits2["default"])(Neo4jError, _Error);

  var _super = _createSuper(Neo4jError);

  /**
   * @constructor
   * @param {string} message - The error message.
   * @param {string} code - Optional error code. Will be populated when error originates in the database.
   */
  function Neo4jError(message) {
    var _this;

    var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'N/A';
    (0, _classCallCheck2["default"])(this, Neo4jError);
    _this = _super.call(this, message);
    /**
     * The error message
     * @type {string}
     */

    _this.message = message;
    /**
     * Optional error code. Will be populated when error originates in the database.
     * @type {string}
     */

    _this.code = code;
    /**
     * The name of the error.
     * @type {string}
     */

    _this.name = 'Neo4jError';
    return _this;
  }

  return Neo4jError;
}( /*#__PURE__*/(0, _wrapNativeSuper2["default"])(Error));

exports.Neo4jError = Neo4jError;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/graph-types.js":
/*!******************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/graph-types.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNode = isNode;
exports.isRelationship = isRelationship;
exports.isUnboundRelationship = isUnboundRelationship;
exports.isPath = isPath;
exports.isPathSegment = isPathSegment;
exports.PathSegment = exports.Path = exports.UnboundRelationship = exports.Relationship = exports.Node = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var IDENTIFIER_PROPERTY_ATTRIBUTES = {
  value: true,
  enumerable: false,
  configurable: false,
  writable: false
};
var NODE_IDENTIFIER_PROPERTY = '__isNode__';
var RELATIONSHIP_IDENTIFIER_PROPERTY = '__isRelationship__';
var UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY = '__isUnboundRelationship__';
var PATH_IDENTIFIER_PROPERTY = '__isPath__';
var PATH_SEGMENT_IDENTIFIER_PROPERTY = '__isPathSegment__';

function hasIdentifierProperty(obj, property) {
  return (obj && obj[property]) === true;
}
/**
 * Class for Node Type.
 */


var Node = /*#__PURE__*/function () {
  /**
   * @constructor
   * @protected
   * @param {Integer} identity - Unique identity
   * @param {Array<string>} labels - Array for all labels
   * @param {Object} properties - Map with node properties
   */
  function Node(identity, labels, properties) {
    (0, _classCallCheck2["default"])(this, Node);

    /**
     * Identity of the node.
     * @type {Integer}
     */
    this.identity = identity;
    /**
     * Labels of the node.
     * @type {string[]}
     */

    this.labels = labels;
    /**
     * Properties of the node.
     * @type {Object}
     */

    this.properties = properties;
  }
  /**
   * @ignore
   */


  (0, _createClass2["default"])(Node, [{
    key: "toString",
    value: function toString() {
      var s = '(' + this.identity;

      for (var i = 0; i < this.labels.length; i++) {
        s += ':' + this.labels[i];
      }

      var keys = Object.keys(this.properties);

      if (keys.length > 0) {
        s += ' {';

        for (var _i = 0; _i < keys.length; _i++) {
          if (_i > 0) s += ',';
          s += keys[_i] + ':' + JSON.stringify(this.properties[keys[_i]]);
        }

        s += '}';
      }

      s += ')';
      return s;
    }
  }]);
  return Node;
}();

exports.Node = Node;
Object.defineProperty(Node.prototype, NODE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Node} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Node}, `false` otherwise.
 */

function isNode(obj) {
  return hasIdentifierProperty(obj, NODE_IDENTIFIER_PROPERTY);
}
/**
 * Class for Relationship Type.
 */


var Relationship = /*#__PURE__*/function () {
  /**
   * @constructor
   * @protected
   * @param {Integer} identity - Unique identity
   * @param {Integer} start - Identity of start Node
   * @param {Integer} end - Identity of end Node
   * @param {string} type - Relationship type
   * @param {Object} properties - Map with relationship properties
   */
  function Relationship(identity, start, end, type, properties) {
    (0, _classCallCheck2["default"])(this, Relationship);

    /**
     * Identity of the relationship.
     * @type {Integer}
     */
    this.identity = identity;
    /**
     * Identity of the start node.
     * @type {Integer}
     */

    this.start = start;
    /**
     * Identity of the end node.
     * @type {Integer}
     */

    this.end = end;
    /**
     * Type of the relationship.
     * @type {string}
     */

    this.type = type;
    /**
     * Properties of the relationship.
     * @type {Object}
     */

    this.properties = properties;
  }
  /**
   * @ignore
   */


  (0, _createClass2["default"])(Relationship, [{
    key: "toString",
    value: function toString() {
      var s = '(' + this.start + ')-[:' + this.type;
      var keys = Object.keys(this.properties);

      if (keys.length > 0) {
        s += ' {';

        for (var i = 0; i < keys.length; i++) {
          if (i > 0) s += ',';
          s += keys[i] + ':' + JSON.stringify(this.properties[keys[i]]);
        }

        s += '}';
      }

      s += ']->(' + this.end + ')';
      return s;
    }
  }]);
  return Relationship;
}();

exports.Relationship = Relationship;
Object.defineProperty(Relationship.prototype, RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Relationship} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Relationship}, `false` otherwise.
 */

function isRelationship(obj) {
  return hasIdentifierProperty(obj, RELATIONSHIP_IDENTIFIER_PROPERTY);
}
/**
 * Class for UnboundRelationship Type.
 * @access private
 */


var UnboundRelationship = /*#__PURE__*/function () {
  /**
   * @constructor
   * @protected
   * @param {Integer} identity - Unique identity
   * @param {string} type - Relationship type
   * @param {Object} properties - Map with relationship properties
   */
  function UnboundRelationship(identity, type, properties) {
    (0, _classCallCheck2["default"])(this, UnboundRelationship);

    /**
     * Identity of the relationship.
     * @type {Integer}
     */
    this.identity = identity;
    /**
     * Type of the relationship.
     * @type {string}
     */

    this.type = type;
    /**
     * Properties of the relationship.
     * @type {Object}
     */

    this.properties = properties;
  }
  /**
   * Bind relationship
   *
   * @protected
   * @param {Integer} start - Identity of start node
   * @param {Integer} end - Identity of end node
   * @return {Relationship} - Created relationship
   */


  (0, _createClass2["default"])(UnboundRelationship, [{
    key: "bind",
    value: function bind(start, end) {
      return new Relationship(this.identity, start, end, this.type, this.properties);
    }
    /**
     * @ignore
     */

  }, {
    key: "toString",
    value: function toString() {
      var s = '-[:' + this.type;
      var keys = Object.keys(this.properties);

      if (keys.length > 0) {
        s += ' {';

        for (var i = 0; i < keys.length; i++) {
          if (i > 0) s += ',';
          s += keys[i] + ':' + JSON.stringify(this.properties[keys[i]]);
        }

        s += '}';
      }

      s += ']->';
      return s;
    }
  }]);
  return UnboundRelationship;
}();

exports.UnboundRelationship = UnboundRelationship;
Object.defineProperty(UnboundRelationship.prototype, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link UnboundRelationship} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link UnboundRelationship}, `false` otherwise.
 */

function isUnboundRelationship(obj) {
  return hasIdentifierProperty(obj, UNBOUNT_RELATIONSHIP_IDENTIFIER_PROPERTY);
}
/**
 * Class for PathSegment Type.
 */


var PathSegment =
/**
 * @constructor
 * @protected
 * @param {Node} start - start node
 * @param {Relationship} rel - relationship that connects start and end node
 * @param {Node} end - end node
 */
function PathSegment(start, rel, end) {
  (0, _classCallCheck2["default"])(this, PathSegment);

  /**
   * Start node.
   * @type {Node}
   */
  this.start = start;
  /**
   * Relationship.
   * @type {Relationship}
   */

  this.relationship = rel;
  /**
   * End node.
   * @type {Node}
   */

  this.end = end;
};

exports.PathSegment = PathSegment;
Object.defineProperty(PathSegment.prototype, PATH_SEGMENT_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link PathSegment} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link PathSegment}, `false` otherwise.
 */

function isPathSegment(obj) {
  return hasIdentifierProperty(obj, PATH_SEGMENT_IDENTIFIER_PROPERTY);
}
/**
 * Class for Path Type.
 */


var Path =
/**
 * @constructor
 * @protected
 * @param {Node} start  - start node
 * @param {Node} end - end node
 * @param {Array<PathSegment>} segments - Array of Segments
 */
function Path(start, end, segments) {
  (0, _classCallCheck2["default"])(this, Path);

  /**
   * Start node.
   * @type {Node}
   */
  this.start = start;
  /**
   * End node.
   * @type {Node}
   */

  this.end = end;
  /**
   * Segments.
   * @type {Array<PathSegment>}
   */

  this.segments = segments;
  /**
   * Length of the segments.
   * @type {Number}
   */

  this.length = segments.length;
};

exports.Path = Path;
Object.defineProperty(Path.prototype, PATH_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Path} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Path}, `false` otherwise.
 */

function isPath(obj) {
  return hasIdentifierProperty(obj, PATH_IDENTIFIER_PROPERTY);
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.driver = driver;
Object.defineProperty(exports, "int", {
  enumerable: true,
  get: function get() {
    return _integer["int"];
  }
});
Object.defineProperty(exports, "isInt", {
  enumerable: true,
  get: function get() {
    return _integer.isInt;
  }
});
Object.defineProperty(exports, "Neo4jError", {
  enumerable: true,
  get: function get() {
    return _error.Neo4jError;
  }
});
Object.defineProperty(exports, "isPoint", {
  enumerable: true,
  get: function get() {
    return _spatialTypes.isPoint;
  }
});
Object.defineProperty(exports, "isDate", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isDate;
  }
});
Object.defineProperty(exports, "isDateTime", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isDateTime;
  }
});
Object.defineProperty(exports, "isDuration", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isDuration;
  }
});
Object.defineProperty(exports, "isLocalDateTime", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isLocalDateTime;
  }
});
Object.defineProperty(exports, "isLocalTime", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isLocalTime;
  }
});
Object.defineProperty(exports, "isTime", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isTime;
  }
});
exports["default"] = exports.temporal = exports.spatial = exports.error = exports.session = exports.types = exports.logging = exports.auth = exports.integer = void 0;

var _integer = _interopRequireWildcard(__webpack_require__(/*! ./integer */ "./node_modules/neo4j-driver/lib/integer.js"));

var _graphTypes = __webpack_require__(/*! ./graph-types */ "./node_modules/neo4j-driver/lib/graph-types.js");

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

var _result = _interopRequireDefault(__webpack_require__(/*! ./result */ "./node_modules/neo4j-driver/lib/result.js"));

var _resultSummary = _interopRequireDefault(__webpack_require__(/*! ./result-summary */ "./node_modules/neo4j-driver/lib/result-summary.js"));

var _record = _interopRequireDefault(__webpack_require__(/*! ./record */ "./node_modules/neo4j-driver/lib/record.js"));

var _driver = __webpack_require__(/*! ./driver */ "./node_modules/neo4j-driver/lib/driver.js");

var _routingDriver = _interopRequireDefault(__webpack_require__(/*! ./routing-driver */ "./node_modules/neo4j-driver/lib/routing-driver.js"));

var _version = _interopRequireDefault(__webpack_require__(/*! ./version */ "./node_modules/neo4j-driver/lib/version.js"));

var _util = __webpack_require__(/*! ./internal/util */ "./node_modules/neo4j-driver/lib/internal/util.js");

var _urlUtil = _interopRequireDefault(__webpack_require__(/*! ./internal/url-util */ "./node_modules/neo4j-driver/lib/internal/url-util.js"));

var _spatialTypes = __webpack_require__(/*! ./spatial-types */ "./node_modules/neo4j-driver/lib/spatial-types.js");

var _temporalTypes = __webpack_require__(/*! ./temporal-types */ "./node_modules/neo4j-driver/lib/temporal-types.js");

var _serverAddress = _interopRequireDefault(__webpack_require__(/*! ./internal/server-address */ "./node_modules/neo4j-driver/lib/internal/server-address.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Construct a new Neo4j Driver. This is your main entry point for this
 * library.
 *
 * ## Configuration
 *
 * This function optionally takes a configuration argument. Available configuration
 * options are as follows:
 *
 *     {
 *       // Encryption level: ENCRYPTION_ON or ENCRYPTION_OFF.
 *       encrypted: ENCRYPTION_ON|ENCRYPTION_OFF
 *
 *       // Trust strategy to use if encryption is enabled. There is no mode to disable
 *       // trust other than disabling encryption altogether. The reason for
 *       // this is that if you don't know who you are talking to, it is easy for an
 *       // attacker to hijack your encrypted connection, rendering encryption pointless.
 *       //
 *       // TRUST_SYSTEM_CA_SIGNED_CERTIFICATES is the default choice. For NodeJS environments, this
 *       // means that you trust whatever certificates are in the default trusted certificate
 *       // store of the underlying system. For Browser environments, the trusted certificate
 *       // store is usually managed by the browser. Refer to your system or browser documentation
 *       // if you want to explicitly add a certificate as trusted.
 *       //
 *       // TRUST_CUSTOM_CA_SIGNED_CERTIFICATES is another option for trust verification -
 *       // whenever we establish an encrypted connection, we ensure the host is using
 *       // an encryption certificate that is in, or is signed by, a certificate given
 *       // as trusted through configuration. This option is only available for NodeJS environments.
 *       //
 *       // TRUST_ALL_CERTIFICATES means that you trust everything without any verifications
 *       // steps carried out.  This option is only available for NodeJS environments and should not
 *       // be used on production systems.
 *       trust: "TRUST_SYSTEM_CA_SIGNED_CERTIFICATES" | "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES" |
 *       "TRUST_ALL_CERTIFICATES",
 *
 *       // List of one or more paths to trusted encryption certificates. This only
 *       // works in the NodeJS bundle, and only matters if you use "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES".
 *       // The certificate files should be in regular X.509 PEM format.
 *       // For instance, ['./trusted.pem']
 *       trustedCertificates: [],
 *
 *       // The maximum total number of connections allowed to be managed by the connection pool, per host.
 *       // This includes both in-use and idle connections. No maximum connection pool size is imposed
 *       // by default.
 *       maxConnectionPoolSize: 100,
 *
 *       // The maximum allowed lifetime for a pooled connection in milliseconds. Pooled connections older than this
 *       // threshold will be closed and removed from the pool. Such discarding happens during connection acquisition
 *       // so that new session is never backed by an old connection. Setting this option to a low value will cause
 *       // a high connection churn and might result in a performance hit. It is recommended to set maximum lifetime
 *       // to a slightly smaller value than the one configured in network equipment (load balancer, proxy, firewall,
 *       // etc. can also limit maximum connection lifetime). No maximum lifetime limit is imposed by default. Zero
 *       // and negative values result in lifetime not being checked.
 *       maxConnectionLifetime: 60 * 60 * 1000, // 1 hour
 *
 *       // The maximum amount of time to wait to acquire a connection from the pool (to either create a new
 *       // connection or borrow an existing one.
 *       connectionAcquisitionTimeout: 60000, // 1 minute
 *
 *       // Specify the maximum time in milliseconds transactions are allowed to retry via
 *       // `Session#readTransaction()` and `Session#writeTransaction()` functions.
 *       // These functions will retry the given unit of work on `ServiceUnavailable`, `SessionExpired` and transient
 *       // errors with exponential backoff using initial delay of 1 second.
 *       // Default value is 30000 which is 30 seconds.
 *       maxTransactionRetryTime: 30000, // 30 seconds
 *
 *       // Specify socket connection timeout in milliseconds. Numeric values are expected. Negative and zero values
 *       // result in no timeout being applied. Connection establishment will be then bound by the timeout configured
 *       // on the operating system level. Default value is 30000, which is 30 seconds.
 *       connectionTimeout: 30000, // 30 seconds
 *
 *       // Make this driver always return native JavaScript numbers for integer values, instead of the
 *       // dedicated {@link Integer} class. Values that do not fit in native number bit range will be represented as
 *       // `Number.NEGATIVE_INFINITY` or `Number.POSITIVE_INFINITY`.
 *       // **Warning:** ResultSummary It is not always safe to enable this setting when JavaScript applications are not the only ones
 *       // interacting with the database. Stored numbers might in such case be not representable by native
 *       // {@link Number} type and thus driver will return lossy values. This might also happen when data was
 *       // initially imported using neo4j import tool and contained numbers larger than
 *       // `Number.MAX_SAFE_INTEGER`. Driver will then return positive infinity, which is lossy.
 *       // Default value for this option is `false` because native JavaScript numbers might result
 *       // in loss of precision in the general case.
 *       disableLosslessIntegers: false,
 *
 *       // Specify the logging configuration for the driver. Object should have two properties `level` and `logger`.
 *       //
 *       // Property `level` represents the logging level which should be one of: 'error', 'warn', 'info' or 'debug'. This property is optional and
 *       // its default value is 'info'. Levels have priorities: 'error': 0, 'warn': 1, 'info': 2, 'debug': 3. Enabling a certain level also enables all
 *       // levels with lower priority. For example: 'error', 'warn' and 'info' will be logged when 'info' level is configured.
 *       //
 *       // Property `logger` represents the logging function which will be invoked for every log call with an acceptable level. The function should
 *       // take two string arguments `level` and `message`. The function should not execute any blocking or long-running operations
 *       // because it is often executed on a hot path.
 *       //
 *       // No logging is done by default. See `neo4j.logging` object that contains predefined logging implementations.
 *       logging: {
 *         level: 'info',
 *         logger: (level, message) => console.log(level + ' ' + message)
 *       },
 *
 *       // Specify a custom server address resolver function used by the routing driver to resolve the initial address used to create the driver.
 *       // Such resolution happens:
 *       //  * during the very first rediscovery when driver is created
 *       //  * when all the known routers from the current routing table have failed and driver needs to fallback to the initial address
 *       //
 *       // In NodeJS environment driver defaults to performing a DNS resolution of the initial address using 'dns' module.
 *       // In browser environment driver uses the initial address as-is.
 *       // Value should be a function that takes a single string argument - the initial address. It should return an array of new addresses.
 *       // Address is a string of shape '<host>:<port>'. Provided function can return either a Promise resolved with an array of addresses
 *       // or array of addresses directly.
 *       resolver: function(address) {
 *         return ['127.0.0.1:8888', 'fallback.db.com:7687'];
 *       },
 *
 *      // Optionally override the default user agent name.
 *       userAgent: USER_AGENT
 *     }
 *
 * @param {string} url The URL for the Neo4j database, for instance "neo4j://localhost" and/or "bolt://localhost"
 * @param {Map<string,string>} authToken Authentication credentials. See {@link auth} for helpers.
 * @param {Object} config Configuration object. See the configuration section above for details.
 * @returns {Driver}
 */
function driver(url, authToken) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  (0, _util.assertString)(url, 'Bolt URL');

  var parsedUrl = _urlUtil["default"].parseDatabaseUrl(url); // Determine entryption/trust options from the URL.


  var routing = false;
  var encrypted = false;
  var trust;

  switch (parsedUrl.scheme) {
    case 'bolt':
      break;

    case 'bolt+s':
      encrypted = true;
      trust = 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES';
      break;

    case 'bolt+ssc':
      encrypted = true;
      trust = 'TRUST_ALL_CERTIFICATES';
      break;

    case 'neo4j':
      routing = true;
      break;

    case 'neo4j+s':
      encrypted = true;
      trust = 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES';
      routing = true;
      break;

    case 'neo4j+ssc':
      encrypted = true;
      trust = 'TRUST_ALL_CERTIFICATES';
      routing = true;
      break;

    default:
      throw new Error("Unknown scheme: ".concat(parsedUrl.scheme));
  } // Encryption enabled on URL, propagate trust to the config.


  if (encrypted) {
    // Check for configuration conflict between URL and config.
    if ('encrypted' in config || 'trust' in config) {
      throw new Error('Encryption/trust can only be configured either through URL or config, not both');
    }

    config.encrypted = _util.ENCRYPTION_ON;
    config.trust = trust;
  } // Sanitize authority token. Nicer error from server when a scheme is set.


  authToken = authToken || {};
  authToken.scheme = authToken.scheme || 'none'; // Use default user agent or user agent specified by user.

  config.userAgent = config.userAgent || USER_AGENT;

  if (routing) {
    return new _routingDriver["default"](_serverAddress["default"].fromUrl(parsedUrl.hostAndPort), parsedUrl.query, config.userAgent, authToken, config);
  } else {
    if (!(0, _util.isEmptyObjectOrNull)(parsedUrl.query)) {
      throw new Error("Parameters are not supported with none routed scheme. Given URL: '".concat(url, "'"));
    }

    return new _driver.Driver(_serverAddress["default"].fromUrl(parsedUrl.hostAndPort), config.userAgent, authToken, config);
  }
}
/**
 * @property {function(username: string, password: string, realm: ?string)} basic the function to create a
 * basic authentication token.
 * @property {function(base64EncodedTicket: string)} kerberos the function to create a Kerberos authentication token.
 * Accepts a single string argument - base64 encoded Kerberos ticket.
 * @property {function(principal: string, credentials: string, realm: string, scheme: string, parameters: ?object)} custom
 * the function to create a custom authentication token.
 */


var auth = {
  basic: function basic(username, password) {
    var realm = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

    if (realm) {
      return {
        scheme: 'basic',
        principal: username,
        credentials: password,
        realm: realm
      };
    } else {
      return {
        scheme: 'basic',
        principal: username,
        credentials: password
      };
    }
  },
  kerberos: function kerberos(base64EncodedTicket) {
    return {
      scheme: 'kerberos',
      principal: '',
      // This empty string is required for backwards compatibility.
      credentials: base64EncodedTicket
    };
  },
  custom: function custom(principal, credentials, realm, scheme) {
    var parameters = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;

    if (parameters) {
      return {
        scheme: scheme,
        principal: principal,
        credentials: credentials,
        realm: realm,
        parameters: parameters
      };
    } else {
      return {
        scheme: scheme,
        principal: principal,
        credentials: credentials,
        realm: realm
      };
    }
  }
};
exports.auth = auth;
var USER_AGENT = 'neo4j-javascript/' + _version["default"];
/**
 * Object containing predefined logging configurations. These are expected to be used as values of the driver config's `logging` property.
 * @property {function(level: ?string): object} console the function to create a logging config that prints all messages to `console.log` with
 * timestamp, level and message. It takes an optional `level` parameter which represents the maximum log level to be logged. Default value is 'info'.
 */

var logging = {
  console: function (_console) {
    function console(_x) {
      return _console.apply(this, arguments);
    }

    console.toString = function () {
      return _console.toString();
    };

    return console;
  }(function (level) {
    return {
      level: level,
      logger: function logger(level, message) {
        return console.log("".concat(global.Date.now(), " ").concat(level.toUpperCase(), " ").concat(message));
      }
    };
  })
};
/**
 * Object containing constructors for all neo4j types.
 */

exports.logging = logging;
var types = {
  Node: _graphTypes.Node,
  Relationship: _graphTypes.Relationship,
  UnboundRelationship: _graphTypes.UnboundRelationship,
  PathSegment: _graphTypes.PathSegment,
  Path: _graphTypes.Path,
  Result: _result["default"],
  ResultSummary: _resultSummary["default"],
  Record: _record["default"],
  Point: _spatialTypes.Point,
  Date: _temporalTypes.Date,
  DateTime: _temporalTypes.DateTime,
  Duration: _temporalTypes.Duration,
  LocalDateTime: _temporalTypes.LocalDateTime,
  LocalTime: _temporalTypes.LocalTime,
  Time: _temporalTypes.Time,
  Integer: _integer["default"]
};
/**
 * Object containing string constants representing session access modes.
 */

exports.types = types;
var session = {
  READ: _driver.READ,
  WRITE: _driver.WRITE
};
/**
 * Object containing string constants representing predefined {@link Neo4jError} codes.
 */

exports.session = session;
var error = {
  SERVICE_UNAVAILABLE: _error.SERVICE_UNAVAILABLE,
  SESSION_EXPIRED: _error.SESSION_EXPIRED,
  PROTOCOL_ERROR: _error.PROTOCOL_ERROR
};
/**
 * Object containing functions to work with {@link Integer} objects.
 */

exports.error = error;
var integer = {
  toNumber: _integer.toNumber,
  toString: _integer.toString,
  inSafeRange: _integer.inSafeRange
};
/**
 * Object containing functions to work with spatial types, like {@link Point}.
 */

exports.integer = integer;
var spatial = {
  isPoint: _spatialTypes.isPoint
};
/**
 * Object containing functions to work with temporal types, like {@link Time} or {@link Duration}.
 */

exports.spatial = spatial;
var temporal = {
  isDuration: _temporalTypes.isDuration,
  isLocalTime: _temporalTypes.isLocalTime,
  isTime: _temporalTypes.isTime,
  isDate: _temporalTypes.isDate,
  isLocalDateTime: _temporalTypes.isLocalDateTime,
  isDateTime: _temporalTypes.isDateTime
};
/**
 * @private
 */

exports.temporal = temporal;
var forExport = {
  driver: driver,
  "int": _integer["int"],
  isInt: _integer.isInt,
  isPoint: _spatialTypes.isPoint,
  isDuration: _temporalTypes.isDuration,
  isLocalTime: _temporalTypes.isLocalTime,
  isTime: _temporalTypes.isTime,
  isDate: _temporalTypes.isDate,
  isLocalDateTime: _temporalTypes.isLocalDateTime,
  isDateTime: _temporalTypes.isDateTime,
  integer: integer,
  Neo4jError: _error.Neo4jError,
  auth: auth,
  logging: logging,
  types: types,
  session: session,
  error: error,
  spatial: spatial,
  temporal: temporal
};
var _default = forExport;
exports["default"] = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/integer.js":
/*!**************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/integer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.toString = exports.toNumber = exports.inSafeRange = exports.isInt = exports["int"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// 64-bit Integer library, originally from Long.js by dcodeIO
// https://github.com/dcodeIO/Long.js
// License Apache 2

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 * See exported functions for more convenient ways of operating integers.
 * Use `int()` function to create new integers, `isInt()` to check if given object is integer,
 * `inSafeRange()` to check if it is safe to convert given value to native number,
 * `toNumber()` and `toString()` to convert given integer to number or string respectively.
 * @access public
 * @exports Integer
 * @class A Integer class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @constructor
 */
var Integer = /*#__PURE__*/function () {
  function Integer(low, high) {
    (0, _classCallCheck2["default"])(this, Integer);

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     * @expose
     */
    this.low = low | 0;
    /**
     * The high 32 bits as a signed value.
     * @type {number}
     * @expose
     */

    this.high = high | 0;
  } // The internal representation of an Integer is the two given signed, 32-bit values.
  // We use 32-bit pieces because these are the size of integers on which
  // JavaScript performs bit-operations.  For operations like addition and
  // multiplication, we split each number into 16 bit pieces, which can easily be
  // multiplied within JavaScript's floating-point representation without overflow
  // or change in sign.
  //
  // In the algorithms below, we frequently reduce the negative case to the
  // positive case by negating the input(s) and then post-processing the result.
  // Note that we must ALWAYS check specially whether those values are MIN_VALUE
  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
  // a positive number, it overflows back into a negative).  Not handling this
  // case would often result in infinite recursion.
  //
  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
  // methods on which they depend.


  (0, _createClass2["default"])(Integer, [{
    key: "inSafeRange",
    value: function inSafeRange() {
      return this.greaterThanOrEqual(Integer.MIN_SAFE_VALUE) && this.lessThanOrEqual(Integer.MAX_SAFE_VALUE);
    }
    /**
     * Converts the Integer to an exact javascript Number, assuming it is a 32 bit integer.
     * @returns {number}
     * @expose
     */

  }, {
    key: "toInt",
    value: function toInt() {
      return this.low;
    }
    /**
     * Converts the Integer to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     * @expose
     */

  }, {
    key: "toNumber",
    value: function toNumber() {
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    }
    /**
     * Converts the Integer to native number or -Infinity/+Infinity when it does not fit.
     * @return {number}
     * @package
     */

  }, {
    key: "toNumberOrInfinity",
    value: function toNumberOrInfinity() {
      if (this.lessThan(Integer.MIN_SAFE_VALUE)) {
        return Number.NEGATIVE_INFINITY;
      } else if (this.greaterThan(Integer.MAX_SAFE_VALUE)) {
        return Number.POSITIVE_INFINITY;
      } else {
        return this.toNumber();
      }
    }
    /**
     * Converts the Integer to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     * @expose
     */

  }, {
    key: "toString",
    value: function toString(radix) {
      radix = radix || 10;

      if (radix < 2 || radix > 36) {
        throw RangeError('radix out of range: ' + radix);
      }

      if (this.isZero()) {
        return '0';
      }

      var rem;

      if (this.isNegative()) {
        if (this.equals(Integer.MIN_VALUE)) {
          // We need to change the Integer value before it can be negated, so we remove
          // the bottom-most digit in this base and then recurse to do the rest.
          var radixInteger = Integer.fromNumber(radix);
          var div = this.div(radixInteger);
          rem = div.multiply(radixInteger).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return '-' + this.negate().toString(radix);
        }
      } // Do several (6) digits each time through the loop, so as to
      // minimize the calls to the very expensive emulated div.


      var radixToPower = Integer.fromNumber(Math.pow(radix, 6));
      rem = this;
      var result = '';

      while (true) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0;
        var digits = intval.toString(radix);
        rem = remDiv;

        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = '0' + digits;
          }

          result = '' + digits + result;
        }
      }
    }
    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     * @expose
     */

  }, {
    key: "getHighBits",
    value: function getHighBits() {
      return this.high;
    }
    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     * @expose
     */

  }, {
    key: "getLowBits",
    value: function getLowBits() {
      return this.low;
    }
    /**
     * Gets the number of bits needed to represent the absolute value of this Integer.
     * @returns {number}
     * @expose
     */

  }, {
    key: "getNumBitsAbs",
    value: function getNumBitsAbs() {
      if (this.isNegative()) {
        return this.equals(Integer.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();
      }

      var val = this.high !== 0 ? this.high : this.low;

      for (var bit = 31; bit > 0; bit--) {
        if ((val & 1 << bit) !== 0) {
          break;
        }
      }

      return this.high !== 0 ? bit + 33 : bit + 1;
    }
    /**
     * Tests if this Integer's value equals zero.
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "isZero",
    value: function isZero() {
      return this.high === 0 && this.low === 0;
    }
    /**
     * Tests if this Integer's value is negative.
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "isNegative",
    value: function isNegative() {
      return this.high < 0;
    }
    /**
     * Tests if this Integer's value is positive.
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "isPositive",
    value: function isPositive() {
      return this.high >= 0;
    }
    /**
     * Tests if this Integer's value is odd.
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "isOdd",
    value: function isOdd() {
      return (this.low & 1) === 1;
    }
    /**
     * Tests if this Integer's value is even.
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "isEven",
    value: function isEven() {
      return (this.low & 1) === 0;
    }
    /**
     * Tests if this Integer's value equals the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "equals",
    value: function equals(other) {
      if (!Integer.isInteger(other)) {
        other = Integer.fromValue(other);
      }

      return this.high === other.high && this.low === other.low;
    }
    /**
     * Tests if this Integer's value differs from the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "notEquals",
    value: function notEquals(other) {
      return !this.equals(
      /* validates */
      other);
    }
    /**
     * Tests if this Integer's value is less than the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "lessThan",
    value: function lessThan(other) {
      return this.compare(
      /* validates */
      other) < 0;
    }
    /**
     * Tests if this Integer's value is less than or equal the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "lessThanOrEqual",
    value: function lessThanOrEqual(other) {
      return this.compare(
      /* validates */
      other) <= 0;
    }
    /**
     * Tests if this Integer's value is greater than the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "greaterThan",
    value: function greaterThan(other) {
      return this.compare(
      /* validates */
      other) > 0;
    }
    /**
     * Tests if this Integer's value is greater than or equal the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "greaterThanOrEqual",
    value: function greaterThanOrEqual(other) {
      return this.compare(
      /* validates */
      other) >= 0;
    }
    /**
     * Compares this Integer's value with the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     * @expose
     */

  }, {
    key: "compare",
    value: function compare(other) {
      if (!Integer.isInteger(other)) {
        other = Integer.fromValue(other);
      }

      if (this.equals(other)) {
        return 0;
      }

      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();

      if (thisNeg && !otherNeg) {
        return -1;
      }

      if (!thisNeg && otherNeg) {
        return 1;
      } // At this point the sign bits are the same


      return this.subtract(other).isNegative() ? -1 : 1;
    }
    /**
     * Negates this Integer's value.
     * @returns {!Integer} Negated Integer
     * @expose
     */

  }, {
    key: "negate",
    value: function negate() {
      if (this.equals(Integer.MIN_VALUE)) {
        return Integer.MIN_VALUE;
      }

      return this.not().add(Integer.ONE);
    }
    /**
     * Returns the sum of this and the specified Integer.
     * @param {!Integer|number|string} addend Addend
     * @returns {!Integer} Sum
     * @expose
     */

  }, {
    key: "add",
    value: function add(addend) {
      if (!Integer.isInteger(addend)) {
        addend = Integer.fromValue(addend);
      } // Divide each number into 4 chunks of 16 bits, and then sum the chunks.


      var a48 = this.high >>> 16;
      var a32 = this.high & 0xffff;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xffff;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 0xffff;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 0xffff;
      var c48 = 0;
      var c32 = 0;
      var c16 = 0;
      var c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 0xffff;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c48 += a48 + b48;
      c48 &= 0xffff;
      return Integer.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    }
    /**
     * Returns the difference of this and the specified Integer.
     * @param {!Integer|number|string} subtrahend Subtrahend
     * @returns {!Integer} Difference
     * @expose
     */

  }, {
    key: "subtract",
    value: function subtract(subtrahend) {
      if (!Integer.isInteger(subtrahend)) {
        subtrahend = Integer.fromValue(subtrahend);
      }

      return this.add(subtrahend.negate());
    }
    /**
     * Returns the product of this and the specified Integer.
     * @param {!Integer|number|string} multiplier Multiplier
     * @returns {!Integer} Product
     * @expose
     */

  }, {
    key: "multiply",
    value: function multiply(multiplier) {
      if (this.isZero()) {
        return Integer.ZERO;
      }

      if (!Integer.isInteger(multiplier)) {
        multiplier = Integer.fromValue(multiplier);
      }

      if (multiplier.isZero()) {
        return Integer.ZERO;
      }

      if (this.equals(Integer.MIN_VALUE)) {
        return multiplier.isOdd() ? Integer.MIN_VALUE : Integer.ZERO;
      }

      if (multiplier.equals(Integer.MIN_VALUE)) {
        return this.isOdd() ? Integer.MIN_VALUE : Integer.ZERO;
      }

      if (this.isNegative()) {
        if (multiplier.isNegative()) {
          return this.negate().multiply(multiplier.negate());
        } else {
          return this.negate().multiply(multiplier).negate();
        }
      } else if (multiplier.isNegative()) {
        return this.multiply(multiplier.negate()).negate();
      } // If both longs are small, use float multiplication


      if (this.lessThan(TWO_PWR_24) && multiplier.lessThan(TWO_PWR_24)) {
        return Integer.fromNumber(this.toNumber() * multiplier.toNumber());
      } // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
      // We can skip products that would overflow.


      var a48 = this.high >>> 16;
      var a32 = this.high & 0xffff;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xffff;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 0xffff;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 0xffff;
      var c48 = 0;
      var c32 = 0;
      var c16 = 0;
      var c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 0xffff;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 0xffff;
      return Integer.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    }
    /**
     * Returns this Integer divided by the specified.
     * @param {!Integer|number|string} divisor Divisor
     * @returns {!Integer} Quotient
     * @expose
     */

  }, {
    key: "div",
    value: function div(divisor) {
      if (!Integer.isInteger(divisor)) {
        divisor = Integer.fromValue(divisor);
      }

      if (divisor.isZero()) {
        throw (0, _error.newError)('division by zero');
      }

      if (this.isZero()) {
        return Integer.ZERO;
      }

      var approx, rem, res;

      if (this.equals(Integer.MIN_VALUE)) {
        if (divisor.equals(Integer.ONE) || divisor.equals(Integer.NEG_ONE)) {
          return Integer.MIN_VALUE;
        }

        if (divisor.equals(Integer.MIN_VALUE)) {
          return Integer.ONE;
        } else {
          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
          var halfThis = this.shiftRight(1);
          approx = halfThis.div(divisor).shiftLeft(1);

          if (approx.equals(Integer.ZERO)) {
            return divisor.isNegative() ? Integer.ONE : Integer.NEG_ONE;
          } else {
            rem = this.subtract(divisor.multiply(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.equals(Integer.MIN_VALUE)) {
        return Integer.ZERO;
      }

      if (this.isNegative()) {
        if (divisor.isNegative()) {
          return this.negate().div(divisor.negate());
        }

        return this.negate().div(divisor).negate();
      } else if (divisor.isNegative()) {
        return this.div(divisor.negate()).negate();
      } // Repeat the following until the remainder is less than other:  find a
      // floating-point that approximates remainder / other *from below*, add this
      // into the result, and subtract it from the remainder.  It is critical that
      // the approximate value is less than or equal to the real value so that the
      // remainder never becomes negative.


      res = Integer.ZERO;
      rem = this;

      while (rem.greaterThanOrEqual(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.

        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48); // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.

        var approxRes = Integer.fromNumber(approx);
        var approxRem = approxRes.multiply(divisor);

        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Integer.fromNumber(approx);
          approxRem = approxRes.multiply(divisor);
        } // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.


        if (approxRes.isZero()) {
          approxRes = Integer.ONE;
        }

        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }

      return res;
    }
    /**
     * Returns this Integer modulo the specified.
     * @param {!Integer|number|string} divisor Divisor
     * @returns {!Integer} Remainder
     * @expose
     */

  }, {
    key: "modulo",
    value: function modulo(divisor) {
      if (!Integer.isInteger(divisor)) {
        divisor = Integer.fromValue(divisor);
      }

      return this.subtract(this.div(divisor).multiply(divisor));
    }
    /**
     * Returns the bitwise NOT of this Integer.
     * @returns {!Integer}
     * @expose
     */

  }, {
    key: "not",
    value: function not() {
      return Integer.fromBits(~this.low, ~this.high);
    }
    /**
     * Returns the bitwise AND of this Integer and the specified.
     * @param {!Integer|number|string} other Other Integer
     * @returns {!Integer}
     * @expose
     */

  }, {
    key: "and",
    value: function and(other) {
      if (!Integer.isInteger(other)) {
        other = Integer.fromValue(other);
      }

      return Integer.fromBits(this.low & other.low, this.high & other.high);
    }
    /**
     * Returns the bitwise OR of this Integer and the specified.
     * @param {!Integer|number|string} other Other Integer
     * @returns {!Integer}
     * @expose
     */

  }, {
    key: "or",
    value: function or(other) {
      if (!Integer.isInteger(other)) {
        other = Integer.fromValue(other);
      }

      return Integer.fromBits(this.low | other.low, this.high | other.high);
    }
    /**
     * Returns the bitwise XOR of this Integer and the given one.
     * @param {!Integer|number|string} other Other Integer
     * @returns {!Integer}
     * @expose
     */

  }, {
    key: "xor",
    value: function xor(other) {
      if (!Integer.isInteger(other)) {
        other = Integer.fromValue(other);
      }

      return Integer.fromBits(this.low ^ other.low, this.high ^ other.high);
    }
    /**
     * Returns this Integer with bits shifted to the left by the given amount.
     * @param {number|!Integer} numBits Number of bits
     * @returns {!Integer} Shifted Integer
     * @expose
     */

  }, {
    key: "shiftLeft",
    value: function shiftLeft(numBits) {
      if (Integer.isInteger(numBits)) {
        numBits = numBits.toInt();
      }

      if ((numBits &= 63) === 0) {
        return this;
      } else if (numBits < 32) {
        return Integer.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits);
      } else {
        return Integer.fromBits(0, this.low << numBits - 32);
      }
    }
    /**
     * Returns this Integer with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Integer} numBits Number of bits
     * @returns {!Integer} Shifted Integer
     * @expose
     */

  }, {
    key: "shiftRight",
    value: function shiftRight(numBits) {
      if (Integer.isInteger(numBits)) {
        numBits = numBits.toInt();
      }

      if ((numBits &= 63) === 0) {
        return this;
      } else if (numBits < 32) {
        return Integer.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits);
      } else {
        return Integer.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1);
      }
    }
  }]);
  return Integer;
}();
/**
 * An indicator used to reliably determine if an object is a Integer or not.
 * @type {boolean}
 * @const
 * @expose
 * @private
 */


Integer.__isInteger__ = true;
Object.defineProperty(Integer.prototype, '__isInteger__', {
  value: true,
  enumerable: false,
  configurable: false
});
/**
 * Tests if the specified object is a Integer.
 * @access private
 * @param {*} obj Object
 * @returns {boolean}
 * @expose
 */

Integer.isInteger = function (obj) {
  return (obj && obj.__isInteger__) === true;
};
/**
 * A cache of the Integer representations of small integer values.
 * @type {!Object}
 * @inner
 * @private
 */


var INT_CACHE = {};
/**
 * Returns a Integer representing the given 32 bit integer value.
 * @access private
 * @param {number} value The 32 bit integer in question
 * @returns {!Integer} The corresponding Integer value
 * @expose
 */

Integer.fromInt = function (value) {
  var obj, cachedObj;
  value = value | 0;

  if (value >= -128 && value < 128) {
    cachedObj = INT_CACHE[value];

    if (cachedObj) {
      return cachedObj;
    }
  }

  obj = new Integer(value, value < 0 ? -1 : 0, false);

  if (value >= -128 && value < 128) {
    INT_CACHE[value] = obj;
  }

  return obj;
};
/**
 * Returns a Integer representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @access private
 * @param {number} value The number in question
 * @returns {!Integer} The corresponding Integer value
 * @expose
 */


Integer.fromNumber = function (value) {
  if (isNaN(value) || !isFinite(value)) {
    return Integer.ZERO;
  }

  if (value <= -TWO_PWR_63_DBL) {
    return Integer.MIN_VALUE;
  }

  if (value + 1 >= TWO_PWR_63_DBL) {
    return Integer.MAX_VALUE;
  }

  if (value < 0) {
    return Integer.fromNumber(-value).negate();
  }

  return new Integer(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0);
};
/**
 * Returns a Integer representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @access private
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @returns {!Integer} The corresponding Integer value
 * @expose
 */


Integer.fromBits = function (lowBits, highBits) {
  return new Integer(lowBits, highBits);
};
/**
 * Returns a Integer representation of the given string, written using the specified radix.
 * @access private
 * @param {string} str The textual representation of the Integer
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Integer} The corresponding Integer value
 * @expose
 */


Integer.fromString = function (str, radix) {
  if (str.length === 0) {
    throw (0, _error.newError)('number format error: empty string');
  }

  if (str === 'NaN' || str === 'Infinity' || str === '+Infinity' || str === '-Infinity') {
    return Integer.ZERO;
  }

  radix = radix || 10;

  if (radix < 2 || radix > 36) {
    throw (0, _error.newError)('radix out of range: ' + radix);
  }

  var p;

  if ((p = str.indexOf('-')) > 0) {
    throw (0, _error.newError)('number format error: interior "-" character: ' + str);
  } else if (p === 0) {
    return Integer.fromString(str.substring(1), radix).negate();
  } // Do several (8) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.


  var radixToPower = Integer.fromNumber(Math.pow(radix, 8));
  var result = Integer.ZERO;

  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i);
    var value = parseInt(str.substring(i, i + size), radix);

    if (size < 8) {
      var power = Integer.fromNumber(Math.pow(radix, size));
      result = result.multiply(power).add(Integer.fromNumber(value));
    } else {
      result = result.multiply(radixToPower);
      result = result.add(Integer.fromNumber(value));
    }
  }

  return result;
};
/**
 * Converts the specified value to a Integer.
 * @access private
 * @param {!Integer|number|string|!{low: number, high: number}} val Value
 * @returns {!Integer}
 * @expose
 */


Integer.fromValue = function (val) {
  if (val
  /* is compatible */
  instanceof Integer) {
    return val;
  }

  if (typeof val === 'number') {
    return Integer.fromNumber(val);
  }

  if (typeof val === 'string') {
    return Integer.fromString(val);
  } // Throws for non-objects, converts non-instanceof Integer:


  return new Integer(val.low, val.high);
};
/**
 * Converts the specified value to a number.
 * @access private
 * @param {!Integer|number|string|!{low: number, high: number}} val Value
 * @returns {number}
 * @expose
 */


Integer.toNumber = function (val) {
  return Integer.fromValue(val).toNumber();
};
/**
 * Converts the specified value to a string.
 * @access private
 * @param {!Integer|number|string|!{low: number, high: number}} val Value
 * @param {number} radix optional radix for string conversion, defaults to 10
 * @returns {string}
 * @expose
 */


Integer.toString = function (val, radix) {
  return Integer.fromValue(val).toString(radix);
};
/**
 * Checks if the given value is in the safe range in order to be converted to a native number
 * @access private
 * @param {!Integer|number|string|!{low: number, high: number}} val Value
 * @param {number} radix optional radix for string conversion, defaults to 10
 * @returns {boolean}
 * @expose
 */


Integer.inSafeRange = function (val) {
  return Integer.fromValue(val).inSafeRange();
};
/**
 * @type {number}
 * @const
 * @inner
 * @private
 */


var TWO_PWR_16_DBL = 1 << 16;
/**
 * @type {number}
 * @const
 * @inner
 * @private
 */

var TWO_PWR_24_DBL = 1 << 24;
/**
 * @type {number}
 * @const
 * @inner
 * @private
 */

var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
/**
 * @type {number}
 * @const
 * @inner
 * @private
 */

var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
/**
 * @type {number}
 * @const
 * @inner
 * @private
 */

var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
/**
 * @type {!Integer}
 * @const
 * @inner
 * @private
 */

var TWO_PWR_24 = Integer.fromInt(TWO_PWR_24_DBL);
/**
 * Signed zero.
 * @type {!Integer}
 * @expose
 */

Integer.ZERO = Integer.fromInt(0);
/**
 * Signed one.
 * @type {!Integer}
 * @expose
 */

Integer.ONE = Integer.fromInt(1);
/**
 * Signed negative one.
 * @type {!Integer}
 * @expose
 */

Integer.NEG_ONE = Integer.fromInt(-1);
/**
 * Maximum signed value.
 * @type {!Integer}
 * @expose
 */

Integer.MAX_VALUE = Integer.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);
/**
 * Minimum signed value.
 * @type {!Integer}
 * @expose
 */

Integer.MIN_VALUE = Integer.fromBits(0, 0x80000000 | 0, false);
/**
 * Minimum safe value.
 * @type {!Integer}
 * @expose
 */

Integer.MIN_SAFE_VALUE = Integer.fromBits(0x1 | 0, 0xffffffffffe00000 | 0);
/**
 * Maximum safe value.
 * @type {!Integer}
 * @expose
 */

Integer.MAX_SAFE_VALUE = Integer.fromBits(0xffffffff | 0, 0x1fffff | 0);
/**
 * Cast value to Integer type.
 * @access public
 * @param {Mixed} value - The value to use.
 * @return {Integer} - An object of type Integer.
 */

var _int = Integer.fromValue;
/**
 * Check if a variable is of Integer type.
 * @access public
 * @param {Mixed} value - The variable to check.
 * @return {Boolean} - Is it of the Integer type?
 */

exports["int"] = _int;
var isInt = Integer.isInteger;
/**
 * Check if a variable can be safely converted to a number
 * @access public
 * @param {Mixed} value - The variable to check
 * @return {Boolean} - true if it is safe to call toNumber on variable otherwise false
 */

exports.isInt = isInt;
var inSafeRange = Integer.inSafeRange;
/**
 * Converts a variable to a number
 * @access public
 * @param {Mixed} value - The variable to convert
 * @return {number} - the variable as a number
 */

exports.inSafeRange = inSafeRange;
var toNumber = Integer.toNumber;
/**
 * Converts the integer to a string representation
 * @access public
 * @param {Mixed} value - The variable to convert
 * @param {number} radix - radix to use in string conversion, defaults to 10
 * @return {string} - returns a string representation of the integer
 */

exports.toNumber = toNumber;
var toString = Integer.toString;
exports.toString = toString;
var _default = Integer;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-util.js":
/*!**********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/bolt-protocol-util.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertDatabaseIsEmpty = assertDatabaseIsEmpty;
exports.assertTxConfigIsEmpty = assertTxConfigIsEmpty;

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {TxConfig} txConfig the auto-commit transaction configuration.
 * @param {Connection} connection the connection.
 * @param {ResultStreamObserver} observer the response observer.
 */
function assertTxConfigIsEmpty(txConfig, connection, observer) {
  if (txConfig && !txConfig.isEmpty()) {
    var error = (0, _error.newError)('Driver is connected to the database that does not support transaction configuration. ' + 'Please upgrade to neo4j 3.5.0 or later in order to use this functionality'); // unsupported API was used, consider this a fatal error for the current connection

    connection._handleFatalError(error);

    observer.onError(error);
    throw error;
  }
}
/**
 * Asserts that the passed-in database name is empty.
 * @param {string} database
 * @param {Connection} connection
 */


function assertDatabaseIsEmpty(database, connection, observer) {
  if (database) {
    var error = (0, _error.newError)('Driver is connected to the database that does not support multiple databases. ' + 'Please upgrade to neo4j 4.0.0 or later in order to use this functionality'); // unsupported API was used, consider this a fatal error for the current connection

    connection._handleFatalError(error);

    observer.onError(error);
    throw error;
  }
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v1.js":
/*!********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/bolt-protocol-v1.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _boltProtocolUtil = __webpack_require__(/*! ./bolt-protocol-util */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-util.js");

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

var _chunking = __webpack_require__(/*! ./chunking */ "./node_modules/neo4j-driver/lib/internal/chunking.js");

var _connection = _interopRequireDefault(__webpack_require__(/*! ./connection */ "./node_modules/neo4j-driver/lib/internal/connection.js"));

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

var v1 = _interopRequireWildcard(__webpack_require__(/*! ./packstream-v1 */ "./node_modules/neo4j-driver/lib/internal/packstream-v1.js"));

var _requestMessage = _interopRequireDefault(__webpack_require__(/*! ./request-message */ "./node_modules/neo4j-driver/lib/internal/request-message.js"));

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

var _txConfig = _interopRequireDefault(__webpack_require__(/*! ./tx-config */ "./node_modules/neo4j-driver/lib/internal/tx-config.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BoltProtocol = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Connection} connection the connection.
   * @param {Chunker} chunker the chunker.
   * @param {boolean} disableLosslessIntegers if this connection should convert all received integers to native JS numbers.
   */
  function BoltProtocol(connection, chunker, disableLosslessIntegers) {
    (0, _classCallCheck2["default"])(this, BoltProtocol);
    this._connection = connection;
    this._packer = this._createPacker(chunker);
    this._unpacker = this._createUnpacker(disableLosslessIntegers);
  }
  /**
   * Returns the numerical version identifier for this protocol
   */


  (0, _createClass2["default"])(BoltProtocol, [{
    key: "packer",

    /**
     * Get the packer.
     * @return {Packer} the protocol's packer.
     */
    value: function packer() {
      return this._packer;
    }
    /**
     * Get the unpacker.
     * @return {Unpacker} the protocol's unpacker.
     */

  }, {
    key: "unpacker",
    value: function unpacker() {
      return this._unpacker;
    }
    /**
     * Transform metadata received in SUCCESS message before it is passed to the handler.
     * @param {Object} metadata the received metadata.
     * @return {Object} transformed metadata.
     */

  }, {
    key: "transformMetadata",
    value: function transformMetadata(metadata) {
      return metadata;
    }
    /**
     * Perform initialization and authentication of the underlying connection.
     * @param {Object} param
     * @param {string} param.userAgent the user agent.
     * @param {Object} param.authToken the authentication token.
     * @param {function(err: Error)} param.onError the callback to invoke on error.
     * @param {function()} param.onComplete the callback to invoke on completion.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "initialize",
    value: function initialize() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          userAgent = _ref.userAgent,
          authToken = _ref.authToken,
          onError = _ref.onError,
          onComplete = _ref.onComplete;

      var observer = new _streamObservers.LoginObserver({
        connection: this._connection,
        afterError: onError,
        afterComplete: onComplete
      });

      this._connection.write(_requestMessage["default"].init(userAgent, authToken), observer, true);

      return observer;
    }
    /**
     * Perform protocol related operations for closing this connection
     */

  }, {
    key: "prepareToClose",
    value: function prepareToClose() {} // no need to notify the database in this protocol version

    /**
     * Begin an explicit transaction.
     * @param {Object} param
     * @param {Bookmark} param.bookmark the bookmark.
     * @param {TxConfig} param.txConfig the configuration.
     * @param {string} param.database the target database name.
     * @param {string} param.mode the access mode.
     * @param {function(err: Error)} param.beforeError the callback to invoke before handling the error.
     * @param {function(err: Error)} param.afterError the callback to invoke after handling the error.
     * @param {function()} param.beforeComplete the callback to invoke before handling the completion.
     * @param {function()} param.afterComplete the callback to invoke after handling the completion.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "beginTransaction",
    value: function beginTransaction() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          bookmark = _ref2.bookmark,
          txConfig = _ref2.txConfig,
          database = _ref2.database,
          mode = _ref2.mode,
          beforeError = _ref2.beforeError,
          afterError = _ref2.afterError,
          beforeComplete = _ref2.beforeComplete,
          afterComplete = _ref2.afterComplete;

      return this.run('BEGIN', bookmark ? bookmark.asBeginTransactionParameters() : {}, {
        bookmark: bookmark,
        txConfig: txConfig,
        database: database,
        mode: mode,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete,
        flush: false
      });
    }
    /**
     * Commit the explicit transaction.
     * @param {Object} param
     * @param {function(err: Error)} param.beforeError the callback to invoke before handling the error.
     * @param {function(err: Error)} param.afterError the callback to invoke after handling the error.
     * @param {function()} param.beforeComplete the callback to invoke before handling the completion.
     * @param {function()} param.afterComplete the callback to invoke after handling the completion.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "commitTransaction",
    value: function commitTransaction() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          beforeError = _ref3.beforeError,
          afterError = _ref3.afterError,
          beforeComplete = _ref3.beforeComplete,
          afterComplete = _ref3.afterComplete;

      // WRITE access mode is used as a place holder here, it has
      // no effect on behaviour for Bolt V1 & V2
      return this.run('COMMIT', {}, {
        bookmark: _bookmark["default"].empty(),
        txConfig: _txConfig["default"].empty(),
        mode: _constants.ACCESS_MODE_WRITE,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
    }
    /**
     * Rollback the explicit transaction.
     * @param {Object} param
     * @param {function(err: Error)} param.beforeError the callback to invoke before handling the error.
     * @param {function(err: Error)} param.afterError the callback to invoke after handling the error.
     * @param {function()} param.beforeComplete the callback to invoke before handling the completion.
     * @param {function()} param.afterComplete the callback to invoke after handling the completion.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "rollbackTransaction",
    value: function rollbackTransaction() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          beforeError = _ref4.beforeError,
          afterError = _ref4.afterError,
          beforeComplete = _ref4.beforeComplete,
          afterComplete = _ref4.afterComplete;

      // WRITE access mode is used as a place holder here, it has
      // no effect on behaviour for Bolt V1 & V2
      return this.run('ROLLBACK', {}, {
        bookmark: _bookmark["default"].empty(),
        txConfig: _txConfig["default"].empty(),
        mode: _constants.ACCESS_MODE_WRITE,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
    }
    /**
     * Send a Cypher query through the underlying connection.
     * @param {string} query the cypher query.
     * @param {Object} parameters the query parameters.
     * @param {Object} param
     * @param {Bookmark} param.bookmark the bookmark.
     * @param {TxConfig} param.txConfig the transaction configuration.
     * @param {string} param.database the target database name.
     * @param {string} param.mode the access mode.
     * @param {function(keys: string[])} param.beforeKeys the callback to invoke before handling the keys.
     * @param {function(keys: string[])} param.afterKeys the callback to invoke after handling the keys.
     * @param {function(err: Error)} param.beforeError the callback to invoke before handling the error.
     * @param {function(err: Error)} param.afterError the callback to invoke after handling the error.
     * @param {function()} param.beforeComplete the callback to invoke before handling the completion.
     * @param {function()} param.afterComplete the callback to invoke after handling the completion.
     * @param {boolean} param.flush whether to flush the buffered messages.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "run",
    value: function run(query, parameters) {
      var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          bookmark = _ref5.bookmark,
          txConfig = _ref5.txConfig,
          database = _ref5.database,
          mode = _ref5.mode,
          beforeKeys = _ref5.beforeKeys,
          afterKeys = _ref5.afterKeys,
          beforeError = _ref5.beforeError,
          afterError = _ref5.afterError,
          beforeComplete = _ref5.beforeComplete,
          afterComplete = _ref5.afterComplete,
          _ref5$flush = _ref5.flush,
          flush = _ref5$flush === void 0 ? true : _ref5$flush;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeKeys: beforeKeys,
        afterKeys: afterKeys,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      }); // bookmark and mode are ignored in this version of the protocol

      (0, _boltProtocolUtil.assertTxConfigIsEmpty)(txConfig, this._connection, observer); // passing in a database name on this protocol version throws an error

      (0, _boltProtocolUtil.assertDatabaseIsEmpty)(database, this._connection, observer);

      this._connection.write(_requestMessage["default"].run(query, parameters), observer, false);

      this._connection.write(_requestMessage["default"].pullAll(), observer, flush);

      return observer;
    }
    /**
     * Send a RESET through the underlying connection.
     * @param {Object} param
     * @param {function(err: Error)} param.onError the callback to invoke on error.
     * @param {function()} param.onComplete the callback to invoke on completion.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "reset",
    value: function reset() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          onError = _ref6.onError,
          onComplete = _ref6.onComplete;

      var observer = new _streamObservers.ResetObserver({
        connection: this._connection,
        onError: onError,
        onComplete: onComplete
      });

      this._connection.write(_requestMessage["default"].reset(), observer, true);

      return observer;
    }
  }, {
    key: "_createPacker",
    value: function _createPacker(chunker) {
      return new v1.Packer(chunker);
    }
  }, {
    key: "_createUnpacker",
    value: function _createUnpacker(disableLosslessIntegers) {
      return new v1.Unpacker(disableLosslessIntegers);
    }
  }, {
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V1;
    }
  }]);
  return BoltProtocol;
}();

exports["default"] = BoltProtocol;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v2.js":
/*!********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/bolt-protocol-v2.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _boltProtocolV = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v1 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v1.js"));

var v2 = _interopRequireWildcard(__webpack_require__(/*! ./packstream-v2 */ "./node_modules/neo4j-driver/lib/internal/packstream-v2.js"));

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var BoltProtocol = /*#__PURE__*/function (_BoltProtocolV) {
  (0, _inherits2["default"])(BoltProtocol, _BoltProtocolV);

  var _super = _createSuper(BoltProtocol);

  function BoltProtocol() {
    (0, _classCallCheck2["default"])(this, BoltProtocol);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(BoltProtocol, [{
    key: "_createPacker",
    value: function _createPacker(chunker) {
      return new v2.Packer(chunker);
    }
  }, {
    key: "_createUnpacker",
    value: function _createUnpacker(disableLosslessIntegers) {
      return new v2.Unpacker(disableLosslessIntegers);
    }
  }, {
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V2;
    }
  }]);
  return BoltProtocol;
}(_boltProtocolV["default"]);

exports["default"] = BoltProtocol;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v3.js":
/*!********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/bolt-protocol-v3.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _boltProtocolV = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v2 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v2.js"));

var _requestMessage = _interopRequireDefault(__webpack_require__(/*! ./request-message */ "./node_modules/neo4j-driver/lib/internal/request-message.js"));

var _boltProtocolUtil = __webpack_require__(/*! ./bolt-protocol-util */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-util.js");

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var noOpObserver = new _streamObservers.StreamObserver();

var BoltProtocol = /*#__PURE__*/function (_BoltProtocolV) {
  (0, _inherits2["default"])(BoltProtocol, _BoltProtocolV);

  var _super = _createSuper(BoltProtocol);

  function BoltProtocol() {
    (0, _classCallCheck2["default"])(this, BoltProtocol);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(BoltProtocol, [{
    key: "transformMetadata",
    value: function transformMetadata(metadata) {
      if ('t_first' in metadata) {
        // Bolt V3 uses shorter key 't_first' to represent 'result_available_after'
        // adjust the key to be the same as in Bolt V1 so that ResultSummary can retrieve the value
        metadata.result_available_after = metadata.t_first;
        delete metadata.t_first;
      }

      if ('t_last' in metadata) {
        // Bolt V3 uses shorter key 't_last' to represent 'result_consumed_after'
        // adjust the key to be the same as in Bolt V1 so that ResultSummary can retrieve the value
        metadata.result_consumed_after = metadata.t_last;
        delete metadata.t_last;
      }

      return metadata;
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          userAgent = _ref.userAgent,
          authToken = _ref.authToken,
          onError = _ref.onError,
          onComplete = _ref.onComplete;

      var observer = new _streamObservers.LoginObserver({
        connection: this._connection,
        afterError: onError,
        afterComplete: onComplete
      });

      this._connection.write(_requestMessage["default"].hello(userAgent, authToken), observer, true);

      return observer;
    }
  }, {
    key: "prepareToClose",
    value: function prepareToClose() {
      this._connection.write(_requestMessage["default"].goodbye(), noOpObserver, true);
    }
  }, {
    key: "beginTransaction",
    value: function beginTransaction() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          bookmark = _ref2.bookmark,
          txConfig = _ref2.txConfig,
          database = _ref2.database,
          mode = _ref2.mode,
          beforeError = _ref2.beforeError,
          afterError = _ref2.afterError,
          beforeComplete = _ref2.beforeComplete,
          afterComplete = _ref2.afterComplete;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
      observer.prepareToHandleSingleResponse(); // passing in a database name on this protocol version throws an error

      (0, _boltProtocolUtil.assertDatabaseIsEmpty)(database, this._connection, observer);

      this._connection.write(_requestMessage["default"].begin({
        bookmark: bookmark,
        txConfig: txConfig,
        mode: mode
      }), observer, true);

      return observer;
    }
  }, {
    key: "commitTransaction",
    value: function commitTransaction() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          beforeError = _ref3.beforeError,
          afterError = _ref3.afterError,
          beforeComplete = _ref3.beforeComplete,
          afterComplete = _ref3.afterComplete;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
      observer.prepareToHandleSingleResponse();

      this._connection.write(_requestMessage["default"].commit(), observer, true);

      return observer;
    }
  }, {
    key: "rollbackTransaction",
    value: function rollbackTransaction() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          beforeError = _ref4.beforeError,
          afterError = _ref4.afterError,
          beforeComplete = _ref4.beforeComplete,
          afterComplete = _ref4.afterComplete;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
      observer.prepareToHandleSingleResponse();

      this._connection.write(_requestMessage["default"].rollback(), observer, true);

      return observer;
    }
  }, {
    key: "run",
    value: function run(query, parameters) {
      var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          bookmark = _ref5.bookmark,
          txConfig = _ref5.txConfig,
          database = _ref5.database,
          mode = _ref5.mode,
          beforeKeys = _ref5.beforeKeys,
          afterKeys = _ref5.afterKeys,
          beforeError = _ref5.beforeError,
          afterError = _ref5.afterError,
          beforeComplete = _ref5.beforeComplete,
          afterComplete = _ref5.afterComplete,
          _ref5$flush = _ref5.flush,
          flush = _ref5$flush === void 0 ? true : _ref5$flush;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeKeys: beforeKeys,
        afterKeys: afterKeys,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      }); // passing in a database name on this protocol version throws an error

      (0, _boltProtocolUtil.assertDatabaseIsEmpty)(database, this._connection, observer);

      this._connection.write(_requestMessage["default"].runWithMetadata(query, parameters, {
        bookmark: bookmark,
        txConfig: txConfig,
        mode: mode
      }), observer, false);

      this._connection.write(_requestMessage["default"].pullAll(), observer, flush);

      return observer;
    }
  }, {
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V3;
    }
  }]);
  return BoltProtocol;
}(_boltProtocolV["default"]);

exports["default"] = BoltProtocol;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v4x0.js":
/*!**********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/bolt-protocol-v4x0.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _boltProtocolV = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v3 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v3.js"));

var _requestMessage = _interopRequireWildcard(__webpack_require__(/*! ./request-message */ "./node_modules/neo4j-driver/lib/internal/request-message.js"));

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var BoltProtocol = /*#__PURE__*/function (_BoltProtocolV) {
  (0, _inherits2["default"])(BoltProtocol, _BoltProtocolV);

  var _super = _createSuper(BoltProtocol);

  function BoltProtocol() {
    (0, _classCallCheck2["default"])(this, BoltProtocol);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(BoltProtocol, [{
    key: "beginTransaction",
    value: function beginTransaction() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          bookmark = _ref.bookmark,
          txConfig = _ref.txConfig,
          database = _ref.database,
          mode = _ref.mode,
          beforeError = _ref.beforeError,
          afterError = _ref.afterError,
          beforeComplete = _ref.beforeComplete,
          afterComplete = _ref.afterComplete;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
      observer.prepareToHandleSingleResponse();

      this._connection.write(_requestMessage["default"].begin({
        bookmark: bookmark,
        txConfig: txConfig,
        database: database,
        mode: mode
      }), observer, true);

      return observer;
    }
  }, {
    key: "run",
    value: function run(query, parameters) {
      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          bookmark = _ref2.bookmark,
          txConfig = _ref2.txConfig,
          database = _ref2.database,
          mode = _ref2.mode,
          beforeKeys = _ref2.beforeKeys,
          afterKeys = _ref2.afterKeys,
          beforeError = _ref2.beforeError,
          afterError = _ref2.afterError,
          beforeComplete = _ref2.beforeComplete,
          afterComplete = _ref2.afterComplete,
          _ref2$flush = _ref2.flush,
          flush = _ref2$flush === void 0 ? true : _ref2$flush,
          _ref2$reactive = _ref2.reactive,
          reactive = _ref2$reactive === void 0 ? false : _ref2$reactive,
          _ref2$fetchSize = _ref2.fetchSize,
          fetchSize = _ref2$fetchSize === void 0 ? _requestMessage.ALL : _ref2$fetchSize;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        reactive: reactive,
        fetchSize: fetchSize,
        moreFunction: this._requestMore,
        discardFunction: this._requestDiscard,
        beforeKeys: beforeKeys,
        afterKeys: afterKeys,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
      var flushRun = reactive;

      this._connection.write(_requestMessage["default"].runWithMetadata(query, parameters, {
        bookmark: bookmark,
        txConfig: txConfig,
        database: database,
        mode: mode
      }), observer, flushRun && flush);

      if (!reactive) {
        this._connection.write(_requestMessage["default"].pull({
          n: fetchSize
        }), observer, flush);
      }

      return observer;
    }
  }, {
    key: "_requestMore",
    value: function _requestMore(connection, stmtId, n, observer) {
      connection.write(_requestMessage["default"].pull({
        stmtId: stmtId,
        n: n
      }), observer, true);
    }
  }, {
    key: "_requestDiscard",
    value: function _requestDiscard(connection, stmtId, observer) {
      connection.write(_requestMessage["default"].discard({
        stmtId: stmtId
      }), observer, true);
    }
  }, {
    key: "_noOp",
    value: function _noOp() {}
  }, {
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V4_0;
    }
  }]);
  return BoltProtocol;
}(_boltProtocolV["default"]);

exports["default"] = BoltProtocol;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v4x1.js":
/*!**********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/bolt-protocol-v4x1.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _boltProtocolV4x = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v4x0 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v4x0.js"));

var _requestMessage = _interopRequireWildcard(__webpack_require__(/*! ./request-message */ "./node_modules/neo4j-driver/lib/internal/request-message.js"));

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var BoltProtocol = /*#__PURE__*/function (_BoltProtocolV) {
  (0, _inherits2["default"])(BoltProtocol, _BoltProtocolV);

  var _super = _createSuper(BoltProtocol);

  /**
   * @constructor
   * @param {Connection} connection the connection.
   * @param {Chunker} chunker the chunker.
   * @param {boolean} disableLosslessIntegers if this connection should convert all received integers to native JS numbers.
   * @param {Object} serversideRouting
   */
  function BoltProtocol(connection, chunker, disableLosslessIntegers, serversideRouting) {
    var _this;

    (0, _classCallCheck2["default"])(this, BoltProtocol);
    _this = _super.call(this, connection, chunker, disableLosslessIntegers);
    _this._serversideRouting = serversideRouting;
    return _this;
  }

  (0, _createClass2["default"])(BoltProtocol, [{
    key: "initialize",
    value: function initialize() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          userAgent = _ref.userAgent,
          authToken = _ref.authToken,
          onError = _ref.onError,
          onComplete = _ref.onComplete;

      var observer = new _streamObservers.LoginObserver({
        connection: this._connection,
        afterError: onError,
        afterComplete: onComplete
      });

      this._connection.write(_requestMessage["default"].hello(userAgent, authToken, this._serversideRouting), observer, true);

      return observer;
    }
  }, {
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V4_1;
    }
  }]);
  return BoltProtocol;
}(_boltProtocolV4x["default"]);

exports["default"] = BoltProtocol;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/bookmark.js":
/*!************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/bookmark.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BOOKMARKS_KEY = 'bookmarks';

var Bookmark = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {string|string[]} values single bookmark as string or multiple bookmarks as a string array.
   */
  function Bookmark(values) {
    (0, _classCallCheck2["default"])(this, Bookmark);
    this._values = asStringArray(values);
  }

  (0, _createClass2["default"])(Bookmark, [{
    key: "isEmpty",

    /**
     * Check if the given bookmark is meaningful and can be send to the database.
     * @return {boolean} returns `true` bookmark has a value, `false` otherwise.
     */
    value: function isEmpty() {
      return this._values.length === 0;
    }
    /**
     * Get all bookmark values as an array.
     * @return {string[]} all values.
     */

  }, {
    key: "values",
    value: function values() {
      return this._values;
    }
    /**
     * Get this bookmark as an object for begin transaction call.
     * @return {Object} the value of this bookmark as object.
     */

  }, {
    key: "asBeginTransactionParameters",
    value: function asBeginTransactionParameters() {
      if (this.isEmpty()) {
        return {};
      } // Driver sends {bookmark: "max", bookmarks: ["one", "two", "max"]} instead of simple
      // {bookmarks: ["one", "two", "max"]} for backwards compatibility reasons. Old servers can only accept single
      // bookmark that is why driver has to parse and compare given list of bookmarks. This functionality will
      // eventually be removed.


      return (0, _defineProperty2["default"])({}, BOOKMARKS_KEY, this._values);
    }
  }], [{
    key: "empty",
    value: function empty() {
      return EMPTY_BOOKMARK;
    }
  }]);
  return Bookmark;
}();

exports["default"] = Bookmark;
var EMPTY_BOOKMARK = new Bookmark(null);
/**
 * Converts given value to an array.
 * @param {string|string[]|Array} [value=undefined] argument to convert.
 * @return {string[]} value converted to an array.
 */

function asStringArray(value) {
  if (!value) {
    return [];
  }

  if (util.isString(value)) {
    return [value];
  }

  if (Array.isArray(value)) {
    var result = [];
    var flattenedValue = flattenArray(value);

    for (var i = 0; i < flattenedValue.length; i++) {
      var element = flattenedValue[i]; // if it is undefined or null, ignore it

      if (element !== undefined && element !== null) {
        if (!util.isString(element)) {
          throw new TypeError("Bookmark value should be a string, given: '".concat(element, "'"));
        }

        result.push(element);
      }
    }

    return result;
  }

  throw new TypeError("Bookmark should either be a string or a string array, given: '".concat(value, "'"));
}
/**
 * Recursively flattens an array so that the result becomes a single array
 * of values, which does not include any sub-arrays
 *
 * @param {Array} value
 */


function flattenArray(values) {
  return values.reduce(function (dest, value) {
    return Array.isArray(value) ? dest.concat(flattenArray(value)) : dest.concat(value);
  }, []);
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/browser/browser-buf.js":
/*!***********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/browser/browser-buf.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _baseBuf = _interopRequireDefault(__webpack_require__(/*! ../buf/base-buf */ "./node_modules/neo4j-driver/lib/internal/buf/base-buf.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var HeapBuffer = /*#__PURE__*/function (_BaseBuffer) {
  (0, _inherits2["default"])(HeapBuffer, _BaseBuffer);

  var _super = _createSuper(HeapBuffer);

  function HeapBuffer(arg) {
    var _this;

    (0, _classCallCheck2["default"])(this, HeapBuffer);
    var buffer = arg instanceof ArrayBuffer ? arg : new ArrayBuffer(arg);
    _this = _super.call(this, buffer.byteLength);
    _this._buffer = buffer;
    _this._view = new DataView(_this._buffer);
    return _this;
  }

  (0, _createClass2["default"])(HeapBuffer, [{
    key: "putUInt8",
    value: function putUInt8(position, val) {
      this._view.setUint8(position, val);
    }
  }, {
    key: "getUInt8",
    value: function getUInt8(position) {
      return this._view.getUint8(position);
    }
  }, {
    key: "putInt8",
    value: function putInt8(position, val) {
      this._view.setInt8(position, val);
    }
  }, {
    key: "getInt8",
    value: function getInt8(position) {
      return this._view.getInt8(position);
    }
  }, {
    key: "getFloat64",
    value: function getFloat64(position) {
      return this._view.getFloat64(position);
    }
  }, {
    key: "putFloat64",
    value: function putFloat64(position, val) {
      this._view.setFloat64(position, val);
    }
  }, {
    key: "getSlice",
    value: function getSlice(start, length) {
      if (this._buffer.slice) {
        return new HeapBuffer(this._buffer.slice(start, start + length));
      } else {
        // Some platforms (eg. phantomjs) don't support slice, so fall back to a copy
        // We do this rather than return a SliceBuffer, because sliceBuffer cannot
        // be passed to native network write ops etc - we need ArrayBuffer for that
        var copy = new HeapBuffer(length);

        for (var i = 0; i < length; i++) {
          copy.putUInt8(i, this.getUInt8(i + start));
        }

        return copy;
      }
    }
    /**
     * Specific to HeapBuffer, this gets a DataView from the
     * current position and of the specified length.
     */

  }, {
    key: "readView",
    value: function readView(length) {
      return new DataView(this._buffer, this._updatePos(length), length);
    }
  }]);
  return HeapBuffer;
}(_baseBuf["default"]);

exports["default"] = HeapBuffer;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/browser/browser-channel.js":
/*!***************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/browser/browser-channel.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _browserBuf = _interopRequireDefault(__webpack_require__(/*! ./browser-buf */ "./node_modules/neo4j-driver/lib/internal/browser/browser-buf.js"));

var _error = __webpack_require__(/*! ../../error */ "./node_modules/neo4j-driver/lib/error.js");

var _util = __webpack_require__(/*! ../util */ "./node_modules/neo4j-driver/lib/internal/util.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Just to be sure that these values are with us even after WebSocket is injected
// for tests.
var WS_CONNECTING = 0;
var WS_OPEN = 1;
var WS_CLOSING = 2;
var WS_CLOSED = 3;
/**
 * Create a new WebSocketChannel to be used in web browsers.
 * @access private
 */

var WebSocketChannel = /*#__PURE__*/function () {
  /**
   * Create new instance
   * @param {ChannelConfig} config - configuration for this channel.
   * @param {function(): string} protocolSupplier - function that detects protocol of the web page. Should only be used in tests.
   */
  function WebSocketChannel(config) {
    var protocolSupplier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : detectWebPageProtocol;
    var socketFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (url) {
      return new WebSocket(url);
    };
    (0, _classCallCheck2["default"])(this, WebSocketChannel);
    this._open = true;
    this._pending = [];
    this._error = null;
    this._handleConnectionError = this._handleConnectionError.bind(this);
    this._config = config;

    var _determineWebSocketSc = determineWebSocketScheme(config, protocolSupplier),
        scheme = _determineWebSocketSc.scheme,
        error = _determineWebSocketSc.error;

    if (error) {
      this._error = error;
      return;
    }

    this._ws = createWebSocket(scheme, config.address, socketFactory);
    this._ws.binaryType = 'arraybuffer';
    var self = this; // All connection errors are not sent to the error handler
    // we must also check for dirty close calls

    this._ws.onclose = function (e) {
      if (e && !e.wasClean) {
        self._handleConnectionError();
      }
    };

    this._ws.onopen = function () {
      // Connected! Cancel the connection timeout
      self._clearConnectionTimeout(); // Drain all pending messages


      var pending = self._pending;
      self._pending = null;

      for (var i = 0; i < pending.length; i++) {
        self.write(pending[i]);
      }
    };

    this._ws.onmessage = function (event) {
      if (self.onmessage) {
        var b = new _browserBuf["default"](event.data);
        self.onmessage(b);
      }
    };

    this._ws.onerror = this._handleConnectionError;
    this._connectionTimeoutFired = false;
    this._connectionTimeoutId = this._setupConnectionTimeout();
  }

  (0, _createClass2["default"])(WebSocketChannel, [{
    key: "_handleConnectionError",
    value: function _handleConnectionError() {
      if (this._connectionTimeoutFired) {
        // timeout fired - not connected within configured time
        this._error = (0, _error.newError)("Failed to establish connection in ".concat(this._config.connectionTimeout, "ms"), this._config.connectionErrorCode);

        if (this.onerror) {
          this.onerror(this._error);
        }

        return;
      } // onerror triggers on websocket close as well.. don't get me started.


      if (this._open) {
        // http://stackoverflow.com/questions/25779831/how-to-catch-websocket-connection-to-ws-xxxnn-failed-connection-closed-be
        this._error = (0, _error.newError)('WebSocket connection failure. Due to security ' + 'constraints in your web browser, the reason for the failure is not available ' + 'to this Neo4j Driver. Please use your browsers development console to determine ' + 'the root cause of the failure. Common reasons include the database being ' + 'unavailable, using the wrong connection URL or temporary network problems. ' + 'If you have enabled encryption, ensure your browser is configured to trust the ' + 'certificate Neo4j is configured to use. WebSocket `readyState` is: ' + this._ws.readyState, this._config.connectionErrorCode);

        if (this.onerror) {
          this.onerror(this._error);
        }
      }
    }
    /**
     * Write the passed in buffer to connection
     * @param {HeapBuffer} buffer - Buffer to write
     */

  }, {
    key: "write",
    value: function write(buffer) {
      // If there is a pending queue, push this on that queue. This means
      // we are not yet connected, so we queue things locally.
      if (this._pending !== null) {
        this._pending.push(buffer);
      } else if (buffer instanceof _browserBuf["default"]) {
        try {
          this._ws.send(buffer._buffer);
        } catch (error) {
          if (this._ws.readyState !== WS_OPEN) {
            // Websocket has been closed
            this._handleConnectionError();
          } else {
            // Some other error occured
            throw error;
          }
        }
      } else {
        throw (0, _error.newError)("Don't know how to send buffer: " + buffer);
      }
    }
    /**
     * Close the connection
     * @returns {Promise} A promise that will be resolved after channel is closed
     */

  }, {
    key: "close",
    value: function close() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (_this._ws && _this._ws.readyState !== WS_CLOSED) {
          _this._open = false;

          _this._clearConnectionTimeout();

          _this._ws.onclose = function () {
            return resolve();
          };

          _this._ws.close();
        } else {
          resolve();
        }
      });
    }
    /**
     * Set connection timeout on the given WebSocket, if configured.
     * @return {number} the timeout id or null.
     * @private
     */

  }, {
    key: "_setupConnectionTimeout",
    value: function _setupConnectionTimeout() {
      var _this2 = this;

      var timeout = this._config.connectionTimeout;

      if (timeout) {
        var webSocket = this._ws;
        return setTimeout(function () {
          if (webSocket.readyState !== WS_OPEN) {
            _this2._connectionTimeoutFired = true;
            webSocket.close();
          }
        }, timeout);
      }

      return null;
    }
    /**
     * Remove active connection timeout, if any.
     * @private
     */

  }, {
    key: "_clearConnectionTimeout",
    value: function _clearConnectionTimeout() {
      var timeoutId = this._connectionTimeoutId;

      if (timeoutId || timeoutId === 0) {
        this._connectionTimeoutFired = false;
        this._connectionTimeoutId = null;
        clearTimeout(timeoutId);
      }
    }
  }]);
  return WebSocketChannel;
}();

exports["default"] = WebSocketChannel;

function createWebSocket(scheme, address, socketFactory) {
  var url = scheme + '://' + address.asHostPort();

  try {
    return socketFactory(url);
  } catch (error) {
    if (isIPv6AddressIssueOnWindows(error, address)) {
      // WebSocket in IE and Edge browsers on Windows do not support regular IPv6 address syntax because they contain ':'.
      // It's an invalid character for UNC (https://en.wikipedia.org/wiki/IPv6_address#Literal_IPv6_addresses_in_UNC_path_names)
      // and Windows requires IPv6 to be changes in the following way:
      //   1) replace all ':' with '-'
      //   2) replace '%' with 's' for link-local address
      //   3) append '.ipv6-literal.net' suffix
      // only then resulting string can be considered a valid IPv6 address. Yes, this is extremely weird!
      // For more details see:
      //   https://social.msdn.microsoft.com/Forums/ie/en-US/06cca73b-63c2-4bf9-899b-b229c50449ff/whether-ie10-websocket-support-ipv6?forum=iewebdevelopment
      //   https://www.itdojo.com/ipv6-addresses-and-unc-path-names-overcoming-illegal/
      // Creation of WebSocket with unconverted address results in SyntaxError without message or stacktrace.
      // That is why here we "catch" SyntaxError and rewrite IPv6 address if needed.
      var windowsFriendlyUrl = asWindowsFriendlyIPv6Address(scheme, address);
      return socketFactory(windowsFriendlyUrl);
    } else {
      throw error;
    }
  }
}

function isIPv6AddressIssueOnWindows(error, address) {
  return error.name === 'SyntaxError' && isIPv6Address(address.asHostPort());
}

function isIPv6Address(hostAndPort) {
  return hostAndPort.charAt(0) === '[' && hostAndPort.indexOf(']') !== -1;
}

function asWindowsFriendlyIPv6Address(scheme, address) {
  // replace all ':' with '-'
  var hostWithoutColons = address.host().replace(new RegExp(':', 'g'), '-'); // replace '%' with 's' for link-local IPv6 address like 'fe80::1%lo0'

  var hostWithoutPercent = hostWithoutColons.replace('%', 's'); // append magic '.ipv6-literal.net' suffix

  var ipv6Host = hostWithoutPercent + '.ipv6-literal.net';
  return "".concat(scheme, "://").concat(ipv6Host, ":").concat(address.port());
}
/**
 * @param {ChannelConfig} config - configuration for the channel.
 * @param {function(): string} protocolSupplier - function that detects protocol of the web page.
 * @return {{scheme: string|null, error: Neo4jError|null}} object containing either scheme or error.
 */


function determineWebSocketScheme(config, protocolSupplier) {
  var encryptionOn = isEncryptionExplicitlyTurnedOn(config);
  var encryptionOff = isEncryptionExplicitlyTurnedOff(config);
  var trust = config.trust;
  var secureProtocol = isProtocolSecure(protocolSupplier);
  verifyEncryptionSettings(encryptionOn, encryptionOff, secureProtocol);

  if (encryptionOff) {
    // encryption explicitly turned off in the config
    return {
      scheme: 'ws',
      error: null
    };
  }

  if (secureProtocol) {
    // driver is used in a secure https web page, use 'wss'
    return {
      scheme: 'wss',
      error: null
    };
  }

  if (encryptionOn) {
    // encryption explicitly requested in the config
    if (!trust || trust === 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES') {
      // trust strategy not specified or the only supported strategy is specified
      return {
        scheme: 'wss',
        error: null
      };
    } else {
      var error = (0, _error.newError)('The browser version of this driver only supports one trust ' + "strategy, 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES'. " + trust + ' is not supported. Please ' + 'either use TRUST_SYSTEM_CA_SIGNED_CERTIFICATES or disable encryption by setting ' + '`encrypted:"' + _util.ENCRYPTION_OFF + '"` in the driver configuration.');
      return {
        scheme: null,
        error: error
      };
    }
  } // default to unencrypted web socket


  return {
    scheme: 'ws',
    error: null
  };
}
/**
 * @param {ChannelConfig} config - configuration for the channel.
 * @return {boolean} `true` if encryption enabled in the config, `false` otherwise.
 */


function isEncryptionExplicitlyTurnedOn(config) {
  return config.encrypted === true || config.encrypted === _util.ENCRYPTION_ON;
}
/**
 * @param {ChannelConfig} config - configuration for the channel.
 * @return {boolean} `true` if encryption disabled in the config, `false` otherwise.
 */


function isEncryptionExplicitlyTurnedOff(config) {
  return config.encrypted === false || config.encrypted === _util.ENCRYPTION_OFF;
}
/**
 * @param {function(): string} protocolSupplier - function that detects protocol of the web page.
 * @return {boolean} `true` if protocol returned by the given function is secure, `false` otherwise.
 */


function isProtocolSecure(protocolSupplier) {
  var protocol = typeof protocolSupplier === 'function' ? protocolSupplier() : '';
  return protocol && protocol.toLowerCase().indexOf('https') >= 0;
}

function verifyEncryptionSettings(encryptionOn, encryptionOff, secureProtocol) {
  if (encryptionOn && !secureProtocol) {
    // encryption explicitly turned on for a driver used on a HTTP web page
    console.warn('Neo4j driver is configured to use secure WebSocket on a HTTP web page. ' + 'WebSockets might not work in a mixed content environment. ' + 'Please consider configuring driver to not use encryption.');
  } else if (encryptionOff && secureProtocol) {
    // encryption explicitly turned off for a driver used on a HTTPS web page
    console.warn('Neo4j driver is configured to use insecure WebSocket on a HTTPS web page. ' + 'WebSockets might not work in a mixed content environment. ' + 'Please consider configuring driver to use encryption.');
  }
}

function detectWebPageProtocol() {
  return typeof window !== 'undefined' && window.location ? window.location.protocol : null;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/browser/browser-host-name-resolver.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/browser/browser-host-name-resolver.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _baseHostNameResolver = _interopRequireDefault(__webpack_require__(/*! ../resolver/base-host-name-resolver */ "./node_modules/neo4j-driver/lib/internal/resolver/base-host-name-resolver.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var BrowserHostNameResolver = /*#__PURE__*/function (_BaseHostNameResolver) {
  (0, _inherits2["default"])(BrowserHostNameResolver, _BaseHostNameResolver);

  var _super = _createSuper(BrowserHostNameResolver);

  function BrowserHostNameResolver() {
    (0, _classCallCheck2["default"])(this, BrowserHostNameResolver);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(BrowserHostNameResolver, [{
    key: "resolve",
    value: function resolve(address) {
      return this._resolveToItself(address);
    }
  }]);
  return BrowserHostNameResolver;
}(_baseHostNameResolver["default"]);

exports["default"] = BrowserHostNameResolver;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/browser/browser-utf8.js":
/*!************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/browser/browser-utf8.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _browserBuf = _interopRequireDefault(__webpack_require__(/*! ../browser/browser-buf */ "./node_modules/neo4j-driver/lib/internal/browser/browser-buf.js"));

var _textEncodingUtf = __webpack_require__(/*! text-encoding-utf-8 */ "./node_modules/text-encoding-utf-8/lib/encoding.lib.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var encoder = new _textEncodingUtf.TextEncoder('utf-8');
var decoder = new _textEncodingUtf.TextDecoder('utf-8');

function encode(str) {
  return new _browserBuf["default"](encoder.encode(str).buffer);
}

function decode(buffer, length) {
  if (buffer instanceof _browserBuf["default"]) {
    return decoder.decode(buffer.readView(Math.min(length, buffer.length - buffer.position)));
  } else {
    // Copy the given buffer into a regular buffer and decode that
    var tmpBuf = new _browserBuf["default"](length);

    for (var i = 0; i < length; i++) {
      tmpBuf.writeUInt8(buffer.readUInt8());
    }

    tmpBuf.reset();
    return decoder.decode(tmpBuf.readView(length));
  }
}

var _default = {
  encode: encode,
  decode: decode
};
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/browser/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/browser/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utf8 = exports.HostNameResolver = exports.Channel = exports.alloc = void 0;

var _browserBuf = _interopRequireDefault(__webpack_require__(/*! ./browser-buf */ "./node_modules/neo4j-driver/lib/internal/browser/browser-buf.js"));

var _browserChannel = _interopRequireDefault(__webpack_require__(/*! ./browser-channel */ "./node_modules/neo4j-driver/lib/internal/browser/browser-channel.js"));

var _browserHostNameResolver = _interopRequireDefault(__webpack_require__(/*! ./browser-host-name-resolver */ "./node_modules/neo4j-driver/lib/internal/browser/browser-host-name-resolver.js"));

var _browserUtf = _interopRequireDefault(__webpack_require__(/*! ./browser-utf8 */ "./node_modules/neo4j-driver/lib/internal/browser/browser-utf8.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*

This module exports a set of components to be used in browser environment.
They are not compatible with NodeJS environment.
All files import/require APIs from `node/index.js` by default.
Such imports are replaced at build time with `browser/index.js` when building a browser bundle.

NOTE: exports in this module should have exactly the same names/structure as exports in `node/index.js`.

 */
var alloc = function alloc(arg) {
  return new _browserBuf["default"](arg);
};

exports.alloc = alloc;
var Channel = _browserChannel["default"];
exports.Channel = Channel;
var HostNameResolver = _browserHostNameResolver["default"];
exports.HostNameResolver = HostNameResolver;
var utf8 = _browserUtf["default"];
exports.utf8 = utf8;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/buf/base-buf.js":
/*!****************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/buf/base-buf.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Common base with default implementation for most buffer methods.
 * Buffers are stateful - they track a current "position", this helps greatly
 * when reading and writing from them incrementally. You can also ignore the
 * stateful read/write methods.
 * readXXX and writeXXX-methods move the inner position of the buffer.
 * putXXX and getXXX-methods do not.
 * @access private
 */
var BaseBuffer = /*#__PURE__*/function () {
  /**
   * Create a instance with the injected size.
   * @constructor
   * @param {Integer} size
   */
  function BaseBuffer(size) {
    (0, _classCallCheck2["default"])(this, BaseBuffer);
    this.position = 0;
    this.length = size;
  }

  (0, _createClass2["default"])(BaseBuffer, [{
    key: "getUInt8",
    value: function getUInt8(position) {
      throw new Error('Not implemented');
    }
  }, {
    key: "getInt8",
    value: function getInt8(position) {
      throw new Error('Not implemented');
    }
  }, {
    key: "getFloat64",
    value: function getFloat64(position) {
      throw new Error('Not implemented');
    }
  }, {
    key: "putUInt8",
    value: function putUInt8(position, val) {
      throw new Error('Not implemented');
    }
  }, {
    key: "putInt8",
    value: function putInt8(position, val) {
      throw new Error('Not implemented');
    }
  }, {
    key: "putFloat64",
    value: function putFloat64(position, val) {
      throw new Error('Not implemented');
    }
    /**
     * @param p
     */

  }, {
    key: "getInt16",
    value: function getInt16(p) {
      return this.getInt8(p) << 8 | this.getUInt8(p + 1);
    }
    /**
     * @param p
     */

  }, {
    key: "getUInt16",
    value: function getUInt16(p) {
      return this.getUInt8(p) << 8 | this.getUInt8(p + 1);
    }
    /**
     * @param p
     */

  }, {
    key: "getInt32",
    value: function getInt32(p) {
      return this.getInt8(p) << 24 | this.getUInt8(p + 1) << 16 | this.getUInt8(p + 2) << 8 | this.getUInt8(p + 3);
    }
    /**
     * @param p
     */

  }, {
    key: "getUInt32",
    value: function getUInt32(p) {
      return this.getUInt8(p) << 24 | this.getUInt8(p + 1) << 16 | this.getUInt8(p + 2) << 8 | this.getUInt8(p + 3);
    }
    /**
     * @param p
     */

  }, {
    key: "getInt64",
    value: function getInt64(p) {
      return this.getInt8(p) << 56 | this.getUInt8(p + 1) << 48 | this.getUInt8(p + 2) << 40 | this.getUInt8(p + 3) << 32 | this.getUInt8(p + 4) << 24 | this.getUInt8(p + 5) << 16 | this.getUInt8(p + 6) << 8 | this.getUInt8(p + 7);
    }
    /**
     * Get a slice of this buffer. This method does not copy any data,
     * but simply provides a slice view of this buffer
     * @param start
     * @param length
     */

  }, {
    key: "getSlice",
    value: function getSlice(start, length) {
      return new SliceBuffer(start, length, this);
    }
    /**
     * @param p
     * @param val
     */

  }, {
    key: "putInt16",
    value: function putInt16(p, val) {
      this.putInt8(p, val >> 8);
      this.putUInt8(p + 1, val & 0xff);
    }
    /**
     * @param p
     * @param val
     */

  }, {
    key: "putUInt16",
    value: function putUInt16(p, val) {
      this.putUInt8(p, val >> 8 & 0xff);
      this.putUInt8(p + 1, val & 0xff);
    }
    /**
     * @param p
     * @param val
     */

  }, {
    key: "putInt32",
    value: function putInt32(p, val) {
      this.putInt8(p, val >> 24);
      this.putUInt8(p + 1, val >> 16 & 0xff);
      this.putUInt8(p + 2, val >> 8 & 0xff);
      this.putUInt8(p + 3, val & 0xff);
    }
    /**
     * @param p
     * @param val
     */

  }, {
    key: "putUInt32",
    value: function putUInt32(p, val) {
      this.putUInt8(p, val >> 24 & 0xff);
      this.putUInt8(p + 1, val >> 16 & 0xff);
      this.putUInt8(p + 2, val >> 8 & 0xff);
      this.putUInt8(p + 3, val & 0xff);
    }
    /**
     * @param p
     * @param val
     */

  }, {
    key: "putInt64",
    value: function putInt64(p, val) {
      this.putInt8(p, val >> 48);
      this.putUInt8(p + 1, val >> 42 & 0xff);
      this.putUInt8(p + 2, val >> 36 & 0xff);
      this.putUInt8(p + 3, val >> 30 & 0xff);
      this.putUInt8(p + 4, val >> 24 & 0xff);
      this.putUInt8(p + 5, val >> 16 & 0xff);
      this.putUInt8(p + 6, val >> 8 & 0xff);
      this.putUInt8(p + 7, val & 0xff);
    }
    /**
     * @param position
     * @param other
     */

  }, {
    key: "putBytes",
    value: function putBytes(position, other) {
      for (var i = 0, end = other.remaining(); i < end; i++) {
        this.putUInt8(position + i, other.readUInt8());
      }
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readUInt8",
    value: function readUInt8() {
      return this.getUInt8(this._updatePos(1));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readInt8",
    value: function readInt8() {
      return this.getInt8(this._updatePos(1));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readUInt16",
    value: function readUInt16() {
      return this.getUInt16(this._updatePos(2));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readUInt32",
    value: function readUInt32() {
      return this.getUInt32(this._updatePos(4));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readInt16",
    value: function readInt16() {
      return this.getInt16(this._updatePos(2));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readInt32",
    value: function readInt32() {
      return this.getInt32(this._updatePos(4));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readInt64",
    value: function readInt64() {
      return this.getInt32(this._updatePos(8));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readFloat64",
    value: function readFloat64() {
      return this.getFloat64(this._updatePos(8));
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeUInt8",
    value: function writeUInt8(val) {
      this.putUInt8(this._updatePos(1), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeInt8",
    value: function writeInt8(val) {
      this.putInt8(this._updatePos(1), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeInt16",
    value: function writeInt16(val) {
      this.putInt16(this._updatePos(2), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeInt32",
    value: function writeInt32(val) {
      this.putInt32(this._updatePos(4), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeUInt32",
    value: function writeUInt32(val) {
      this.putUInt32(this._updatePos(4), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeInt64",
    value: function writeInt64(val) {
      this.putInt64(this._updatePos(8), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeFloat64",
    value: function writeFloat64(val) {
      this.putFloat64(this._updatePos(8), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeBytes",
    value: function writeBytes(val) {
      this.putBytes(this._updatePos(val.remaining()), val);
    }
    /**
     * Get a slice of this buffer. This method does not copy any data,
     * but simply provides a slice view of this buffer
     * @param length
     */

  }, {
    key: "readSlice",
    value: function readSlice(length) {
      return this.getSlice(this._updatePos(length), length);
    }
  }, {
    key: "_updatePos",
    value: function _updatePos(length) {
      var p = this.position;
      this.position += length;
      return p;
    }
    /**
     * Get remaining
     */

  }, {
    key: "remaining",
    value: function remaining() {
      return this.length - this.position;
    }
    /**
     * Has remaining
     */

  }, {
    key: "hasRemaining",
    value: function hasRemaining() {
      return this.remaining() > 0;
    }
    /**
     * Reset position state
     */

  }, {
    key: "reset",
    value: function reset() {
      this.position = 0;
    }
    /**
     * Get string representation of buffer and it's state.
     * @return {string} Buffer as a string
     */

  }, {
    key: "toString",
    value: function toString() {
      return this.constructor.name + '( position=' + this.position + ' )\n  ' + this.toHex();
    }
    /**
     * Get string representation of buffer.
     * @return {string} Buffer as a string
     */

  }, {
    key: "toHex",
    value: function toHex() {
      var out = '';

      for (var i = 0; i < this.length; i++) {
        var hexByte = this.getUInt8(i).toString(16);

        if (hexByte.length === 1) {
          hexByte = '0' + hexByte;
        }

        out += hexByte;

        if (i !== this.length - 1) {
          out += ' ';
        }
      }

      return out;
    }
  }]);
  return BaseBuffer;
}();
/**
 * Represents a view as slice of another buffer.
 * @access private
 */


exports["default"] = BaseBuffer;

var SliceBuffer = /*#__PURE__*/function (_BaseBuffer) {
  (0, _inherits2["default"])(SliceBuffer, _BaseBuffer);

  var _super = _createSuper(SliceBuffer);

  function SliceBuffer(start, length, inner) {
    var _this;

    (0, _classCallCheck2["default"])(this, SliceBuffer);
    _this = _super.call(this, length);
    _this._start = start;
    _this._inner = inner;
    return _this;
  }

  (0, _createClass2["default"])(SliceBuffer, [{
    key: "putUInt8",
    value: function putUInt8(position, val) {
      this._inner.putUInt8(this._start + position, val);
    }
  }, {
    key: "getUInt8",
    value: function getUInt8(position) {
      return this._inner.getUInt8(this._start + position);
    }
  }, {
    key: "putInt8",
    value: function putInt8(position, val) {
      this._inner.putInt8(this._start + position, val);
    }
  }, {
    key: "putFloat64",
    value: function putFloat64(position, val) {
      this._inner.putFloat64(this._start + position, val);
    }
  }, {
    key: "getInt8",
    value: function getInt8(position) {
      return this._inner.getInt8(this._start + position);
    }
  }, {
    key: "getFloat64",
    value: function getFloat64(position) {
      return this._inner.getFloat64(this._start + position);
    }
  }]);
  return SliceBuffer;
}(BaseBuffer);

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/buf/combined-buf.js":
/*!********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/buf/combined-buf.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _baseBuf = _interopRequireDefault(__webpack_require__(/*! ./base-buf */ "./node_modules/neo4j-driver/lib/internal/buf/base-buf.js"));

var _node = __webpack_require__(/*! ../node */ "./node_modules/neo4j-driver/lib/internal/browser/index.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Buffer that combines multiple buffers, exposing them as one single buffer.
 */
var CombinedBuffer = /*#__PURE__*/function (_BaseBuffer) {
  (0, _inherits2["default"])(CombinedBuffer, _BaseBuffer);

  var _super = _createSuper(CombinedBuffer);

  function CombinedBuffer(buffers) {
    var _this;

    (0, _classCallCheck2["default"])(this, CombinedBuffer);
    var length = 0;

    for (var i = 0; i < buffers.length; i++) {
      length += buffers[i].length;
    }

    _this = _super.call(this, length);
    _this._buffers = buffers;
    return _this;
  }

  (0, _createClass2["default"])(CombinedBuffer, [{
    key: "getUInt8",
    value: function getUInt8(position) {
      // Surely there's a faster way to do this.. some sort of lookup table thing?
      for (var i = 0; i < this._buffers.length; i++) {
        var buffer = this._buffers[i]; // If the position is not in the current buffer, skip the current buffer

        if (position >= buffer.length) {
          position -= buffer.length;
        } else {
          return buffer.getUInt8(position);
        }
      }
    }
  }, {
    key: "getInt8",
    value: function getInt8(position) {
      // Surely there's a faster way to do this.. some sort of lookup table thing?
      for (var i = 0; i < this._buffers.length; i++) {
        var buffer = this._buffers[i]; // If the position is not in the current buffer, skip the current buffer

        if (position >= buffer.length) {
          position -= buffer.length;
        } else {
          return buffer.getInt8(position);
        }
      }
    }
  }, {
    key: "getFloat64",
    value: function getFloat64(position) {
      // At some point, a more efficient impl. For now, we copy the 8 bytes
      // we want to read and depend on the platform impl of IEEE 754.
      var b = (0, _node.alloc)(8);

      for (var i = 0; i < 8; i++) {
        b.putUInt8(i, this.getUInt8(position + i));
      }

      return b.getFloat64(0);
    }
  }]);
  return CombinedBuffer;
}(_baseBuf["default"]);

exports["default"] = CombinedBuffer;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/channel-config.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/channel-config.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _util = __webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_CONNECTION_TIMEOUT_MILLIS = 30000; // 30 seconds by default

var ALLOWED_VALUES_ENCRYPTED = [null, undefined, true, false, _util.ENCRYPTION_ON, _util.ENCRYPTION_OFF];
var ALLOWED_VALUES_TRUST = [null, undefined, 'TRUST_ALL_CERTIFICATES', 'TRUST_CUSTOM_CA_SIGNED_CERTIFICATES', 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES'];

var ChannelConfig =
/**
 * @constructor
 * @param {ServerAddress} address the address for the channel to connect to.
 * @param {Object} driverConfig the driver config provided by the user when driver is created.
 * @param {string} connectionErrorCode the default error code to use on connection errors.
 */
function ChannelConfig(address, driverConfig, connectionErrorCode) {
  (0, _classCallCheck2["default"])(this, ChannelConfig);
  this.address = address;
  this.encrypted = extractEncrypted(driverConfig);
  this.trust = extractTrust(driverConfig);
  this.trustedCertificates = extractTrustedCertificates(driverConfig);
  this.knownHostsPath = extractKnownHostsPath(driverConfig);
  this.connectionErrorCode = connectionErrorCode || _error.SERVICE_UNAVAILABLE;
  this.connectionTimeout = extractConnectionTimeout(driverConfig);
};

exports["default"] = ChannelConfig;

function extractEncrypted(driverConfig) {
  var value = driverConfig.encrypted;

  if (ALLOWED_VALUES_ENCRYPTED.indexOf(value) === -1) {
    throw (0, _error.newError)("Illegal value of the encrypted setting ".concat(value, ". Expected one of ").concat(ALLOWED_VALUES_ENCRYPTED));
  }

  return value;
}

function extractTrust(driverConfig) {
  var value = driverConfig.trust;

  if (ALLOWED_VALUES_TRUST.indexOf(value) === -1) {
    throw (0, _error.newError)("Illegal value of the trust setting ".concat(value, ". Expected one of ").concat(ALLOWED_VALUES_TRUST));
  }

  return value;
}

function extractTrustedCertificates(driverConfig) {
  return driverConfig.trustedCertificates || [];
}

function extractKnownHostsPath(driverConfig) {
  return driverConfig.knownHosts || null;
}

function extractConnectionTimeout(driverConfig) {
  var configuredTimeout = parseInt(driverConfig.connectionTimeout, 10);

  if (configuredTimeout === 0) {
    // timeout explicitly configured to 0
    return null;
  } else if (configuredTimeout && configuredTimeout < 0) {
    // timeout explicitly configured to a negative value
    return null;
  } else if (!configuredTimeout) {
    // timeout not configured, use default value
    return DEFAULT_CONNECTION_TIMEOUT_MILLIS;
  } else {
    // timeout configured, use the provided value
    return configuredTimeout;
  }
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/chunking.js":
/*!************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/chunking.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dechunker = exports.Chunker = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _baseBuf = _interopRequireDefault(__webpack_require__(/*! ./buf/base-buf */ "./node_modules/neo4j-driver/lib/internal/buf/base-buf.js"));

var _node = __webpack_require__(/*! ./node */ "./node_modules/neo4j-driver/lib/internal/browser/index.js");

var _combinedBuf = _interopRequireDefault(__webpack_require__(/*! ./buf/combined-buf */ "./node_modules/neo4j-driver/lib/internal/buf/combined-buf.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var _CHUNK_HEADER_SIZE = 2;
var _MESSAGE_BOUNDARY = 0x00;
var _DEFAULT_BUFFER_SIZE = 1400; // http://stackoverflow.com/questions/2613734/maximum-packet-size-for-a-tcp-connection

/**
 * Looks like a writable buffer, chunks output transparently into a channel below.
 * @access private
 */

var Chunker = /*#__PURE__*/function (_BaseBuffer) {
  (0, _inherits2["default"])(Chunker, _BaseBuffer);

  var _super = _createSuper(Chunker);

  function Chunker(channel, bufferSize) {
    var _this;

    (0, _classCallCheck2["default"])(this, Chunker);
    _this = _super.call(this, 0);
    _this._bufferSize = bufferSize || _DEFAULT_BUFFER_SIZE;
    _this._ch = channel;
    _this._buffer = (0, _node.alloc)(_this._bufferSize);
    _this._currentChunkStart = 0;
    _this._chunkOpen = false;
    return _this;
  }

  (0, _createClass2["default"])(Chunker, [{
    key: "putUInt8",
    value: function putUInt8(position, val) {
      this._ensure(1);

      this._buffer.writeUInt8(val);
    }
  }, {
    key: "putInt8",
    value: function putInt8(position, val) {
      this._ensure(1);

      this._buffer.writeInt8(val);
    }
  }, {
    key: "putFloat64",
    value: function putFloat64(position, val) {
      this._ensure(8);

      this._buffer.writeFloat64(val);
    }
  }, {
    key: "putBytes",
    value: function putBytes(position, data) {
      // TODO: If data is larger than our chunk size or so, we're very likely better off just passing this buffer on
      // rather than doing the copy here TODO: *however* note that we need some way to find out when the data has been
      // written (and thus the buffer can be re-used) if we take that approach
      while (data.remaining() > 0) {
        // Ensure there is an open chunk, and that it has at least one byte of space left
        this._ensure(1);

        if (this._buffer.remaining() > data.remaining()) {
          this._buffer.writeBytes(data);
        } else {
          this._buffer.writeBytes(data.readSlice(this._buffer.remaining()));
        }
      }

      return this;
    }
  }, {
    key: "flush",
    value: function flush() {
      if (this._buffer.position > 0) {
        this._closeChunkIfOpen(); // Local copy and clear the buffer field. This ensures that the buffer is not re-released if the flush call fails


        var out = this._buffer;
        this._buffer = null;

        this._ch.write(out.getSlice(0, out.position)); // Alloc a new output buffer. We assume we're using NodeJS's buffer pooling under the hood here!


        this._buffer = (0, _node.alloc)(this._bufferSize);
        this._chunkOpen = false;
      }

      return this;
    }
    /**
     * Bolt messages are encoded in one or more chunks, and the boundary between two messages
     * is encoded as a 0-length chunk, `00 00`. This inserts such a message boundary, closing
     * any currently open chunk as needed
     */

  }, {
    key: "messageBoundary",
    value: function messageBoundary() {
      this._closeChunkIfOpen();

      if (this._buffer.remaining() < _CHUNK_HEADER_SIZE) {
        this.flush();
      } // Write message boundary


      this._buffer.writeInt16(_MESSAGE_BOUNDARY);
    }
    /** Ensure at least the given size is available for writing */

  }, {
    key: "_ensure",
    value: function _ensure(size) {
      var toWriteSize = this._chunkOpen ? size : size + _CHUNK_HEADER_SIZE;

      if (this._buffer.remaining() < toWriteSize) {
        this.flush();
      }

      if (!this._chunkOpen) {
        this._currentChunkStart = this._buffer.position;
        this._buffer.position = this._buffer.position + _CHUNK_HEADER_SIZE;
        this._chunkOpen = true;
      }
    }
  }, {
    key: "_closeChunkIfOpen",
    value: function _closeChunkIfOpen() {
      if (this._chunkOpen) {
        var chunkSize = this._buffer.position - (this._currentChunkStart + _CHUNK_HEADER_SIZE);

        this._buffer.putUInt16(this._currentChunkStart, chunkSize);

        this._chunkOpen = false;
      }
    }
  }]);
  return Chunker;
}(_baseBuf["default"]);
/**
 * Combines chunks until a complete message is gathered up, and then forwards that
 * message to an 'onmessage' listener.
 * @access private
 */


exports.Chunker = Chunker;

var Dechunker = /*#__PURE__*/function () {
  function Dechunker() {
    (0, _classCallCheck2["default"])(this, Dechunker);
    this._currentMessage = [];
    this._partialChunkHeader = 0;
    this._state = this.AWAITING_CHUNK;
  }

  (0, _createClass2["default"])(Dechunker, [{
    key: "AWAITING_CHUNK",
    value: function AWAITING_CHUNK(buf) {
      if (buf.remaining() >= 2) {
        // Whole header available, read that
        return this._onHeader(buf.readUInt16());
      } else {
        // Only one byte available, read that and wait for the second byte
        this._partialChunkHeader = buf.readUInt8() << 8;
        return this.IN_HEADER;
      }
    }
  }, {
    key: "IN_HEADER",
    value: function IN_HEADER(buf) {
      // First header byte read, now we read the next one
      return this._onHeader((this._partialChunkHeader | buf.readUInt8()) & 0xffff);
    }
  }, {
    key: "IN_CHUNK",
    value: function IN_CHUNK(buf) {
      if (this._chunkSize <= buf.remaining()) {
        // Current packet is larger than current chunk, or same size:
        this._currentMessage.push(buf.readSlice(this._chunkSize));

        return this.AWAITING_CHUNK;
      } else {
        // Current packet is smaller than the chunk we're reading, split the current chunk itself up
        this._chunkSize -= buf.remaining();

        this._currentMessage.push(buf.readSlice(buf.remaining()));

        return this.IN_CHUNK;
      }
    }
  }, {
    key: "CLOSED",
    value: function CLOSED(buf) {} // no-op

    /** Called when a complete chunk header has been received */

  }, {
    key: "_onHeader",
    value: function _onHeader(header) {
      if (header === 0) {
        // Message boundary
        var message;

        switch (this._currentMessage.length) {
          case 0:
            // Keep alive chunk, sent by server to keep network alive.
            return this.AWAITING_CHUNK;

          case 1:
            // All data in one chunk, this signals the end of that chunk.
            message = this._currentMessage[0];
            break;

          default:
            // A large chunk of data received, this signals that the last chunk has been received.
            message = new _combinedBuf["default"](this._currentMessage);
            break;
        }

        this._currentMessage = [];
        this.onmessage(message);
        return this.AWAITING_CHUNK;
      } else {
        this._chunkSize = header;
        return this.IN_CHUNK;
      }
    }
  }, {
    key: "write",
    value: function write(buf) {
      while (buf.hasRemaining()) {
        this._state = this._state(buf);
      }
    }
  }]);
  return Dechunker;
}();

exports.Dechunker = Dechunker;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-channel.js":
/*!**********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-channel.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _node = __webpack_require__(/*! ./node */ "./node_modules/neo4j-driver/lib/internal/browser/index.js");

var _chunking = __webpack_require__(/*! ./chunking */ "./node_modules/neo4j-driver/lib/internal/chunking.js");

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _channelConfig = _interopRequireDefault(__webpack_require__(/*! ./channel-config */ "./node_modules/neo4j-driver/lib/internal/channel-config.js"));

var _protocolHandshaker = _interopRequireDefault(__webpack_require__(/*! ./protocol-handshaker */ "./node_modules/neo4j-driver/lib/internal/protocol-handshaker.js"));

var _connection = _interopRequireDefault(__webpack_require__(/*! ./connection */ "./node_modules/neo4j-driver/lib/internal/connection.js"));

var _boltProtocolV = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v1 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v1.js"));

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

// Signature bytes for each response message type
var SUCCESS = 0x70; // 0111 0000 // SUCCESS <metadata>

var RECORD = 0x71; // 0111 0001 // RECORD <value>

var IGNORED = 0x7e; // 0111 1110 // IGNORED <metadata>

var FAILURE = 0x7f; // 0111 1111 // FAILURE <metadata>

function NO_OP() {}

var NO_OP_OBSERVER = {
  onNext: NO_OP,
  onCompleted: NO_OP,
  onError: NO_OP
};
var idGenerator = 0;

var ChannelConnection = /*#__PURE__*/function (_Connection) {
  (0, _inherits2["default"])(ChannelConnection, _Connection);

  var _super = _createSuper(ChannelConnection);

  /**
   * @constructor
   * @param {Channel} channel - channel with a 'write' function and a 'onmessage' callback property.
   * @param {ConnectionErrorHandler} errorHandler the error handler.
   * @param {ServerAddress} address - the server address to connect to.
   * @param {Logger} log - the configured logger.
   * @param {boolean} disableLosslessIntegers if this connection should convert all received integers to native JS numbers.
   */
  function ChannelConnection(channel, errorHandler, address, log) {
    var _this;

    var disableLosslessIntegers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var serversideRouting = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    (0, _classCallCheck2["default"])(this, ChannelConnection);
    _this = _super.call(this, errorHandler);
    _this._id = idGenerator++;
    _this._address = address;
    _this._server = {
      address: address.asHostPort()
    };
    _this.creationTimestamp = Date.now();
    _this._disableLosslessIntegers = disableLosslessIntegers;
    _this._pendingObservers = [];
    _this._currentObserver = undefined;
    _this._ch = channel;
    _this._dechunker = new _chunking.Dechunker();
    _this._chunker = new _chunking.Chunker(channel);
    _this._log = log;
    _this._serversideRouting = serversideRouting; // connection from the database, returned in response for HELLO message and might not be available

    _this._dbConnectionId = null; // bolt protocol is initially not initialized

    /**
     * @private
     * @type {BoltProtocol}
     */

    _this._protocol = null; // error extracted from a FAILURE message

    _this._currentFailure = null; // Set to true on fatal errors, to get this out of connection pool.

    _this._isBroken = false;

    if (_this._log.isDebugEnabled()) {
      _this._log.debug("".concat((0, _assertThisInitialized2["default"])(_this), " created towards ").concat(address));
    }

    return _this;
  }
  /**
   * Crete new connection to the provided address. Returned connection is not connected.
   * @param {ServerAddress} address - the Bolt endpoint to connect to.
   * @param {Object} config - the driver configuration.
   * @param {ConnectionErrorHandler} errorHandler - the error handler for connection errors.
   * @param {Logger} log - configured logger.
   * @return {Connection} - new connection.
   */


  (0, _createClass2["default"])(ChannelConnection, [{
    key: "connect",

    /**
     * Connect to the target address, negotiate Bolt protocol and send initialization message.
     * @param {string} userAgent the user agent for this driver.
     * @param {Object} authToken the object containing auth information.
     * @return {Promise<Connection>} promise resolved with the current connection if connection is successful. Rejected promise otherwise.
     */
    value: function connect(userAgent, authToken) {
      var _this2 = this;

      return this._negotiateProtocol().then(function () {
        return _this2._initialize(userAgent, authToken);
      });
    }
    /**
     * Execute Bolt protocol handshake to initialize the protocol version.
     * @return {Promise<Connection>} promise resolved with the current connection if handshake is successful. Rejected promise otherwise.
     */

  }, {
    key: "_negotiateProtocol",
    value: function _negotiateProtocol() {
      var _this3 = this;

      var protocolHandshaker = new _protocolHandshaker["default"](this, this._ch, this._chunker, this._disableLosslessIntegers, this._log, this._serversideRouting);
      return new Promise(function (resolve, reject) {
        var handshakeErrorHandler = function handshakeErrorHandler(error) {
          _this3._handleFatalError(error);

          reject(error);
        };

        _this3._ch.onerror = handshakeErrorHandler.bind(_this3);

        if (_this3._ch._error) {
          // channel is already broken
          handshakeErrorHandler(_this3._ch._error);
        }

        _this3._ch.onmessage = function (buffer) {
          try {
            // read the response buffer and initialize the protocol
            _this3._protocol = protocolHandshaker.createNegotiatedProtocol(buffer); // reset the error handler to just handle errors and forget about the handshake promise

            _this3._ch.onerror = _this3._handleFatalError.bind(_this3); // Ok, protocol running. Simply forward all messages to the dechunker

            _this3._ch.onmessage = function (buf) {
              return _this3._dechunker.write(buf);
            }; // setup dechunker to dechunk messages and forward them to the message handler


            _this3._dechunker.onmessage = function (buf) {
              _this3._handleMessage(_this3._protocol.unpacker().unpack(buf));
            }; // forward all pending bytes to the dechunker


            if (buffer.hasRemaining()) {
              _this3._dechunker.write(buffer.readSlice(buffer.remaining()));
            }

            resolve(_this3);
          } catch (e) {
            _this3._handleFatalError(e);

            reject(e);
          }
        };

        protocolHandshaker.writeHandshakeRequest();
      });
    }
    /**
     * Perform protocol-specific initialization which includes authentication.
     * @param {string} userAgent the user agent for this driver.
     * @param {Object} authToken the object containing auth information.
     * @return {Promise<Connection>} promise resolved with the current connection if initialization is successful. Rejected promise otherwise.
     */

  }, {
    key: "_initialize",
    value: function _initialize(userAgent, authToken) {
      var _this4 = this;

      var self = this;
      return new Promise(function (resolve, reject) {
        _this4._protocol.initialize({
          userAgent: userAgent,
          authToken: authToken,
          onError: function onError(err) {
            return reject(err);
          },
          onComplete: function onComplete() {
            return resolve(self);
          }
        });
      });
    }
    /**
     * Get the Bolt protocol for the connection.
     * @return {BoltProtocol} the protocol.
     */

  }, {
    key: "protocol",
    value: function protocol() {
      return this._protocol;
    }
  }, {
    key: "write",

    /**
     * Write a message to the network channel.
     * @param {RequestMessage} message the message to write.
     * @param {ResultStreamObserver} observer the response observer.
     * @param {boolean} flush `true` if flush should happen after the message is written to the buffer.
     */
    value: function write(message, observer, flush) {
      var _this5 = this;

      var queued = this._queueObserver(observer);

      if (queued) {
        if (this._log.isDebugEnabled()) {
          this._log.debug("".concat(this, " C: ").concat(message));
        }

        this._protocol.packer().packStruct(message.signature, message.fields.map(function (field) {
          return _this5._packable(field);
        }));

        this._chunker.messageBoundary();

        if (flush) {
          this._chunker.flush();
        }
      }
    }
    /**
     * "Fatal" means the connection is dead. Only call this if something
     * happens that cannot be recovered from. This will lead to all subscribers
     * failing, and the connection getting ejected from the session pool.
     *
     * @param error an error object, forwarded to all current and future subscribers
     */

  }, {
    key: "_handleFatalError",
    value: function _handleFatalError(error) {
      this._isBroken = true;
      this._error = this.handleAndTransformError(error, this._address);

      if (this._log.isErrorEnabled()) {
        this._log.error("".concat(this, " experienced a fatal error ").concat(JSON.stringify(this._error)));
      }

      if (this._currentObserver && this._currentObserver.onError) {
        this._currentObserver.onError(this._error);
      }

      while (this._pendingObservers.length > 0) {
        var observer = this._pendingObservers.shift();

        if (observer && observer.onError) {
          observer.onError(this._error);
        }
      }
    }
  }, {
    key: "_handleMessage",
    value: function _handleMessage(msg) {
      if (this._isBroken) {
        // ignore all incoming messages when this connection is broken. all previously pending observers failed
        // with the fatal error. all future observers will fail with same fatal error.
        return;
      }

      var payload = msg.fields[0];

      switch (msg.signature) {
        case RECORD:
          if (this._log.isDebugEnabled()) {
            this._log.debug("".concat(this, " S: RECORD ").concat(JSON.stringify(msg)));
          }

          this._currentObserver.onNext(payload);

          break;

        case SUCCESS:
          if (this._log.isDebugEnabled()) {
            this._log.debug("".concat(this, " S: SUCCESS ").concat(JSON.stringify(msg)));
          }

          try {
            var metadata = this._protocol.transformMetadata(payload);

            this._currentObserver.onCompleted(metadata);
          } finally {
            this._updateCurrentObserver();
          }

          break;

        case FAILURE:
          if (this._log.isDebugEnabled()) {
            this._log.debug("".concat(this, " S: FAILURE ").concat(JSON.stringify(msg)));
          }

          try {
            var error = (0, _error.newError)(payload.message, payload.code);
            this._currentFailure = this.handleAndTransformError(error, this._address);

            this._currentObserver.onError(this._currentFailure);
          } finally {
            this._updateCurrentObserver(); // Things are now broken. Pending observers will get FAILURE messages routed until we are done handling this failure.


            this._resetOnFailure();
          }

          break;

        case IGNORED:
          if (this._log.isDebugEnabled()) {
            this._log.debug("".concat(this, " S: IGNORED ").concat(JSON.stringify(msg)));
          }

          try {
            if (this._currentFailure && this._currentObserver.onError) {
              this._currentObserver.onError(this._currentFailure);
            } else if (this._currentObserver.onError) {
              this._currentObserver.onError((0, _error.newError)('Ignored either because of an error or RESET'));
            }
          } finally {
            this._updateCurrentObserver();
          }

          break;

        default:
          this._handleFatalError((0, _error.newError)('Unknown Bolt protocol message: ' + msg));

      }
    }
    /**
     * Send a RESET-message to the database. Message is immediately flushed to the network.
     * @return {Promise<void>} promise resolved when SUCCESS-message response arrives, or failed when other response messages arrives.
     */

  }, {
    key: "resetAndFlush",
    value: function resetAndFlush() {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        _this6._protocol.reset({
          onError: function onError(error) {
            if (_this6._isBroken) {
              // handling a fatal error, no need to raise a protocol violation
              reject(error);
            } else {
              var neo4jError = _this6._handleProtocolError('Received FAILURE as a response for RESET: ' + error);

              reject(neo4jError);
            }
          },
          onComplete: function onComplete() {
            resolve();
          }
        });
      });
    }
  }, {
    key: "_resetOnFailure",
    value: function _resetOnFailure() {
      var _this7 = this;

      this._protocol.reset({
        onError: function onError() {
          _this7._currentFailure = null;
        },
        onComplete: function onComplete() {
          _this7._currentFailure = null;
        }
      });
    }
  }, {
    key: "_queueObserver",
    value: function _queueObserver(observer) {
      if (this._isBroken) {
        if (observer && observer.onError) {
          observer.onError(this._error);
        }

        return false;
      }

      observer = observer || NO_OP_OBSERVER;
      observer.onCompleted = observer.onCompleted || NO_OP;
      observer.onError = observer.onError || NO_OP;
      observer.onNext = observer.onNext || NO_OP;

      if (this._currentObserver === undefined) {
        this._currentObserver = observer;
      } else {
        this._pendingObservers.push(observer);
      }

      return true;
    }
    /*
     * Pop next pending observer form the list of observers and make it current observer.
     * @protected
     */

  }, {
    key: "_updateCurrentObserver",
    value: function _updateCurrentObserver() {
      this._currentObserver = this._pendingObservers.shift();
    }
    /** Check if this connection is in working condition */

  }, {
    key: "isOpen",
    value: function isOpen() {
      return !this._isBroken && this._ch._open;
    }
    /**
     * Call close on the channel.
     * @returns {Promise<void>} - A promise that will be resolved when the underlying channel is closed.
     */

  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(this, " closing"));
                }

                if (this._protocol && this.isOpen()) {
                  // protocol has been initialized and this connection is healthy
                  // notify the database about the upcoming close of the connection
                  this._protocol.prepareToClose();
                }

                _context.next = 4;
                return this._ch.close();

              case 4:
                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(this, " closed"));
                }

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "toString",
    value: function toString() {
      return "Connection [".concat(this.id, "][").concat(this.databaseId || '', "]");
    }
  }, {
    key: "_packable",
    value: function _packable(value) {
      return this._protocol.packer().packable(value);
    }
  }, {
    key: "_handleProtocolError",
    value: function _handleProtocolError(message) {
      this._currentFailure = null;

      this._updateCurrentObserver();

      var error = (0, _error.newError)(message, _error.PROTOCOL_ERROR);

      this._handleFatalError(error);

      return error;
    }
  }, {
    key: "id",
    get: function get() {
      return this._id;
    }
  }, {
    key: "databaseId",
    get: function get() {
      return this._dbConnectionId;
    },
    set: function set(value) {
      this._dbConnectionId = value;
    }
  }, {
    key: "address",
    get: function get() {
      return this._address;
    }
    /**
     * Get the version of the connected server.
     * Available only after initialization
     *
     * @returns {ServerVersion} version
     */

  }, {
    key: "version",
    get: function get() {
      return this._server.version;
    },
    set: function set(value) {
      this._server.version = value;
    }
  }, {
    key: "server",
    get: function get() {
      return this._server;
    }
  }], [{
    key: "create",
    value: function create(address, config, errorHandler, log) {
      var serversideRouting = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var channelConfig = new _channelConfig["default"](address, config, errorHandler.errorCode());
      return new ChannelConnection(new _node.Channel(channelConfig), errorHandler, address, log, config.disableLosslessIntegers, serversideRouting);
    }
  }]);
  return ChannelConnection;
}(_connection["default"]);

exports["default"] = ChannelConnection;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-delegate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-delegate.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _connection = _interopRequireDefault(__webpack_require__(/*! ./connection */ "./node_modules/neo4j-driver/lib/internal/connection.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var DelegateConnection = /*#__PURE__*/function (_Connection) {
  (0, _inherits2["default"])(DelegateConnection, _Connection);

  var _super = _createSuper(DelegateConnection);

  /**
   * @param delegate {Connection} the delegated connection
   * @param errorHandler {ConnectionErrorHandler} the error handler
   */
  function DelegateConnection(delegate, errorHandler) {
    var _this;

    (0, _classCallCheck2["default"])(this, DelegateConnection);
    _this = _super.call(this, errorHandler);

    if (errorHandler) {
      _this._originalErrorHandler = delegate._errorHandler;
      delegate._errorHandler = _this._errorHandler;
    }

    _this._delegate = delegate;
    return _this;
  }

  (0, _createClass2["default"])(DelegateConnection, [{
    key: "isOpen",
    value: function isOpen() {
      return this._delegate.isOpen();
    }
  }, {
    key: "protocol",
    value: function protocol() {
      return this._delegate.protocol();
    }
  }, {
    key: "connect",
    value: function connect(userAgent, authToken) {
      return this._delegate.connect(userAgent, authToken);
    }
  }, {
    key: "write",
    value: function write(message, observer, flush) {
      return this._delegate.write(message, observer, flush);
    }
  }, {
    key: "resetAndFlush",
    value: function resetAndFlush() {
      return this._delegate.resetAndFlush();
    }
  }, {
    key: "close",
    value: function close() {
      return this._delegate.close();
    }
  }, {
    key: "_release",
    value: function _release() {
      if (this._originalErrorHandler) {
        this._delegate._errorHandler = this._originalErrorHandler;
      }

      return this._delegate._release();
    }
  }, {
    key: "id",
    get: function get() {
      return this._delegate.id;
    }
  }, {
    key: "databaseId",
    get: function get() {
      return this._delegate.databaseId;
    },
    set: function set(value) {
      this._delegate.databaseId = value;
    }
  }, {
    key: "server",
    get: function get() {
      return this._delegate.server;
    }
  }, {
    key: "address",
    get: function get() {
      return this._delegate.address;
    }
  }, {
    key: "version",
    get: function get() {
      return this._delegate.version;
    },
    set: function set(value) {
      this._delegate.version = value;
    }
  }]);
  return DelegateConnection;
}(_connection["default"]);

exports["default"] = DelegateConnection;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-error-handler.js":
/*!****************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-error-handler.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ConnectionErrorHandler = /*#__PURE__*/function () {
  function ConnectionErrorHandler(errorCode, handleUnavailability, handleWriteFailure) {
    (0, _classCallCheck2["default"])(this, ConnectionErrorHandler);
    this._errorCode = errorCode;
    this._handleUnavailability = handleUnavailability || noOpHandler;
    this._handleWriteFailure = handleWriteFailure || noOpHandler;
  }
  /**
   * Error code to use for network errors.
   * @return {string} the error code.
   */


  (0, _createClass2["default"])(ConnectionErrorHandler, [{
    key: "errorCode",
    value: function errorCode() {
      return this._errorCode;
    }
    /**
     * Handle and transform the error.
     * @param {Neo4jError} error the original error.
     * @param {ServerAddress} address the address of the connection where the error happened.
     * @return {Neo4jError} new error that should be propagated to the user.
     */

  }, {
    key: "handleAndTransformError",
    value: function handleAndTransformError(error, address) {
      if (isAvailabilityError(error)) {
        return this._handleUnavailability(error, address);
      }

      if (isFailureToWrite(error)) {
        return this._handleWriteFailure(error, address);
      }

      return error;
    }
  }]);
  return ConnectionErrorHandler;
}();

exports["default"] = ConnectionErrorHandler;

function isAvailabilityError(error) {
  if (error) {
    return error.code === _error.SESSION_EXPIRED || error.code === _error.SERVICE_UNAVAILABLE || error.code === 'Neo.TransientError.General.DatabaseUnavailable';
  }

  return false;
}

function isFailureToWrite(error) {
  if (error) {
    return error.code === 'Neo.ClientError.Cluster.NotALeader' || error.code === 'Neo.ClientError.General.ForbiddenOnReadOnlyDatabase';
  }

  return false;
}

function noOpHandler(error) {
  return error;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-holder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-holder.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EMPTY_CONNECTION_HOLDER = exports["default"] = void 0;

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _util = __webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js");

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Utility to lazily initialize connections and return them back to the pool when unused.
 */
var ConnectionHolder = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {string} mode - the access mode for new connection holder.
   * @param {string} database - the target database name.
   * @param {ConnectionProvider} connectionProvider - the connection provider to acquire connections from.
   */
  function ConnectionHolder() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$mode = _ref.mode,
        mode = _ref$mode === void 0 ? _constants.ACCESS_MODE_WRITE : _ref$mode,
        _ref$database = _ref.database,
        database = _ref$database === void 0 ? '' : _ref$database,
        bookmark = _ref.bookmark,
        connectionProvider = _ref.connectionProvider;

    (0, _classCallCheck2["default"])(this, ConnectionHolder);
    this._mode = mode;
    this._database = database ? (0, _util.assertString)(database, 'database') : '';
    this._bookmark = bookmark || _bookmark["default"].empty();
    this._connectionProvider = connectionProvider;
    this._referenceCount = 0;
    this._connectionPromise = Promise.resolve(null);
  }
  /**
   * Returns the assigned access mode.
   * @returns {string} access mode
   */


  (0, _createClass2["default"])(ConnectionHolder, [{
    key: "mode",
    value: function mode() {
      return this._mode;
    }
    /**
     * Returns the target database name
     * @returns {string} the database name
     */

  }, {
    key: "database",
    value: function database() {
      return this._database;
    }
    /**
     * Make this holder initialize new connection if none exists already.
     * @return {boolean}
     */

  }, {
    key: "initializeConnection",
    value: function initializeConnection() {
      if (this._referenceCount === 0) {
        this._connectionPromise = this._connectionProvider.acquireConnection({
          accessMode: this._mode,
          database: this._database,
          bookmark: this._bookmark
        });
      } else {
        this._referenceCount++;
        return false;
      }

      this._referenceCount++;
      return true;
    }
    /**
     * Get the current connection promise.
     * @return {Promise<Connection>} promise resolved with the current connection.
     */

  }, {
    key: "getConnection",
    value: function getConnection() {
      return this._connectionPromise;
    }
    /**
     * Notify this holder that single party does not require current connection any more.
     * @return {Promise<Connection>} promise resolved with the current connection, never a rejected promise.
     */

  }, {
    key: "releaseConnection",
    value: function releaseConnection() {
      if (this._referenceCount === 0) {
        return this._connectionPromise;
      }

      this._referenceCount--;

      if (this._referenceCount === 0) {
        return this._releaseConnection();
      }

      return this._connectionPromise;
    }
    /**
     * Closes this holder and releases current connection (if any) despite any existing users.
     * @return {Promise<Connection>} promise resolved when current connection is released to the pool.
     */

  }, {
    key: "close",
    value: function close() {
      if (this._referenceCount === 0) {
        return this._connectionPromise;
      }

      this._referenceCount = 0;
      return this._releaseConnection();
    }
    /**
     * Return the current pooled connection instance to the connection pool.
     * We don't pool Session instances, to avoid users using the Session after they've called close.
     * The `Session` object is just a thin wrapper around Connection anyway, so it makes little difference.
     * @return {Promise} - promise resolved then connection is returned to the pool.
     * @private
     */

  }, {
    key: "_releaseConnection",
    value: function _releaseConnection() {
      this._connectionPromise = this._connectionPromise.then(function (connection) {
        if (connection) {
          return connection.resetAndFlush()["catch"](ignoreError).then(function () {
            return connection._release();
          });
        } else {
          return Promise.resolve();
        }
      })["catch"](ignoreError);
      return this._connectionPromise;
    }
  }]);
  return ConnectionHolder;
}();

exports["default"] = ConnectionHolder;

var EmptyConnectionHolder = /*#__PURE__*/function (_ConnectionHolder) {
  (0, _inherits2["default"])(EmptyConnectionHolder, _ConnectionHolder);

  var _super = _createSuper(EmptyConnectionHolder);

  function EmptyConnectionHolder() {
    (0, _classCallCheck2["default"])(this, EmptyConnectionHolder);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(EmptyConnectionHolder, [{
    key: "initializeConnection",
    value: function initializeConnection() {
      // nothing to initialize
      return true;
    }
  }, {
    key: "getConnection",
    value: function getConnection() {
      return Promise.reject((0, _error.newError)('This connection holder does not serve connections'));
    }
  }, {
    key: "releaseConnection",
    value: function releaseConnection() {
      return Promise.resolve();
    }
  }, {
    key: "close",
    value: function close() {
      return Promise.resolve();
    }
  }]);
  return EmptyConnectionHolder;
}(ConnectionHolder); // eslint-disable-next-line handle-callback-err


function ignoreError(error) {}
/**
 * Connection holder that does not manage any connections.
 * @type {ConnectionHolder}
 */


var EMPTY_CONNECTION_HOLDER = new EmptyConnectionHolder();
exports.EMPTY_CONNECTION_HOLDER = EMPTY_CONNECTION_HOLDER;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-provider-direct.js":
/*!******************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-provider-direct.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _connectionProviderPooled = _interopRequireDefault(__webpack_require__(/*! ./connection-provider-pooled */ "./node_modules/neo4j-driver/lib/internal/connection-provider-pooled.js"));

var _connectionDelegate = _interopRequireDefault(__webpack_require__(/*! ./connection-delegate */ "./node_modules/neo4j-driver/lib/internal/connection-delegate.js"));

var _connectionChannel = _interopRequireDefault(__webpack_require__(/*! ./connection-channel */ "./node_modules/neo4j-driver/lib/internal/connection-channel.js"));

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var DirectConnectionProvider = /*#__PURE__*/function (_PooledConnectionProv) {
  (0, _inherits2["default"])(DirectConnectionProvider, _PooledConnectionProv);

  var _super = _createSuper(DirectConnectionProvider);

  function DirectConnectionProvider(_ref) {
    var _this;

    var id = _ref.id,
        config = _ref.config,
        log = _ref.log,
        address = _ref.address,
        userAgent = _ref.userAgent,
        authToken = _ref.authToken;
    (0, _classCallCheck2["default"])(this, DirectConnectionProvider);
    _this = _super.call(this, {
      id: id,
      config: config,
      log: log,
      userAgent: userAgent,
      authToken: authToken
    });
    _this._address = address;
    return _this;
  }
  /**
   * See {@link ConnectionProvider} for more information about this method and
   * its arguments.
   */


  (0, _createClass2["default"])(DirectConnectionProvider, [{
    key: "acquireConnection",
    value: function acquireConnection() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          accessMode = _ref2.accessMode,
          database = _ref2.database,
          bookmarks = _ref2.bookmarks;

      return this._connectionPool.acquire(this._address).then(function (connection) {
        return new _connectionDelegate["default"](connection, null);
      });
    }
  }, {
    key: "_hasProtocolVersion",
    value: function () {
      var _hasProtocolVersion2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(versionPredicate) {
        var connection, protocol;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                connection = _connectionChannel["default"].create(this._address, this._config, this._createConnectionErrorHandler(), this._log);
                _context.prev = 1;
                _context.next = 4;
                return connection._negotiateProtocol();

              case 4:
                protocol = connection.protocol();

                if (!protocol) {
                  _context.next = 7;
                  break;
                }

                return _context.abrupt("return", versionPredicate(protocol.version));

              case 7:
                return _context.abrupt("return", false);

              case 8:
                _context.prev = 8;
                _context.next = 11;
                return connection.close();

              case 11:
                return _context.finish(8);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1,, 8, 12]]);
      }));

      function _hasProtocolVersion(_x) {
        return _hasProtocolVersion2.apply(this, arguments);
      }

      return _hasProtocolVersion;
    }()
  }, {
    key: "supportsMultiDb",
    value: function () {
      var _supportsMultiDb = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._hasProtocolVersion(function (version) {
                  return version >= _constants.BOLT_PROTOCOL_V4_0;
                });

              case 2:
                return _context2.abrupt("return", _context2.sent);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function supportsMultiDb() {
        return _supportsMultiDb.apply(this, arguments);
      }

      return supportsMultiDb;
    }()
  }, {
    key: "supportsTransactionConfig",
    value: function () {
      var _supportsTransactionConfig = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._hasProtocolVersion(function (version) {
                  return version >= _constants.BOLT_PROTOCOL_V3;
                });

              case 2:
                return _context3.abrupt("return", _context3.sent);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function supportsTransactionConfig() {
        return _supportsTransactionConfig.apply(this, arguments);
      }

      return supportsTransactionConfig;
    }()
  }]);
  return DirectConnectionProvider;
}(_connectionProviderPooled["default"]);

exports["default"] = DirectConnectionProvider;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-provider-pooled.js":
/*!******************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-provider-pooled.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _connectionChannel = _interopRequireDefault(__webpack_require__(/*! ./connection-channel */ "./node_modules/neo4j-driver/lib/internal/connection-channel.js"));

var _pool = _interopRequireDefault(__webpack_require__(/*! ./pool */ "./node_modules/neo4j-driver/lib/internal/pool.js"));

var _poolConfig = _interopRequireDefault(__webpack_require__(/*! ./pool-config */ "./node_modules/neo4j-driver/lib/internal/pool-config.js"));

var _connectionErrorHandler = _interopRequireDefault(__webpack_require__(/*! ./connection-error-handler */ "./node_modules/neo4j-driver/lib/internal/connection-error-handler.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _connectionProvider = _interopRequireDefault(__webpack_require__(/*! ./connection-provider */ "./node_modules/neo4j-driver/lib/internal/connection-provider.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var PooledConnectionProvider = /*#__PURE__*/function (_ConnectionProvider) {
  (0, _inherits2["default"])(PooledConnectionProvider, _ConnectionProvider);

  var _super = _createSuper(PooledConnectionProvider);

  function PooledConnectionProvider(_ref) {
    var _this;

    var id = _ref.id,
        config = _ref.config,
        log = _ref.log,
        userAgent = _ref.userAgent,
        authToken = _ref.authToken;
    var createChannelConnectionHook = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _classCallCheck2["default"])(this, PooledConnectionProvider);
    _this = _super.call(this);
    _this._id = id;
    _this._config = config;
    _this._log = log;
    _this._userAgent = userAgent;
    _this._authToken = authToken;

    _this._createChannelConnection = createChannelConnectionHook || function (address) {
      return _connectionChannel["default"].create(address, _this._config, _this._createConnectionErrorHandler(), _this._log);
    };

    _this._connectionPool = new _pool["default"]({
      create: _this._createConnection.bind((0, _assertThisInitialized2["default"])(_this)),
      destroy: _this._destroyConnection.bind((0, _assertThisInitialized2["default"])(_this)),
      validate: _this._validateConnection.bind((0, _assertThisInitialized2["default"])(_this)),
      installIdleObserver: PooledConnectionProvider._installIdleObserverOnConnection.bind((0, _assertThisInitialized2["default"])(_this)),
      removeIdleObserver: PooledConnectionProvider._removeIdleObserverOnConnection.bind((0, _assertThisInitialized2["default"])(_this)),
      config: _poolConfig["default"].fromDriverConfig(config),
      log: _this._log
    });
    _this._openConnections = {};
    return _this;
  }

  (0, _createClass2["default"])(PooledConnectionProvider, [{
    key: "_createConnectionErrorHandler",
    value: function _createConnectionErrorHandler() {
      return new _connectionErrorHandler["default"](_error.SERVICE_UNAVAILABLE);
    }
    /**
     * Create a new connection and initialize it.
     * @return {Promise<Connection>} promise resolved with a new connection or rejected when failed to connect.
     * @access private
     */

  }, {
    key: "_createConnection",
    value: function _createConnection(address, release) {
      var _this2 = this;

      var connection = this._createChannelConnection(address);

      connection._release = function () {
        return release(address, connection);
      };

      this._openConnections[connection.id] = connection;
      return connection.connect(this._userAgent, this._authToken)["catch"](function (error) {
        // let's destroy this connection
        _this2._destroyConnection(connection); // propagate the error because connection failed to connect / initialize


        throw error;
      });
    }
    /**
     * Check that a connection is usable
     * @return {boolean} true if the connection is open
     * @access private
     **/

  }, {
    key: "_validateConnection",
    value: function _validateConnection(conn) {
      if (!conn.isOpen()) {
        return false;
      }

      var maxConnectionLifetime = this._config.maxConnectionLifetime;
      var lifetime = Date.now() - conn.creationTimestamp;
      return lifetime <= maxConnectionLifetime;
    }
    /**
     * Dispose of a connection.
     * @return {Connection} the connection to dispose.
     * @access private
     */

  }, {
    key: "_destroyConnection",
    value: function _destroyConnection(conn) {
      delete this._openConnections[conn.id];
      return conn.close();
    }
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._connectionPool.close();

              case 2:
                _context.next = 4;
                return Promise.all(Object.values(this._openConnections).map(function (c) {
                  return c.close();
                }));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }], [{
    key: "_installIdleObserverOnConnection",
    value: function _installIdleObserverOnConnection(conn, observer) {
      conn._queueObserver(observer);
    }
  }, {
    key: "_removeIdleObserverOnConnection",
    value: function _removeIdleObserverOnConnection(conn) {
      conn._updateCurrentObserver();
    }
  }]);
  return PooledConnectionProvider;
}(_connectionProvider["default"]);

exports["default"] = PooledConnectionProvider;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-provider-routing.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-provider-routing.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _driver = __webpack_require__(/*! ../driver */ "./node_modules/neo4j-driver/lib/driver.js");

var _session = _interopRequireDefault(__webpack_require__(/*! ../session */ "./node_modules/neo4j-driver/lib/session.js"));

var _routingTable = _interopRequireDefault(__webpack_require__(/*! ./routing-table */ "./node_modules/neo4j-driver/lib/internal/routing-table.js"));

var _rediscovery = _interopRequireDefault(__webpack_require__(/*! ./rediscovery */ "./node_modules/neo4j-driver/lib/internal/rediscovery.js"));

var _routingUtil = _interopRequireDefault(__webpack_require__(/*! ./routing-util */ "./node_modules/neo4j-driver/lib/internal/routing-util.js"));

var _node = __webpack_require__(/*! ./node */ "./node_modules/neo4j-driver/lib/internal/browser/index.js");

var _connectionProviderSingle = _interopRequireDefault(__webpack_require__(/*! ./connection-provider-single */ "./node_modules/neo4j-driver/lib/internal/connection-provider-single.js"));

var _connectionProviderPooled = _interopRequireDefault(__webpack_require__(/*! ./connection-provider-pooled */ "./node_modules/neo4j-driver/lib/internal/connection-provider-pooled.js"));

var _connectionErrorHandler = _interopRequireDefault(__webpack_require__(/*! ./connection-error-handler */ "./node_modules/neo4j-driver/lib/internal/connection-error-handler.js"));

var _connectionDelegate = _interopRequireDefault(__webpack_require__(/*! ./connection-delegate */ "./node_modules/neo4j-driver/lib/internal/connection-delegate.js"));

var _leastConnectedLoadBalancingStrategy = _interopRequireDefault(__webpack_require__(/*! ./least-connected-load-balancing-strategy */ "./node_modules/neo4j-driver/lib/internal/least-connected-load-balancing-strategy.js"));

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

var _connectionChannel = _interopRequireDefault(__webpack_require__(/*! ./connection-channel */ "./node_modules/neo4j-driver/lib/internal/connection-channel.js"));

var _integer = __webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js");

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var UNAUTHORIZED_ERROR_CODE = 'Neo.ClientError.Security.Unauthorized';
var DATABASE_NOT_FOUND_ERROR_CODE = 'Neo.ClientError.Database.DatabaseNotFound';
var SYSTEM_DB_NAME = 'system';
var DEFAULT_DB_NAME = '';
var DEFAULT_ROUTING_TABLE_PURGE_DELAY = (0, _integer["int"])(30000);

var RoutingConnectionProvider = /*#__PURE__*/function (_PooledConnectionProv) {
  (0, _inherits2["default"])(RoutingConnectionProvider, _PooledConnectionProv);

  var _super = _createSuper(RoutingConnectionProvider);

  function RoutingConnectionProvider(_ref) {
    var _this;

    var id = _ref.id,
        address = _ref.address,
        routingContext = _ref.routingContext,
        hostNameResolver = _ref.hostNameResolver,
        config = _ref.config,
        log = _ref.log,
        userAgent = _ref.userAgent,
        authToken = _ref.authToken,
        routingTablePurgeDelay = _ref.routingTablePurgeDelay;
    (0, _classCallCheck2["default"])(this, RoutingConnectionProvider);
    _this = _super.call(this, {
      id: id,
      config: config,
      log: log,
      userAgent: userAgent,
      authToken: authToken
    }, function (address) {
      return _connectionChannel["default"].create(address, _this._config, _this._createConnectionErrorHandler(), _this._log, routingContext || {});
    });
    _this._seedRouter = address;
    _this._routingTables = {};
    _this._rediscovery = new _rediscovery["default"](new _routingUtil["default"](routingContext, address.toString()));
    _this._loadBalancingStrategy = new _leastConnectedLoadBalancingStrategy["default"](_this._connectionPool);
    _this._hostNameResolver = hostNameResolver;
    _this._dnsResolver = new _node.HostNameResolver();
    _this._log = log;
    _this._useSeedRouter = true;
    _this._routingTablePurgeDelay = routingTablePurgeDelay ? (0, _integer["int"])(routingTablePurgeDelay) : DEFAULT_ROUTING_TABLE_PURGE_DELAY;
    return _this;
  }

  (0, _createClass2["default"])(RoutingConnectionProvider, [{
    key: "_createConnectionErrorHandler",
    value: function _createConnectionErrorHandler() {
      // connection errors mean SERVICE_UNAVAILABLE for direct driver but for routing driver they should only
      // result in SESSION_EXPIRED because there might still exist other servers capable of serving the request
      return new _connectionErrorHandler["default"](_error.SESSION_EXPIRED);
    }
  }, {
    key: "_handleUnavailability",
    value: function _handleUnavailability(error, address, database) {
      this._log.warn("Routing driver ".concat(this._id, " will forget ").concat(address, " for database '").concat(database, "' because of an error ").concat(error.code, " '").concat(error.message, "'"));

      this.forget(address, database || '');
      return error;
    }
  }, {
    key: "_handleWriteFailure",
    value: function _handleWriteFailure(error, address, database) {
      this._log.warn("Routing driver ".concat(this._id, " will forget writer ").concat(address, " for database '").concat(database, "' because of an error ").concat(error.code, " '").concat(error.message, "'"));

      this.forgetWriter(address, database || '');
      return (0, _error.newError)('No longer possible to write to server at ' + address, _error.SESSION_EXPIRED);
    }
    /**
     * See {@link ConnectionProvider} for more information about this method and
     * its arguments.
     */

  }, {
    key: "acquireConnection",
    value: function () {
      var _acquireConnection = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var _this2 = this;

        var _ref2,
            accessMode,
            database,
            bookmark,
            name,
            address,
            databaseSpecificErrorHandler,
            routingTable,
            connection,
            transformed,
            _args = arguments;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _ref2 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, accessMode = _ref2.accessMode, database = _ref2.database, bookmark = _ref2.bookmark;
                databaseSpecificErrorHandler = new _connectionErrorHandler["default"](_error.SESSION_EXPIRED, function (error, address) {
                  return _this2._handleUnavailability(error, address, database);
                }, function (error, address) {
                  return _this2._handleWriteFailure(error, address, database);
                });
                _context.next = 4;
                return this._freshRoutingTable({
                  accessMode: accessMode,
                  database: database || DEFAULT_DB_NAME,
                  bookmark: bookmark
                });

              case 4:
                routingTable = _context.sent;

                if (!(accessMode === _driver.READ)) {
                  _context.next = 10;
                  break;
                }

                address = this._loadBalancingStrategy.selectReader(routingTable.readers);
                name = 'read';
                _context.next = 16;
                break;

              case 10:
                if (!(accessMode === _driver.WRITE)) {
                  _context.next = 15;
                  break;
                }

                address = this._loadBalancingStrategy.selectWriter(routingTable.writers);
                name = 'write';
                _context.next = 16;
                break;

              case 15:
                throw (0, _error.newError)('Illegal mode ' + accessMode);

              case 16:
                if (address) {
                  _context.next = 18;
                  break;
                }

                throw (0, _error.newError)("Failed to obtain connection towards ".concat(name, " server. Known routing table is: ").concat(routingTable), _error.SESSION_EXPIRED);

              case 18:
                _context.prev = 18;
                _context.next = 21;
                return this._acquireConnectionToServer(address, name, routingTable);

              case 21:
                connection = _context.sent;
                return _context.abrupt("return", new _connectionDelegate["default"](connection, databaseSpecificErrorHandler));

              case 25:
                _context.prev = 25;
                _context.t0 = _context["catch"](18);
                transformed = databaseSpecificErrorHandler.handleAndTransformError(_context.t0, address);
                throw transformed;

              case 29:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[18, 25]]);
      }));

      function acquireConnection() {
        return _acquireConnection.apply(this, arguments);
      }

      return acquireConnection;
    }()
  }, {
    key: "_hasProtocolVersion",
    value: function () {
      var _hasProtocolVersion2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(versionPredicate) {
        var addresses, lastError, i, connection, protocol;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._resolveSeedRouter(this._seedRouter);

              case 2:
                addresses = _context2.sent;
                i = 0;

              case 4:
                if (!(i < addresses.length)) {
                  _context2.next = 25;
                  break;
                }

                connection = _connectionChannel["default"].create(addresses[i], this._config, this._createConnectionErrorHandler(), this._log);
                _context2.prev = 6;
                _context2.next = 9;
                return connection._negotiateProtocol();

              case 9:
                protocol = connection.protocol();

                if (!protocol) {
                  _context2.next = 12;
                  break;
                }

                return _context2.abrupt("return", versionPredicate(protocol.version));

              case 12:
                return _context2.abrupt("return", false);

              case 15:
                _context2.prev = 15;
                _context2.t0 = _context2["catch"](6);
                lastError = _context2.t0;

              case 18:
                _context2.prev = 18;
                _context2.next = 21;
                return connection.close();

              case 21:
                return _context2.finish(18);

              case 22:
                i++;
                _context2.next = 4;
                break;

              case 25:
                if (!lastError) {
                  _context2.next = 27;
                  break;
                }

                throw lastError;

              case 27:
                return _context2.abrupt("return", false);

              case 28:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 15, 18, 22]]);
      }));

      function _hasProtocolVersion(_x) {
        return _hasProtocolVersion2.apply(this, arguments);
      }

      return _hasProtocolVersion;
    }()
  }, {
    key: "supportsMultiDb",
    value: function () {
      var _supportsMultiDb = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._hasProtocolVersion(function (version) {
                  return version >= _constants.BOLT_PROTOCOL_V4_0;
                });

              case 2:
                return _context3.abrupt("return", _context3.sent);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function supportsMultiDb() {
        return _supportsMultiDb.apply(this, arguments);
      }

      return supportsMultiDb;
    }()
  }, {
    key: "supportsTransactionConfig",
    value: function () {
      var _supportsTransactionConfig = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._hasProtocolVersion(function (version) {
                  return version >= _constants.BOLT_PROTOCOL_V3;
                });

              case 2:
                return _context4.abrupt("return", _context4.sent);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function supportsTransactionConfig() {
        return _supportsTransactionConfig.apply(this, arguments);
      }

      return supportsTransactionConfig;
    }()
  }, {
    key: "forget",
    value: function forget(address, database) {
      if (database || database === '') {
        this._routingTables[database].forget(address);
      } else {
        Object.values(this._routingTables).forEach(function (routingTable) {
          return routingTable.forget(address);
        });
      } // We're firing and forgetting this operation explicitly and listening for any
      // errors to avoid unhandled promise rejection


      this._connectionPool.purge(address)["catch"](function () {});
    }
  }, {
    key: "forgetWriter",
    value: function forgetWriter(address, database) {
      if (database || database === '') {
        this._routingTables[database].forgetWriter(address);
      } else {
        Object.values(this._routingTables).forEach(function (routingTable) {
          return routingTable.forgetWriter(address);
        });
      }
    }
  }, {
    key: "_acquireConnectionToServer",
    value: function _acquireConnectionToServer(address, serverName, routingTable) {
      return this._connectionPool.acquire(address);
    }
  }, {
    key: "_freshRoutingTable",
    value: function _freshRoutingTable() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          accessMode = _ref3.accessMode,
          database = _ref3.database,
          bookmark = _ref3.bookmark;

      var currentRoutingTable = this._routingTables[database] || new _routingTable["default"]({
        database: database
      });

      if (!currentRoutingTable.isStaleFor(accessMode)) {
        return currentRoutingTable;
      }

      this._log.info("Routing table is stale for database: \"".concat(database, "\" and access mode: \"").concat(accessMode, "\": ").concat(currentRoutingTable));

      return this._refreshRoutingTable(currentRoutingTable, bookmark);
    }
  }, {
    key: "_refreshRoutingTable",
    value: function _refreshRoutingTable(currentRoutingTable, bookmark) {
      var knownRouters = currentRoutingTable.routers;

      if (this._useSeedRouter) {
        return this._fetchRoutingTableFromSeedRouterFallbackToKnownRouters(knownRouters, currentRoutingTable, bookmark);
      }

      return this._fetchRoutingTableFromKnownRoutersFallbackToSeedRouter(knownRouters, currentRoutingTable, bookmark);
    }
  }, {
    key: "_fetchRoutingTableFromSeedRouterFallbackToKnownRouters",
    value: function () {
      var _fetchRoutingTableFromSeedRouterFallbackToKnownRouters2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(knownRouters, currentRoutingTable, bookmark) {
        var seenRouters, newRoutingTable;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                // we start with seed router, no routers were probed before
                seenRouters = [];
                _context5.next = 3;
                return this._fetchRoutingTableUsingSeedRouter(seenRouters, this._seedRouter, currentRoutingTable, bookmark);

              case 3:
                newRoutingTable = _context5.sent;

                if (!newRoutingTable) {
                  _context5.next = 8;
                  break;
                }

                this._useSeedRouter = false;
                _context5.next = 11;
                break;

              case 8:
                _context5.next = 10;
                return this._fetchRoutingTableUsingKnownRouters(knownRouters, currentRoutingTable, bookmark);

              case 10:
                newRoutingTable = _context5.sent;

              case 11:
                _context5.next = 13;
                return this._applyRoutingTableIfPossible(currentRoutingTable, newRoutingTable);

              case 13:
                return _context5.abrupt("return", _context5.sent);

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _fetchRoutingTableFromSeedRouterFallbackToKnownRouters(_x2, _x3, _x4) {
        return _fetchRoutingTableFromSeedRouterFallbackToKnownRouters2.apply(this, arguments);
      }

      return _fetchRoutingTableFromSeedRouterFallbackToKnownRouters;
    }()
  }, {
    key: "_fetchRoutingTableFromKnownRoutersFallbackToSeedRouter",
    value: function () {
      var _fetchRoutingTableFromKnownRoutersFallbackToSeedRouter2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(knownRouters, currentRoutingTable, bookmark) {
        var newRoutingTable;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this._fetchRoutingTableUsingKnownRouters(knownRouters, currentRoutingTable, bookmark);

              case 2:
                newRoutingTable = _context6.sent;

                if (newRoutingTable) {
                  _context6.next = 7;
                  break;
                }

                _context6.next = 6;
                return this._fetchRoutingTableUsingSeedRouter(knownRouters, this._seedRouter, currentRoutingTable, bookmark);

              case 6:
                newRoutingTable = _context6.sent;

              case 7:
                _context6.next = 9;
                return this._applyRoutingTableIfPossible(currentRoutingTable, newRoutingTable);

              case 9:
                return _context6.abrupt("return", _context6.sent);

              case 10:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _fetchRoutingTableFromKnownRoutersFallbackToSeedRouter(_x5, _x6, _x7) {
        return _fetchRoutingTableFromKnownRoutersFallbackToSeedRouter2.apply(this, arguments);
      }

      return _fetchRoutingTableFromKnownRoutersFallbackToSeedRouter;
    }()
  }, {
    key: "_fetchRoutingTableUsingKnownRouters",
    value: function () {
      var _fetchRoutingTableUsingKnownRouters2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(knownRouters, currentRoutingTable, bookmark) {
        var newRoutingTable, lastRouterIndex;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._fetchRoutingTable(knownRouters, currentRoutingTable, bookmark);

              case 2:
                newRoutingTable = _context7.sent;

                if (!newRoutingTable) {
                  _context7.next = 5;
                  break;
                }

                return _context7.abrupt("return", newRoutingTable);

              case 5:
                // returned routing table was undefined, this means a connection error happened and the last known
                // router did not return a valid routing table, so we need to forget it
                lastRouterIndex = knownRouters.length - 1;

                RoutingConnectionProvider._forgetRouter(currentRoutingTable, knownRouters, lastRouterIndex);

                return _context7.abrupt("return", null);

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _fetchRoutingTableUsingKnownRouters(_x8, _x9, _x10) {
        return _fetchRoutingTableUsingKnownRouters2.apply(this, arguments);
      }

      return _fetchRoutingTableUsingKnownRouters;
    }()
  }, {
    key: "_fetchRoutingTableUsingSeedRouter",
    value: function () {
      var _fetchRoutingTableUsingSeedRouter2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(seenRouters, seedRouter, routingTable, bookmark) {
        var resolvedAddresses, newAddresses;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this._resolveSeedRouter(seedRouter);

              case 2:
                resolvedAddresses = _context8.sent;
                // filter out all addresses that we've already tried
                newAddresses = resolvedAddresses.filter(function (address) {
                  return seenRouters.indexOf(address) < 0;
                });
                _context8.next = 6;
                return this._fetchRoutingTable(newAddresses, routingTable, bookmark);

              case 6:
                return _context8.abrupt("return", _context8.sent);

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _fetchRoutingTableUsingSeedRouter(_x11, _x12, _x13, _x14) {
        return _fetchRoutingTableUsingSeedRouter2.apply(this, arguments);
      }

      return _fetchRoutingTableUsingSeedRouter;
    }()
  }, {
    key: "_resolveSeedRouter",
    value: function () {
      var _resolveSeedRouter2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(seedRouter) {
        var _this3 = this;

        var resolvedAddresses, dnsResolvedAddresses;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._hostNameResolver.resolve(seedRouter);

              case 2:
                resolvedAddresses = _context9.sent;
                _context9.next = 5;
                return Promise.all(resolvedAddresses.map(function (address) {
                  return _this3._dnsResolver.resolve(address);
                }));

              case 5:
                dnsResolvedAddresses = _context9.sent;
                return _context9.abrupt("return", [].concat.apply([], dnsResolvedAddresses));

              case 7:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function _resolveSeedRouter(_x15) {
        return _resolveSeedRouter2.apply(this, arguments);
      }

      return _resolveSeedRouter;
    }()
  }, {
    key: "_fetchRoutingTable",
    value: function _fetchRoutingTable(routerAddresses, routingTable, bookmark) {
      var _this4 = this;

      return routerAddresses.reduce( /*#__PURE__*/function () {
        var _ref4 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(refreshedTablePromise, currentRouter, currentIndex) {
          var newRoutingTable, previousRouterIndex, session;
          return _regenerator["default"].wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  _context10.next = 2;
                  return refreshedTablePromise;

                case 2:
                  newRoutingTable = _context10.sent;

                  if (!newRoutingTable) {
                    _context10.next = 7;
                    break;
                  }

                  return _context10.abrupt("return", newRoutingTable);

                case 7:
                  // returned routing table was undefined, this means a connection error happened and we need to forget the
                  // previous router and try the next one
                  previousRouterIndex = currentIndex - 1;

                  RoutingConnectionProvider._forgetRouter(routingTable, routerAddresses, previousRouterIndex);

                case 9:
                  _context10.next = 11;
                  return _this4._createSessionForRediscovery(currentRouter, bookmark);

                case 11:
                  session = _context10.sent;

                  if (!session) {
                    _context10.next = 27;
                    break;
                  }

                  _context10.prev = 13;
                  _context10.next = 16;
                  return _this4._rediscovery.lookupRoutingTableOnRouter(session, routingTable.database, currentRouter);

                case 16:
                  return _context10.abrupt("return", _context10.sent);

                case 19:
                  _context10.prev = 19;
                  _context10.t0 = _context10["catch"](13);

                  if (!(_context10.t0 && _context10.t0.code === DATABASE_NOT_FOUND_ERROR_CODE)) {
                    _context10.next = 23;
                    break;
                  }

                  throw _context10.t0;

                case 23:
                  _this4._log.warn("unable to fetch routing table because of an error ".concat(_context10.t0));

                  return _context10.abrupt("return", null);

                case 25:
                  _context10.next = 28;
                  break;

                case 27:
                  return _context10.abrupt("return", null);

                case 28:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10, null, [[13, 19]]);
        }));

        return function (_x16, _x17, _x18) {
          return _ref4.apply(this, arguments);
        };
      }(), Promise.resolve(null));
    }
  }, {
    key: "_createSessionForRediscovery",
    value: function () {
      var _createSessionForRediscovery2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(routerAddress, bookmark) {
        var connection, connectionProvider, protocolVersion;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.prev = 0;
                _context11.next = 3;
                return this._connectionPool.acquire(routerAddress);

              case 3:
                connection = _context11.sent;
                connectionProvider = new _connectionProviderSingle["default"](connection);
                protocolVersion = connection.protocol().version;

                if (!(protocolVersion < 4.0)) {
                  _context11.next = 8;
                  break;
                }

                return _context11.abrupt("return", new _session["default"]({
                  mode: _driver.WRITE,
                  bookmark: _bookmark["default"].empty(),
                  connectionProvider: connectionProvider
                }));

              case 8:
                return _context11.abrupt("return", new _session["default"]({
                  mode: _driver.READ,
                  database: SYSTEM_DB_NAME,
                  bookmark: bookmark,
                  connectionProvider: connectionProvider
                }));

              case 11:
                _context11.prev = 11;
                _context11.t0 = _context11["catch"](0);

                if (!(_context11.t0 && _context11.t0.code === UNAUTHORIZED_ERROR_CODE)) {
                  _context11.next = 15;
                  break;
                }

                throw _context11.t0;

              case 15:
                return _context11.abrupt("return", null);

              case 16:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[0, 11]]);
      }));

      function _createSessionForRediscovery(_x19, _x20) {
        return _createSessionForRediscovery2.apply(this, arguments);
      }

      return _createSessionForRediscovery;
    }()
  }, {
    key: "_applyRoutingTableIfPossible",
    value: function () {
      var _applyRoutingTableIfPossible2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12(currentRoutingTable, newRoutingTable) {
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (newRoutingTable) {
                  _context12.next = 2;
                  break;
                }

                throw (0, _error.newError)("Could not perform discovery. No routing servers available. Known routing table: ".concat(currentRoutingTable), _error.SERVICE_UNAVAILABLE);

              case 2:
                if (newRoutingTable.writers.length === 0) {
                  // use seed router next time. this is important when cluster is partitioned. it tries to make sure driver
                  // does not always get routing table without writers because it talks exclusively to a minority partition
                  this._useSeedRouter = true;
                }

                _context12.next = 5;
                return this._updateRoutingTable(newRoutingTable);

              case 5:
                return _context12.abrupt("return", newRoutingTable);

              case 6:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function _applyRoutingTableIfPossible(_x21, _x22) {
        return _applyRoutingTableIfPossible2.apply(this, arguments);
      }

      return _applyRoutingTableIfPossible;
    }()
  }, {
    key: "_updateRoutingTable",
    value: function () {
      var _updateRoutingTable2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13(newRoutingTable) {
        var _this5 = this;

        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this._connectionPool.keepAll(newRoutingTable.allServers());

              case 2:
                // filter out expired to purge (expired for a pre-configured amount of time) routing table entries
                Object.values(this._routingTables).forEach(function (value) {
                  if (value.isExpiredFor(_this5._routingTablePurgeDelay)) {
                    delete _this5._routingTables[value.database];
                  }
                }); // make this driver instance aware of the new table

                this._routingTables[newRoutingTable.database] = newRoutingTable;

                this._log.info("Updated routing table ".concat(newRoutingTable));

              case 5:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function _updateRoutingTable(_x23) {
        return _updateRoutingTable2.apply(this, arguments);
      }

      return _updateRoutingTable;
    }()
  }], [{
    key: "_forgetRouter",
    value: function _forgetRouter(routingTable, routersArray, routerIndex) {
      var address = routersArray[routerIndex];

      if (routingTable && address) {
        routingTable.forgetRouter(address);
      }
    }
  }]);
  return RoutingConnectionProvider;
}(_connectionProviderPooled["default"]);

exports["default"] = RoutingConnectionProvider;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-provider-single.js":
/*!******************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-provider-single.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _connectionProvider = _interopRequireDefault(__webpack_require__(/*! ./connection-provider */ "./node_modules/neo4j-driver/lib/internal/connection-provider.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var SingleConnectionProvider = /*#__PURE__*/function (_ConnectionProvider) {
  (0, _inherits2["default"])(SingleConnectionProvider, _ConnectionProvider);

  var _super = _createSuper(SingleConnectionProvider);

  function SingleConnectionProvider(connection) {
    var _this;

    (0, _classCallCheck2["default"])(this, SingleConnectionProvider);
    _this = _super.call(this);
    _this._connection = connection;
    return _this;
  }
  /**
   * See {@link ConnectionProvider} for more information about this method and
   * its arguments.
   */


  (0, _createClass2["default"])(SingleConnectionProvider, [{
    key: "acquireConnection",
    value: function acquireConnection() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          accessMode = _ref.accessMode,
          database = _ref.database,
          bookmarks = _ref.bookmarks;

      var connection = this._connection;
      this._connection = null;
      return Promise.resolve(connection);
    }
  }]);
  return SingleConnectionProvider;
}(_connectionProvider["default"]);

exports["default"] = SingleConnectionProvider;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection-provider.js":
/*!***********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection-provider.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ConnectionProvider = /*#__PURE__*/function () {
  function ConnectionProvider() {
    (0, _classCallCheck2["default"])(this, ConnectionProvider);
  }

  (0, _createClass2["default"])(ConnectionProvider, [{
    key: "acquireConnection",

    /**
     * This method acquires a connection against the specified database.
     *
     * Access mode and Bookmarks only applies to routing driver. Access mode only
     * differentiates the target server for the connection, where WRITE selects a
     * WRITER server, whereas READ selects a READ server. Bookmarks, when specified,
     * is only passed to the routing discovery procedure, for the system database to
     * synchronize on creation of databases and is never used in direct drivers.
     *
     * @param {object} param - object parameter
     * @param {string} param.accessMode - the access mode for the to-be-acquired connection
     * @param {string} param.database - the target database for the to-be-acquired connection
     * @param {Bookmark} param.bookmarks - the bookmarks to send to routing discovery
     */
    value: function acquireConnection() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          accessMode = _ref.accessMode,
          database = _ref.database,
          bookmarks = _ref.bookmarks;

      throw new Error('not implemented');
    }
    /**
     * This method checks whether the backend database supports multi database functionality
     * by checking protocol handshake result.
     *
     * @returns {Promise<boolean>}
     */

  }, {
    key: "supportsMultiDb",
    value: function supportsMultiDb() {
      throw new Error('not implemented');
    }
    /**
     * This method checks whether the backend database supports transaction config functionality
     * by checking protocol handshake result.
     *
     * @returns {Promise<boolean>}
     */

  }, {
    key: "supportsTransactionConfig",
    value: function supportsTransactionConfig() {
      throw new Error('not implemented');
    }
    /**
     * Closes this connection provider along with its internals (connections, pools, etc.)
     *
     * @returns {Promise<void>}
     */

  }, {
    key: "close",
    value: function close() {
      throw new Error('not implemented');
    }
  }]);
  return ConnectionProvider;
}();

exports["default"] = ConnectionProvider;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connection.js":
/*!**************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connection.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

var _boltProtocolV = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v1 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v1.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Connection = /*#__PURE__*/function () {
  /**
   * @param {ConnectionErrorHandler} errorHandler the error handler
   */
  function Connection(errorHandler) {
    (0, _classCallCheck2["default"])(this, Connection);
    this._errorHandler = errorHandler;
  }

  (0, _createClass2["default"])(Connection, [{
    key: "isOpen",

    /**
     * @returns {boolean} whether this connection is in a working condition
     */
    value: function isOpen() {
      throw new Error('not implemented');
    }
    /**
     * @returns {BoltProtocol} the underlying bolt protocol assigned to this connection
     */

  }, {
    key: "protocol",
    value: function protocol() {
      throw new Error('not implemented');
    }
    /**
     * @returns {ServerAddress} the server address this connection is opened against
     */

  }, {
    key: "connect",

    /**
     * Connect to the target address, negotiate Bolt protocol and send initialization message.
     * @param {string} userAgent the user agent for this driver.
     * @param {Object} authToken the object containing auth information.
     * @return {Promise<Connection>} promise resolved with the current connection if connection is successful. Rejected promise otherwise.
     */
    value: function connect(userAgent, authToken) {
      throw new Error('not implemented');
    }
    /**
     * Write a message to the network channel.
     * @param {RequestMessage} message the message to write.
     * @param {ResultStreamObserver} observer the response observer.
     * @param {boolean} flush `true` if flush should happen after the message is written to the buffer.
     */

  }, {
    key: "write",
    value: function write(message, observer, flush) {
      throw new Error('not implemented');
    }
    /**
     * Send a RESET-message to the database. Message is immediately flushed to the network.
     * @return {Promise<void>} promise resolved when SUCCESS-message response arrives, or failed when other response messages arrives.
     */

  }, {
    key: "resetAndFlush",
    value: function resetAndFlush() {
      throw new Error('not implemented');
    }
    /**
     * Call close on the channel.
     * @returns {Promise<void>} - A promise that will be resolved when the connection is closed.
     *
     */

  }, {
    key: "close",
    value: function close() {
      throw new Error('not implemented');
    }
    /**
     *
     * @param error
     * @param address
     * @returns {Neo4jError|*}
     */

  }, {
    key: "handleAndTransformError",
    value: function handleAndTransformError(error, address) {
      if (this._errorHandler) {
        return this._errorHandler.handleAndTransformError(error, address);
      }

      return error;
    }
  }, {
    key: "id",
    get: function get() {
      throw new Error('not implemented');
    }
  }, {
    key: "databaseId",
    get: function get() {
      throw new Error('not implemented');
    },
    set: function set(value) {
      throw new Error('not implemented');
    }
  }, {
    key: "address",
    get: function get() {
      throw new Error('not implemented');
    }
    /**
     * @returns {ServerVersion} the version of the server this connection is connected to
     */

  }, {
    key: "version",
    get: function get() {
      throw new Error('not implemented');
    },
    set: function set(value) {
      throw new Error('not implemented');
    }
  }, {
    key: "server",
    get: function get() {
      throw new Error('not implemented');
    }
  }]);
  return Connection;
}();

exports["default"] = Connection;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/connectivity-verifier.js":
/*!*************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/connectivity-verifier.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _connectionHolder = _interopRequireDefault(__webpack_require__(/*! ./connection-holder */ "./node_modules/neo4j-driver/lib/internal/connection-holder.js"));

var _driver = __webpack_require__(/*! ../driver */ "./node_modules/neo4j-driver/lib/driver.js");

var _streamObservers = __webpack_require__(/*! ./stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Verifies connectivity using the given connection provider.
 */
var ConnectivityVerifier = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {ConnectionProvider} connectionProvider the provider to obtain connections from.
   */
  function ConnectivityVerifier(connectionProvider) {
    (0, _classCallCheck2["default"])(this, ConnectivityVerifier);
    this._connectionProvider = connectionProvider;
  }
  /**
   * Try to obtain a working connection from the connection provider.
   * @returns {Promise<object>} promise resolved with server info or rejected with error.
   */


  (0, _createClass2["default"])(ConnectivityVerifier, [{
    key: "verify",
    value: function verify() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$database = _ref.database,
          database = _ref$database === void 0 ? '' : _ref$database;

      return acquireAndReleaseDummyConnection(this._connectionProvider, database);
    }
  }]);
  return ConnectivityVerifier;
}();
/**
 * @private
 * @param {ConnectionProvider} connectionProvider the provider to obtain connections from.
 * @return {Promise<object>} promise resolved with server info or rejected with error.
 */


exports["default"] = ConnectivityVerifier;

function acquireAndReleaseDummyConnection(connectionProvider, database) {
  var connectionHolder = new _connectionHolder["default"]({
    mode: _driver.READ,
    database: database,
    connectionProvider: connectionProvider
  });
  connectionHolder.initializeConnection();
  return connectionHolder.getConnection().then(function (connection) {
    // able to establish a connection
    return connectionHolder.close().then(function () {
      return connection.server;
    });
  })["catch"](function (error) {
    // failed to establish a connection
    return connectionHolder.close()["catch"](function (ignoredError) {// ignore connection release error
    }).then(function () {
      return Promise.reject(error);
    });
  });
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/constants.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BOLT_PROTOCOL_V4_1 = exports.BOLT_PROTOCOL_V4_0 = exports.BOLT_PROTOCOL_V3 = exports.BOLT_PROTOCOL_V2 = exports.BOLT_PROTOCOL_V1 = exports.ACCESS_MODE_WRITE = exports.ACCESS_MODE_READ = void 0;

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ACCESS_MODE_READ = 'READ';
exports.ACCESS_MODE_READ = ACCESS_MODE_READ;
var ACCESS_MODE_WRITE = 'WRITE';
exports.ACCESS_MODE_WRITE = ACCESS_MODE_WRITE;
var BOLT_PROTOCOL_V1 = 1;
exports.BOLT_PROTOCOL_V1 = BOLT_PROTOCOL_V1;
var BOLT_PROTOCOL_V2 = 2;
exports.BOLT_PROTOCOL_V2 = BOLT_PROTOCOL_V2;
var BOLT_PROTOCOL_V3 = 3;
exports.BOLT_PROTOCOL_V3 = BOLT_PROTOCOL_V3;
var BOLT_PROTOCOL_V4_0 = 4.0;
exports.BOLT_PROTOCOL_V4_0 = BOLT_PROTOCOL_V4_0;
var BOLT_PROTOCOL_V4_1 = 4.1;
exports.BOLT_PROTOCOL_V4_1 = BOLT_PROTOCOL_V4_1;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/least-connected-load-balancing-strategy.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/least-connected-load-balancing-strategy.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _roundRobinArrayIndex = _interopRequireDefault(__webpack_require__(/*! ./round-robin-array-index */ "./node_modules/neo4j-driver/lib/internal/round-robin-array-index.js"));

var _loadBalancingStrategy = _interopRequireDefault(__webpack_require__(/*! ./load-balancing-strategy */ "./node_modules/neo4j-driver/lib/internal/load-balancing-strategy.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var LeastConnectedLoadBalancingStrategy = /*#__PURE__*/function (_LoadBalancingStrateg) {
  (0, _inherits2["default"])(LeastConnectedLoadBalancingStrategy, _LoadBalancingStrateg);

  var _super = _createSuper(LeastConnectedLoadBalancingStrategy);

  /**
   * @constructor
   * @param {Pool} connectionPool the connection pool of this driver.
   */
  function LeastConnectedLoadBalancingStrategy(connectionPool) {
    var _this;

    (0, _classCallCheck2["default"])(this, LeastConnectedLoadBalancingStrategy);
    _this = _super.call(this);
    _this._readersIndex = new _roundRobinArrayIndex["default"]();
    _this._writersIndex = new _roundRobinArrayIndex["default"]();
    _this._connectionPool = connectionPool;
    return _this;
  }
  /**
   * @inheritDoc
   */


  (0, _createClass2["default"])(LeastConnectedLoadBalancingStrategy, [{
    key: "selectReader",
    value: function selectReader(knownReaders) {
      return this._select(knownReaders, this._readersIndex);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "selectWriter",
    value: function selectWriter(knownWriters) {
      return this._select(knownWriters, this._writersIndex);
    }
  }, {
    key: "_select",
    value: function _select(addresses, roundRobinIndex) {
      var length = addresses.length;

      if (length === 0) {
        return null;
      } // choose start index for iteration in round-robin fashion


      var startIndex = roundRobinIndex.next(length);
      var index = startIndex;
      var leastConnectedAddress = null;
      var leastActiveConnections = Number.MAX_SAFE_INTEGER; // iterate over the array to find least connected address

      do {
        var address = addresses[index];

        var activeConnections = this._connectionPool.activeResourceCount(address);

        if (activeConnections < leastActiveConnections) {
          leastConnectedAddress = address;
          leastActiveConnections = activeConnections;
        } // loop over to the start of the array when end is reached


        if (index === length - 1) {
          index = 0;
        } else {
          index++;
        }
      } while (index !== startIndex);

      return leastConnectedAddress;
    }
  }]);
  return LeastConnectedLoadBalancingStrategy;
}(_loadBalancingStrategy["default"]);

exports["default"] = LeastConnectedLoadBalancingStrategy;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/load-balancing-strategy.js":
/*!***************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/load-balancing-strategy.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A facility to select most appropriate reader or writer among the given addresses for request processing.
 */
var LoadBalancingStrategy = /*#__PURE__*/function () {
  function LoadBalancingStrategy() {
    (0, _classCallCheck2["default"])(this, LoadBalancingStrategy);
  }

  (0, _createClass2["default"])(LoadBalancingStrategy, [{
    key: "selectReader",

    /**
     * Select next most appropriate reader from the list of given readers.
     * @param {string[]} knownReaders an array of currently known readers to select from.
     * @return {string} most appropriate reader or `null` if given array is empty.
     */
    value: function selectReader(knownReaders) {
      throw new Error('Abstract function');
    }
    /**
     * Select next most appropriate writer from the list of given writers.
     * @param {string[]} knownWriters an array of currently known writers to select from.
     * @return {string} most appropriate writer or `null` if given array is empty.
     */

  }, {
    key: "selectWriter",
    value: function selectWriter(knownWriters) {
      throw new Error('Abstract function');
    }
  }]);
  return LoadBalancingStrategy;
}();

exports["default"] = LoadBalancingStrategy;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/logger.js":
/*!**********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/logger.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _levels;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var ERROR = 'error';
var WARN = 'warn';
var INFO = 'info';
var DEBUG = 'debug';
var DEFAULT_LEVEL = INFO;
var levels = (_levels = {}, (0, _defineProperty2["default"])(_levels, ERROR, 0), (0, _defineProperty2["default"])(_levels, WARN, 1), (0, _defineProperty2["default"])(_levels, INFO, 2), (0, _defineProperty2["default"])(_levels, DEBUG, 3), _levels);
/**
 * Logger used by the driver to notify about various internal events. Single logger should be used per driver.
 */

var Logger = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {string} level the enabled logging level.
   * @param {function(level: string, message: string)} loggerFunction the function to write the log level and message.
   */
  function Logger(level, loggerFunction) {
    (0, _classCallCheck2["default"])(this, Logger);
    this._level = level;
    this._loggerFunction = loggerFunction;
  }
  /**
   * Create a new logger based on the given driver configuration.
   * @param {Object} driverConfig the driver configuration as supplied by the user.
   * @return {Logger} a new logger instance or a no-op logger when not configured.
   */


  (0, _createClass2["default"])(Logger, [{
    key: "isErrorEnabled",

    /**
     * Check if error logging is enabled, i.e. it is not a no-op implementation.
     * @return {boolean} `true` when enabled, `false` otherwise.
     */
    value: function isErrorEnabled() {
      return isLevelEnabled(this._level, ERROR);
    }
    /**
     * Log an error message.
     * @param {string} message the message to log.
     */

  }, {
    key: "error",
    value: function error(message) {
      if (this.isErrorEnabled()) {
        this._loggerFunction(ERROR, message);
      }
    }
    /**
     * Check if warn logging is enabled, i.e. it is not a no-op implementation.
     * @return {boolean} `true` when enabled, `false` otherwise.
     */

  }, {
    key: "isWarnEnabled",
    value: function isWarnEnabled() {
      return isLevelEnabled(this._level, WARN);
    }
    /**
     * Log an warning message.
     * @param {string} message the message to log.
     */

  }, {
    key: "warn",
    value: function warn(message) {
      if (this.isWarnEnabled()) {
        this._loggerFunction(WARN, message);
      }
    }
    /**
     * Check if info logging is enabled, i.e. it is not a no-op implementation.
     * @return {boolean} `true` when enabled, `false` otherwise.
     */

  }, {
    key: "isInfoEnabled",
    value: function isInfoEnabled() {
      return isLevelEnabled(this._level, INFO);
    }
    /**
     * Log an info message.
     * @param {string} message the message to log.
     */

  }, {
    key: "info",
    value: function info(message) {
      if (this.isInfoEnabled()) {
        this._loggerFunction(INFO, message);
      }
    }
    /**
     * Check if debug logging is enabled, i.e. it is not a no-op implementation.
     * @return {boolean} `true` when enabled, `false` otherwise.
     */

  }, {
    key: "isDebugEnabled",
    value: function isDebugEnabled() {
      return isLevelEnabled(this._level, DEBUG);
    }
    /**
     * Log a debug message.
     * @param {string} message the message to log.
     */

  }, {
    key: "debug",
    value: function debug(message) {
      if (this.isDebugEnabled()) {
        this._loggerFunction(DEBUG, message);
      }
    }
  }], [{
    key: "create",
    value: function create(driverConfig) {
      if (driverConfig && driverConfig.logging) {
        var loggingConfig = driverConfig.logging;
        var level = extractConfiguredLevel(loggingConfig);
        var loggerFunction = extractConfiguredLogger(loggingConfig);
        return new Logger(level, loggerFunction);
      }

      return this.noOp();
    }
    /**
     * Create a no-op logger implementation.
     * @return {Logger} the no-op logger implementation.
     */

  }, {
    key: "noOp",
    value: function noOp() {
      return noOpLogger;
    }
  }]);
  return Logger;
}();

var NoOpLogger = /*#__PURE__*/function (_Logger) {
  (0, _inherits2["default"])(NoOpLogger, _Logger);

  var _super = _createSuper(NoOpLogger);

  function NoOpLogger() {
    (0, _classCallCheck2["default"])(this, NoOpLogger);
    return _super.call(this, null, null);
  }

  (0, _createClass2["default"])(NoOpLogger, [{
    key: "isErrorEnabled",
    value: function isErrorEnabled() {
      return false;
    }
  }, {
    key: "error",
    value: function error(message) {}
  }, {
    key: "isWarnEnabled",
    value: function isWarnEnabled() {
      return false;
    }
  }, {
    key: "warn",
    value: function warn(message) {}
  }, {
    key: "isInfoEnabled",
    value: function isInfoEnabled() {
      return false;
    }
  }, {
    key: "info",
    value: function info(message) {}
  }, {
    key: "isDebugEnabled",
    value: function isDebugEnabled() {
      return false;
    }
  }, {
    key: "debug",
    value: function debug(message) {}
  }]);
  return NoOpLogger;
}(Logger);

var noOpLogger = new NoOpLogger();
/**
 * Check if the given logging level is enabled.
 * @param {string} configuredLevel the configured level.
 * @param {string} targetLevel the level to check.
 * @return {boolean} value of `true` when enabled, `false` otherwise.
 */

function isLevelEnabled(configuredLevel, targetLevel) {
  return levels[configuredLevel] >= levels[targetLevel];
}
/**
 * Extract the configured logging level from the driver's logging configuration.
 * @param {Object} loggingConfig the logging configuration.
 * @return {string} the configured log level or default when none configured.
 */


function extractConfiguredLevel(loggingConfig) {
  if (loggingConfig && loggingConfig.level) {
    var configuredLevel = loggingConfig.level;
    var value = levels[configuredLevel];

    if (!value && value !== 0) {
      throw (0, _error.newError)("Illegal logging level: ".concat(configuredLevel, ". Supported levels are: ").concat(Object.keys(levels)));
    }

    return configuredLevel;
  }

  return DEFAULT_LEVEL;
}
/**
 * Extract the configured logger function from the driver's logging configuration.
 * @param {Object} loggingConfig the logging configuration.
 * @return {function(level: string, message: string)} the configured logging function.
 */


function extractConfiguredLogger(loggingConfig) {
  if (loggingConfig && loggingConfig.logger) {
    var configuredLogger = loggingConfig.logger;

    if (configuredLogger && typeof configuredLogger === 'function') {
      return configuredLogger;
    }
  }

  throw (0, _error.newError)("Illegal logger function: ".concat(loggingConfig.logger));
}

var _default = Logger;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/packstream-v1.js":
/*!*****************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/packstream-v1.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Structure = exports.Unpacker = exports.Packer = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _node = __webpack_require__(/*! ./node */ "./node_modules/neo4j-driver/lib/internal/browser/index.js");

var _integer = _interopRequireWildcard(__webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _graphTypes = __webpack_require__(/*! ../graph-types */ "./node_modules/neo4j-driver/lib/graph-types.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TINY_STRING = 0x80;
var TINY_LIST = 0x90;
var TINY_MAP = 0xa0;
var TINY_STRUCT = 0xb0;
var NULL = 0xc0;
var FLOAT_64 = 0xc1;
var FALSE = 0xc2;
var TRUE = 0xc3;
var INT_8 = 0xc8;
var INT_16 = 0xc9;
var INT_32 = 0xca;
var INT_64 = 0xcb;
var STRING_8 = 0xd0;
var STRING_16 = 0xd1;
var STRING_32 = 0xd2;
var LIST_8 = 0xd4;
var LIST_16 = 0xd5;
var LIST_32 = 0xd6;
var BYTES_8 = 0xcc;
var BYTES_16 = 0xcd;
var BYTES_32 = 0xce;
var MAP_8 = 0xd8;
var MAP_16 = 0xd9;
var MAP_32 = 0xda;
var STRUCT_8 = 0xdc;
var STRUCT_16 = 0xdd;
var NODE = 0x4e;
var NODE_STRUCT_SIZE = 3;
var RELATIONSHIP = 0x52;
var RELATIONSHIP_STRUCT_SIZE = 5;
var UNBOUND_RELATIONSHIP = 0x72;
var UNBOUND_RELATIONSHIP_STRUCT_SIZE = 3;
var PATH = 0x50;
var PATH_STRUCT_SIZE = 3;
/**
 * A Structure have a signature and fields.
 * @access private
 */

var Structure = /*#__PURE__*/function () {
  /**
   * Create new instance
   */
  function Structure(signature, fields) {
    (0, _classCallCheck2["default"])(this, Structure);
    this.signature = signature;
    this.fields = fields;
  }

  (0, _createClass2["default"])(Structure, [{
    key: "toString",
    value: function toString() {
      var fieldStr = '';

      for (var i = 0; i < this.fields.length; i++) {
        if (i > 0) {
          fieldStr += ', ';
        }

        fieldStr += this.fields[i];
      }

      return 'Structure(' + this.signature + ', [' + fieldStr + '])';
    }
  }]);
  return Structure;
}();
/**
 * Class to pack
 * @access private
 */


exports.Structure = Structure;

var Packer = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Chunker} channel the chunker backed by a network channel.
   */
  function Packer(channel) {
    (0, _classCallCheck2["default"])(this, Packer);
    this._ch = channel;
    this._byteArraysSupported = true;
  }
  /**
   * Creates a packable function out of the provided value
   * @param x the value to pack
   * @returns Function
   */


  (0, _createClass2["default"])(Packer, [{
    key: "packable",
    value: function packable(x) {
      var _this = this;

      if (x === null) {
        return function () {
          return _this._ch.writeUInt8(NULL);
        };
      } else if (x === true) {
        return function () {
          return _this._ch.writeUInt8(TRUE);
        };
      } else if (x === false) {
        return function () {
          return _this._ch.writeUInt8(FALSE);
        };
      } else if (typeof x === 'number') {
        return function () {
          return _this.packFloat(x);
        };
      } else if (typeof x === 'string') {
        return function () {
          return _this.packString(x);
        };
      } else if ((0, _integer.isInt)(x)) {
        return function () {
          return _this.packInteger(x);
        };
      } else if (x instanceof Int8Array) {
        return function () {
          return _this.packBytes(x);
        };
      } else if (x instanceof Array) {
        return function () {
          _this.packListHeader(x.length);

          for (var _i = 0; _i < x.length; _i++) {
            _this.packable(x[_i] === undefined ? null : x[_i])();
          }
        };
      } else if (isIterable(x)) {
        return this.packableIterable(x);
      } else if (x instanceof _graphTypes.Node) {
        return this._nonPackableValue("It is not allowed to pass nodes in query parameters, given: ".concat(x));
      } else if (x instanceof _graphTypes.Relationship) {
        return this._nonPackableValue("It is not allowed to pass relationships in query parameters, given: ".concat(x));
      } else if (x instanceof _graphTypes.Path) {
        return this._nonPackableValue("It is not allowed to pass paths in query parameters, given: ".concat(x));
      } else if (x instanceof Structure) {
        var packableFields = [];

        for (var i = 0; i < x.fields.length; i++) {
          packableFields[i] = this.packable(x.fields[i]);
        }

        return function () {
          return _this.packStruct(x.signature, packableFields);
        };
      } else if ((0, _typeof2["default"])(x) === 'object') {
        return function () {
          var keys = Object.keys(x);
          var count = 0;

          for (var _i2 = 0; _i2 < keys.length; _i2++) {
            if (x[keys[_i2]] !== undefined) {
              count++;
            }
          }

          _this.packMapHeader(count);

          for (var _i3 = 0; _i3 < keys.length; _i3++) {
            var key = keys[_i3];

            if (x[key] !== undefined) {
              _this.packString(key);

              _this.packable(x[key])();
            }
          }
        };
      } else {
        return this._nonPackableValue("Unable to pack the given value: ".concat(x));
      }
    }
  }, {
    key: "packableIterable",
    value: function packableIterable(iterable) {
      try {
        var array = Array.from(iterable);
        return this.packable(array);
      } catch (e) {
        // handle errors from iterable to array conversion
        throw (0, _error.newError)("Cannot pack given iterable, ".concat(e.message, ": ").concat(iterable));
      }
    }
    /**
     * Packs a struct
     * @param signature the signature of the struct
     * @param packableFields the fields of the struct, make sure you call `packable on all fields`
     */

  }, {
    key: "packStruct",
    value: function packStruct(signature, packableFields) {
      packableFields = packableFields || [];
      this.packStructHeader(packableFields.length, signature);

      for (var i = 0; i < packableFields.length; i++) {
        packableFields[i]();
      }
    }
  }, {
    key: "packInteger",
    value: function packInteger(x) {
      var high = x.high;
      var low = x.low;

      if (x.greaterThanOrEqual(-0x10) && x.lessThan(0x80)) {
        this._ch.writeInt8(low);
      } else if (x.greaterThanOrEqual(-0x80) && x.lessThan(-0x10)) {
        this._ch.writeUInt8(INT_8);

        this._ch.writeInt8(low);
      } else if (x.greaterThanOrEqual(-0x8000) && x.lessThan(0x8000)) {
        this._ch.writeUInt8(INT_16);

        this._ch.writeInt16(low);
      } else if (x.greaterThanOrEqual(-0x80000000) && x.lessThan(0x80000000)) {
        this._ch.writeUInt8(INT_32);

        this._ch.writeInt32(low);
      } else {
        this._ch.writeUInt8(INT_64);

        this._ch.writeInt32(high);

        this._ch.writeInt32(low);
      }
    }
  }, {
    key: "packFloat",
    value: function packFloat(x) {
      this._ch.writeUInt8(FLOAT_64);

      this._ch.writeFloat64(x);
    }
  }, {
    key: "packString",
    value: function packString(x) {
      var bytes = _node.utf8.encode(x);

      var size = bytes.length;

      if (size < 0x10) {
        this._ch.writeUInt8(TINY_STRING | size);

        this._ch.writeBytes(bytes);
      } else if (size < 0x100) {
        this._ch.writeUInt8(STRING_8);

        this._ch.writeUInt8(size);

        this._ch.writeBytes(bytes);
      } else if (size < 0x10000) {
        this._ch.writeUInt8(STRING_16);

        this._ch.writeUInt8(size / 256 >> 0);

        this._ch.writeUInt8(size % 256);

        this._ch.writeBytes(bytes);
      } else if (size < 0x100000000) {
        this._ch.writeUInt8(STRING_32);

        this._ch.writeUInt8((size / 16777216 >> 0) % 256);

        this._ch.writeUInt8((size / 65536 >> 0) % 256);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);

        this._ch.writeBytes(bytes);
      } else {
        throw (0, _error.newError)('UTF-8 strings of size ' + size + ' are not supported');
      }
    }
  }, {
    key: "packListHeader",
    value: function packListHeader(size) {
      if (size < 0x10) {
        this._ch.writeUInt8(TINY_LIST | size);
      } else if (size < 0x100) {
        this._ch.writeUInt8(LIST_8);

        this._ch.writeUInt8(size);
      } else if (size < 0x10000) {
        this._ch.writeUInt8(LIST_16);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);
      } else if (size < 0x100000000) {
        this._ch.writeUInt8(LIST_32);

        this._ch.writeUInt8((size / 16777216 >> 0) % 256);

        this._ch.writeUInt8((size / 65536 >> 0) % 256);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);
      } else {
        throw (0, _error.newError)('Lists of size ' + size + ' are not supported');
      }
    }
  }, {
    key: "packBytes",
    value: function packBytes(array) {
      if (this._byteArraysSupported) {
        this.packBytesHeader(array.length);

        for (var i = 0; i < array.length; i++) {
          this._ch.writeInt8(array[i]);
        }
      } else {
        throw (0, _error.newError)('Byte arrays are not supported by the database this driver is connected to');
      }
    }
  }, {
    key: "packBytesHeader",
    value: function packBytesHeader(size) {
      if (size < 0x100) {
        this._ch.writeUInt8(BYTES_8);

        this._ch.writeUInt8(size);
      } else if (size < 0x10000) {
        this._ch.writeUInt8(BYTES_16);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);
      } else if (size < 0x100000000) {
        this._ch.writeUInt8(BYTES_32);

        this._ch.writeUInt8((size / 16777216 >> 0) % 256);

        this._ch.writeUInt8((size / 65536 >> 0) % 256);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);
      } else {
        throw (0, _error.newError)('Byte arrays of size ' + size + ' are not supported');
      }
    }
  }, {
    key: "packMapHeader",
    value: function packMapHeader(size) {
      if (size < 0x10) {
        this._ch.writeUInt8(TINY_MAP | size);
      } else if (size < 0x100) {
        this._ch.writeUInt8(MAP_8);

        this._ch.writeUInt8(size);
      } else if (size < 0x10000) {
        this._ch.writeUInt8(MAP_16);

        this._ch.writeUInt8(size / 256 >> 0);

        this._ch.writeUInt8(size % 256);
      } else if (size < 0x100000000) {
        this._ch.writeUInt8(MAP_32);

        this._ch.writeUInt8((size / 16777216 >> 0) % 256);

        this._ch.writeUInt8((size / 65536 >> 0) % 256);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);
      } else {
        throw (0, _error.newError)('Maps of size ' + size + ' are not supported');
      }
    }
  }, {
    key: "packStructHeader",
    value: function packStructHeader(size, signature) {
      if (size < 0x10) {
        this._ch.writeUInt8(TINY_STRUCT | size);

        this._ch.writeUInt8(signature);
      } else if (size < 0x100) {
        this._ch.writeUInt8(STRUCT_8);

        this._ch.writeUInt8(size);

        this._ch.writeUInt8(signature);
      } else if (size < 0x10000) {
        this._ch.writeUInt8(STRUCT_16);

        this._ch.writeUInt8(size / 256 >> 0);

        this._ch.writeUInt8(size % 256);
      } else {
        throw (0, _error.newError)('Structures of size ' + size + ' are not supported');
      }
    }
  }, {
    key: "disableByteArrays",
    value: function disableByteArrays() {
      this._byteArraysSupported = false;
    }
  }, {
    key: "_nonPackableValue",
    value: function _nonPackableValue(message) {
      return function () {
        throw (0, _error.newError)(message, _error.PROTOCOL_ERROR);
      };
    }
  }]);
  return Packer;
}();
/**
 * Class to unpack
 * @access private
 */


exports.Packer = Packer;

var Unpacker = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.
   */
  function Unpacker() {
    var disableLosslessIntegers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    (0, _classCallCheck2["default"])(this, Unpacker);
    this._disableLosslessIntegers = disableLosslessIntegers;
  }

  (0, _createClass2["default"])(Unpacker, [{
    key: "unpack",
    value: function unpack(buffer) {
      var marker = buffer.readUInt8();
      var markerHigh = marker & 0xf0;
      var markerLow = marker & 0x0f;

      if (marker === NULL) {
        return null;
      }

      var _boolean = this._unpackBoolean(marker);

      if (_boolean !== null) {
        return _boolean;
      }

      var numberOrInteger = this._unpackNumberOrInteger(marker, buffer);

      if (numberOrInteger !== null) {
        if (this._disableLosslessIntegers && (0, _integer.isInt)(numberOrInteger)) {
          return numberOrInteger.toNumberOrInfinity();
        }

        return numberOrInteger;
      }

      var string = this._unpackString(marker, markerHigh, markerLow, buffer);

      if (string !== null) {
        return string;
      }

      var list = this._unpackList(marker, markerHigh, markerLow, buffer);

      if (list !== null) {
        return list;
      }

      var byteArray = this._unpackByteArray(marker, buffer);

      if (byteArray !== null) {
        return byteArray;
      }

      var map = this._unpackMap(marker, markerHigh, markerLow, buffer);

      if (map !== null) {
        return map;
      }

      var struct = this._unpackStruct(marker, markerHigh, markerLow, buffer);

      if (struct !== null) {
        return struct;
      }

      throw (0, _error.newError)('Unknown packed value with marker ' + marker.toString(16));
    }
  }, {
    key: "unpackInteger",
    value: function unpackInteger(buffer) {
      var marker = buffer.readUInt8();

      var result = this._unpackInteger(marker, buffer);

      if (result == null) {
        throw (0, _error.newError)('Unable to unpack integer value with marker ' + marker.toString(16));
      }

      return result;
    }
  }, {
    key: "_unpackBoolean",
    value: function _unpackBoolean(marker) {
      if (marker === TRUE) {
        return true;
      } else if (marker === FALSE) {
        return false;
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackNumberOrInteger",
    value: function _unpackNumberOrInteger(marker, buffer) {
      if (marker === FLOAT_64) {
        return buffer.readFloat64();
      } else {
        return this._unpackInteger(marker, buffer);
      }
    }
  }, {
    key: "_unpackInteger",
    value: function _unpackInteger(marker, buffer) {
      if (marker >= 0 && marker < 128) {
        return (0, _integer["int"])(marker);
      } else if (marker >= 240 && marker < 256) {
        return (0, _integer["int"])(marker - 256);
      } else if (marker === INT_8) {
        return (0, _integer["int"])(buffer.readInt8());
      } else if (marker === INT_16) {
        return (0, _integer["int"])(buffer.readInt16());
      } else if (marker === INT_32) {
        var b = buffer.readInt32();
        return (0, _integer["int"])(b);
      } else if (marker === INT_64) {
        var high = buffer.readInt32();
        var low = buffer.readInt32();
        return new _integer["default"](low, high);
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackString",
    value: function _unpackString(marker, markerHigh, markerLow, buffer) {
      if (markerHigh === TINY_STRING) {
        return _node.utf8.decode(buffer, markerLow);
      } else if (marker === STRING_8) {
        return _node.utf8.decode(buffer, buffer.readUInt8());
      } else if (marker === STRING_16) {
        return _node.utf8.decode(buffer, buffer.readUInt16());
      } else if (marker === STRING_32) {
        return _node.utf8.decode(buffer, buffer.readUInt32());
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackList",
    value: function _unpackList(marker, markerHigh, markerLow, buffer) {
      if (markerHigh === TINY_LIST) {
        return this._unpackListWithSize(markerLow, buffer);
      } else if (marker === LIST_8) {
        return this._unpackListWithSize(buffer.readUInt8(), buffer);
      } else if (marker === LIST_16) {
        return this._unpackListWithSize(buffer.readUInt16(), buffer);
      } else if (marker === LIST_32) {
        return this._unpackListWithSize(buffer.readUInt32(), buffer);
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackListWithSize",
    value: function _unpackListWithSize(size, buffer) {
      var value = [];

      for (var i = 0; i < size; i++) {
        value.push(this.unpack(buffer));
      }

      return value;
    }
  }, {
    key: "_unpackByteArray",
    value: function _unpackByteArray(marker, buffer) {
      if (marker === BYTES_8) {
        return this._unpackByteArrayWithSize(buffer.readUInt8(), buffer);
      } else if (marker === BYTES_16) {
        return this._unpackByteArrayWithSize(buffer.readUInt16(), buffer);
      } else if (marker === BYTES_32) {
        return this._unpackByteArrayWithSize(buffer.readUInt32(), buffer);
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackByteArrayWithSize",
    value: function _unpackByteArrayWithSize(size, buffer) {
      var value = new Int8Array(size);

      for (var i = 0; i < size; i++) {
        value[i] = buffer.readInt8();
      }

      return value;
    }
  }, {
    key: "_unpackMap",
    value: function _unpackMap(marker, markerHigh, markerLow, buffer) {
      if (markerHigh === TINY_MAP) {
        return this._unpackMapWithSize(markerLow, buffer);
      } else if (marker === MAP_8) {
        return this._unpackMapWithSize(buffer.readUInt8(), buffer);
      } else if (marker === MAP_16) {
        return this._unpackMapWithSize(buffer.readUInt16(), buffer);
      } else if (marker === MAP_32) {
        return this._unpackMapWithSize(buffer.readUInt32(), buffer);
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackMapWithSize",
    value: function _unpackMapWithSize(size, buffer) {
      var value = {};

      for (var i = 0; i < size; i++) {
        var key = this.unpack(buffer);
        value[key] = this.unpack(buffer);
      }

      return value;
    }
  }, {
    key: "_unpackStruct",
    value: function _unpackStruct(marker, markerHigh, markerLow, buffer) {
      if (markerHigh === TINY_STRUCT) {
        return this._unpackStructWithSize(markerLow, buffer);
      } else if (marker === STRUCT_8) {
        return this._unpackStructWithSize(buffer.readUInt8(), buffer);
      } else if (marker === STRUCT_16) {
        return this._unpackStructWithSize(buffer.readUInt16(), buffer);
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackStructWithSize",
    value: function _unpackStructWithSize(structSize, buffer) {
      var signature = buffer.readUInt8();

      if (signature === NODE) {
        return this._unpackNode(structSize, buffer);
      } else if (signature === RELATIONSHIP) {
        return this._unpackRelationship(structSize, buffer);
      } else if (signature === UNBOUND_RELATIONSHIP) {
        return this._unpackUnboundRelationship(structSize, buffer);
      } else if (signature === PATH) {
        return this._unpackPath(structSize, buffer);
      } else {
        return this._unpackUnknownStruct(signature, structSize, buffer);
      }
    }
  }, {
    key: "_unpackNode",
    value: function _unpackNode(structSize, buffer) {
      this._verifyStructSize('Node', NODE_STRUCT_SIZE, structSize);

      return new _graphTypes.Node(this.unpack(buffer), // Identity
      this.unpack(buffer), // Labels
      this.unpack(buffer) // Properties
      );
    }
  }, {
    key: "_unpackRelationship",
    value: function _unpackRelationship(structSize, buffer) {
      this._verifyStructSize('Relationship', RELATIONSHIP_STRUCT_SIZE, structSize);

      return new _graphTypes.Relationship(this.unpack(buffer), // Identity
      this.unpack(buffer), // Start Node Identity
      this.unpack(buffer), // End Node Identity
      this.unpack(buffer), // Type
      this.unpack(buffer) // Properties
      );
    }
  }, {
    key: "_unpackUnboundRelationship",
    value: function _unpackUnboundRelationship(structSize, buffer) {
      this._verifyStructSize('UnboundRelationship', UNBOUND_RELATIONSHIP_STRUCT_SIZE, structSize);

      return new _graphTypes.UnboundRelationship(this.unpack(buffer), // Identity
      this.unpack(buffer), // Type
      this.unpack(buffer) // Properties
      );
    }
  }, {
    key: "_unpackPath",
    value: function _unpackPath(structSize, buffer) {
      this._verifyStructSize('Path', PATH_STRUCT_SIZE, structSize);

      var nodes = this.unpack(buffer);
      var rels = this.unpack(buffer);
      var sequence = this.unpack(buffer);
      var segments = [];
      var prevNode = nodes[0];

      for (var i = 0; i < sequence.length; i += 2) {
        var nextNode = nodes[sequence[i + 1]];
        var relIndex = sequence[i];
        var rel = void 0;

        if (relIndex > 0) {
          rel = rels[relIndex - 1];

          if (rel instanceof _graphTypes.UnboundRelationship) {
            // To avoid duplication, relationships in a path do not contain
            // information about their start and end nodes, that's instead
            // inferred from the path sequence. This is us inferring (and,
            // for performance reasons remembering) the start/end of a rel.
            rels[relIndex - 1] = rel = rel.bind(prevNode.identity, nextNode.identity);
          }
        } else {
          rel = rels[-relIndex - 1];

          if (rel instanceof _graphTypes.UnboundRelationship) {
            // See above
            rels[-relIndex - 1] = rel = rel.bind(nextNode.identity, prevNode.identity);
          }
        } // Done hydrating one path segment.


        segments.push(new _graphTypes.PathSegment(prevNode, rel, nextNode));
        prevNode = nextNode;
      }

      return new _graphTypes.Path(nodes[0], nodes[nodes.length - 1], segments);
    }
  }, {
    key: "_unpackUnknownStruct",
    value: function _unpackUnknownStruct(signature, structSize, buffer) {
      var result = new Structure(signature, []);

      for (var i = 0; i < structSize; i++) {
        result.fields.push(this.unpack(buffer));
      }

      return result;
    }
  }, {
    key: "_verifyStructSize",
    value: function _verifyStructSize(structName, expectedSize, actualSize) {
      if (expectedSize !== actualSize) {
        throw (0, _error.newError)("Wrong struct size for ".concat(structName, ", expected ").concat(expectedSize, " but was ").concat(actualSize), _error.PROTOCOL_ERROR);
      }
    }
  }]);
  return Unpacker;
}();

exports.Unpacker = Unpacker;

function isIterable(obj) {
  if (obj == null) {
    return false;
  }

  return typeof obj[Symbol.iterator] === 'function';
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/packstream-v2.js":
/*!*****************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/packstream-v2.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Unpacker = exports.Packer = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var v1 = _interopRequireWildcard(__webpack_require__(/*! ./packstream-v1 */ "./node_modules/neo4j-driver/lib/internal/packstream-v1.js"));

var _spatialTypes = __webpack_require__(/*! ../spatial-types */ "./node_modules/neo4j-driver/lib/spatial-types.js");

var _temporalTypes = __webpack_require__(/*! ../temporal-types */ "./node_modules/neo4j-driver/lib/temporal-types.js");

var _integer = __webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js");

var _temporalUtil = __webpack_require__(/*! ./temporal-util */ "./node_modules/neo4j-driver/lib/internal/temporal-util.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var POINT_2D = 0x58;
var POINT_2D_STRUCT_SIZE = 3;
var POINT_3D = 0x59;
var POINT_3D_STRUCT_SIZE = 4;
var DURATION = 0x45;
var DURATION_STRUCT_SIZE = 4;
var LOCAL_TIME = 0x74;
var LOCAL_TIME_STRUCT_SIZE = 1;
var TIME = 0x54;
var TIME_STRUCT_SIZE = 2;
var DATE = 0x44;
var DATE_STRUCT_SIZE = 1;
var LOCAL_DATE_TIME = 0x64;
var LOCAL_DATE_TIME_STRUCT_SIZE = 2;
var DATE_TIME_WITH_ZONE_OFFSET = 0x46;
var DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;
var DATE_TIME_WITH_ZONE_ID = 0x66;
var DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;

var Packer = /*#__PURE__*/function (_v1$Packer) {
  (0, _inherits2["default"])(Packer, _v1$Packer);

  var _super = _createSuper(Packer);

  function Packer() {
    (0, _classCallCheck2["default"])(this, Packer);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(Packer, [{
    key: "disableByteArrays",
    value: function disableByteArrays() {
      throw new Error('Bolt V2 should always support byte arrays');
    }
  }, {
    key: "packable",
    value: function packable(obj) {
      var _this = this;

      if ((0, _spatialTypes.isPoint)(obj)) {
        return function () {
          return packPoint(obj, _this);
        };
      } else if ((0, _temporalTypes.isDuration)(obj)) {
        return function () {
          return packDuration(obj, _this);
        };
      } else if ((0, _temporalTypes.isLocalTime)(obj)) {
        return function () {
          return packLocalTime(obj, _this);
        };
      } else if ((0, _temporalTypes.isTime)(obj)) {
        return function () {
          return packTime(obj, _this);
        };
      } else if ((0, _temporalTypes.isDate)(obj)) {
        return function () {
          return packDate(obj, _this);
        };
      } else if ((0, _temporalTypes.isLocalDateTime)(obj)) {
        return function () {
          return packLocalDateTime(obj, _this);
        };
      } else if ((0, _temporalTypes.isDateTime)(obj)) {
        return function () {
          return packDateTime(obj, _this);
        };
      } else {
        return (0, _get2["default"])((0, _getPrototypeOf2["default"])(Packer.prototype), "packable", this).call(this, obj);
      }
    }
  }]);
  return Packer;
}(v1.Packer);

exports.Packer = Packer;

var Unpacker = /*#__PURE__*/function (_v1$Unpacker) {
  (0, _inherits2["default"])(Unpacker, _v1$Unpacker);

  var _super2 = _createSuper(Unpacker);

  /**
   * @constructor
   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.
   */
  function Unpacker() {
    var disableLosslessIntegers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    (0, _classCallCheck2["default"])(this, Unpacker);
    return _super2.call(this, disableLosslessIntegers);
  }

  (0, _createClass2["default"])(Unpacker, [{
    key: "_unpackUnknownStruct",
    value: function _unpackUnknownStruct(signature, structSize, buffer) {
      if (signature === POINT_2D) {
        return unpackPoint2D(this, structSize, buffer);
      } else if (signature === POINT_3D) {
        return unpackPoint3D(this, structSize, buffer);
      } else if (signature === DURATION) {
        return unpackDuration(this, structSize, buffer);
      } else if (signature === LOCAL_TIME) {
        return unpackLocalTime(this, structSize, buffer, this._disableLosslessIntegers);
      } else if (signature === TIME) {
        return unpackTime(this, structSize, buffer, this._disableLosslessIntegers);
      } else if (signature === DATE) {
        return unpackDate(this, structSize, buffer, this._disableLosslessIntegers);
      } else if (signature === LOCAL_DATE_TIME) {
        return unpackLocalDateTime(this, structSize, buffer, this._disableLosslessIntegers);
      } else if (signature === DATE_TIME_WITH_ZONE_OFFSET) {
        return unpackDateTimeWithZoneOffset(this, structSize, buffer, this._disableLosslessIntegers);
      } else if (signature === DATE_TIME_WITH_ZONE_ID) {
        return unpackDateTimeWithZoneId(this, structSize, buffer, this._disableLosslessIntegers);
      } else {
        return (0, _get2["default"])((0, _getPrototypeOf2["default"])(Unpacker.prototype), "_unpackUnknownStruct", this).call(this, signature, structSize, buffer, this._disableLosslessIntegers);
      }
    }
  }]);
  return Unpacker;
}(v1.Unpacker);
/**
 * Pack given 2D or 3D point.
 * @param {Point} point the point value to pack.
 * @param {Packer} packer the packer to use.
 */


exports.Unpacker = Unpacker;

function packPoint(point, packer) {
  var is2DPoint = point.z === null || point.z === undefined;

  if (is2DPoint) {
    packPoint2D(point, packer);
  } else {
    packPoint3D(point, packer);
  }
}
/**
 * Pack given 2D point.
 * @param {Point} point the point value to pack.
 * @param {Packer} packer the packer to use.
 */


function packPoint2D(point, packer) {
  var packableStructFields = [packer.packable((0, _integer["int"])(point.srid)), packer.packable(point.x), packer.packable(point.y)];
  packer.packStruct(POINT_2D, packableStructFields);
}
/**
 * Pack given 3D point.
 * @param {Point} point the point value to pack.
 * @param {Packer} packer the packer to use.
 */


function packPoint3D(point, packer) {
  var packableStructFields = [packer.packable((0, _integer["int"])(point.srid)), packer.packable(point.x), packer.packable(point.y), packer.packable(point.z)];
  packer.packStruct(POINT_3D, packableStructFields);
}
/**
 * Unpack 2D point value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @return {Point} the unpacked 2D point value.
 */


function unpackPoint2D(unpacker, structSize, buffer) {
  unpacker._verifyStructSize('Point2D', POINT_2D_STRUCT_SIZE, structSize);

  return new _spatialTypes.Point(unpacker.unpack(buffer), // srid
  unpacker.unpack(buffer), // x
  unpacker.unpack(buffer), // y
  undefined // z
  );
}
/**
 * Unpack 3D point value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @return {Point} the unpacked 3D point value.
 */


function unpackPoint3D(unpacker, structSize, buffer) {
  unpacker._verifyStructSize('Point3D', POINT_3D_STRUCT_SIZE, structSize);

  return new _spatialTypes.Point(unpacker.unpack(buffer), // srid
  unpacker.unpack(buffer), // x
  unpacker.unpack(buffer), // y
  unpacker.unpack(buffer) // z
  );
}
/**
 * Pack given duration.
 * @param {Duration} value the duration value to pack.
 * @param {Packer} packer the packer to use.
 */


function packDuration(value, packer) {
  var months = (0, _integer["int"])(value.months);
  var days = (0, _integer["int"])(value.days);
  var seconds = (0, _integer["int"])(value.seconds);
  var nanoseconds = (0, _integer["int"])(value.nanoseconds);
  var packableStructFields = [packer.packable(months), packer.packable(days), packer.packable(seconds), packer.packable(nanoseconds)];
  packer.packStruct(DURATION, packableStructFields);
}
/**
 * Unpack duration value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @return {Duration} the unpacked duration value.
 */


function unpackDuration(unpacker, structSize, buffer) {
  unpacker._verifyStructSize('Duration', DURATION_STRUCT_SIZE, structSize);

  var months = unpacker.unpack(buffer);
  var days = unpacker.unpack(buffer);
  var seconds = unpacker.unpack(buffer);
  var nanoseconds = unpacker.unpack(buffer);
  return new _temporalTypes.Duration(months, days, seconds, nanoseconds);
}
/**
 * Pack given local time.
 * @param {LocalTime} value the local time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packLocalTime(value, packer) {
  var nanoOfDay = (0, _temporalUtil.localTimeToNanoOfDay)(value.hour, value.minute, value.second, value.nanosecond);
  var packableStructFields = [packer.packable(nanoOfDay)];
  packer.packStruct(LOCAL_TIME, packableStructFields);
}
/**
 * Unpack local time value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result local time should be native JS numbers.
 * @return {LocalTime} the unpacked local time value.
 */


function unpackLocalTime(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('LocalTime', LOCAL_TIME_STRUCT_SIZE, structSize);

  var nanoOfDay = unpacker.unpackInteger(buffer);
  var result = (0, _temporalUtil.nanoOfDayToLocalTime)(nanoOfDay);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}
/**
 * Pack given time.
 * @param {Time} value the time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packTime(value, packer) {
  var nanoOfDay = (0, _temporalUtil.localTimeToNanoOfDay)(value.hour, value.minute, value.second, value.nanosecond);
  var offsetSeconds = (0, _integer["int"])(value.timeZoneOffsetSeconds);
  var packableStructFields = [packer.packable(nanoOfDay), packer.packable(offsetSeconds)];
  packer.packStruct(TIME, packableStructFields);
}
/**
 * Unpack time value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result time should be native JS numbers.
 * @return {Time} the unpacked time value.
 */


function unpackTime(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('Time', TIME_STRUCT_SIZE, structSize);

  var nanoOfDay = unpacker.unpackInteger(buffer);
  var offsetSeconds = unpacker.unpackInteger(buffer);
  var localTime = (0, _temporalUtil.nanoOfDayToLocalTime)(nanoOfDay);
  var result = new _temporalTypes.Time(localTime.hour, localTime.minute, localTime.second, localTime.nanosecond, offsetSeconds);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}
/**
 * Pack given neo4j date.
 * @param {Date} value the date value to pack.
 * @param {Packer} packer the packer to use.
 */


function packDate(value, packer) {
  var epochDay = (0, _temporalUtil.dateToEpochDay)(value.year, value.month, value.day);
  var packableStructFields = [packer.packable(epochDay)];
  packer.packStruct(DATE, packableStructFields);
}
/**
 * Unpack neo4j date value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result date should be native JS numbers.
 * @return {Date} the unpacked neo4j date value.
 */


function unpackDate(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('Date', DATE_STRUCT_SIZE, structSize);

  var epochDay = unpacker.unpackInteger(buffer);
  var result = (0, _temporalUtil.epochDayToDate)(epochDay);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}
/**
 * Pack given local date time.
 * @param {LocalDateTime} value the local date time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packLocalDateTime(value, packer) {
  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);
  var nano = (0, _integer["int"])(value.nanosecond);
  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano)];
  packer.packStruct(LOCAL_DATE_TIME, packableStructFields);
}
/**
 * Unpack local date time value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result local date-time should be native JS numbers.
 * @return {LocalDateTime} the unpacked local date time value.
 */


function unpackLocalDateTime(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('LocalDateTime', LOCAL_DATE_TIME_STRUCT_SIZE, structSize);

  var epochSecond = unpacker.unpackInteger(buffer);
  var nano = unpacker.unpackInteger(buffer);
  var result = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}
/**
 * Pack given date time.
 * @param {DateTime} value the date time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packDateTime(value, packer) {
  if (value.timeZoneId) {
    packDateTimeWithZoneId(value, packer);
  } else {
    packDateTimeWithZoneOffset(value, packer);
  }
}
/**
 * Pack given date time with zone offset.
 * @param {DateTime} value the date time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packDateTimeWithZoneOffset(value, packer) {
  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);
  var nano = (0, _integer["int"])(value.nanosecond);
  var timeZoneOffsetSeconds = (0, _integer["int"])(value.timeZoneOffsetSeconds);
  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneOffsetSeconds)];
  packer.packStruct(DATE_TIME_WITH_ZONE_OFFSET, packableStructFields);
}
/**
 * Unpack date time with zone offset value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.
 * @return {DateTime} the unpacked date time with zone offset value.
 */


function unpackDateTimeWithZoneOffset(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, structSize);

  var epochSecond = unpacker.unpackInteger(buffer);
  var nano = unpacker.unpackInteger(buffer);
  var timeZoneOffsetSeconds = unpacker.unpackInteger(buffer);
  var localDateTime = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);
  var result = new _temporalTypes.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}
/**
 * Pack given date time with zone id.
 * @param {DateTime} value the date time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packDateTimeWithZoneId(value, packer) {
  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);
  var nano = (0, _integer["int"])(value.nanosecond);
  var timeZoneId = value.timeZoneId;
  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneId)];
  packer.packStruct(DATE_TIME_WITH_ZONE_ID, packableStructFields);
}
/**
 * Unpack date time with zone id value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.
 * @return {DateTime} the unpacked date time with zone id value.
 */


function unpackDateTimeWithZoneId(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, structSize);

  var epochSecond = unpacker.unpackInteger(buffer);
  var nano = unpacker.unpackInteger(buffer);
  var timeZoneId = unpacker.unpack(buffer);
  var localDateTime = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);
  var result = new _temporalTypes.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, null, timeZoneId);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}

function convertIntegerPropsIfNeeded(obj, disableLosslessIntegers) {
  if (!disableLosslessIntegers) {
    return obj;
  }

  var clone = Object.create(Object.getPrototypeOf(obj));

  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      var value = obj[prop];
      clone[prop] = (0, _integer.isInt)(value) ? value.toNumberOrInfinity() : value;
    }
  }

  Object.freeze(clone);
  return clone;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/pool-config.js":
/*!***************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/pool-config.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_ACQUISITION_TIMEOUT = exports.DEFAULT_MAX_SIZE = exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_MAX_SIZE = 100;
exports.DEFAULT_MAX_SIZE = DEFAULT_MAX_SIZE;
var DEFAULT_ACQUISITION_TIMEOUT = 60 * 1000; // 60 seconds

exports.DEFAULT_ACQUISITION_TIMEOUT = DEFAULT_ACQUISITION_TIMEOUT;

var PoolConfig = /*#__PURE__*/function () {
  function PoolConfig(maxSize, acquisitionTimeout) {
    (0, _classCallCheck2["default"])(this, PoolConfig);
    this.maxSize = valueOrDefault(maxSize, DEFAULT_MAX_SIZE);
    this.acquisitionTimeout = valueOrDefault(acquisitionTimeout, DEFAULT_ACQUISITION_TIMEOUT);
  }

  (0, _createClass2["default"])(PoolConfig, null, [{
    key: "defaultConfig",
    value: function defaultConfig() {
      return new PoolConfig(DEFAULT_MAX_SIZE, DEFAULT_ACQUISITION_TIMEOUT);
    }
  }, {
    key: "fromDriverConfig",
    value: function fromDriverConfig(config) {
      var maxSizeConfigured = isConfigured(config.maxConnectionPoolSize);
      var maxSize = maxSizeConfigured ? config.maxConnectionPoolSize : DEFAULT_MAX_SIZE;
      var acquisitionTimeoutConfigured = isConfigured(config.connectionAcquisitionTimeout);
      var acquisitionTimeout = acquisitionTimeoutConfigured ? config.connectionAcquisitionTimeout : DEFAULT_ACQUISITION_TIMEOUT;
      return new PoolConfig(maxSize, acquisitionTimeout);
    }
  }]);
  return PoolConfig;
}();

exports["default"] = PoolConfig;

function valueOrDefault(value, defaultValue) {
  return value === 0 || value ? value : defaultValue;
}

function isConfigured(value) {
  return value === 0 || value;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/pool.js":
/*!********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/pool.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _poolConfig = _interopRequireDefault(__webpack_require__(/*! ./pool-config */ "./node_modules/neo4j-driver/lib/internal/pool-config.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _logger = _interopRequireDefault(__webpack_require__(/*! ./logger */ "./node_modules/neo4j-driver/lib/internal/logger.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Pool = /*#__PURE__*/function () {
  /**
   * @param {function(address: ServerAddress, function(address: ServerAddress, resource: object): Promise<object>): Promise<object>} create
   *                an allocation function that creates a promise with a new resource. It's given an address for which to
   *                allocate the connection and a function that will return the resource to the pool if invoked, which is
   *                meant to be called on .dispose or .close or whatever mechanism the resource uses to finalize.
   * @param {function(resource: object): Promise<void>} destroy
   *                called with the resource when it is evicted from this pool
   * @param {function(resource: object): boolean} validate
   *                called at various times (like when an instance is acquired and when it is returned.
   *                If this returns false, the resource will be evicted
   * @param {function(resource: object, observer: { onError }): void} installIdleObserver
   *                called when the resource is released back to pool
   * @param {function(resource: object): void} removeIdleObserver
   *                called when the resource is acquired from the pool
   * @param {PoolConfig} config configuration for the new driver.
   * @param {Logger} log the driver logger.
   */
  function Pool() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$create = _ref.create,
        create = _ref$create === void 0 ? function (address, release) {
      return Promise.resolve();
    } : _ref$create,
        _ref$destroy = _ref.destroy,
        destroy = _ref$destroy === void 0 ? function (conn) {
      return Promise.resolve();
    } : _ref$destroy,
        _ref$validate = _ref.validate,
        validate = _ref$validate === void 0 ? function (conn) {
      return true;
    } : _ref$validate,
        _ref$installIdleObser = _ref.installIdleObserver,
        installIdleObserver = _ref$installIdleObser === void 0 ? function (conn, observer) {} : _ref$installIdleObser,
        _ref$removeIdleObserv = _ref.removeIdleObserver,
        removeIdleObserver = _ref$removeIdleObserv === void 0 ? function (conn) {} : _ref$removeIdleObserv,
        _ref$config = _ref.config,
        config = _ref$config === void 0 ? _poolConfig["default"].defaultConfig() : _ref$config,
        _ref$log = _ref.log,
        log = _ref$log === void 0 ? _logger["default"].noOp() : _ref$log;

    (0, _classCallCheck2["default"])(this, Pool);
    this._create = create;
    this._destroy = destroy;
    this._validate = validate;
    this._installIdleObserver = installIdleObserver;
    this._removeIdleObserver = removeIdleObserver;
    this._maxSize = config.maxSize;
    this._acquisitionTimeout = config.acquisitionTimeout;
    this._pools = {};
    this._pendingCreates = {};
    this._acquireRequests = {};
    this._activeResourceCounts = {};
    this._release = this._release.bind(this);
    this._log = log;
    this._closed = false;
  }
  /**
   * Acquire and idle resource fom the pool or create a new one.
   * @param {ServerAddress} address the address for which we're acquiring.
   * @return {Object} resource that is ready to use.
   */


  (0, _createClass2["default"])(Pool, [{
    key: "acquire",
    value: function acquire(address) {
      var _this = this;

      return this._acquire(address).then(function (resource) {
        var key = address.asKey();

        if (resource) {
          resourceAcquired(key, _this._activeResourceCounts);

          if (_this._log.isDebugEnabled()) {
            _this._log.debug("".concat(resource, " acquired from the pool ").concat(key));
          }

          return resource;
        } // We're out of resources and will try to acquire later on when an existing resource is released.


        var allRequests = _this._acquireRequests;
        var requests = allRequests[key];

        if (!requests) {
          allRequests[key] = [];
        }

        return new Promise(function (resolve, reject) {
          var request;
          var timeoutId = setTimeout(function () {
            // acquisition timeout fired
            // remove request from the queue of pending requests, if it's still there
            // request might've been taken out by the release operation
            var pendingRequests = allRequests[key];

            if (pendingRequests) {
              allRequests[key] = pendingRequests.filter(function (item) {
                return item !== request;
              });
            }

            if (request.isCompleted()) {// request already resolved/rejected by the release operation; nothing to do
            } else {
              // request is still pending and needs to be failed
              var activeCount = _this.activeResourceCount(address);

              var idleCount = _this.has(address) ? _this._pools[key].length : 0;
              request.reject((0, _error.newError)("Connection acquisition timed out in ".concat(_this._acquisitionTimeout, " ms. Poos status: Active conn count = ").concat(activeCount, ", Idle conn count = ").concat(idleCount, ".")));
            }
          }, _this._acquisitionTimeout);
          request = new PendingRequest(key, resolve, reject, timeoutId, _this._log);
          allRequests[key].push(request);
        });
      });
    }
    /**
     * Destroy all idle resources for the given address.
     * @param {ServerAddress} address the address of the server to purge its pool.
     * @returns {Promise<void>} A promise that is resolved when the resources are purged
     */

  }, {
    key: "purge",
    value: function purge(address) {
      return this._purgeKey(address.asKey());
    }
    /**
     * Destroy all idle resources in this pool.
     * @returns {Promise<void>} A promise that is resolved when the resources are purged
     */

  }, {
    key: "close",
    value: function close() {
      var _this2 = this;

      this._closed = true;
      return Promise.all(Object.keys(this._pools).map(function (key) {
        return _this2._purgeKey(key);
      }));
    }
    /**
     * Keep the idle resources for the provided addresses and purge the rest.
     * @returns {Promise<void>} A promise that is resolved when the other resources are purged
     */

  }, {
    key: "keepAll",
    value: function keepAll(addresses) {
      var _this3 = this;

      var keysToKeep = addresses.map(function (a) {
        return a.asKey();
      });
      var keysPresent = Object.keys(this._pools);
      var keysToPurge = keysPresent.filter(function (k) {
        return keysToKeep.indexOf(k) === -1;
      });
      return Promise.all(keysToPurge.map(function (key) {
        return _this3._purgeKey(key);
      }));
    }
    /**
     * Check if this pool contains resources for the given address.
     * @param {ServerAddress} address the address of the server to check.
     * @return {boolean} `true` when pool contains entries for the given key, <code>false</code> otherwise.
     */

  }, {
    key: "has",
    value: function has(address) {
      return address.asKey() in this._pools;
    }
    /**
     * Get count of active (checked out of the pool) resources for the given key.
     * @param {ServerAddress} address the address of the server to check.
     * @return {number} count of resources acquired by clients.
     */

  }, {
    key: "activeResourceCount",
    value: function activeResourceCount(address) {
      return this._activeResourceCounts[address.asKey()] || 0;
    }
  }, {
    key: "_acquire",
    value: function () {
      var _acquire2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(address) {
        var key, pool, _resource, numConnections, resource;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._closed) {
                  _context.next = 2;
                  break;
                }

                throw (0, _error.newError)('Pool is closed, it is no more able to serve requests.');

              case 2:
                key = address.asKey();
                pool = this._pools[key];

                if (!pool) {
                  pool = [];
                  this._pools[key] = pool;
                  this._pendingCreates[key] = 0;
                }

              case 5:
                if (!pool.length) {
                  _context.next = 16;
                  break;
                }

                _resource = pool.pop();

                if (!this._validate(_resource)) {
                  _context.next = 12;
                  break;
                }

                if (this._removeIdleObserver) {
                  this._removeIdleObserver(_resource);
                } // idle resource is valid and can be acquired


                return _context.abrupt("return", Promise.resolve(_resource));

              case 12:
                _context.next = 14;
                return this._destroy(_resource);

              case 14:
                _context.next = 5;
                break;

              case 16:
                if (!(this._maxSize > 0)) {
                  _context.next = 20;
                  break;
                }

                // Include pending creates when checking pool size since these probably will add
                // to the number when fulfilled.
                numConnections = this.activeResourceCount(address) + this._pendingCreates[key];

                if (!(numConnections >= this._maxSize)) {
                  _context.next = 20;
                  break;
                }

                return _context.abrupt("return", null);

              case 20:
                // there exist no idle valid resources, create a new one for acquisition
                // Keep track of how many pending creates there are to avoid making too many connections.
                this._pendingCreates[key] = this._pendingCreates[key] + 1;
                _context.prev = 21;
                _context.next = 24;
                return this._create(address, this._release);

              case 24:
                resource = _context.sent;

              case 25:
                _context.prev = 25;
                this._pendingCreates[key] = this._pendingCreates[key] - 1;
                return _context.finish(25);

              case 28:
                return _context.abrupt("return", resource);

              case 29:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[21,, 25, 28]]);
      }));

      function _acquire(_x) {
        return _acquire2.apply(this, arguments);
      }

      return _acquire;
    }()
  }, {
    key: "_release",
    value: function () {
      var _release2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(address, resource) {
        var _this4 = this;

        var key, pool;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                key = address.asKey();
                pool = this._pools[key];

                if (!pool) {
                  _context2.next = 14;
                  break;
                }

                if (this._validate(resource)) {
                  _context2.next = 9;
                  break;
                }

                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(resource, " destroyed and can't be released to the pool ").concat(key, " because it is not functional"));
                }

                _context2.next = 7;
                return this._destroy(resource);

              case 7:
                _context2.next = 12;
                break;

              case 9:
                if (this._installIdleObserver) {
                  this._installIdleObserver(resource, {
                    onError: function onError(error) {
                      _this4._log.debug("Idle connection ".concat(resource, " destroyed because of error: ").concat(error));

                      var pool = _this4._pools[key];

                      if (pool) {
                        _this4._pools[key] = pool.filter(function (r) {
                          return r !== resource;
                        });
                      } // let's not care about background clean-ups due to errors but just trigger the destroy
                      // process for the resource, we especially catch any errors and ignore them to avoid
                      // unhandled promise rejection warnings


                      _this4._destroy(resource)["catch"](function () {});
                    }
                  });
                }

                pool.push(resource);

                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(resource, " released to the pool ").concat(key));
                }

              case 12:
                _context2.next = 17;
                break;

              case 14:
                // key has been purged, don't put it back, just destroy the resource
                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(resource, " destroyed and can't be released to the pool ").concat(key, " because pool has been purged"));
                }

                _context2.next = 17;
                return this._destroy(resource);

              case 17:
                resourceReleased(key, this._activeResourceCounts);

                this._processPendingAcquireRequests(address);

              case 19:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _release(_x2, _x3) {
        return _release2.apply(this, arguments);
      }

      return _release;
    }()
  }, {
    key: "_purgeKey",
    value: function () {
      var _purgeKey2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(key) {
        var pool, resource;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                pool = this._pools[key] || [];

              case 1:
                if (!pool.length) {
                  _context3.next = 8;
                  break;
                }

                resource = pool.pop();

                if (this._removeIdleObserver) {
                  this._removeIdleObserver(resource);
                }

                _context3.next = 6;
                return this._destroy(resource);

              case 6:
                _context3.next = 1;
                break;

              case 8:
                delete this._pools[key];

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _purgeKey(_x4) {
        return _purgeKey2.apply(this, arguments);
      }

      return _purgeKey;
    }()
  }, {
    key: "_processPendingAcquireRequests",
    value: function _processPendingAcquireRequests(address) {
      var _this5 = this;

      var key = address.asKey();
      var requests = this._acquireRequests[key];

      if (requests) {
        var pendingRequest = requests.shift(); // pop a pending acquire request

        if (pendingRequest) {
          this._acquire(address)["catch"](function (error) {
            // failed to acquire/create a new connection to resolve the pending acquire request
            // propagate the error by failing the pending request
            pendingRequest.reject(error);
            return null;
          }).then(function (resource) {
            if (resource) {
              // managed to acquire a valid resource from the pool
              if (pendingRequest.isCompleted()) {
                // request has been completed, most likely failed by a timeout
                // return the acquired resource back to the pool
                _this5._release(address, resource);
              } else {
                // request is still pending and can be resolved with the newly acquired resource
                resourceAcquired(key, _this5._activeResourceCounts); // increment the active counter

                pendingRequest.resolve(resource); // resolve the pending request with the acquired resource
              }
            }
          });
        } else {
          delete this._acquireRequests[key];
        }
      }
    }
  }]);
  return Pool;
}();
/**
 * Increment active (checked out of the pool) resource counter.
 * @param {string} key the resource group identifier (server address for connections).
 * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.
 */


function resourceAcquired(key, activeResourceCounts) {
  var currentCount = activeResourceCounts[key] || 0;
  activeResourceCounts[key] = currentCount + 1;
}
/**
 * Decrement active (checked out of the pool) resource counter.
 * @param {string} key the resource group identifier (server address for connections).
 * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.
 */


function resourceReleased(key, activeResourceCounts) {
  var currentCount = activeResourceCounts[key] || 0;
  var nextCount = currentCount - 1;

  if (nextCount > 0) {
    activeResourceCounts[key] = nextCount;
  } else {
    delete activeResourceCounts[key];
  }
}

var PendingRequest = /*#__PURE__*/function () {
  function PendingRequest(key, resolve, reject, timeoutId, log) {
    (0, _classCallCheck2["default"])(this, PendingRequest);
    this._key = key;
    this._resolve = resolve;
    this._reject = reject;
    this._timeoutId = timeoutId;
    this._log = log;
    this._completed = false;
  }

  (0, _createClass2["default"])(PendingRequest, [{
    key: "isCompleted",
    value: function isCompleted() {
      return this._completed;
    }
  }, {
    key: "resolve",
    value: function resolve(resource) {
      if (this._completed) {
        return;
      }

      this._completed = true;
      clearTimeout(this._timeoutId);

      if (this._log.isDebugEnabled()) {
        this._log.debug("".concat(resource, " acquired from the pool ").concat(this._key));
      }

      this._resolve(resource);
    }
  }, {
    key: "reject",
    value: function reject(error) {
      if (this._completed) {
        return;
      }

      this._completed = true;
      clearTimeout(this._timeoutId);

      this._reject(error);
    }
  }]);
  return PendingRequest;
}();

var _default = Pool;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/protocol-handshaker.js":
/*!***********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/protocol-handshaker.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _node = __webpack_require__(/*! ./node */ "./node_modules/neo4j-driver/lib/internal/browser/index.js");

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _boltProtocolV = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v1 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v1.js"));

var _boltProtocolV2 = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v2 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v2.js"));

var _boltProtocolV3 = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v3 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v3.js"));

var _boltProtocolV4x = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v4x0 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v4x0.js"));

var _boltProtocolV4x2 = _interopRequireDefault(__webpack_require__(/*! ./bolt-protocol-v4x1 */ "./node_modules/neo4j-driver/lib/internal/bolt-protocol-v4x1.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BOLT_MAGIC_PREAMBLE = 0x6060b017;

var ProtocolHandshaker = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Connection} connection the connection owning this protocol.
   * @param {Channel} channel the network channel.
   * @param {Chunker} chunker the message chunker.
   * @param {boolean} disableLosslessIntegers flag to use native JS numbers.
   * @param {Logger} log the logger.
   */
  function ProtocolHandshaker(connection, channel, chunker, disableLosslessIntegers, log) {
    var serversideRouting = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    (0, _classCallCheck2["default"])(this, ProtocolHandshaker);
    this._connection = connection;
    this._channel = channel;
    this._chunker = chunker;
    this._disableLosslessIntegers = disableLosslessIntegers;
    this._log = log;
    this._serversideRouting = serversideRouting;
  }
  /**
   * Write a Bolt handshake into the underlying network channel.
   */


  (0, _createClass2["default"])(ProtocolHandshaker, [{
    key: "writeHandshakeRequest",
    value: function writeHandshakeRequest() {
      this._channel.write(newHandshakeBuffer());
    }
    /**
     * Read the given handshake response and create the negotiated bolt protocol.
     * @param {BaseBuffer} buffer byte buffer containing the handshake response.
     * @return {BoltProtocol} bolt protocol corresponding to the version suggested by the database.
     * @throws {Neo4jError} when bolt protocol can't be instantiated.
     */

  }, {
    key: "createNegotiatedProtocol",
    value: function createNegotiatedProtocol(buffer) {
      var h = [buffer.readUInt8(), buffer.readUInt8(), buffer.readUInt8(), buffer.readUInt8()];

      if (h[0] === 0x48 && h[1] === 0x54 && h[2] === 0x54 && h[3] === 0x50) {
        throw (0, _error.newError)('Server responded HTTP. Make sure you are not trying to connect to the http endpoint ' + '(HTTP defaults to port 7474 whereas BOLT defaults to port 7687)');
      }

      var negotiatedVersion = Number(h[3] + '.' + h[2]);

      if (this._log.isDebugEnabled()) {
        this._log.debug("".concat(this._connection, " negotiated protocol version ").concat(negotiatedVersion));
      }

      return this._createProtocolWithVersion(negotiatedVersion);
    }
    /**
     * @return {BoltProtocol}
     * @private
     */

  }, {
    key: "_createProtocolWithVersion",
    value: function _createProtocolWithVersion(version) {
      switch (version) {
        case 1:
          return new _boltProtocolV["default"](this._connection, this._chunker, this._disableLosslessIntegers);

        case 2:
          return new _boltProtocolV2["default"](this._connection, this._chunker, this._disableLosslessIntegers);

        case 3:
          return new _boltProtocolV3["default"](this._connection, this._chunker, this._disableLosslessIntegers);

        case 4.0:
          return new _boltProtocolV4x["default"](this._connection, this._chunker, this._disableLosslessIntegers);

        case 4.1:
          return new _boltProtocolV4x2["default"](this._connection, this._chunker, this._disableLosslessIntegers, this._serversideRouting);

        default:
          throw (0, _error.newError)('Unknown Bolt protocol version: ' + version);
      }
    }
  }]);
  return ProtocolHandshaker;
}();
/**
 * @return {BaseBuffer}
 * @private
 */


exports["default"] = ProtocolHandshaker;

function newHandshakeBuffer() {
  var handshakeBuffer = (0, _node.alloc)(5 * 4); // magic preamble

  handshakeBuffer.writeInt32(BOLT_MAGIC_PREAMBLE); // proposed versions

  handshakeBuffer.writeInt32(1 << 8 | 4);
  handshakeBuffer.writeInt32(4);
  handshakeBuffer.writeInt32(3);
  handshakeBuffer.writeInt32(2); // reset the reader position

  handshakeBuffer.reset();
  return handshakeBuffer;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/rediscovery.js":
/*!***************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/rediscovery.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _routingTable = _interopRequireDefault(__webpack_require__(/*! ./routing-table */ "./node_modules/neo4j-driver/lib/internal/routing-table.js"));

var _routingUtil = _interopRequireDefault(__webpack_require__(/*! ./routing-util */ "./node_modules/neo4j-driver/lib/internal/routing-util.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Rediscovery = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {RoutingUtil} routingUtil the util to use.
   */
  function Rediscovery(routingUtil) {
    (0, _classCallCheck2["default"])(this, Rediscovery);
    this._routingUtil = routingUtil;
  }
  /**
   * Try to fetch new routing table from the given router.
   * @param {Session} session the session to use.
   * @param {string} database the database for which to lookup routing table.
   * @param {string} routerAddress the URL of the router.
   * @return {Promise<RoutingTable>} promise resolved with new routing table or null when connection error happened.
   */


  (0, _createClass2["default"])(Rediscovery, [{
    key: "lookupRoutingTableOnRouter",
    value: function () {
      var _lookupRoutingTableOnRouter = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(session, database, routerAddress) {
        var records, record, expirationTime, _this$_routingUtil$pa, routers, readers, writers;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._routingUtil.callRoutingProcedure(session, database, routerAddress);

              case 2:
                records = _context.sent;

                if (!(records === null)) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return", null);

              case 5:
                if (!(records.length !== 1)) {
                  _context.next = 7;
                  break;
                }

                throw (0, _error.newError)('Illegal response from router "' + routerAddress + '". ' + 'Received ' + records.length + ' records but expected only one.\n' + JSON.stringify(records), _error.PROTOCOL_ERROR);

              case 7:
                record = records[0];
                expirationTime = this._routingUtil.parseTtl(record, routerAddress);
                _this$_routingUtil$pa = this._routingUtil.parseServers(record, routerAddress), routers = _this$_routingUtil$pa.routers, readers = _this$_routingUtil$pa.readers, writers = _this$_routingUtil$pa.writers;

                Rediscovery._assertNonEmpty(routers, 'routers', routerAddress);

                Rediscovery._assertNonEmpty(readers, 'readers', routerAddress); // case with no writers is processed higher in the promise chain because only RoutingDriver knows
                // how to deal with such table and how to treat router that returned such table


                return _context.abrupt("return", new _routingTable["default"]({
                  database: database,
                  routers: routers,
                  readers: readers,
                  writers: writers,
                  expirationTime: expirationTime
                }));

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function lookupRoutingTableOnRouter(_x, _x2, _x3) {
        return _lookupRoutingTableOnRouter.apply(this, arguments);
      }

      return lookupRoutingTableOnRouter;
    }()
  }], [{
    key: "_assertNonEmpty",
    value: function _assertNonEmpty(serverAddressesArray, serversName, routerAddress) {
      if (serverAddressesArray.length === 0) {
        throw (0, _error.newError)('Received no ' + serversName + ' from router ' + routerAddress, _error.PROTOCOL_ERROR);
      }
    }
  }]);
  return Rediscovery;
}();

exports["default"] = Rediscovery;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/request-message.js":
/*!*******************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/request-message.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.ALL = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

var _integer = __webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js");

var _util = __webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
// Signature bytes for each request message type
var INIT = 0x01; // 0000 0001 // INIT <user_agent> <authentication_token>

var ACK_FAILURE = 0x0e; // 0000 1110 // ACK_FAILURE - unused

var RESET = 0x0f; // 0000 1111 // RESET

var RUN = 0x10; // 0001 0000 // RUN <query> <parameters>

var DISCARD_ALL = 0x2f; // 0010 1111 // DISCARD_ALL - unused

var PULL_ALL = 0x3f; // 0011 1111 // PULL_ALL

var HELLO = 0x01; // 0000 0001 // HELLO <metadata>

var GOODBYE = 0x02; // 0000 0010 // GOODBYE

var BEGIN = 0x11; // 0001 0001 // BEGIN <metadata>

var COMMIT = 0x12; // 0001 0010 // COMMIT

var ROLLBACK = 0x13; // 0001 0011 // ROLLBACK

var DISCARD = 0x2f; // 0010 1111 // DISCARD

var PULL = 0x3f; // 0011 1111 // PULL

var READ_MODE = 'r';
/* eslint-enable no-unused-vars */

var NO_STATEMENT_ID = -1;
var ALL = -1;
exports.ALL = ALL;

var RequestMessage = /*#__PURE__*/function () {
  function RequestMessage(signature, fields, toString) {
    (0, _classCallCheck2["default"])(this, RequestMessage);
    this.signature = signature;
    this.fields = fields;
    this.toString = toString;
  }
  /**
   * Create a new INIT message.
   * @param {string} clientName the client name.
   * @param {Object} authToken the authentication token.
   * @return {RequestMessage} new INIT message.
   */


  (0, _createClass2["default"])(RequestMessage, null, [{
    key: "init",
    value: function init(clientName, authToken) {
      return new RequestMessage(INIT, [clientName, authToken], function () {
        return "INIT ".concat(clientName, " {...}");
      });
    }
    /**
     * Create a new RUN message.
     * @param {string} query the cypher query.
     * @param {Object} parameters the query parameters.
     * @return {RequestMessage} new RUN message.
     */

  }, {
    key: "run",
    value: function run(query, parameters) {
      return new RequestMessage(RUN, [query, parameters], function () {
        return "RUN ".concat(query, " ").concat(JSON.stringify(parameters));
      });
    }
    /**
     * Get a PULL_ALL message.
     * @return {RequestMessage} the PULL_ALL message.
     */

  }, {
    key: "pullAll",
    value: function pullAll() {
      return PULL_ALL_MESSAGE;
    }
    /**
     * Get a RESET message.
     * @return {RequestMessage} the RESET message.
     */

  }, {
    key: "reset",
    value: function reset() {
      return RESET_MESSAGE;
    }
    /**
     * Create a new HELLO message.
     * @param {string} userAgent the user agent.
     * @param {Object} authToken the authentication token.
     * @param {Object} optional server side routing, set to routing context to turn on server side routing (> 4.1)
     * @return {RequestMessage} new HELLO message.
     */

  }, {
    key: "hello",
    value: function hello(userAgent, authToken) {
      var routing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var metadata = Object.assign({
        user_agent: userAgent
      }, authToken);

      if (routing != null) {
        metadata.routing = routing;
      }

      return new RequestMessage(HELLO, [metadata], function () {
        return "HELLO {user_agent: '".concat(userAgent, "', ...}");
      });
    }
    /**
     * Create a new BEGIN message.
     * @param {Bookmark} bookmark the bookmark.
     * @param {TxConfig} txConfig the configuration.
     * @param {string} database the database name.
     * @param {string} mode the access mode.
     * @return {RequestMessage} new BEGIN message.
     */

  }, {
    key: "begin",
    value: function begin() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          bookmark = _ref.bookmark,
          txConfig = _ref.txConfig,
          database = _ref.database,
          mode = _ref.mode;

      var metadata = buildTxMetadata(bookmark, txConfig, database, mode);
      return new RequestMessage(BEGIN, [metadata], function () {
        return "BEGIN ".concat(JSON.stringify(metadata));
      });
    }
    /**
     * Get a COMMIT message.
     * @return {RequestMessage} the COMMIT message.
     */

  }, {
    key: "commit",
    value: function commit() {
      return COMMIT_MESSAGE;
    }
    /**
     * Get a ROLLBACK message.
     * @return {RequestMessage} the ROLLBACK message.
     */

  }, {
    key: "rollback",
    value: function rollback() {
      return ROLLBACK_MESSAGE;
    }
    /**
     * Create a new RUN message with additional metadata.
     * @param {string} query the cypher query.
     * @param {Object} parameters the query parameters.
     * @param {Bookmark} bookmark the bookmark.
     * @param {TxConfig} txConfig the configuration.
     * @param {string} database the database name.
     * @param {string} mode the access mode.
     * @return {RequestMessage} new RUN message with additional metadata.
     */

  }, {
    key: "runWithMetadata",
    value: function runWithMetadata(query, parameters) {
      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          bookmark = _ref2.bookmark,
          txConfig = _ref2.txConfig,
          database = _ref2.database,
          mode = _ref2.mode;

      var metadata = buildTxMetadata(bookmark, txConfig, database, mode);
      return new RequestMessage(RUN, [query, parameters, metadata], function () {
        return "RUN ".concat(query, " ").concat(JSON.stringify(parameters), " ").concat(JSON.stringify(metadata));
      });
    }
    /**
     * Get a GOODBYE message.
     * @return {RequestMessage} the GOODBYE message.
     */

  }, {
    key: "goodbye",
    value: function goodbye() {
      return GOODBYE_MESSAGE;
    }
    /**
     * Generates a new PULL message with additional metadata.
     * @param {Integer|number} stmtId
     * @param {Integer|number} n
     * @return {RequestMessage} the PULL message.
     */

  }, {
    key: "pull",
    value: function pull() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$stmtId = _ref3.stmtId,
          stmtId = _ref3$stmtId === void 0 ? NO_STATEMENT_ID : _ref3$stmtId,
          _ref3$n = _ref3.n,
          n = _ref3$n === void 0 ? ALL : _ref3$n;

      var metadata = buildStreamMetadata(stmtId || NO_STATEMENT_ID, n || ALL);
      return new RequestMessage(PULL, [metadata], function () {
        return "PULL ".concat(JSON.stringify(metadata));
      });
    }
    /**
     * Generates a new DISCARD message with additional metadata.
     * @param {Integer|number} stmtId
     * @param {Integer|number} n
     * @return {RequestMessage} the PULL message.
     */

  }, {
    key: "discard",
    value: function discard() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref4$stmtId = _ref4.stmtId,
          stmtId = _ref4$stmtId === void 0 ? NO_STATEMENT_ID : _ref4$stmtId,
          _ref4$n = _ref4.n,
          n = _ref4$n === void 0 ? ALL : _ref4$n;

      var metadata = buildStreamMetadata(stmtId || NO_STATEMENT_ID, n || ALL);
      return new RequestMessage(DISCARD, [metadata], function () {
        return "DISCARD ".concat(JSON.stringify(metadata));
      });
    }
  }]);
  return RequestMessage;
}();
/**
 * Create an object that represent transaction metadata.
 * @param {Bookmark} bookmark the bookmark.
 * @param {TxConfig} txConfig the configuration.
 * @param {string} database the database name.
 * @param {string} mode the access mode.
 * @return {Object} a metadata object.
 */


exports["default"] = RequestMessage;

function buildTxMetadata(bookmark, txConfig, database, mode) {
  var metadata = {};

  if (!bookmark.isEmpty()) {
    metadata.bookmarks = bookmark.values();
  }

  if (txConfig.timeout) {
    metadata.tx_timeout = txConfig.timeout;
  }

  if (txConfig.metadata) {
    metadata.tx_metadata = txConfig.metadata;
  }

  if (database) {
    metadata.db = (0, _util.assertString)(database, 'database');
  }

  if (mode === _constants.ACCESS_MODE_READ) {
    metadata.mode = READ_MODE;
  }

  return metadata;
}
/**
 * Create an object that represents streaming metadata.
 * @param {Integer|number} stmtId The query id to stream its results.
 * @param {Integer|number} n The number of records to stream.
 * @returns {Object} a metadata object.
 */


function buildStreamMetadata(stmtId, n) {
  var metadata = {
    n: (0, _integer["int"])(n)
  };

  if (stmtId !== NO_STATEMENT_ID) {
    metadata.qid = (0, _integer["int"])(stmtId);
  }

  return metadata;
} // constants for messages that never change


var PULL_ALL_MESSAGE = new RequestMessage(PULL_ALL, [], function () {
  return 'PULL_ALL';
});
var RESET_MESSAGE = new RequestMessage(RESET, [], function () {
  return 'RESET';
});
var COMMIT_MESSAGE = new RequestMessage(COMMIT, [], function () {
  return 'COMMIT';
});
var ROLLBACK_MESSAGE = new RequestMessage(ROLLBACK, [], function () {
  return 'ROLLBACK';
});
var GOODBYE_MESSAGE = new RequestMessage(GOODBYE, [], function () {
  return 'GOODBYE';
});

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/resolver/base-host-name-resolver.js":
/*!************************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/resolver/base-host-name-resolver.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BaseHostNameResolver = /*#__PURE__*/function () {
  function BaseHostNameResolver() {
    (0, _classCallCheck2["default"])(this, BaseHostNameResolver);
  }

  (0, _createClass2["default"])(BaseHostNameResolver, [{
    key: "resolve",
    value: function resolve() {
      throw new Error('Abstract function');
    }
    /**
     * @protected
     */

  }, {
    key: "_resolveToItself",
    value: function _resolveToItself(address) {
      return Promise.resolve([address]);
    }
  }]);
  return BaseHostNameResolver;
}();

exports["default"] = BaseHostNameResolver;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/resolver/configured-custom-resolver.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/resolver/configured-custom-resolver.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _serverAddress = _interopRequireDefault(__webpack_require__(/*! ../server-address */ "./node_modules/neo4j-driver/lib/internal/server-address.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function resolveToSelf(address) {
  return Promise.resolve([address]);
}

var ConfiguredCustomResolver = /*#__PURE__*/function () {
  function ConfiguredCustomResolver(resolverFunction) {
    (0, _classCallCheck2["default"])(this, ConfiguredCustomResolver);
    this._resolverFunction = resolverFunction || resolveToSelf;
  }

  (0, _createClass2["default"])(ConfiguredCustomResolver, [{
    key: "resolve",
    value: function resolve(seedRouter) {
      var _this = this;

      return new Promise(function (resolve) {
        return resolve(_this._resolverFunction(seedRouter.asHostPort()));
      }).then(function (resolved) {
        if (!Array.isArray(resolved)) {
          throw new TypeError('Configured resolver function should either return an array of addresses or a Promise resolved with an array of addresses.' + "Each address is '<host>:<port>'. Got: ".concat(resolved));
        }

        return resolved.map(function (r) {
          return _serverAddress["default"].fromUrl(r);
        });
      });
    }
  }]);
  return ConfiguredCustomResolver;
}();

exports["default"] = ConfiguredCustomResolver;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/retry-logic-rx.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/retry-logic-rx.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _rxjs = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");

var _logger = _interopRequireDefault(__webpack_require__(/*! ./logger */ "./node_modules/neo4j-driver/lib/internal/logger.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds

var DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds

var DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;
var DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;

var RxRetryLogic = /*#__PURE__*/function () {
  /**
   *
   * @param {Object} args
   * @param {Logger} args.logger
   */
  function RxRetryLogic() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$maxRetryTimeout = _ref.maxRetryTimeout,
        maxRetryTimeout = _ref$maxRetryTimeout === void 0 ? DEFAULT_MAX_RETRY_TIME_MS : _ref$maxRetryTimeout,
        _ref$initialDelay = _ref.initialDelay,
        initialDelay = _ref$initialDelay === void 0 ? DEFAULT_INITIAL_RETRY_DELAY_MS : _ref$initialDelay,
        _ref$delayMultiplier = _ref.delayMultiplier,
        delayMultiplier = _ref$delayMultiplier === void 0 ? DEFAULT_RETRY_DELAY_MULTIPLIER : _ref$delayMultiplier,
        _ref$delayJitter = _ref.delayJitter,
        delayJitter = _ref$delayJitter === void 0 ? DEFAULT_RETRY_DELAY_JITTER_FACTOR : _ref$delayJitter,
        _ref$logger = _ref.logger,
        logger = _ref$logger === void 0 ? null : _ref$logger;

    (0, _classCallCheck2["default"])(this, RxRetryLogic);
    this._maxRetryTimeout = valueOrDefault(maxRetryTimeout, DEFAULT_MAX_RETRY_TIME_MS);
    this._initialDelay = valueOrDefault(initialDelay, DEFAULT_INITIAL_RETRY_DELAY_MS);
    this._delayMultiplier = valueOrDefault(delayMultiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);
    this._delayJitter = valueOrDefault(delayJitter, DEFAULT_RETRY_DELAY_JITTER_FACTOR);
    this._logger = logger;
  }
  /**
   *
   * @param {Observable<Any>} work
   */


  (0, _createClass2["default"])(RxRetryLogic, [{
    key: "retry",
    value: function retry(work) {
      var _this = this;

      return work.pipe((0, _operators.retryWhen)(function (failedWork) {
        var handledExceptions = [];
        var startTime = Date.now();
        var retryCount = 1;
        var delayDuration = _this._initialDelay;
        return failedWork.pipe((0, _operators.flatMap)(function (err) {
          if (!RxRetryLogic._canRetryOn(err)) {
            return (0, _rxjs.throwError)(err);
          }

          handledExceptions.push(err);

          if (retryCount >= 2 && Date.now() - startTime >= _this._maxRetryTimeout) {
            var error = (0, _error.newError)("Failed after retried for ".concat(retryCount, " times in ").concat(_this._maxRetryTimeout, " ms. Make sure that your database is online and retry again."), _error.SERVICE_UNAVAILABLE);
            error.seenErrors = handledExceptions;
            return (0, _rxjs.throwError)(error);
          }

          var nextDelayDuration = _this._computeNextDelay(delayDuration);

          delayDuration = delayDuration * _this._delayMultiplier;
          retryCount++;

          if (_this._logger) {
            _this._logger.warn("Transaction failed and will be retried in ".concat(nextDelayDuration));
          }

          return (0, _rxjs.of)(1).pipe((0, _operators.delay)(nextDelayDuration));
        }));
      }));
    }
  }, {
    key: "_computeNextDelay",
    value: function _computeNextDelay(delay) {
      var jitter = delay * this._delayJitter;
      return delay - jitter + 2 * jitter * Math.random();
    }
  }], [{
    key: "_canRetryOn",
    value: function _canRetryOn(error) {
      return error && error.code && (error.code === _error.SERVICE_UNAVAILABLE || error.code === _error.SESSION_EXPIRED || this._isTransientError(error));
    }
  }, {
    key: "_isTransientError",
    value: function _isTransientError(error) {
      // Retries should not happen when transaction was explicitly terminated by the user.
      // Termination of transaction might result in two different error codes depending on where it was
      // terminated. These are really client errors but classification on the server is not entirely correct and
      // they are classified as transient.
      var code = error.code;

      if (code.indexOf('TransientError') >= 0) {
        if (code === 'Neo.TransientError.Transaction.Terminated' || code === 'Neo.TransientError.Transaction.LockClientStopped') {
          return false;
        }

        return true;
      }

      return false;
    }
  }]);
  return RxRetryLogic;
}();

exports["default"] = RxRetryLogic;

function valueOrDefault(value, defaultValue) {
  if (value || value === 0) {
    return value;
  }

  return defaultValue;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/round-robin-array-index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/round-robin-array-index.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var RoundRobinArrayIndex = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {number} [initialOffset=0] the initial offset for round robin.
   */
  function RoundRobinArrayIndex(initialOffset) {
    (0, _classCallCheck2["default"])(this, RoundRobinArrayIndex);
    this._offset = initialOffset || 0;
  }
  /**
   * Get next index for an array with given length.
   * @param {number} arrayLength the array length.
   * @return {number} index in the array.
   */


  (0, _createClass2["default"])(RoundRobinArrayIndex, [{
    key: "next",
    value: function next(arrayLength) {
      if (arrayLength === 0) {
        return -1;
      }

      var nextOffset = this._offset;
      this._offset += 1;

      if (this._offset === Number.MAX_SAFE_INTEGER) {
        this._offset = 0;
      }

      return nextOffset % arrayLength;
    }
  }]);
  return RoundRobinArrayIndex;
}();

exports["default"] = RoundRobinArrayIndex;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/routing-table.js":
/*!*****************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/routing-table.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _integer = __webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js");

var _driver = __webpack_require__(/*! ../driver */ "./node_modules/neo4j-driver/lib/driver.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MIN_ROUTERS = 1;

var RoutingTable = /*#__PURE__*/function () {
  function RoutingTable() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        database = _ref.database,
        routers = _ref.routers,
        readers = _ref.readers,
        writers = _ref.writers,
        expirationTime = _ref.expirationTime;

    (0, _classCallCheck2["default"])(this, RoutingTable);
    this.database = database;
    this.databaseName = database || 'default database';
    this.routers = routers || [];
    this.readers = readers || [];
    this.writers = writers || [];
    this.expirationTime = expirationTime || (0, _integer["int"])(0);
  }

  (0, _createClass2["default"])(RoutingTable, [{
    key: "forget",
    value: function forget(address) {
      // Don't remove it from the set of routers, since that might mean we lose our ability to re-discover,
      // just remove it from the set of readers and writers, so that we don't use it for actual work without
      // performing discovery first.
      this.readers = removeFromArray(this.readers, address);
      this.writers = removeFromArray(this.writers, address);
    }
  }, {
    key: "forgetRouter",
    value: function forgetRouter(address) {
      this.routers = removeFromArray(this.routers, address);
    }
  }, {
    key: "forgetWriter",
    value: function forgetWriter(address) {
      this.writers = removeFromArray(this.writers, address);
    }
    /**
     * Check if this routing table is fresh to perform the required operation.
     * @param {string} accessMode the type of operation. Allowed values are {@link READ} and {@link WRITE}.
     * @return {boolean} `true` when this table contains servers to serve the required operation, `false` otherwise.
     */

  }, {
    key: "isStaleFor",
    value: function isStaleFor(accessMode) {
      return this.expirationTime.lessThan(Date.now()) || this.routers.length < MIN_ROUTERS || accessMode === _driver.READ && this.readers.length === 0 || accessMode === _driver.WRITE && this.writers.length === 0;
    }
    /**
     * Check if this routing table is expired for specified amount of duration
     *
     * @param {Integer} duration amount of duration in milliseconds to check for expiration
     * @returns {boolean}
     */

  }, {
    key: "isExpiredFor",
    value: function isExpiredFor(duration) {
      return this.expirationTime.add(duration).lessThan(Date.now());
    }
  }, {
    key: "allServers",
    value: function allServers() {
      return [].concat((0, _toConsumableArray2["default"])(this.routers), (0, _toConsumableArray2["default"])(this.readers), (0, _toConsumableArray2["default"])(this.writers));
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'RoutingTable[' + "database=".concat(this.databaseName, ", ") + "expirationTime=".concat(this.expirationTime, ", ") + "currentTime=".concat(Date.now(), ", ") + "routers=[".concat(this.routers, "], ") + "readers=[".concat(this.readers, "], ") + "writers=[".concat(this.writers, "]]");
    }
  }]);
  return RoutingTable;
}();
/**
 * Remove all occurrences of the element in the array.
 * @param {Array} array the array to filter.
 * @param {Object} element the element to remove.
 * @return {Array} new filtered array.
 */


exports["default"] = RoutingTable;

function removeFromArray(array, element) {
  return array.filter(function (item) {
    return item.asKey() !== element.asKey();
  });
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/routing-util.js":
/*!****************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/routing-util.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _integer = _interopRequireWildcard(__webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js"));

var _serverVersion = __webpack_require__(/*! ./server-version */ "./node_modules/neo4j-driver/lib/internal/server-version.js");

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

var _session = _interopRequireDefault(__webpack_require__(/*! ../session */ "./node_modules/neo4j-driver/lib/session.js"));

var _txConfig = _interopRequireDefault(__webpack_require__(/*! ./tx-config */ "./node_modules/neo4j-driver/lib/internal/tx-config.js"));

var _serverAddress = _interopRequireDefault(__webpack_require__(/*! ./server-address */ "./node_modules/neo4j-driver/lib/internal/server-address.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var CONTEXT = 'context';
var CALL_GET_ROUTING_TABLE = "CALL dbms.cluster.routing.getRoutingTable($".concat(CONTEXT, ")");
var DATABASE = 'database';
var CALL_GET_ROUTING_TABLE_MULTI_DB = "CALL dbms.routing.getRoutingTable($".concat(CONTEXT, ", $").concat(DATABASE, ")");
var PROCEDURE_NOT_FOUND_CODE = 'Neo.ClientError.Procedure.ProcedureNotFound';
var DATABASE_NOT_FOUND_CODE = 'Neo.ClientError.Database.DatabaseNotFound';

var RoutingUtil = /*#__PURE__*/function () {
  function RoutingUtil(routingContext, initialAddress) {
    (0, _classCallCheck2["default"])(this, RoutingUtil);
    this._routingContext = routingContext; // The address that the driver is connecting to, used by routing as a fallback when routing
    // and clustering isn't configured.

    this._initialAddress = initialAddress;
  }
  /**
   * Invoke routing procedure using the given session.
   * @param {Session} session the session to use.
   * @param {string} routerAddress the URL of the router.
   * @return {Promise<Record[]>} promise resolved with records returned by the procedure call or null if
   * connection error happened.
   */


  (0, _createClass2["default"])(RoutingUtil, [{
    key: "callRoutingProcedure",
    value: function () {
      var _callRoutingProcedure = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(session, database, routerAddress) {
        var result;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return this._callAvailableRoutingProcedure(session, database);

              case 3:
                result = _context.sent;
                _context.next = 6;
                return session.close();

              case 6:
                return _context.abrupt("return", result.records);

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](0);

                if (!(_context.t0.code === DATABASE_NOT_FOUND_CODE)) {
                  _context.next = 15;
                  break;
                }

                throw _context.t0;

              case 15:
                if (!(_context.t0.code === PROCEDURE_NOT_FOUND_CODE)) {
                  _context.next = 19;
                  break;
                }

                throw (0, _error.newError)("Server at ".concat(routerAddress.asHostPort(), " can't perform routing. Make sure you are connecting to a causal cluster"), _error.SERVICE_UNAVAILABLE);

              case 19:
                return _context.abrupt("return", null);

              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 9]]);
      }));

      function callRoutingProcedure(_x, _x2, _x3) {
        return _callRoutingProcedure.apply(this, arguments);
      }

      return callRoutingProcedure;
    }()
  }, {
    key: "parseTtl",
    value: function parseTtl(record, routerAddress) {
      try {
        var now = (0, _integer["int"])(Date.now());
        var expires = (0, _integer["int"])(record.get('ttl')).multiply(1000).add(now); // if the server uses a really big expire time like Long.MAX_VALUE this may have overflowed

        if (expires.lessThan(now)) {
          return _integer["default"].MAX_VALUE;
        }

        return expires;
      } catch (error) {
        throw (0, _error.newError)("Unable to parse TTL entry from router ".concat(routerAddress, " from record:\n").concat(JSON.stringify(record), "\nError message: ").concat(error.message), _error.PROTOCOL_ERROR);
      }
    }
  }, {
    key: "parseServers",
    value: function parseServers(record, routerAddress) {
      try {
        var servers = record.get('servers');
        var routers = [];
        var readers = [];
        var writers = [];
        servers.forEach(function (server) {
          var role = server.role;
          var addresses = server.addresses;

          if (role === 'ROUTE') {
            routers = parseArray(addresses).map(function (address) {
              return _serverAddress["default"].fromUrl(address);
            });
          } else if (role === 'WRITE') {
            writers = parseArray(addresses).map(function (address) {
              return _serverAddress["default"].fromUrl(address);
            });
          } else if (role === 'READ') {
            readers = parseArray(addresses).map(function (address) {
              return _serverAddress["default"].fromUrl(address);
            });
          } else {
            throw (0, _error.newError)('Unknown server role "' + role + '"', _error.PROTOCOL_ERROR);
          }
        });
        return {
          routers: routers,
          readers: readers,
          writers: writers
        };
      } catch (error) {
        throw (0, _error.newError)("Unable to parse servers entry from router ".concat(routerAddress, " from record:\n").concat(JSON.stringify(record), "\nError message: ").concat(error.message), _error.PROTOCOL_ERROR);
      }
    }
  }, {
    key: "_callAvailableRoutingProcedure",
    value: function _callAvailableRoutingProcedure(session, database) {
      var _this = this;

      return session._run(null, null, function (connection) {
        var query;
        var params;
        var protocolVersion = connection.protocol().version;

        if (protocolVersion >= 4.0) {
          query = CALL_GET_ROUTING_TABLE_MULTI_DB;
          params = {
            context: _this._routingContext || {},
            database: database || null
          };
          params.context.address = _this._initialAddress;
        } else {
          query = CALL_GET_ROUTING_TABLE;
          params = {
            context: _this._routingContext
          };
        }

        return connection.protocol().run(query, params, {
          bookmark: session._lastBookmark,
          txConfig: _txConfig["default"].empty(),
          mode: session._mode,
          database: session._database,
          afterComplete: session._onComplete
        });
      });
    }
  }]);
  return RoutingUtil;
}();

exports["default"] = RoutingUtil;

function parseArray(addresses) {
  if (!Array.isArray(addresses)) {
    throw new TypeError('Array expected but got: ' + addresses);
  }

  return Array.from(addresses);
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/server-address.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/server-address.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _util = __webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js");

var _urlUtil = _interopRequireDefault(__webpack_require__(/*! ./url-util */ "./node_modules/neo4j-driver/lib/internal/url-util.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ServerAddress = /*#__PURE__*/function () {
  function ServerAddress(host, resolved, port, hostPort) {
    (0, _classCallCheck2["default"])(this, ServerAddress);
    this._host = (0, _util.assertString)(host, 'host');
    this._resolved = resolved ? (0, _util.assertString)(resolved, 'resolved') : null;
    this._port = (0, _util.assertNumber)(port, 'port');
    this._hostPort = hostPort;
    this._stringValue = resolved ? "".concat(hostPort, "(").concat(resolved, ")") : "".concat(hostPort);
  }

  (0, _createClass2["default"])(ServerAddress, [{
    key: "host",
    value: function host() {
      return this._host;
    }
  }, {
    key: "resolvedHost",
    value: function resolvedHost() {
      return this._resolved ? this._resolved : this._host;
    }
  }, {
    key: "port",
    value: function port() {
      return this._port;
    }
  }, {
    key: "resolveWith",
    value: function resolveWith(resolved) {
      return new ServerAddress(this._host, resolved, this._port, this._hostPort);
    }
  }, {
    key: "asHostPort",
    value: function asHostPort() {
      return this._hostPort;
    }
  }, {
    key: "asKey",
    value: function asKey() {
      return this._hostPort;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this._stringValue;
    }
  }], [{
    key: "fromUrl",
    value: function fromUrl(url) {
      var urlParsed = _urlUtil["default"].parseDatabaseUrl(url);

      return new ServerAddress(urlParsed.host, null, urlParsed.port, urlParsed.hostAndPort);
    }
  }]);
  return ServerAddress;
}();

exports["default"] = ServerAddress;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/server-version.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/server-version.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION_IN_DEV = exports.VERSION_4_0_0 = exports.VERSION_3_5_0 = exports.VERSION_3_4_0 = exports.VERSION_3_2_0 = exports.ServerVersion = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _util = __webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SERVER_VERSION_REGEX = new RegExp('^(Neo4j/)?(\\d+)\\.(\\d+)(?:\\.)?(\\d*)(\\.|-|\\+)?([0-9A-Za-z-.]*)?$');
var NEO4J_IN_DEV_VERSION_STRING = 'Neo4j/dev';

var ServerVersion = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {number} major the major version number.
   * @param {number} minor the minor version number.
   * @param {number} patch the patch version number.
   * @param {string} the original version string
   */
  function ServerVersion(major, minor, patch, originalVersionString) {
    (0, _classCallCheck2["default"])(this, ServerVersion);
    this.major = major;
    this.minor = minor;
    this.patch = patch;
    this._originalVersionString = originalVersionString;
  }
  /**
   * Fetch server version using the given driver.
   * @param {Driver} driver the driver to use.
   * @return {Promise<ServerVersion>} promise resolved with a {@link ServerVersion} object or rejected with error.
   */


  (0, _createClass2["default"])(ServerVersion, [{
    key: "compareTo",

    /**
     * Compare this version to the given one.
     * @param {ServerVersion} other the version to compare with.
     * @return {number} value 0 if this version is the same as the given one, value less then 0 when this version
     * was released earlier than the given one and value greater then 0 when this version was released after
     * than the given one.
     */
    value: function compareTo(other) {
      var result = compareInts(this.major, other.major);

      if (result === 0) {
        result = compareInts(this.minor, other.minor);

        if (result === 0) {
          result = compareInts(this.patch, other.patch);
        }
      }

      return result;
    }
  }, {
    key: "toString",
    value: function toString() {
      if (this._originalVersionString) {
        return this._originalVersionString;
      }

      return "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);
    }
  }], [{
    key: "fromDriver",
    value: function fromDriver(driver) {
      var session = driver.session();
      return session.run('RETURN 1').then(function (result) {
        return session.close().then(function () {
          return ServerVersion.fromString(result.summary.server.version);
        });
      });
    }
    /**
     * Parse given string to a {@link ServerVersion} object.
     * @param {string} versionStr the string to parse.
     * @return {ServerVersion} version for the given string.
     * @throws Error if given string can't be parsed.
     */

  }, {
    key: "fromString",
    value: function fromString(versionStr) {
      if (!versionStr) {
        return new ServerVersion(3, 0, 0);
      }

      (0, _util.assertString)(versionStr, 'Neo4j version string');

      if (versionStr.toLowerCase() === NEO4J_IN_DEV_VERSION_STRING.toLowerCase()) {
        return VERSION_IN_DEV;
      }

      var version = versionStr.match(SERVER_VERSION_REGEX);

      if (!version) {
        throw new Error("Unparsable Neo4j version: ".concat(versionStr));
      }

      var major = parseIntStrict(version[2]);
      var minor = parseIntStrict(version[3]);
      var patch = parseIntStrict(version[4] || 0);
      return new ServerVersion(major, minor, patch, versionStr);
    }
  }]);
  return ServerVersion;
}();

exports.ServerVersion = ServerVersion;

function parseIntStrict(str, name) {
  var value = parseInt(str, 10);

  if (!value && value !== 0) {
    throw new Error("Unparsable number ".concat(name, ": '").concat(str, "'"));
  }

  return value;
}

function compareInts(x, y) {
  return x < y ? -1 : x === y ? 0 : 1;
}

var VERSION_3_2_0 = ServerVersion.fromString('Neo4j/3.2.0');
exports.VERSION_3_2_0 = VERSION_3_2_0;
var VERSION_3_4_0 = ServerVersion.fromString('Neo4j/3.4.0');
exports.VERSION_3_4_0 = VERSION_3_4_0;
var VERSION_3_5_0 = ServerVersion.fromString('Neo4j/3.5.0');
exports.VERSION_3_5_0 = VERSION_3_5_0;
var VERSION_4_0_0 = ServerVersion.fromString('Neo4j/4.0.0');
exports.VERSION_4_0_0 = VERSION_4_0_0;
var maxVer = Number.MAX_SAFE_INTEGER;
var VERSION_IN_DEV = new ServerVersion(maxVer, maxVer, maxVer, NEO4J_IN_DEV_VERSION_STRING);
exports.VERSION_IN_DEV = VERSION_IN_DEV;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/stream-observers.js":
/*!********************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/stream-observers.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompletedObserver = exports.FailedObserver = exports.ResetObserver = exports.LoginObserver = exports.ResultStreamObserver = exports.StreamObserver = void 0;

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _record = _interopRequireDefault(__webpack_require__(/*! ../record */ "./node_modules/neo4j-driver/lib/record.js"));

var _connection = _interopRequireDefault(__webpack_require__(/*! ./connection */ "./node_modules/neo4j-driver/lib/internal/connection.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

var _integer = _interopRequireDefault(__webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js"));

var _requestMessage = __webpack_require__(/*! ./request-message */ "./node_modules/neo4j-driver/lib/internal/request-message.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var StreamObserver = /*#__PURE__*/function () {
  function StreamObserver() {
    (0, _classCallCheck2["default"])(this, StreamObserver);
  }

  (0, _createClass2["default"])(StreamObserver, [{
    key: "onNext",
    value: function onNext(rawRecord) {}
  }, {
    key: "onError",
    value: function onError(error) {}
  }, {
    key: "onCompleted",
    value: function onCompleted(meta) {}
  }]);
  return StreamObserver;
}();
/**
 * Handles a RUN/PULL_ALL, or RUN/DISCARD_ALL requests, maps the responses
 * in a way that a user-provided observer can see these as a clean Stream
 * of records.
 * This class will queue up incoming messages until a user-provided observer
 * for the incoming stream is registered. Thus, we keep fields around
 * for tracking head/records/tail. These are only used if there is no
 * observer registered.
 * @access private
 */


exports.StreamObserver = StreamObserver;

var ResultStreamObserver = /*#__PURE__*/function (_StreamObserver) {
  (0, _inherits2["default"])(ResultStreamObserver, _StreamObserver);

  var _super = _createSuper(ResultStreamObserver);

  /**
   *
   * @param {Object} param
   * @param {Connection} param.connection
   * @param {boolean} param.reactive
   * @param {function(connection: Connection, stmtId: number|Integer, n: number|Integer, observer: StreamObserver)} param.moreFunction -
   * @param {function(connection: Connection, stmtId: number|Integer, observer: StreamObserver)} param.discardFunction -
   * @param {number|Integer} param.fetchSize -
   * @param {function(err: Error): Promise|void} param.beforeError -
   * @param {function(err: Error): Promise|void} param.afterError -
   * @param {function(keys: string[]): Promise|void} param.beforeKeys -
   * @param {function(keys: string[]): Promise|void} param.afterKeys -
   * @param {function(metadata: Object): Promise|void} param.beforeComplete -
   * @param {function(metadata: Object): Promise|void} param.afterComplete -
   */
  function ResultStreamObserver() {
    var _this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        connection = _ref.connection,
        _ref$reactive = _ref.reactive,
        reactive = _ref$reactive === void 0 ? false : _ref$reactive,
        moreFunction = _ref.moreFunction,
        discardFunction = _ref.discardFunction,
        _ref$fetchSize = _ref.fetchSize,
        fetchSize = _ref$fetchSize === void 0 ? _requestMessage.ALL : _ref$fetchSize,
        beforeError = _ref.beforeError,
        afterError = _ref.afterError,
        beforeKeys = _ref.beforeKeys,
        afterKeys = _ref.afterKeys,
        beforeComplete = _ref.beforeComplete,
        afterComplete = _ref.afterComplete;

    (0, _classCallCheck2["default"])(this, ResultStreamObserver);
    _this = _super.call(this);
    _this._connection = connection;
    _this._fieldKeys = null;
    _this._fieldLookup = null;
    _this._head = null;
    _this._queuedRecords = [];
    _this._tail = null;
    _this._error = null;
    _this._observers = [];
    _this._meta = {};
    _this._beforeError = beforeError;
    _this._afterError = afterError;
    _this._beforeKeys = beforeKeys;
    _this._afterKeys = afterKeys;
    _this._beforeComplete = beforeComplete;
    _this._afterComplete = afterComplete;
    _this._queryId = null;
    _this._moreFunction = moreFunction;
    _this._discardFunction = discardFunction;
    _this._discard = false;
    _this._fetchSize = fetchSize;

    _this._setState(reactive ? _states.READY : _states.READY_STREAMING);

    _this._setupAuoPull(fetchSize);

    return _this;
  }
  /**
   * Will be called on every record that comes in and transform a raw record
   * to a Object. If user-provided observer is present, pass transformed record
   * to it's onNext method, otherwise, push to record que.
   * @param {Array} rawRecord - An array with the raw record
   */


  (0, _createClass2["default"])(ResultStreamObserver, [{
    key: "onNext",
    value: function onNext(rawRecord) {
      var record = new _record["default"](this._fieldKeys, rawRecord, this._fieldLookup);

      if (this._observers.some(function (o) {
        return o.onNext;
      })) {
        this._observers.forEach(function (o) {
          if (o.onNext) {
            o.onNext(record);
          }
        });
      } else {
        this._queuedRecords.push(record);

        if (this._queuedRecords.length > this._highRecordWatermark) {
          this._autoPull = false;
        }
      }
    }
  }, {
    key: "onCompleted",
    value: function onCompleted(meta) {
      this._state.onSuccess(this, meta);
    }
    /**
     * Will be called on errors.
     * If user-provided observer is present, pass the error
     * to it's onError method, otherwise set instance variable _error.
     * @param {Object} error - An error object
     */

  }, {
    key: "onError",
    value: function onError(error) {
      this._state.onError(this, error);
    }
    /**
     * Cancel pending record stream
     */

  }, {
    key: "cancel",
    value: function cancel() {
      this._discard = true;
    }
    /**
     * Stream observer defaults to handling responses for two messages: RUN + PULL_ALL or RUN + DISCARD_ALL.
     * Response for RUN initializes query keys. Response for PULL_ALL / DISCARD_ALL exposes the result stream.
     *
     * However, some operations can be represented as a single message which receives full metadata in a single response.
     * For example, operations to begin, commit and rollback an explicit transaction use two messages in Bolt V1 but a single message in Bolt V3.
     * Messages are `RUN "BEGIN" {}` + `PULL_ALL` in Bolt V1 and `BEGIN` in Bolt V3.
     *
     * This function prepares the observer to only handle a single response message.
     */

  }, {
    key: "prepareToHandleSingleResponse",
    value: function prepareToHandleSingleResponse() {
      this._head = [];
      this._fieldKeys = [];

      this._setState(_states.STREAMING);
    }
    /**
     * Mark this observer as if it has completed with no metadata.
     */

  }, {
    key: "markCompleted",
    value: function markCompleted() {
      this._head = [];
      this._fieldKeys = [];
      this._tail = {};

      this._setState(_states.SUCCEEDED);
    }
    /**
     * Subscribe to events with provided observer.
     * @param {Object} observer - Observer object
     * @param {function(keys: String[])} observer.onKeys - Handle stream header, field keys.
     * @param {function(record: Object)} observer.onNext - Handle records, one by one.
     * @param {function(metadata: Object)} observer.onCompleted - Handle stream tail, the metadata.
     * @param {function(error: Object)} observer.onError - Handle errors, should always be provided.
     */

  }, {
    key: "subscribe",
    value: function subscribe(observer) {
      if (this._error) {
        observer.onError(this._error);
        return;
      }

      if (this._head && observer.onKeys) {
        observer.onKeys(this._head);
      }

      if (this._queuedRecords.length > 0 && observer.onNext) {
        for (var i = 0; i < this._queuedRecords.length; i++) {
          observer.onNext(this._queuedRecords[i]);

          if (this._queuedRecords.length - i - 1 <= this._lowRecordWatermark) {
            this._autoPull = true;

            if (this._state === _states.READY) {
              this._handleStreaming();
            }
          }
        }
      }

      if (this._tail && observer.onCompleted) {
        observer.onCompleted(this._tail);
      }

      this._observers.push(observer);

      if (this._state === _states.READY) {
        this._handleStreaming();
      }
    }
  }, {
    key: "_handleHasMore",
    value: function _handleHasMore(meta) {
      // We've consumed current batch and server notified us that there're more
      // records to stream. Let's invoke more or discard function based on whether
      // the user wants to discard streaming or not
      this._setState(_states.READY); // we've done streaming


      this._handleStreaming();

      delete meta.has_more;
    }
  }, {
    key: "_handlePullSuccess",
    value: function _handlePullSuccess(meta) {
      var _this2 = this;

      this._setState(_states.SUCCEEDED);

      var completionMetadata = Object.assign(this._connection ? {
        server: this._connection.server
      } : {}, this._meta, meta);
      var beforeHandlerResult = null;

      if (this._beforeComplete) {
        beforeHandlerResult = this._beforeComplete(completionMetadata);
      }

      var continuation = function continuation() {
        // End of stream
        _this2._tail = completionMetadata;

        if (_this2._observers.some(function (o) {
          return o.onCompleted;
        })) {
          _this2._observers.forEach(function (o) {
            if (o.onCompleted) {
              o.onCompleted(completionMetadata);
            }
          });
        }

        if (_this2._afterComplete) {
          _this2._afterComplete(completionMetadata);
        }
      };

      if (beforeHandlerResult) {
        Promise.resolve(beforeHandlerResult).then(function () {
          return continuation();
        });
      } else {
        continuation();
      }
    }
  }, {
    key: "_handleRunSuccess",
    value: function _handleRunSuccess(meta, afterSuccess) {
      var _this3 = this;

      if (this._fieldKeys === null) {
        // Stream header, build a name->index field lookup table
        // to be used by records. This is an optimization to make it
        // faster to look up fields in a record by name, rather than by index.
        // Since the records we get back via Bolt are just arrays of values.
        this._fieldKeys = [];
        this._fieldLookup = {};

        if (meta.fields && meta.fields.length > 0) {
          this._fieldKeys = meta.fields;

          for (var i = 0; i < meta.fields.length; i++) {
            this._fieldLookup[meta.fields[i]] = i;
          } // remove fields key from metadata object


          delete meta.fields;
        } // Extract server generated query id for use in requestMore and discard
        // functions


        if (meta.qid) {
          this._queryId = meta.qid; // remove qid from metadata object

          delete meta.qid;
        }

        this._storeMetadataForCompletion(meta);

        var beforeHandlerResult = null;

        if (this._beforeKeys) {
          beforeHandlerResult = this._beforeKeys(this._fieldKeys);
        }

        var continuation = function continuation() {
          _this3._head = _this3._fieldKeys;

          if (_this3._observers.some(function (o) {
            return o.onKeys;
          })) {
            _this3._observers.forEach(function (o) {
              if (o.onKeys) {
                o.onKeys(_this3._fieldKeys);
              }
            });
          }

          if (_this3._afterKeys) {
            _this3._afterKeys(_this3._fieldKeys);
          }

          afterSuccess();
        };

        if (beforeHandlerResult) {
          Promise.resolve(beforeHandlerResult).then(function () {
            return continuation();
          });
        } else {
          continuation();
        }
      }
    }
  }, {
    key: "_handleError",
    value: function _handleError(error) {
      var _this4 = this;

      this._setState(_states.FAILED);

      this._error = error;
      var beforeHandlerResult = null;

      if (this._beforeError) {
        beforeHandlerResult = this._beforeError(error);
      }

      var continuation = function continuation() {
        if (_this4._observers.some(function (o) {
          return o.onError;
        })) {
          _this4._observers.forEach(function (o) {
            if (o.onError) {
              o.onError(error);
            }
          });
        }

        if (_this4._afterError) {
          _this4._afterError(error);
        }
      };

      if (beforeHandlerResult) {
        Promise.resolve(beforeHandlerResult).then(function () {
          return continuation();
        });
      } else {
        continuation();
      }
    }
  }, {
    key: "_handleStreaming",
    value: function _handleStreaming() {
      if (this._head && this._observers.some(function (o) {
        return o.onNext || o.onCompleted;
      })) {
        if (this._discard) {
          this._discardFunction(this._connection, this._queryId, this);

          this._setState(_states.STREAMING);
        } else if (this._autoPull) {
          this._moreFunction(this._connection, this._queryId, this._fetchSize, this);

          this._setState(_states.STREAMING);
        }
      }
    }
  }, {
    key: "_storeMetadataForCompletion",
    value: function _storeMetadataForCompletion(meta) {
      var keys = Object.keys(meta);
      var index = keys.length;
      var key = '';

      while (index--) {
        key = keys[index];
        this._meta[key] = meta[key];
      }
    }
  }, {
    key: "_setState",
    value: function _setState(state) {
      this._state = state;
    }
  }, {
    key: "_setupAuoPull",
    value: function _setupAuoPull(fetchSize) {
      this._autoPull = true;

      if (fetchSize === _requestMessage.ALL) {
        this._lowRecordWatermark = Number.MAX_VALUE; // we shall always lower than this number to enable auto pull

        this._highRecordWatermark = Number.MAX_VALUE; // we shall never reach this number to disable auto pull
      } else {
        this._lowRecordWatermark = 0.3 * fetchSize;
        this._highRecordWatermark = 0.7 * fetchSize;
      }
    }
  }]);
  return ResultStreamObserver;
}(StreamObserver);

exports.ResultStreamObserver = ResultStreamObserver;

var LoginObserver = /*#__PURE__*/function (_StreamObserver2) {
  (0, _inherits2["default"])(LoginObserver, _StreamObserver2);

  var _super2 = _createSuper(LoginObserver);

  /**
   *
   * @param {Object} param -
   * @param {Connection} param.connection
   * @param {function(err: Error)} param.beforeError
   * @param {function(err: Error)} param.afterError
   * @param {function(metadata)} param.beforeComplete
   * @param {function(metadata)} param.afterComplete
   */
  function LoginObserver() {
    var _this5;

    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        connection = _ref2.connection,
        beforeError = _ref2.beforeError,
        afterError = _ref2.afterError,
        beforeComplete = _ref2.beforeComplete,
        afterComplete = _ref2.afterComplete;

    (0, _classCallCheck2["default"])(this, LoginObserver);
    _this5 = _super2.call(this);
    _this5._connection = connection;
    _this5._beforeError = beforeError;
    _this5._afterError = afterError;
    _this5._beforeComplete = beforeComplete;
    _this5._afterComplete = afterComplete;
    return _this5;
  }

  (0, _createClass2["default"])(LoginObserver, [{
    key: "onNext",
    value: function onNext(record) {
      this.onError((0, _error.newError)('Received RECORD when initializing ' + JSON.stringify(record)));
    }
  }, {
    key: "onError",
    value: function onError(error) {
      if (this._beforeError) {
        this._beforeError(error);
      }

      this._connection._updateCurrentObserver(); // make sure this exact observer will not be called again


      this._connection._handleFatalError(error); // initialization errors are fatal


      if (this._afterError) {
        this._afterError(error);
      }
    }
  }, {
    key: "onCompleted",
    value: function onCompleted(metadata) {
      if (this._beforeComplete) {
        this._beforeComplete(metadata);
      }

      if (metadata) {
        // read server version from the response metadata, if it is available
        var serverVersion = metadata.server;

        if (!this._connection.version) {
          this._connection.version = serverVersion;
        } // read database connection id from the response metadata, if it is available


        var dbConnectionId = metadata.connection_id;

        if (!this._connection.databaseId) {
          this._connection.databaseId = dbConnectionId;
        }
      }

      if (this._afterComplete) {
        this._afterComplete(metadata);
      }
    }
  }]);
  return LoginObserver;
}(StreamObserver);

exports.LoginObserver = LoginObserver;

var ResetObserver = /*#__PURE__*/function (_StreamObserver3) {
  (0, _inherits2["default"])(ResetObserver, _StreamObserver3);

  var _super3 = _createSuper(ResetObserver);

  /**
   *
   * @param {Object} param -
   * @param {Connection} param.connection
   * @param {function(err: Error)} param.onError
   * @param {function(metadata)} param.onComplete
   */
  function ResetObserver() {
    var _this6;

    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        connection = _ref3.connection,
        onError = _ref3.onError,
        onComplete = _ref3.onComplete;

    (0, _classCallCheck2["default"])(this, ResetObserver);
    _this6 = _super3.call(this);
    _this6._connection = connection;
    _this6._onError = onError;
    _this6._onComplete = onComplete;
    return _this6;
  }

  (0, _createClass2["default"])(ResetObserver, [{
    key: "onNext",
    value: function onNext(record) {
      this.onError((0, _error.newError)('Received RECORD when resetting: received record is: ' + JSON.stringify(record), _error.PROTOCOL_ERROR));
    }
  }, {
    key: "onError",
    value: function onError(error) {
      if (error.code === _error.PROTOCOL_ERROR) {
        this._connection._handleProtocolError(error.message);
      }

      if (this._onError) {
        this._onError(error);
      }
    }
  }, {
    key: "onCompleted",
    value: function onCompleted(metadata) {
      if (this._onComplete) {
        this._onComplete(metadata);
      }
    }
  }]);
  return ResetObserver;
}(StreamObserver);

exports.ResetObserver = ResetObserver;

var FailedObserver = /*#__PURE__*/function (_ResultStreamObserver) {
  (0, _inherits2["default"])(FailedObserver, _ResultStreamObserver);

  var _super4 = _createSuper(FailedObserver);

  function FailedObserver(_ref4) {
    var _this7;

    var error = _ref4.error,
        onError = _ref4.onError;
    (0, _classCallCheck2["default"])(this, FailedObserver);
    _this7 = _super4.call(this, {
      beforeError: onError
    });

    _this7.onError(error);

    return _this7;
  }

  return FailedObserver;
}(ResultStreamObserver);

exports.FailedObserver = FailedObserver;

var CompletedObserver = /*#__PURE__*/function (_ResultStreamObserver2) {
  (0, _inherits2["default"])(CompletedObserver, _ResultStreamObserver2);

  var _super5 = _createSuper(CompletedObserver);

  function CompletedObserver() {
    var _thisSuper, _this8;

    (0, _classCallCheck2["default"])(this, CompletedObserver);
    _this8 = _super5.call(this);
    (0, _get2["default"])((_thisSuper = (0, _assertThisInitialized2["default"])(_this8), (0, _getPrototypeOf2["default"])(CompletedObserver.prototype)), "markCompleted", _thisSuper).call(_thisSuper);
    return _this8;
  }

  return CompletedObserver;
}(ResultStreamObserver);

exports.CompletedObserver = CompletedObserver;
var _states = {
  READY_STREAMING: {
    // async start state
    onSuccess: function onSuccess(streamObserver, meta) {
      streamObserver._handleRunSuccess(meta, function () {
        streamObserver._setState(_states.STREAMING);
      } // after run succeeded, async directly move to streaming
      // state
      );
    },
    onError: function onError(streamObserver, error) {
      streamObserver._handleError(error);
    },
    name: function name() {
      return 'READY_STREAMING';
    }
  },
  READY: {
    // reactive start state
    onSuccess: function onSuccess(streamObserver, meta) {
      streamObserver._handleRunSuccess(meta, function () {
        return streamObserver._handleStreaming();
      } // after run succeeded received, reactive shall start pulling
      );
    },
    onError: function onError(streamObserver, error) {
      streamObserver._handleError(error);
    },
    name: function name() {
      return 'READY';
    }
  },
  STREAMING: {
    onSuccess: function onSuccess(streamObserver, meta) {
      if (meta.has_more) {
        streamObserver._handleHasMore(meta);
      } else {
        streamObserver._handlePullSuccess(meta);
      }
    },
    onError: function onError(streamObserver, error) {
      streamObserver._handleError(error);
    },
    name: function name() {
      return 'STREAMING';
    }
  },
  FAILED: {
    onError: function onError(error) {// more errors are ignored
    },
    name: function name() {
      return 'FAILED';
    }
  },
  SUCCEEDED: {
    name: function name() {
      return 'SUCCEEDED';
    }
  }
};

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/temporal-util.js":
/*!*****************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/temporal-util.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeSecondsForDuration = normalizeSecondsForDuration;
exports.normalizeNanosecondsForDuration = normalizeNanosecondsForDuration;
exports.localTimeToNanoOfDay = localTimeToNanoOfDay;
exports.nanoOfDayToLocalTime = nanoOfDayToLocalTime;
exports.localDateTimeToEpochSecond = localDateTimeToEpochSecond;
exports.epochSecondAndNanoToLocalDateTime = epochSecondAndNanoToLocalDateTime;
exports.dateToEpochDay = dateToEpochDay;
exports.epochDayToDate = epochDayToDate;
exports.durationToIsoString = durationToIsoString;
exports.timeToIsoString = timeToIsoString;
exports.timeZoneOffsetToIsoString = timeZoneOffsetToIsoString;
exports.dateToIsoString = dateToIsoString;
exports.totalNanoseconds = totalNanoseconds;
exports.timeZoneOffsetInSeconds = timeZoneOffsetInSeconds;
exports.assertValidYear = assertValidYear;
exports.assertValidMonth = assertValidMonth;
exports.assertValidDay = assertValidDay;
exports.assertValidHour = assertValidHour;
exports.assertValidMinute = assertValidMinute;
exports.assertValidSecond = assertValidSecond;
exports.assertValidNanosecond = assertValidNanosecond;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _integer = __webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js");

var _temporalTypes = __webpack_require__(/*! ../temporal-types */ "./node_modules/neo4j-driver/lib/temporal-types.js");

var _util = __webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js");

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
  Code in this util should be compatible with code in the database that uses JSR-310 java.time APIs.

  It is based on a library called ThreeTen (https://github.com/ThreeTen/threetenbp) which was derived
  from JSR-310 reference implementation previously hosted on GitHub. Code uses `Integer` type everywhere
  to correctly handle large integer values that are greater than `Number.MAX_SAFE_INTEGER`.

  Please consult either ThreeTen or js-joda (https://github.com/js-joda/js-joda) when working with the
  conversion functions.
 */
var ValueRange = /*#__PURE__*/function () {
  function ValueRange(min, max) {
    (0, _classCallCheck2["default"])(this, ValueRange);
    this._minNumber = min;
    this._maxNumber = max;
    this._minInteger = (0, _integer["int"])(min);
    this._maxInteger = (0, _integer["int"])(max);
  }

  (0, _createClass2["default"])(ValueRange, [{
    key: "contains",
    value: function contains(value) {
      if ((0, _integer.isInt)(value)) {
        return value.greaterThanOrEqual(this._minInteger) && value.lessThanOrEqual(this._maxInteger);
      } else {
        return value >= this._minNumber && value <= this._maxNumber;
      }
    }
  }, {
    key: "toString",
    value: function toString() {
      return "[".concat(this._minNumber, ", ").concat(this._maxNumber, "]");
    }
  }]);
  return ValueRange;
}();

var YEAR_RANGE = new ValueRange(-999999999, 999999999);
var MONTH_OF_YEAR_RANGE = new ValueRange(1, 12);
var DAY_OF_MONTH_RANGE = new ValueRange(1, 31);
var HOUR_OF_DAY_RANGE = new ValueRange(0, 23);
var MINUTE_OF_HOUR_RANGE = new ValueRange(0, 59);
var SECOND_OF_MINUTE_RANGE = new ValueRange(0, 59);
var NANOSECOND_OF_SECOND_RANGE = new ValueRange(0, 999999999);
var MINUTES_PER_HOUR = 60;
var SECONDS_PER_MINUTE = 60;
var SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
var NANOS_PER_SECOND = 1000000000;
var NANOS_PER_MILLISECOND = 1000000;
var NANOS_PER_MINUTE = NANOS_PER_SECOND * SECONDS_PER_MINUTE;
var NANOS_PER_HOUR = NANOS_PER_MINUTE * MINUTES_PER_HOUR;
var DAYS_0000_TO_1970 = 719528;
var DAYS_PER_400_YEAR_CYCLE = 146097;
var SECONDS_PER_DAY = 86400;

function normalizeSecondsForDuration(seconds, nanoseconds) {
  return (0, _integer["int"])(seconds).add(floorDiv(nanoseconds, NANOS_PER_SECOND));
}

function normalizeNanosecondsForDuration(nanoseconds) {
  return floorMod(nanoseconds, NANOS_PER_SECOND);
}
/**
 * Converts given local time into a single integer representing this same time in nanoseconds of the day.
 * @param {Integer|number|string} hour the hour of the local time to convert.
 * @param {Integer|number|string} minute the minute of the local time to convert.
 * @param {Integer|number|string} second the second of the local time to convert.
 * @param {Integer|number|string} nanosecond the nanosecond of the local time to convert.
 * @return {Integer} nanoseconds representing the given local time.
 */


function localTimeToNanoOfDay(hour, minute, second, nanosecond) {
  hour = (0, _integer["int"])(hour);
  minute = (0, _integer["int"])(minute);
  second = (0, _integer["int"])(second);
  nanosecond = (0, _integer["int"])(nanosecond);
  var totalNanos = hour.multiply(NANOS_PER_HOUR);
  totalNanos = totalNanos.add(minute.multiply(NANOS_PER_MINUTE));
  totalNanos = totalNanos.add(second.multiply(NANOS_PER_SECOND));
  return totalNanos.add(nanosecond);
}
/**
 * Converts nanoseconds of the day into local time.
 * @param {Integer|number|string} nanoOfDay the nanoseconds of the day to convert.
 * @return {LocalTime} the local time representing given nanoseconds of the day.
 */


function nanoOfDayToLocalTime(nanoOfDay) {
  nanoOfDay = (0, _integer["int"])(nanoOfDay);
  var hour = nanoOfDay.div(NANOS_PER_HOUR);
  nanoOfDay = nanoOfDay.subtract(hour.multiply(NANOS_PER_HOUR));
  var minute = nanoOfDay.div(NANOS_PER_MINUTE);
  nanoOfDay = nanoOfDay.subtract(minute.multiply(NANOS_PER_MINUTE));
  var second = nanoOfDay.div(NANOS_PER_SECOND);
  var nanosecond = nanoOfDay.subtract(second.multiply(NANOS_PER_SECOND));
  return new _temporalTypes.LocalTime(hour, minute, second, nanosecond);
}
/**
 * Converts given local date time into a single integer representing this same time in epoch seconds UTC.
 * @param {Integer|number|string} year the year of the local date-time to convert.
 * @param {Integer|number|string} month the month of the local date-time to convert.
 * @param {Integer|number|string} day the day of the local date-time to convert.
 * @param {Integer|number|string} hour the hour of the local date-time to convert.
 * @param {Integer|number|string} minute the minute of the local date-time to convert.
 * @param {Integer|number|string} second the second of the local date-time to convert.
 * @param {Integer|number|string} nanosecond the nanosecond of the local date-time to convert.
 * @return {Integer} epoch second in UTC representing the given local date time.
 */


function localDateTimeToEpochSecond(year, month, day, hour, minute, second, nanosecond) {
  var epochDay = dateToEpochDay(year, month, day);
  var localTimeSeconds = localTimeToSecondOfDay(hour, minute, second);
  return epochDay.multiply(SECONDS_PER_DAY).add(localTimeSeconds);
}
/**
 * Converts given epoch second and nanosecond adjustment into a local date time object.
 * @param {Integer|number|string} epochSecond the epoch second to use.
 * @param {Integer|number|string} nano the nanosecond to use.
 * @return {LocalDateTime} the local date time representing given epoch second and nano.
 */


function epochSecondAndNanoToLocalDateTime(epochSecond, nano) {
  var epochDay = floorDiv(epochSecond, SECONDS_PER_DAY);
  var secondsOfDay = floorMod(epochSecond, SECONDS_PER_DAY);
  var nanoOfDay = secondsOfDay.multiply(NANOS_PER_SECOND).add(nano);
  var localDate = epochDayToDate(epochDay);
  var localTime = nanoOfDayToLocalTime(nanoOfDay);
  return new _temporalTypes.LocalDateTime(localDate.year, localDate.month, localDate.day, localTime.hour, localTime.minute, localTime.second, localTime.nanosecond);
}
/**
 * Converts given local date into a single integer representing it's epoch day.
 * @param {Integer|number|string} year the year of the local date to convert.
 * @param {Integer|number|string} month the month of the local date to convert.
 * @param {Integer|number|string} day the day of the local date to convert.
 * @return {Integer} epoch day representing the given date.
 */


function dateToEpochDay(year, month, day) {
  year = (0, _integer["int"])(year);
  month = (0, _integer["int"])(month);
  day = (0, _integer["int"])(day);
  var epochDay = year.multiply(365);

  if (year.greaterThanOrEqual(0)) {
    epochDay = epochDay.add(year.add(3).div(4).subtract(year.add(99).div(100)).add(year.add(399).div(400)));
  } else {
    epochDay = epochDay.subtract(year.div(-4).subtract(year.div(-100)).add(year.div(-400)));
  }

  epochDay = epochDay.add(month.multiply(367).subtract(362).div(12));
  epochDay = epochDay.add(day.subtract(1));

  if (month.greaterThan(2)) {
    epochDay = epochDay.subtract(1);

    if (!isLeapYear(year)) {
      epochDay = epochDay.subtract(1);
    }
  }

  return epochDay.subtract(DAYS_0000_TO_1970);
}
/**
 * Converts given epoch day to a local date.
 * @param {Integer|number|string} epochDay the epoch day to convert.
 * @return {Date} the date representing the epoch day in years, months and days.
 */


function epochDayToDate(epochDay) {
  epochDay = (0, _integer["int"])(epochDay);
  var zeroDay = epochDay.add(DAYS_0000_TO_1970).subtract(60);
  var adjust = (0, _integer["int"])(0);

  if (zeroDay.lessThan(0)) {
    var adjustCycles = zeroDay.add(1).div(DAYS_PER_400_YEAR_CYCLE).subtract(1);
    adjust = adjustCycles.multiply(400);
    zeroDay = zeroDay.add(adjustCycles.multiply(-DAYS_PER_400_YEAR_CYCLE));
  }

  var year = zeroDay.multiply(400).add(591).div(DAYS_PER_400_YEAR_CYCLE);
  var dayOfYearEst = zeroDay.subtract(year.multiply(365).add(year.div(4)).subtract(year.div(100)).add(year.div(400)));

  if (dayOfYearEst.lessThan(0)) {
    year = year.subtract(1);
    dayOfYearEst = zeroDay.subtract(year.multiply(365).add(year.div(4)).subtract(year.div(100)).add(year.div(400)));
  }

  year = year.add(adjust);
  var marchDayOfYear = dayOfYearEst;
  var marchMonth = marchDayOfYear.multiply(5).add(2).div(153);
  var month = marchMonth.add(2).modulo(12).add(1);
  var day = marchDayOfYear.subtract(marchMonth.multiply(306).add(5).div(10)).add(1);
  year = year.add(marchMonth.div(10));
  return new _temporalTypes.Date(year, month, day);
}
/**
 * Format given duration to an ISO 8601 string.
 * @param {Integer|number|string} months the number of months.
 * @param {Integer|number|string} days the number of days.
 * @param {Integer|number|string} seconds the number of seconds.
 * @param {Integer|number|string} nanoseconds the number of nanoseconds.
 * @return {string} ISO string that represents given duration.
 */


function durationToIsoString(months, days, seconds, nanoseconds) {
  var monthsString = formatNumber(months);
  var daysString = formatNumber(days);
  var secondsAndNanosecondsString = formatSecondsAndNanosecondsForDuration(seconds, nanoseconds);
  return "P".concat(monthsString, "M").concat(daysString, "DT").concat(secondsAndNanosecondsString, "S");
}
/**
 * Formats given time to an ISO 8601 string.
 * @param {Integer|number|string} hour the hour value.
 * @param {Integer|number|string} minute the minute value.
 * @param {Integer|number|string} second the second value.
 * @param {Integer|number|string} nanosecond the nanosecond value.
 * @return {string} ISO string that represents given time.
 */


function timeToIsoString(hour, minute, second, nanosecond) {
  var hourString = formatNumber(hour, 2);
  var minuteString = formatNumber(minute, 2);
  var secondString = formatNumber(second, 2);
  var nanosecondString = formatNanosecond(nanosecond);
  return "".concat(hourString, ":").concat(minuteString, ":").concat(secondString).concat(nanosecondString);
}
/**
 * Formats given time zone offset in seconds to string representation like 'HH:MM', 'HH:MM:SS' or 'Z' for UTC.
 * @param {Integer|number|string} offsetSeconds the offset in seconds.
 * @return {string} ISO string that represents given offset.
 */


function timeZoneOffsetToIsoString(offsetSeconds) {
  offsetSeconds = (0, _integer["int"])(offsetSeconds);

  if (offsetSeconds.equals(0)) {
    return 'Z';
  }

  var isNegative = offsetSeconds.isNegative();

  if (isNegative) {
    offsetSeconds = offsetSeconds.multiply(-1);
  }

  var signPrefix = isNegative ? '-' : '+';
  var hours = formatNumber(offsetSeconds.div(SECONDS_PER_HOUR), 2);
  var minutes = formatNumber(offsetSeconds.div(SECONDS_PER_MINUTE).modulo(MINUTES_PER_HOUR), 2);
  var secondsValue = offsetSeconds.modulo(SECONDS_PER_MINUTE);
  var seconds = secondsValue.equals(0) ? null : formatNumber(secondsValue, 2);
  return seconds ? "".concat(signPrefix).concat(hours, ":").concat(minutes, ":").concat(seconds) : "".concat(signPrefix).concat(hours, ":").concat(minutes);
}
/**
 * Formats given date to an ISO 8601 string.
 * @param {Integer|number|string} year the date year.
 * @param {Integer|number|string} month the date month.
 * @param {Integer|number|string} day the date day.
 * @return {string} ISO string that represents given date.
 */


function dateToIsoString(year, month, day) {
  year = (0, _integer["int"])(year);
  var isNegative = year.isNegative();

  if (isNegative) {
    year = year.multiply(-1);
  }

  var yearString = formatNumber(year, 4);

  if (isNegative) {
    yearString = '-' + yearString;
  }

  var monthString = formatNumber(month, 2);
  var dayString = formatNumber(day, 2);
  return "".concat(yearString, "-").concat(monthString, "-").concat(dayString);
}
/**
 * Get the total number of nanoseconds from the milliseconds of the given standard JavaScript date and optional nanosecond part.
 * @param {global.Date} standardDate the standard JavaScript date.
 * @param {Integer|number|undefined} nanoseconds the optional number of nanoseconds.
 * @return {Integer|number} the total amount of nanoseconds.
 */


function totalNanoseconds(standardDate, nanoseconds) {
  nanoseconds = nanoseconds || 0;
  var nanosFromMillis = standardDate.getMilliseconds() * NANOS_PER_MILLISECOND;
  return (0, _integer.isInt)(nanoseconds) ? nanoseconds.add(nanosFromMillis) : nanoseconds + nanosFromMillis;
}
/**
 * Get the time zone offset in seconds from the given standard JavaScript date.
 *
 * <b>Implementation note:</b>
 * Time zone offset returned by the standard JavaScript date is the difference, in minutes, from local time to UTC.
 * So positive value means offset is behind UTC and negative value means it is ahead.
 * For Neo4j temporal types, like `Time` or `DateTime` offset is in seconds and represents difference from UTC to local time.
 * This is different from standard JavaScript dates and that's why implementation negates the returned value.
 *
 * @param {global.Date} standardDate the standard JavaScript date.
 * @return {number} the time zone offset in seconds.
 */


function timeZoneOffsetInSeconds(standardDate) {
  var offsetInMinutes = standardDate.getTimezoneOffset();

  if (offsetInMinutes === 0) {
    return 0;
  }

  return -1 * offsetInMinutes * SECONDS_PER_MINUTE;
}
/**
 * Assert that the year value is valid.
 * @param {Integer|number} year the value to check.
 * @return {Integer|number} the value of the year if it is valid. Exception is thrown otherwise.
 */


function assertValidYear(year) {
  return assertValidTemporalValue(year, YEAR_RANGE, 'Year');
}
/**
 * Assert that the month value is valid.
 * @param {Integer|number} month the value to check.
 * @return {Integer|number} the value of the month if it is valid. Exception is thrown otherwise.
 */


function assertValidMonth(month) {
  return assertValidTemporalValue(month, MONTH_OF_YEAR_RANGE, 'Month');
}
/**
 * Assert that the day value is valid.
 * @param {Integer|number} day the value to check.
 * @return {Integer|number} the value of the day if it is valid. Exception is thrown otherwise.
 */


function assertValidDay(day) {
  return assertValidTemporalValue(day, DAY_OF_MONTH_RANGE, 'Day');
}
/**
 * Assert that the hour value is valid.
 * @param {Integer|number} hour the value to check.
 * @return {Integer|number} the value of the hour if it is valid. Exception is thrown otherwise.
 */


function assertValidHour(hour) {
  return assertValidTemporalValue(hour, HOUR_OF_DAY_RANGE, 'Hour');
}
/**
 * Assert that the minute value is valid.
 * @param {Integer|number} minute the value to check.
 * @return {Integer|number} the value of the minute if it is valid. Exception is thrown otherwise.
 */


function assertValidMinute(minute) {
  return assertValidTemporalValue(minute, MINUTE_OF_HOUR_RANGE, 'Minute');
}
/**
 * Assert that the second value is valid.
 * @param {Integer|number} second the value to check.
 * @return {Integer|number} the value of the second if it is valid. Exception is thrown otherwise.
 */


function assertValidSecond(second) {
  return assertValidTemporalValue(second, SECOND_OF_MINUTE_RANGE, 'Second');
}
/**
 * Assert that the nanosecond value is valid.
 * @param {Integer|number} nanosecond the value to check.
 * @return {Integer|number} the value of the nanosecond if it is valid. Exception is thrown otherwise.
 */


function assertValidNanosecond(nanosecond) {
  return assertValidTemporalValue(nanosecond, NANOSECOND_OF_SECOND_RANGE, 'Nanosecond');
}
/**
 * Check if the given value is of expected type and is in the expected range.
 * @param {Integer|number} value the value to check.
 * @param {ValueRange} range the range.
 * @param {string} name the name of the value.
 * @return {Integer|number} the value if valid. Exception is thrown otherwise.
 */


function assertValidTemporalValue(value, range, name) {
  (0, _util.assertNumberOrInteger)(value, name);

  if (!range.contains(value)) {
    throw (0, _error.newError)("".concat(name, " is expected to be in range ").concat(range, " but was: ").concat(value));
  }

  return value;
}
/**
 * Converts given local time into a single integer representing this same time in seconds of the day. Nanoseconds are skipped.
 * @param {Integer|number|string} hour the hour of the local time.
 * @param {Integer|number|string} minute the minute of the local time.
 * @param {Integer|number|string} second the second of the local time.
 * @return {Integer} seconds representing the given local time.
 */


function localTimeToSecondOfDay(hour, minute, second) {
  hour = (0, _integer["int"])(hour);
  minute = (0, _integer["int"])(minute);
  second = (0, _integer["int"])(second);
  var totalSeconds = hour.multiply(SECONDS_PER_HOUR);
  totalSeconds = totalSeconds.add(minute.multiply(SECONDS_PER_MINUTE));
  return totalSeconds.add(second);
}
/**
 * Check if given year is a leap year. Uses algorithm described here {@link https://en.wikipedia.org/wiki/Leap_year#Algorithm}.
 * @param {Integer|number|string} year the year to check. Will be converted to {@link Integer} for all calculations.
 * @return {boolean} `true` if given year is a leap year, `false` otherwise.
 */


function isLeapYear(year) {
  year = (0, _integer["int"])(year);

  if (!year.modulo(4).equals(0)) {
    return false;
  } else if (!year.modulo(100).equals(0)) {
    return true;
  } else if (!year.modulo(400).equals(0)) {
    return false;
  } else {
    return true;
  }
}
/**
 * @param {Integer|number|string} x the divident.
 * @param {Integer|number|string} y the divisor.
 * @return {Integer} the result.
 */


function floorDiv(x, y) {
  x = (0, _integer["int"])(x);
  y = (0, _integer["int"])(y);
  var result = x.div(y);

  if (x.isPositive() !== y.isPositive() && result.multiply(y).notEquals(x)) {
    result = result.subtract(1);
  }

  return result;
}
/**
 * @param {Integer|number|string} x the divident.
 * @param {Integer|number|string} y the divisor.
 * @return {Integer} the result.
 */


function floorMod(x, y) {
  x = (0, _integer["int"])(x);
  y = (0, _integer["int"])(y);
  return x.subtract(floorDiv(x, y).multiply(y));
}
/**
 * @param {Integer|number|string} seconds the number of seconds to format.
 * @param {Integer|number|string} nanoseconds the number of nanoseconds to format.
 * @return {string} formatted value.
 */


function formatSecondsAndNanosecondsForDuration(seconds, nanoseconds) {
  seconds = (0, _integer["int"])(seconds);
  nanoseconds = (0, _integer["int"])(nanoseconds);
  var secondsString;
  var nanosecondsString;
  var secondsNegative = seconds.isNegative();
  var nanosecondsGreaterThanZero = nanoseconds.greaterThan(0);

  if (secondsNegative && nanosecondsGreaterThanZero) {
    if (seconds.equals(-1)) {
      secondsString = '-0';
    } else {
      secondsString = seconds.add(1).toString();
    }
  } else {
    secondsString = seconds.toString();
  }

  if (nanosecondsGreaterThanZero) {
    if (secondsNegative) {
      nanosecondsString = formatNanosecond(nanoseconds.negate().add(2 * NANOS_PER_SECOND).modulo(NANOS_PER_SECOND));
    } else {
      nanosecondsString = formatNanosecond(nanoseconds.add(NANOS_PER_SECOND).modulo(NANOS_PER_SECOND));
    }
  }

  return nanosecondsString ? secondsString + nanosecondsString : secondsString;
}
/**
 * @param {Integer|number|string} value the number of nanoseconds to format.
 * @return {string} formatted and possibly left-padded nanoseconds part as string.
 */


function formatNanosecond(value) {
  value = (0, _integer["int"])(value);
  return value.equals(0) ? '' : '.' + formatNumber(value, 9);
}
/**
 * @param {Integer|number|string} num the number to format.
 * @param {number} [stringLength=undefined] the string length to left-pad to.
 * @return {string} formatted and possibly left-padded number as string.
 */


function formatNumber(num) {
  var stringLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  num = (0, _integer["int"])(num);
  var isNegative = num.isNegative();

  if (isNegative) {
    num = num.negate();
  }

  var numString = num.toString();

  if (stringLength) {
    // left pad the string with zeroes
    while (numString.length < stringLength) {
      numString = '0' + numString;
    }
  }

  return isNegative ? '-' + numString : numString;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/transaction-executor.js":
/*!************************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/transaction-executor.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds

var DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds

var DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;
var DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;

var TransactionExecutor = /*#__PURE__*/function () {
  function TransactionExecutor(maxRetryTimeMs, initialRetryDelayMs, multiplier, jitterFactor) {
    (0, _classCallCheck2["default"])(this, TransactionExecutor);
    this._maxRetryTimeMs = _valueOrDefault(maxRetryTimeMs, DEFAULT_MAX_RETRY_TIME_MS);
    this._initialRetryDelayMs = _valueOrDefault(initialRetryDelayMs, DEFAULT_INITIAL_RETRY_DELAY_MS);
    this._multiplier = _valueOrDefault(multiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);
    this._jitterFactor = _valueOrDefault(jitterFactor, DEFAULT_RETRY_DELAY_JITTER_FACTOR);
    this._inFlightTimeoutIds = [];

    this._verifyAfterConstruction();
  }

  (0, _createClass2["default"])(TransactionExecutor, [{
    key: "execute",
    value: function execute(transactionCreator, transactionWork) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);
      })["catch"](function (error) {
        var retryStartTimeMs = Date.now();
        var retryDelayMs = _this._initialRetryDelayMs;
        return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTimeMs, retryDelayMs);
      });
    }
  }, {
    key: "close",
    value: function close() {
      // cancel all existing timeouts to prevent further retries
      this._inFlightTimeoutIds.forEach(function (timeoutId) {
        return clearTimeout(timeoutId);
      });

      this._inFlightTimeoutIds = [];
    }
  }, {
    key: "_retryTransactionPromise",
    value: function _retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, retryDelayMs) {
      var _this2 = this;

      var elapsedTimeMs = Date.now() - retryStartTime;

      if (elapsedTimeMs > this._maxRetryTimeMs || !TransactionExecutor._canRetryOn(error)) {
        return Promise.reject(error);
      }

      return new Promise(function (resolve, reject) {
        var nextRetryTime = _this2._computeDelayWithJitter(retryDelayMs);

        var timeoutId = setTimeout(function () {
          // filter out this timeoutId when time has come and function is being executed
          _this2._inFlightTimeoutIds = _this2._inFlightTimeoutIds.filter(function (id) {
            return id !== timeoutId;
          });

          _this2._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);
        }, nextRetryTime); // add newly created timeoutId to the list of all in-flight timeouts

        _this2._inFlightTimeoutIds.push(timeoutId);
      })["catch"](function (error) {
        var nextRetryDelayMs = retryDelayMs * _this2._multiplier;
        return _this2._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, nextRetryDelayMs);
      });
    }
  }, {
    key: "_executeTransactionInsidePromise",
    value: function _executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject) {
      var _this3 = this;

      var tx;

      try {
        tx = transactionCreator();
      } catch (error) {
        // failed to create a transaction
        reject(error);
        return;
      }

      var resultPromise = this._safeExecuteTransactionWork(tx, transactionWork);

      resultPromise.then(function (result) {
        return _this3._handleTransactionWorkSuccess(result, tx, resolve, reject);
      })["catch"](function (error) {
        return _this3._handleTransactionWorkFailure(error, tx, reject);
      });
    }
  }, {
    key: "_safeExecuteTransactionWork",
    value: function _safeExecuteTransactionWork(tx, transactionWork) {
      try {
        var result = transactionWork(tx); // user defined callback is supposed to return a promise, but it might not; so to protect against an
        // incorrect API usage we wrap the returned value with a resolved promise; this is effectively a
        // validation step without type checks

        return Promise.resolve(result);
      } catch (error) {
        return Promise.reject(error);
      }
    }
  }, {
    key: "_handleTransactionWorkSuccess",
    value: function _handleTransactionWorkSuccess(result, tx, resolve, reject) {
      if (tx.isOpen()) {
        // transaction work returned resolved promise and transaction has not been committed/rolled back
        // try to commit the transaction
        tx.commit().then(function () {
          // transaction was committed, return result to the user
          resolve(result);
        })["catch"](function (error) {
          // transaction failed to commit, propagate the failure
          reject(error);
        });
      } else {
        // transaction work returned resolved promise and transaction is already committed/rolled back
        // return the result returned by given transaction work
        resolve(result);
      }
    }
  }, {
    key: "_handleTransactionWorkFailure",
    value: function _handleTransactionWorkFailure(error, tx, reject) {
      if (tx.isOpen()) {
        // transaction work failed and the transaction is still open, roll it back and propagate the failure
        tx.rollback()["catch"](function (ignore) {// ignore the rollback error
        }).then(function () {
          return reject(error);
        }); // propagate the original error we got from the transaction work
      } else {
        // transaction is already rolled back, propagate the error
        reject(error);
      }
    }
  }, {
    key: "_computeDelayWithJitter",
    value: function _computeDelayWithJitter(delayMs) {
      var jitter = delayMs * this._jitterFactor;
      var min = delayMs - jitter;
      var max = delayMs + jitter;
      return Math.random() * (max - min) + min;
    }
  }, {
    key: "_verifyAfterConstruction",
    value: function _verifyAfterConstruction() {
      if (this._maxRetryTimeMs < 0) {
        throw (0, _error.newError)('Max retry time should be >= 0: ' + this._maxRetryTimeMs);
      }

      if (this._initialRetryDelayMs < 0) {
        throw (0, _error.newError)('Initial retry delay should >= 0: ' + this._initialRetryDelayMs);
      }

      if (this._multiplier < 1.0) {
        throw (0, _error.newError)('Multiplier should be >= 1.0: ' + this._multiplier);
      }

      if (this._jitterFactor < 0 || this._jitterFactor > 1) {
        throw (0, _error.newError)('Jitter factor should be in [0.0, 1.0]: ' + this._jitterFactor);
      }
    }
  }], [{
    key: "_canRetryOn",
    value: function _canRetryOn(error) {
      return error && error instanceof _error.Neo4jError && error.code && (error.code === _error.SERVICE_UNAVAILABLE || error.code === _error.SESSION_EXPIRED || this._isTransientError(error));
    }
  }, {
    key: "_isTransientError",
    value: function _isTransientError(error) {
      // Retries should not happen when transaction was explicitly terminated by the user.
      // Termination of transaction might result in two different error codes depending on where it was
      // terminated. These are really client errors but classification on the server is not entirely correct and
      // they are classified as transient.
      var code = error.code;

      if (code.indexOf('TransientError') >= 0) {
        if (code === 'Neo.TransientError.Transaction.Terminated' || code === 'Neo.TransientError.Transaction.LockClientStopped') {
          return false;
        }

        return true;
      }

      return false;
    }
  }]);
  return TransactionExecutor;
}();

exports["default"] = TransactionExecutor;

function _valueOrDefault(value, defaultValue) {
  if (value || value === 0) {
    return value;
  }

  return defaultValue;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/tx-config.js":
/*!*************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/tx-config.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var util = _interopRequireWildcard(__webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js"));

var _integer = __webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js");

var _error = __webpack_require__(/*! ../error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Internal holder of the transaction configuration.
 * It performs input validation and value conversion for further serialization by the Bolt protocol layer.
 * Users of the driver provide transaction configuration as regular objects `{timeout: 10, metadata: {key: 'value'}}`.
 * Driver converts such objects to {@link TxConfig} immediately and uses converted values everywhere.
 */
var TxConfig = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Object} config the raw configuration object.
   */
  function TxConfig(config) {
    (0, _classCallCheck2["default"])(this, TxConfig);
    assertValidConfig(config);
    this.timeout = extractTimeout(config);
    this.metadata = extractMetadata(config);
  }
  /**
   * Get an empty config object.
   * @return {TxConfig} an empty config.
   */


  (0, _createClass2["default"])(TxConfig, [{
    key: "isEmpty",

    /**
     * Check if this config object is empty. I.e. has no configuration values specified.
     * @return {boolean} `true` if this object is empty, `false` otherwise.
     */
    value: function isEmpty() {
      return Object.values(this).every(function (value) {
        return value == null;
      });
    }
  }], [{
    key: "empty",
    value: function empty() {
      return EMPTY_CONFIG;
    }
  }]);
  return TxConfig;
}();

exports["default"] = TxConfig;
var EMPTY_CONFIG = new TxConfig({});
/**
 * @return {Integer|null}
 */

function extractTimeout(config) {
  if (util.isObject(config) && (config.timeout || config.timeout === 0)) {
    util.assertNumberOrInteger(config.timeout, 'Transaction timeout');
    var timeout = (0, _integer["int"])(config.timeout);

    if (timeout.isZero()) {
      throw (0, _error.newError)('Transaction timeout should not be zero');
    }

    if (timeout.isNegative()) {
      throw (0, _error.newError)('Transaction timeout should not be negative');
    }

    return timeout;
  }

  return null;
}
/**
 * @return {object|null}
 */


function extractMetadata(config) {
  if (util.isObject(config) && config.metadata) {
    var metadata = config.metadata;
    util.assertObject(metadata);

    if (Object.keys(metadata).length !== 0) {
      // not an empty object
      return metadata;
    }
  }

  return null;
}

function assertValidConfig(config) {
  if (config) {
    util.assertObject(config, 'Transaction config');
  }
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/url-util.js":
/*!************************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/url-util.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _uriJs = __webpack_require__(/*! uri-js */ "./node_modules/uri-js/dist/es5/uri.all.js");

var _util = __webpack_require__(/*! ./util */ "./node_modules/neo4j-driver/lib/internal/util.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_BOLT_PORT = 7687;
var DEFAULT_HTTP_PORT = 7474;
var DEFAULT_HTTPS_PORT = 7473;

var Url = function Url(scheme, host, port, hostAndPort, query) {
  (0, _classCallCheck2["default"])(this, Url);

  /**
   * Nullable scheme (protocol) of the URL.
   * Example: 'bolt', 'neo4j', 'http', 'https', etc.
   * @type {string}
   */
  this.scheme = scheme;
  /**
   * Nonnull host name or IP address. IPv6 not wrapped in square brackets.
   * Example: 'neo4j.com', 'localhost', '127.0.0.1', '192.168.10.15', '::1', '2001:4860:4860::8844', etc.
   * @type {string}
   */

  this.host = host;
  /**
   * Nonnull number representing port. Default port for the given scheme is used if given URL string
   * does not contain port. Example: 7687 for bolt, 7474 for HTTP and 7473 for HTTPS.
   * @type {number}
   */

  this.port = port;
  /**
   * Nonnull host name or IP address plus port, separated by ':'. IPv6 wrapped in square brackets.
   * Example: 'neo4j.com', 'neo4j.com:7687', '127.0.0.1', '127.0.0.1:8080', '[2001:4860:4860::8844]',
   * '[2001:4860:4860::8844]:9090', etc.
   * @type {string}
   */

  this.hostAndPort = hostAndPort;
  /**
   * Nonnull object representing parsed query string key-value pairs. Duplicated keys not supported.
   * Example: '{}', '{'key1': 'value1', 'key2': 'value2'}', etc.
   * @type {Object}
   */

  this.query = query;
};

function parseDatabaseUrl(url) {
  (0, _util.assertString)(url, 'URL');
  var sanitized = sanitizeUrl(url);
  var parsedUrl = (0, _uriJs.parse)(sanitized.url);
  var scheme = sanitized.schemeMissing ? null : extractScheme(parsedUrl.scheme);
  var host = extractHost(parsedUrl.host); // no square brackets for IPv6

  var formattedHost = formatHost(host); // has square brackets for IPv6

  var port = extractPort(parsedUrl.port, scheme);
  var hostAndPort = "".concat(formattedHost, ":").concat(port);
  var query = extractQuery(parsedUrl.query, url);
  return new Url(scheme, host, port, hostAndPort, query);
}

function sanitizeUrl(url) {
  url = url.trim();

  if (url.indexOf('://') === -1) {
    // url does not contain scheme, add dummy 'none://' to make parser work correctly
    return {
      schemeMissing: true,
      url: "none://".concat(url)
    };
  }

  return {
    schemeMissing: false,
    url: url
  };
}

function extractScheme(scheme) {
  if (scheme) {
    scheme = scheme.trim();

    if (scheme.charAt(scheme.length - 1) === ':') {
      scheme = scheme.substring(0, scheme.length - 1);
    }

    return scheme;
  }

  return null;
}

function extractHost(host, url) {
  if (!host) {
    throw new Error("Unable to extract host from ".concat(url));
  }

  return host.trim();
}

function extractPort(portString, scheme) {
  var port = parseInt(portString, 10);
  return port === 0 || port ? port : defaultPortForScheme(scheme);
}

function extractQuery(queryString, url) {
  var query = trimAndSanitizeQuery(queryString);
  var context = {};

  if (query) {
    query.split('&').forEach(function (pair) {
      var keyValue = pair.split('=');

      if (keyValue.length !== 2) {
        throw new Error("Invalid parameters: '".concat(keyValue, "' in URL '").concat(url, "'."));
      }

      var key = trimAndVerifyQueryElement(keyValue[0], 'key', url);
      var value = trimAndVerifyQueryElement(keyValue[1], 'value', url);

      if (context[key]) {
        throw new Error("Duplicated query parameters with key '".concat(key, "' in URL '").concat(url, "'"));
      }

      context[key] = value;
    });
  }

  return context;
}

function trimAndSanitizeQuery(query) {
  query = (query || '').trim();

  if (query && query.charAt(0) === '?') {
    query = query.substring(1, query.length);
  }

  return query;
}

function trimAndVerifyQueryElement(element, name, url) {
  element = (element || '').trim();

  if (!element) {
    throw new Error("Illegal empty ".concat(name, " in URL query '").concat(url, "'"));
  }

  return element;
}

function escapeIPv6Address(address) {
  var startsWithSquareBracket = address.charAt(0) === '[';
  var endsWithSquareBracket = address.charAt(address.length - 1) === ']';

  if (!startsWithSquareBracket && !endsWithSquareBracket) {
    return "[".concat(address, "]");
  } else if (startsWithSquareBracket && endsWithSquareBracket) {
    return address;
  } else {
    throw new Error("Illegal IPv6 address ".concat(address));
  }
}

function formatHost(host) {
  if (!host) {
    throw new Error("Illegal host ".concat(host));
  }

  var isIPv6Address = host.indexOf(':') >= 0;
  return isIPv6Address ? escapeIPv6Address(host) : host;
}

function formatIPv4Address(address, port) {
  return "".concat(address, ":").concat(port);
}

function formatIPv6Address(address, port) {
  var escapedAddress = escapeIPv6Address(address);
  return "".concat(escapedAddress, ":").concat(port);
}

function defaultPortForScheme(scheme) {
  if (scheme === 'http') {
    return DEFAULT_HTTP_PORT;
  } else if (scheme === 'https') {
    return DEFAULT_HTTPS_PORT;
  } else {
    return DEFAULT_BOLT_PORT;
  }
}

var _default = {
  parseDatabaseUrl: parseDatabaseUrl,
  defaultPortForScheme: defaultPortForScheme,
  formatIPv4Address: formatIPv4Address,
  formatIPv6Address: formatIPv6Address
};
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/internal/util.js":
/*!********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/internal/util.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEmptyObjectOrNull = isEmptyObjectOrNull;
exports.isObject = isObject;
exports.isString = isString;
exports.assertObject = assertObject;
exports.assertString = assertString;
exports.assertNumber = assertNumber;
exports.assertNumberOrInteger = assertNumberOrInteger;
exports.assertValidDate = assertValidDate;
exports.validateQueryAndParameters = validateQueryAndParameters;
exports.ENCRYPTION_OFF = exports.ENCRYPTION_ON = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

var _integer = __webpack_require__(/*! ../integer */ "./node_modules/neo4j-driver/lib/integer.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ENCRYPTION_ON = 'ENCRYPTION_ON';
exports.ENCRYPTION_ON = ENCRYPTION_ON;
var ENCRYPTION_OFF = 'ENCRYPTION_OFF';
exports.ENCRYPTION_OFF = ENCRYPTION_OFF;

function isEmptyObjectOrNull(obj) {
  if (obj === null) {
    return true;
  }

  if (!isObject(obj)) {
    return false;
  }

  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      return false;
    }
  }

  return true;
}

function isObject(obj) {
  return (0, _typeof2["default"])(obj) === 'object' && !Array.isArray(obj) && obj !== null;
}
/**
 * Check and normalize given query and parameters.
 * @param {string|{text: string, parameters: object}} query the query to check.
 * @param {Object} parameters
 * @return {{query: string, params: object}} the normalized query with parameters.
 * @throws TypeError when either given query or parameters are invalid.
 */


function validateQueryAndParameters(query, parameters) {
  var validatedQuery = query;
  var params = parameters || {};

  if ((0, _typeof2["default"])(query) === 'object' && query.text) {
    validatedQuery = query.text;
    params = query.parameters || {};
  }

  assertCypherQuery(validatedQuery);
  assertQueryParameters(params);
  return {
    validatedQuery: validatedQuery,
    params: params
  };
}

function assertObject(obj, objName) {
  if (!isObject(obj)) {
    throw new TypeError(objName + ' expected to be an object but was: ' + JSON.stringify(obj));
  }

  return obj;
}

function assertString(obj, objName) {
  if (!isString(obj)) {
    throw new TypeError(objName + ' expected to be string but was: ' + JSON.stringify(obj));
  }

  return obj;
}

function assertNumber(obj, objName) {
  if (typeof obj !== 'number') {
    throw new TypeError(objName + ' expected to be a number but was: ' + JSON.stringify(obj));
  }

  return obj;
}

function assertNumberOrInteger(obj, objName) {
  if (typeof obj !== 'number' && !(0, _integer.isInt)(obj)) {
    throw new TypeError(objName + ' expected to be either a number or an Integer object but was: ' + JSON.stringify(obj));
  }

  return obj;
}

function assertValidDate(obj, objName) {
  if (Object.prototype.toString.call(obj) !== '[object Date]') {
    throw new TypeError(objName + ' expected to be a standard JavaScript Date but was: ' + JSON.stringify(obj));
  }

  if (Number.isNaN(obj.getTime())) {
    throw new TypeError(objName + ' expected to be valid JavaScript Date but its time was NaN: ' + JSON.stringify(obj));
  }

  return obj;
}

function assertCypherQuery(obj) {
  assertString(obj, 'Cypher query');

  if (obj.trim().length === 0) {
    throw new TypeError('Cypher query is expected to be a non-empty string.');
  }
}

function assertQueryParameters(obj) {
  if (!isObject(obj)) {
    // objects created with `Object.create(null)` do not have a constructor property
    var _constructor = obj.constructor ? ' ' + obj.constructor.name : '';

    throw new TypeError("Query parameters are expected to either be undefined/null or an object, given:".concat(_constructor, " ").concat(obj));
  }
}

function isString(str) {
  return Object.prototype.toString.call(str) === '[object String]';
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/record.js":
/*!*************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/record.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function generateFieldLookup(keys) {
  var lookup = {};
  keys.forEach(function (name, idx) {
    lookup[name] = idx;
  });
  return lookup;
}
/**
 * Records make up the contents of the {@link Result}, and is how you access
 * the output of a query. A simple query might yield a result stream
 * with a single record, for instance:
 *
 *     MATCH (u:User) RETURN u.name, u.age
 *
 * This returns a stream of records with two fields, named `u.name` and `u.age`,
 * each record represents one user found by the query above. You can access
 * the values of each field either by name:
 *
 *     record.get("u.name")
 *
 * Or by it's position:
 *
 *     record.get(0)
 *
 * @access public
 */


var Record = /*#__PURE__*/function () {
  /**
   * Create a new record object.
   * @constructor
   * @protected
   * @param {string[]} keys An array of field keys, in the order the fields appear in the record
   * @param {Array} fields An array of field values
   * @param {Object} fieldLookup An object of fieldName -> value index, used to map
   *                            field names to values. If this is null, one will be
   *                            generated.
   */
  function Record(keys, fields) {
    var fieldLookup = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    (0, _classCallCheck2["default"])(this, Record);

    /**
     * Field keys, in the order the fields appear in the record.
     * @type {string[]}
     */
    this.keys = keys;
    /**
     * Number of fields
     * @type {Number}
     */

    this.length = keys.length;
    this._fields = fields;
    this._fieldLookup = fieldLookup || generateFieldLookup(keys);
  }
  /**
   * Run the given function for each field in this record. The function
   * will get three arguments - the value, the key and this record, in that
   * order.
   *
   * @param {function(value: Object, key: string, record: Record)} visitor the function to apply to each field.
   */


  (0, _createClass2["default"])(Record, [{
    key: "forEach",
    value: function forEach(visitor) {
      var _iterator = _createForOfIteratorHelper(this.entries()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = (0, _slicedToArray2["default"])(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];

          visitor(value, key, this);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Run the given function for each field in this record. The function
     * will get three arguments - the value, the key and this record, in that
     * order.
     *
     * @param {function(value: Object, key: string, record: Record)} visitor the function to apply on each field
     * and return a value that is saved to the returned Array.
     *
     * @returns {Array}
     */

  }, {
    key: "map",
    value: function map(visitor) {
      var resultArray = [];

      var _iterator2 = _createForOfIteratorHelper(this.entries()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = (0, _slicedToArray2["default"])(_step2.value, 2),
              key = _step2$value[0],
              value = _step2$value[1];

          resultArray.push(visitor(value, key, this));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return resultArray;
    }
    /**
     * Iterate over results. Each iteration will yield an array
     * of exactly two items - the key, and the value (in order).
     *
     * @generator
     * @returns {IterableIterator<Array>}
     */

  }, {
    key: "entries",
    value: /*#__PURE__*/_regenerator["default"].mark(function entries() {
      var i;
      return _regenerator["default"].wrap(function entries$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              i = 0;

            case 1:
              if (!(i < this.keys.length)) {
                _context.next = 7;
                break;
              }

              _context.next = 4;
              return [this.keys[i], this._fields[i]];

            case 4:
              i++;
              _context.next = 1;
              break;

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, entries, this);
    })
    /**
     * Iterate over values.
     *
     * @generator
     * @returns {IterableIterator<Object>}
     */

  }, {
    key: "values",
    value: /*#__PURE__*/_regenerator["default"].mark(function values() {
      var i;
      return _regenerator["default"].wrap(function values$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              i = 0;

            case 1:
              if (!(i < this.keys.length)) {
                _context2.next = 7;
                break;
              }

              _context2.next = 4;
              return this._fields[i];

            case 4:
              i++;
              _context2.next = 1;
              break;

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, values, this);
    })
    /**
     * Iterate over values. Delegates to {@link Record#values}
     *
     * @generator
     * @returns {IterableIterator<Object>}
     */

  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regenerator["default"].mark(function value() {
      return _regenerator["default"].wrap(function value$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.delegateYield(this.values(), "t0", 1);

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, value, this);
    })
    /**
     * Generates an object out of the current Record
     *
     * @returns {Object}
     */

  }, {
    key: "toObject",
    value: function toObject() {
      var object = {};

      var _iterator3 = _createForOfIteratorHelper(this.entries()),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _step3$value = (0, _slicedToArray2["default"])(_step3.value, 2),
              key = _step3$value[0],
              _value = _step3$value[1];

          object[key] = _value;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return object;
    }
    /**
     * Get a value from this record, either by index or by field key.
     *
     * @param {string|Number} key Field key, or the index of the field.
     * @returns {*}
     */

  }, {
    key: "get",
    value: function get(key) {
      var index;

      if (!(typeof key === 'number')) {
        index = this._fieldLookup[key];

        if (index === undefined) {
          throw (0, _error.newError)("This record has no field with key '" + key + "', available key are: [" + this.keys + '].');
        }
      } else {
        index = key;
      }

      if (index > this._fields.length - 1 || index < 0) {
        throw (0, _error.newError)("This record has no field with index '" + index + "'. Remember that indexes start at `0`, " + 'and make sure your query returns records in the shape you meant it to.');
      }

      return this._fields[index];
    }
    /**
     * Check if a value from this record, either by index or by field key, exists.
     *
     * @param {string|Number} key Field key, or the index of the field.
     * @returns {boolean}
     */

  }, {
    key: "has",
    value: function has(key) {
      // if key is a number, we check if it is in the _fields array
      if (typeof key === 'number') {
        return key >= 0 && key < this._fields.length;
      } // if it's not a number, we check _fieldLookup dictionary directly


      return this._fieldLookup[key] !== undefined;
    }
  }]);
  return Record;
}();

var _default = Record;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/result-rx.js":
/*!****************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/result-rx.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

var _resultSummary = _interopRequireDefault(__webpack_require__(/*! ./result-summary */ "./node_modules/neo4j-driver/lib/result-summary.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");

var _record = _interopRequireDefault(__webpack_require__(/*! ./record */ "./node_modules/neo4j-driver/lib/record.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var States = {
  READY: 0,
  STREAMING: 1,
  COMPLETED: 2
};
/**
 * The reactive result interface.
 */

var RxResult = /*#__PURE__*/function () {
  /**
   * @constructor
   * @protected
   * @param {Observable<Result>} result - An observable of single Result instance to relay requests.
   */
  function RxResult(result) {
    (0, _classCallCheck2["default"])(this, RxResult);
    var replayedResult = result.pipe((0, _operators.publishReplay)(1), (0, _operators.refCount)());
    this._result = replayedResult;
    this._keys = replayedResult.pipe((0, _operators.flatMap)(function (r) {
      return (0, _rxjs.from)(r.keys());
    }), (0, _operators.publishReplay)(1), (0, _operators.refCount)());
    this._records = new _rxjs.Subject();
    this._summary = new _rxjs.ReplaySubject();
    this._state = States.READY;
  }
  /**
   * Returns an observable that exposes a single item containing field names
   * returned by the executing query.
   *
   * Errors raised by actual query execution can surface on the returned
   * observable stream.
   *
   * @public
   * @returns {Observable<string[]>} - An observable stream (with exactly one element) of field names.
   */


  (0, _createClass2["default"])(RxResult, [{
    key: "keys",
    value: function keys() {
      return this._keys;
    }
    /**
     * Returns an observable that exposes each record returned by the executing query.
     *
     * Errors raised during the streaming phase can surface on the returned observable stream.
     *
     * @public
     * @returns {Observable<Record>} - An observable stream of records.
     */

  }, {
    key: "records",
    value: function records() {
      var _this = this;

      return this._result.pipe((0, _operators.flatMap)(function (result) {
        return new _rxjs.Observable(function (recordsObserver) {
          return _this._startStreaming({
            result: result,
            recordsObserver: recordsObserver
          });
        });
      }));
    }
    /**
     * Returns an observable that exposes a single item of {@link ResultSummary} that is generated by
     * the server after the streaming of the executing query is completed.
     *
     * *Subscribing to this stream before subscribing to records() stream causes the results to be discarded on the server.*
     *
     * @public
     * @returns {Observable<ResultSummary>} - An observable stream (with exactly one element) of result summary.
     */

  }, {
    key: "consume",
    value: function consume() {
      var _this2 = this;

      return this._result.pipe((0, _operators.flatMap)(function (result) {
        return new _rxjs.Observable(function (summaryObserver) {
          return _this2._startStreaming({
            result: result,
            summaryObserver: summaryObserver
          });
        });
      }));
    }
  }, {
    key: "_startStreaming",
    value: function _startStreaming() {
      var _this3 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          result = _ref.result,
          _ref$recordsObserver = _ref.recordsObserver,
          recordsObserver = _ref$recordsObserver === void 0 ? null : _ref$recordsObserver,
          _ref$summaryObserver = _ref.summaryObserver,
          summaryObserver = _ref$summaryObserver === void 0 ? null : _ref$summaryObserver;

      var subscriptions = [];

      if (summaryObserver) {
        subscriptions.push(this._summary.subscribe(summaryObserver));
      }

      if (this._state < States.STREAMING) {
        this._state = States.STREAMING;

        if (recordsObserver) {
          subscriptions.push(this._records.subscribe(recordsObserver));
        }

        subscriptions.push({
          unsubscribe: function unsubscribe() {
            if (result._cancel) {
              result._cancel();
            }
          }
        });

        if (this._records.observers.length === 0) {
          result._cancel();
        }

        result.subscribe({
          onNext: function onNext(record) {
            _this3._records.next(record);
          },
          onCompleted: function onCompleted(summary) {
            _this3._records.complete();

            _this3._summary.next(summary);

            _this3._summary.complete();

            _this3._state = States.COMPLETED;
          },
          onError: function onError(err) {
            _this3._records.error(err);

            _this3._summary.error(err);

            _this3._state = States.COMPLETED;
          }
        });
      } else if (recordsObserver) {
        recordsObserver.error((0, _error.newError)('Streaming has already started/consumed with a previous records or summary subscription.'));
      }

      return function () {
        subscriptions.forEach(function (s) {
          return s.unsubscribe();
        });
      };
    }
  }]);
  return RxResult;
}();

exports["default"] = RxResult;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/result-summary.js":
/*!*********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/result-summary.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.queryType = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _integer = __webpack_require__(/*! ./integer */ "./node_modules/neo4j-driver/lib/integer.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A ResultSummary instance contains structured metadata for a {@link Result}.
 * @access public
 */
var ResultSummary = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {string} query - The query this summary is for
   * @param {Object} parameters - Parameters for the query
   * @param {Object} metadata - Query metadata
   * @param {number} protocolVersion - Bolt protocol version
   */
  function ResultSummary(query, parameters, metadata, protocolVersion) {
    (0, _classCallCheck2["default"])(this, ResultSummary);

    /**
     * The query and parameters this summary is for.
     * @type {{text: string, parameters: Object}}
     * @public
     */
    this.query = {
      text: query,
      parameters: parameters
    };
    /**
     * The type of query executed. Can be "r" for read-only query, "rw" for read-write query,
     * "w" for write-only query and "s" for schema-write query.
     * String constants are available in {@link queryType} object.
     * @type {string}
     * @public
     */

    this.queryType = metadata.type;
    /**
     * Counters for operations the query triggered.
     * @type {QueryStatistics}
     * @public
     */

    this.counters = new QueryStatistics(metadata.stats || {}); // for backwards compatibility, remove in future version

    /**
     * Use {@link ResultSummary.counters} instead.
     * @type {QueryStatistics}
     * @deprecated
     */

    this.updateStatistics = this.counters;
    /**
     * This describes how the database will execute the query.
     * Query plan for the executed query if available, otherwise undefined.
     * Will only be populated for queries that start with "EXPLAIN".
     * @type {Plan}
     * @public
     */

    this.plan = metadata.plan || metadata.profile ? new Plan(metadata.plan || metadata.profile) : false;
    /**
     * This describes how the database did execute your query. This will contain detailed information about what
     * each step of the plan did. Profiled query plan for the executed query if available, otherwise undefined.
     * Will only be populated for queries that start with "PROFILE".
     * @type {ProfiledPlan}
     * @public
     */

    this.profile = metadata.profile ? new ProfiledPlan(metadata.profile) : false;
    /**
     * An array of notifications that might arise when executing the query. Notifications can be warnings about
     * problematic queries or other valuable information that can be presented in a client. Unlike failures
     * or errors, notifications do not affect the execution of a query.
     * @type {Array<Notification>}
     * @public
     */

    this.notifications = this._buildNotifications(metadata.notifications);
    /**
     * The basic information of the server where the result is obtained from.
     * @type {ServerInfo}
     * @public
     */

    this.server = new ServerInfo(metadata.server, protocolVersion);
    /**
     * The time it took the server to consume the result.
     * @type {number}
     * @public
     */

    this.resultConsumedAfter = metadata.result_consumed_after;
    /**
     * The time it took the server to make the result available for consumption in milliseconds.
     * @type {number}
     * @public
     */

    this.resultAvailableAfter = metadata.result_available_after;
    /**
     * The database name where this summary is obtained from.
     * @type {{name: string}}
     * @public
     */

    this.database = {
      name: metadata.db || null
    };
  }

  (0, _createClass2["default"])(ResultSummary, [{
    key: "_buildNotifications",
    value: function _buildNotifications(notifications) {
      if (!notifications) {
        return [];
      }

      return notifications.map(function (n) {
        return new Notification(n);
      });
    }
    /**
     * Check if the result summary has a plan
     * @return {boolean}
     */

  }, {
    key: "hasPlan",
    value: function hasPlan() {
      return this.plan instanceof Plan;
    }
    /**
     * Check if the result summary has a profile
     * @return {boolean}
     */

  }, {
    key: "hasProfile",
    value: function hasProfile() {
      return this.profile instanceof ProfiledPlan;
    }
  }]);
  return ResultSummary;
}();
/**
 * Class for execution plan received by prepending Cypher with EXPLAIN.
 * @access public
 */


var Plan =
/**
 * Create a Plan instance
 * @constructor
 * @param {Object} plan - Object with plan data
 */
function Plan(plan) {
  (0, _classCallCheck2["default"])(this, Plan);
  this.operatorType = plan.operatorType;
  this.identifiers = plan.identifiers;
  this.arguments = plan.args;
  this.children = plan.children ? plan.children.map(function (child) {
    return new Plan(child);
  }) : [];
};
/**
 * Class for execution plan received by prepending Cypher with PROFILE.
 * @access public
 */


var ProfiledPlan = /*#__PURE__*/function () {
  /**
   * Create a ProfiledPlan instance
   * @constructor
   * @param {Object} profile - Object with profile data
   */
  function ProfiledPlan(profile) {
    (0, _classCallCheck2["default"])(this, ProfiledPlan);
    this.operatorType = profile.operatorType;
    this.identifiers = profile.identifiers;
    this.arguments = profile.args;
    this.dbHits = valueOrDefault('dbHits', profile);
    this.rows = valueOrDefault('rows', profile);
    this.pageCacheMisses = valueOrDefault('pageCacheMisses', profile);
    this.pageCacheHits = valueOrDefault('pageCacheHits', profile);
    this.pageCacheHitRatio = valueOrDefault('pageCacheHitRatio', profile);
    this.time = valueOrDefault('time', profile);
    this.children = profile.children ? profile.children.map(function (child) {
      return new ProfiledPlan(child);
    }) : [];
  }

  (0, _createClass2["default"])(ProfiledPlan, [{
    key: "hasPageCacheStats",
    value: function hasPageCacheStats() {
      return this.pageCacheMisses > 0 || this.pageCacheHits > 0 || this.pageCacheHitRatio > 0;
    }
  }]);
  return ProfiledPlan;
}();
/**
 * Get statistical information for a {@link Result}.
 * @access public
 */


var QueryStatistics = /*#__PURE__*/function () {
  /**
   * Structurize the statistics
   * @constructor
   * @param {Object} statistics - Result statistics
   */
  function QueryStatistics(statistics) {
    var _this = this;

    (0, _classCallCheck2["default"])(this, QueryStatistics);
    this._stats = {
      nodesCreated: 0,
      nodesDeleted: 0,
      relationshipsCreated: 0,
      relationshipsDeleted: 0,
      propertiesSet: 0,
      labelsAdded: 0,
      labelsRemoved: 0,
      indexesAdded: 0,
      indexesRemoved: 0,
      constraintsAdded: 0,
      constraintsRemoved: 0
    };
    this._systemUpdates = 0;
    Object.keys(statistics).forEach(function (index) {
      // To camelCase
      var camelCaseIndex = index.replace(/(-\w)/g, function (m) {
        return m[1].toUpperCase();
      });

      if (camelCaseIndex in _this._stats) {
        _this._stats[camelCaseIndex] = intValue(statistics[index]);
      } else if (camelCaseIndex === 'systemUpdates') {
        _this._systemUpdates = intValue(statistics[index]);
      }
    });
    this._stats = Object.freeze(this._stats);
  }
  /**
   * Did the database get updated?
   * @return {boolean}
   */


  (0, _createClass2["default"])(QueryStatistics, [{
    key: "containsUpdates",
    value: function containsUpdates() {
      var _this2 = this;

      return Object.keys(this._stats).reduce(function (last, current) {
        return last + _this2._stats[current];
      }, 0) > 0;
    }
    /**
     * Returns the query statistics updates in a dictionary.
     * @returns {*}
     */

  }, {
    key: "updates",
    value: function updates() {
      return this._stats;
    }
    /**
     * Return true if the system database get updated, otherwise false
     * @returns {boolean} - If the system database get updated or not.
     */

  }, {
    key: "containsSystemUpdates",
    value: function containsSystemUpdates() {
      return this._systemUpdates > 0;
    }
    /**
     * @returns {number} - Number of system updates
     */

  }, {
    key: "systemUpdates",
    value: function systemUpdates() {
      return this._systemUpdates;
    }
  }]);
  return QueryStatistics;
}();
/**
 * Class for Cypher notifications
 * @access public
 */


var Notification = /*#__PURE__*/function () {
  /**
   * Create a Notification instance
   * @constructor
   * @param {Object} notification - Object with notification data
   */
  function Notification(notification) {
    (0, _classCallCheck2["default"])(this, Notification);
    this.code = notification.code;
    this.title = notification.title;
    this.description = notification.description;
    this.severity = notification.severity;
    this.position = Notification._constructPosition(notification.position);
  }

  (0, _createClass2["default"])(Notification, null, [{
    key: "_constructPosition",
    value: function _constructPosition(pos) {
      if (!pos) {
        return {};
      }

      return {
        offset: intValue(pos.offset),
        line: intValue(pos.line),
        column: intValue(pos.column)
      };
    }
  }]);
  return Notification;
}();
/**
 * Class for exposing server info from a result.
 * @access public
 */


var ServerInfo =
/**
 * Create a ServerInfo instance
 * @constructor
 * @param {Object} serverMeta - Object with serverMeta data
 * @param {number} protocolVersion - Bolt protocol version
 */
function ServerInfo(serverMeta, protocolVersion) {
  (0, _classCallCheck2["default"])(this, ServerInfo);

  if (serverMeta) {
    this.address = serverMeta.address;
    this.version = serverMeta.version;
  }

  this.protocolVersion = protocolVersion;
};

function intValue(value) {
  return (0, _integer.isInt)(value) ? value.toInt() : value;
}

function valueOrDefault(key, values) {
  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  if (key in values) {
    var value = values[key];
    return (0, _integer.isInt)(value) ? value.toInt() : value;
  } else {
    return defaultValue;
  }
}
/**
 * The constants for query types
 * @type {{SCHEMA_WRITE: string, WRITE_ONLY: string, READ_ONLY: string, READ_WRITE: string}}
 */


var queryType = {
  READ_ONLY: 'r',
  READ_WRITE: 'rw',
  WRITE_ONLY: 'w',
  SCHEMA_WRITE: 's'
};
exports.queryType = queryType;
var _default = ResultSummary;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/result.js":
/*!*************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/result.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _resultSummary = _interopRequireDefault(__webpack_require__(/*! ./result-summary */ "./node_modules/neo4j-driver/lib/result-summary.js"));

var _connectionHolder = __webpack_require__(/*! ./internal/connection-holder */ "./node_modules/neo4j-driver/lib/internal/connection-holder.js");

var _streamObservers = __webpack_require__(/*! ./internal/stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_ON_ERROR = function DEFAULT_ON_ERROR(error) {
  console.log('Uncaught error when processing result: ' + error);
};

var DEFAULT_ON_COMPLETED = function DEFAULT_ON_COMPLETED(summary) {};

var DEFAULT_METADATA_SUPPLIER = function DEFAULT_METADATA_SUPPLIER(metadata) {};
/**
 * A stream of {@link Record} representing the result of a query.
 * Can be consumed eagerly as {@link Promise} resolved with array of records and {@link ResultSummary}
 * summary, or rejected with error that contains {@link string} code and {@link string} message.
 * Alternatively can be consumed lazily using {@link Result#subscribe} function.
 * @access public
 */


var Result = /*#__PURE__*/function () {
  /**
   * Inject the observer to be used.
   * @constructor
   * @access private
   * @param {Promise<ResultStreamObserver>} streamObserverPromise
   * @param {mixed} query - Cypher query to execute
   * @param {Object} parameters - Map with parameters to use in query
   * @param {ConnectionHolder} connectionHolder - to be notified when result is either fully consumed or error happened.
   */
  function Result(streamObserverPromise, query, parameters, connectionHolder) {
    (0, _classCallCheck2["default"])(this, Result);
    this._stack = captureStacktrace();
    this._streamObserverPromise = streamObserverPromise;
    this._p = null;
    this._query = query;
    this._parameters = parameters || {};
    this._connectionHolder = connectionHolder || _connectionHolder.EMPTY_CONNECTION_HOLDER;
  }
  /**
   * Returns a promise for the field keys.
   *
   * *Should not be combined with {@link Result#subscribe} function.*
   *
   * @public
   * @returns {Promise<string[]>} - Field keys, in the order they will appear in records.
   }
   */


  (0, _createClass2["default"])(Result, [{
    key: "keys",
    value: function keys() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        _this._streamObserverPromise.then(function (observer) {
          return observer.subscribe({
            onKeys: function onKeys(keys) {
              return resolve(keys);
            },
            onError: function onError(err) {
              return reject(err);
            }
          });
        });
      });
    }
    /**
     * Returns a promise for the result summary.
     *
     * *Should not be combined with {@link Result#subscribe} function.*
     *
     * @public
     * @returns {Promise<ResultSummary>} - Result summary.
     *
     */

  }, {
    key: "summary",
    value: function summary() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2._streamObserverPromise.then(function (o) {
          o.cancel();
          o.subscribe({
            onCompleted: function onCompleted(metadata) {
              return resolve(metadata);
            },
            onError: function onError(err) {
              return reject(err);
            }
          });
        });
      });
    }
    /**
     * Create and return new Promise
     *
     * @private
     * @return {Promise} new Promise.
     */

  }, {
    key: "_getOrCreatePromise",
    value: function _getOrCreatePromise() {
      var _this3 = this;

      if (!this._p) {
        this._p = new Promise(function (resolve, reject) {
          var records = [];
          var observer = {
            onNext: function onNext(record) {
              records.push(record);
            },
            onCompleted: function onCompleted(summary) {
              resolve({
                records: records,
                summary: summary
              });
            },
            onError: function onError(error) {
              reject(error);
            }
          };

          _this3.subscribe(observer);
        });
      }

      return this._p;
    }
    /**
     * Waits for all results and calls the passed in function with the results.
     *
     * *Should not be combined with {@link Result#subscribe} function.*
     *
     * @param {function(result: {records:Array<Record>, summary: ResultSummary})} onFulfilled - function to be called
     * when finished.
     * @param {function(error: {message:string, code:string})} onRejected - function to be called upon errors.
     * @return {Promise} promise.
     */

  }, {
    key: "then",
    value: function then(onFulfilled, onRejected) {
      return this._getOrCreatePromise().then(onFulfilled, onRejected);
    }
    /**
     * Catch errors when using promises.
     *
     * *Should not be combined with {@link Result#subscribe} function.*
     *
     * @param {function(error: Neo4jError)} onRejected - Function to be called upon errors.
     * @return {Promise} promise.
     */

  }, {
    key: "catch",
    value: function _catch(onRejected) {
      return this._getOrCreatePromise()["catch"](onRejected);
    }
    /**
     * Stream records to observer as they come in, this is a more efficient method
     * of handling the results, and allows you to handle arbitrarily large results.
     *
     * @param {Object} observer - Observer object
     * @param {function(keys: string[])} observer.onKeys - handle stream head, the field keys.
     * @param {function(record: Record)} observer.onNext - handle records, one by one.
     * @param {function(summary: ResultSummary)} observer.onCompleted - handle stream tail, the result summary.
     * @param {function(error: {message:string, code:string})} observer.onError - handle errors.
     * @return
     */

  }, {
    key: "subscribe",
    value: function subscribe(observer) {
      var _this4 = this;

      var onCompletedOriginal = observer.onCompleted || DEFAULT_ON_COMPLETED;

      var onCompletedWrapper = function onCompletedWrapper(metadata) {
        var connectionHolder = _this4._connectionHolder;
        var query = _this4._query;
        var parameters = _this4._parameters;

        function release(protocolVersion) {
          // notify connection holder that the used connection is not needed any more because result has
          // been fully consumed; call the original onCompleted callback after that
          connectionHolder.releaseConnection().then(function () {
            onCompletedOriginal.call(observer, new _resultSummary["default"](query, parameters, metadata, protocolVersion));
          });
        }

        connectionHolder.getConnection().then( // onFulfilled:
        function (connection) {
          release(connection ? connection.protocol().version : undefined);
        }, // onRejected:
        function (_) {
          release();
        });
      };

      observer.onCompleted = onCompletedWrapper;
      var onErrorOriginal = observer.onError || DEFAULT_ON_ERROR;

      var onErrorWrapper = function onErrorWrapper(error) {
        // notify connection holder that the used connection is not needed any more because error happened
        // and result can't bee consumed any further; call the original onError callback after that
        _this4._connectionHolder.releaseConnection().then(function () {
          replaceStacktrace(error, _this4._stack);
          onErrorOriginal.call(observer, error);
        });
      };

      observer.onError = onErrorWrapper;

      this._streamObserverPromise.then(function (o) {
        return o.subscribe(observer);
      });
    }
    /**
     * Signals the stream observer that the future records should be discarded on the server.
     *
     * @protected
     * @since 4.0.0
     */

  }, {
    key: "_cancel",
    value: function _cancel() {
      this._streamObserverPromise.then(function (o) {
        return o.cancel();
      });
    }
  }]);
  return Result;
}();

function captureStacktrace() {
  var error = new Error('');

  if (error.stack) {
    return error.stack.replace(/^Error(\n\r)*/, ''); // we don't need the 'Error\n' part, if only it exists
  }

  return null;
}

function replaceStacktrace(error, newStack) {
  if (newStack) {
    // Error.prototype.toString() concatenates error.name and error.message nicely
    // then we add the rest of the stack trace
    error.stack = error.toString() + '\n' + newStack;
  }
}

var _default = Result;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/routing-driver.js":
/*!*********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/routing-driver.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _driver = __webpack_require__(/*! ./driver */ "./node_modules/neo4j-driver/lib/driver.js");

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

var _connectionProviderRouting = _interopRequireDefault(__webpack_require__(/*! ./internal/connection-provider-routing */ "./node_modules/neo4j-driver/lib/internal/connection-provider-routing.js"));

var _leastConnectedLoadBalancingStrategy = _interopRequireDefault(__webpack_require__(/*! ./internal/least-connected-load-balancing-strategy */ "./node_modules/neo4j-driver/lib/internal/least-connected-load-balancing-strategy.js"));

var _connectionErrorHandler = _interopRequireDefault(__webpack_require__(/*! ./internal/connection-error-handler */ "./node_modules/neo4j-driver/lib/internal/connection-error-handler.js"));

var _configuredCustomResolver = _interopRequireDefault(__webpack_require__(/*! ./internal/resolver/configured-custom-resolver */ "./node_modules/neo4j-driver/lib/internal/resolver/configured-custom-resolver.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * A driver that supports routing in a causal cluster.
 * @private
 */
var RoutingDriver = /*#__PURE__*/function (_Driver) {
  (0, _inherits2["default"])(RoutingDriver, _Driver);

  var _super = _createSuper(RoutingDriver);

  function RoutingDriver(address, routingContext, userAgent) {
    var _this;

    var token = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var config = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    (0, _classCallCheck2["default"])(this, RoutingDriver);
    _this = _super.call(this, address, userAgent, token, validateConfig(config));
    _this._routingContext = routingContext;
    return _this;
  }

  (0, _createClass2["default"])(RoutingDriver, [{
    key: "_afterConstruction",
    value: function _afterConstruction() {
      this._log.info("Routing driver ".concat(this._id, " created for server address ").concat(this._address));
    }
  }, {
    key: "_createConnectionProvider",
    value: function _createConnectionProvider(address, userAgent, authToken) {
      return new _connectionProviderRouting["default"]({
        id: this._id,
        address: address,
        routingContext: this._routingContext,
        hostNameResolver: createHostNameResolver(this._config),
        config: this._config,
        log: this._log,
        userAgent: userAgent,
        authToken: authToken
      });
    }
  }, {
    key: "_supportsRouting",
    value: function _supportsRouting() {
      return true;
    }
  }]);
  return RoutingDriver;
}(_driver.Driver);
/**
 * @private
 * @returns {ConfiguredCustomResolver} new custom resolver that wraps the passed-in resolver function.
 *              If resolved function is not specified, it defaults to an identity resolver.
 */


function createHostNameResolver(config) {
  return new _configuredCustomResolver["default"](config.resolver);
}
/**
 * @private
 * @returns {Object} the given config.
 */


function validateConfig(config) {
  var resolver = config.resolver;

  if (resolver && typeof resolver !== 'function') {
    throw new TypeError("Configured resolver should be a function. Got: ".concat(resolver));
  }

  return config;
}

var _default = RoutingDriver;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/session-rx.js":
/*!*****************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/session-rx.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");

var _resultRx = _interopRequireDefault(__webpack_require__(/*! ./result-rx */ "./node_modules/neo4j-driver/lib/result-rx.js"));

var _session = _interopRequireDefault(__webpack_require__(/*! ./session */ "./node_modules/neo4j-driver/lib/session.js"));

var _transactionRx = _interopRequireDefault(__webpack_require__(/*! ./transaction-rx */ "./node_modules/neo4j-driver/lib/transaction-rx.js"));

var _constants = __webpack_require__(/*! ./internal/constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

var _txConfig = _interopRequireDefault(__webpack_require__(/*! ./internal/tx-config */ "./node_modules/neo4j-driver/lib/internal/tx-config.js"));

var _retryLogicRx = _interopRequireDefault(__webpack_require__(/*! ./internal/retry-logic-rx */ "./node_modules/neo4j-driver/lib/internal/retry-logic-rx.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A Reactive session, which provides the same functionality as {@link Session} but through a Reactive API.
 */
var RxSession = /*#__PURE__*/function () {
  /**
   * Constructs a reactive session with given default session instance and provided driver configuration.
   *
   * @protected
   * @param {Object} param - Object parameter
   * @param {Session} param.session - The underlying session instance to relay requests
   */
  function RxSession() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        session = _ref.session,
        config = _ref.config;

    (0, _classCallCheck2["default"])(this, RxSession);
    this._session = session;
    this._retryLogic = _createRetryLogic(config);
  }
  /**
   * Creates a reactive result that will execute the  query with the provided parameters and the provided
   * transaction configuration that applies to the underlying auto-commit transaction.
   *
   * @public
   * @param {string} query - Query to be executed.
   * @param {Object} parameters - Parameter values to use in query execution.
   * @param {TransactionConfig} transactionConfig - Configuration for the new auto-commit transaction.
   * @returns {RxResult} - A reactive result
   */


  (0, _createClass2["default"])(RxSession, [{
    key: "run",
    value: function run(query, parameters, transactionConfig) {
      var _this = this;

      return new _resultRx["default"](new _rxjs.Observable(function (observer) {
        try {
          observer.next(_this._session.run(query, parameters, transactionConfig));
          observer.complete();
        } catch (err) {
          observer.error(err);
        }

        return function () {};
      }));
    }
    /**
     * Starts a new explicit transaction with the provided transaction configuration.
     *
     * @public
     * @param {TransactionConfig} transactionConfig - Configuration for the new transaction.
     * @returns {Observable<RxTransaction>} - A reactive stream that will generate at most **one** RxTransaction instance.
     */

  }, {
    key: "beginTransaction",
    value: function beginTransaction(transactionConfig) {
      return this._beginTransaction(this._session._mode, transactionConfig);
    }
    /**
     * Executes the provided unit of work in a {@link READ} reactive transaction which is created with the provided
     * transaction configuration.
     * @public
     * @param {function(txc: RxTransaction): Observable} work - A unit of work to be executed.
     * @param {TransactionConfig} transactionConfig - Configuration for the enclosing transaction created by the driver.
     * @returns {Observable} - A reactive stream returned by the unit of work.
     */

  }, {
    key: "readTransaction",
    value: function readTransaction(work, transactionConfig) {
      return this._runTransaction(_constants.ACCESS_MODE_READ, work, transactionConfig);
    }
    /**
     * Executes the provided unit of work in a {@link WRITE} reactive transaction which is created with the provided
     * transaction configuration.
     * @public
     * @param {function(txc: RxTransaction): Observable} work - A unit of work to be executed.
     * @param {TransactionConfig} transactionConfig - Configuration for the enclosing transaction created by the driver.
     * @returns {Observable} - A reactive stream returned by the unit of work.
     */

  }, {
    key: "writeTransaction",
    value: function writeTransaction(work, transactionConfig) {
      return this._runTransaction(_constants.ACCESS_MODE_WRITE, work, transactionConfig);
    }
    /**
     * Closes this reactive session.
     *
     * @public
     * @returns {Observable} - An empty reactive stream
     */

  }, {
    key: "close",
    value: function close() {
      var _this2 = this;

      return new _rxjs.Observable(function (observer) {
        _this2._session.close().then(function () {
          observer.complete();
        })["catch"](function (err) {
          return observer.error(err);
        });
      });
    }
    /**
     * Returns the bookmark received following the last successfully completed query, which is executed
     * either in an {@link RxTransaction} obtained from this session instance or directly through one of
     * the {@link RxSession#run} method of this session instance.
     *
     * If no bookmark was received or if this transaction was rolled back, the bookmark value will not be
     * changed.
     *
     * @public
     * @returns {string}
     */

  }, {
    key: "lastBookmark",
    value: function lastBookmark() {
      return this._session.lastBookmark();
    }
    /**
     * @private
     */

  }, {
    key: "_beginTransaction",
    value: function _beginTransaction(accessMode, transactionConfig) {
      var _this3 = this;

      var txConfig = _txConfig["default"].empty();

      if (transactionConfig) {
        txConfig = new _txConfig["default"](transactionConfig);
      }

      return new _rxjs.Observable(function (observer) {
        try {
          observer.next(new _transactionRx["default"](_this3._session._beginTransaction(accessMode, txConfig)));
          observer.complete();
        } catch (err) {
          observer.error(err);
        }

        return function () {};
      });
    }
    /**
     * @private
     */

  }, {
    key: "_runTransaction",
    value: function _runTransaction(accessMode, work, transactionConfig) {
      var txConfig = _txConfig["default"].empty();

      if (transactionConfig) {
        txConfig = new _txConfig["default"](transactionConfig);
      }

      return this._retryLogic.retry(this._beginTransaction(accessMode, transactionConfig).pipe((0, _operators.flatMap)(function (txc) {
        return (0, _rxjs.defer)(function () {
          try {
            return work(txc);
          } catch (err) {
            return (0, _rxjs.throwError)(err);
          }
        }).pipe((0, _operators.catchError)(function (err) {
          return txc.rollback().pipe((0, _operators.concat)((0, _rxjs.throwError)(err)));
        }), (0, _operators.concat)(txc.commit()));
      })));
    }
  }]);
  return RxSession;
}();

exports["default"] = RxSession;

function _createRetryLogic(config) {
  var maxRetryTimeout = config && config.maxTransactionRetryTime ? config.maxTransactionRetryTime : null;
  return new _retryLogicRx["default"]({
    maxRetryTimeout: maxRetryTimeout
  });
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/session.js":
/*!**************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/session.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _streamObservers = __webpack_require__(/*! ./internal/stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

var _result = _interopRequireDefault(__webpack_require__(/*! ./result */ "./node_modules/neo4j-driver/lib/result.js"));

var _transaction = _interopRequireDefault(__webpack_require__(/*! ./transaction */ "./node_modules/neo4j-driver/lib/transaction.js"));

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

var _util = __webpack_require__(/*! ./internal/util */ "./node_modules/neo4j-driver/lib/internal/util.js");

var _connectionHolder = _interopRequireDefault(__webpack_require__(/*! ./internal/connection-holder */ "./node_modules/neo4j-driver/lib/internal/connection-holder.js"));

var _driver = _interopRequireDefault(__webpack_require__(/*! ./driver */ "./node_modules/neo4j-driver/lib/driver.js"));

var _constants = __webpack_require__(/*! ./internal/constants */ "./node_modules/neo4j-driver/lib/internal/constants.js");

var _transactionExecutor = _interopRequireDefault(__webpack_require__(/*! ./internal/transaction-executor */ "./node_modules/neo4j-driver/lib/internal/transaction-executor.js"));

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./internal/bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

var _txConfig = _interopRequireDefault(__webpack_require__(/*! ./internal/tx-config */ "./node_modules/neo4j-driver/lib/internal/tx-config.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A Session instance is used for handling the connection and
 * sending queries through the connection.
 * In a single session, multiple queries will be executed serially.
 * In order to execute parallel queries, multiple sessions are required.
 * @access public
 */
var Session = /*#__PURE__*/function () {
  /**
   * @constructor
   * @protected
   * @param {Object} args
   * @param {string} args.mode the default access mode for this session.
   * @param {ConnectionProvider} args.connectionProvider - The connection provider to acquire connections from.
   * @param {Bookmark} args.bookmark - The initial bookmark for this session.
   * @param {string} args.database the database name
   * @param {Object} args.config={} - This driver configuration.
   * @param {boolean} args.reactive - Whether this session should create reactive streams
   * @param {number} args.fetchSize - Defines how many records is pulled in each pulling batch
   */
  function Session(_ref) {
    var mode = _ref.mode,
        connectionProvider = _ref.connectionProvider,
        bookmark = _ref.bookmark,
        database = _ref.database,
        config = _ref.config,
        reactive = _ref.reactive,
        fetchSize = _ref.fetchSize;
    (0, _classCallCheck2["default"])(this, Session);
    this._mode = mode;
    this._database = database;
    this._reactive = reactive;
    this._fetchSize = fetchSize;
    this._readConnectionHolder = new _connectionHolder["default"]({
      mode: _constants.ACCESS_MODE_READ,
      database: database,
      bookmark: bookmark,
      connectionProvider: connectionProvider
    });
    this._writeConnectionHolder = new _connectionHolder["default"]({
      mode: _constants.ACCESS_MODE_WRITE,
      database: database,
      bookmark: bookmark,
      connectionProvider: connectionProvider
    });
    this._open = true;
    this._hasTx = false;
    this._lastBookmark = bookmark;
    this._transactionExecutor = _createTransactionExecutor(config);
    this._onComplete = this._onCompleteCallback.bind(this);
  }
  /**
   * Run Cypher query
   * Could be called with a query object i.e.: `{text: "MATCH ...", prameters: {param: 1}}`
   * or with the query and parameters as separate arguments.
   *
   * @public
   * @param {mixed} query - Cypher query to execute
   * @param {Object} parameters - Map with parameters to use in query
   * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.
   * @return {Result} New Result.
   */


  (0, _createClass2["default"])(Session, [{
    key: "run",
    value: function run(query, parameters, transactionConfig) {
      var _this = this;

      var _validateQueryAndPara = (0, _util.validateQueryAndParameters)(query, parameters),
          validatedQuery = _validateQueryAndPara.validatedQuery,
          params = _validateQueryAndPara.params;

      var autoCommitTxConfig = transactionConfig ? new _txConfig["default"](transactionConfig) : _txConfig["default"].empty();
      return this._run(validatedQuery, params, function (connection) {
        _this._assertSessionIsOpen();

        return connection.protocol().run(validatedQuery, params, {
          bookmark: _this._lastBookmark,
          txConfig: autoCommitTxConfig,
          mode: _this._mode,
          database: _this._database,
          afterComplete: _this._onComplete,
          reactive: _this._reactive,
          fetchSize: _this._fetchSize
        });
      });
    }
  }, {
    key: "_run",
    value: function _run(query, parameters, customRunner) {
      var connectionHolder = this._connectionHolderWithMode(this._mode);

      var observerPromise;

      if (!this._open) {
        observerPromise = Promise.resolve(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot run query in a closed session.')
        }));
      } else if (!this._hasTx && connectionHolder.initializeConnection()) {
        observerPromise = connectionHolder.getConnection().then(function (connection) {
          return customRunner(connection);
        })["catch"](function (error) {
          return Promise.resolve(new _streamObservers.FailedObserver({
            error: error
          }));
        });
      } else {
        observerPromise = Promise.resolve(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Queries cannot be run directly on a ' + 'session with an open transaction; either run from within the ' + 'transaction or use a different session.')
        }));
      }

      return new _result["default"](observerPromise, query, parameters, connectionHolder);
    }
    /**
     * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you
     * want to run multiple concurrent transactions, you should use multiple concurrent sessions.
     *
     * While a transaction is open the session cannot be used to run queries outside the transaction.
     *
     * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.
     * @returns {Transaction} New Transaction.
     */

  }, {
    key: "beginTransaction",
    value: function beginTransaction(transactionConfig) {
      // this function needs to support bookmarks parameter for backwards compatibility
      // parameter was of type {string|string[]} and represented either a single or multiple bookmarks
      // that's why we need to check parameter type and decide how to interpret the value
      var arg = transactionConfig;

      var txConfig = _txConfig["default"].empty();

      if (arg) {
        txConfig = new _txConfig["default"](arg);
      }

      return this._beginTransaction(this._mode, txConfig);
    }
  }, {
    key: "_beginTransaction",
    value: function _beginTransaction(accessMode, txConfig) {
      if (!this._open) {
        throw (0, _error.newError)('Cannot begin a transaction on a closed session.');
      }

      if (this._hasTx) {
        throw (0, _error.newError)('You cannot begin a transaction on a session with an open transaction; ' + 'either run from within the transaction or use a different session.');
      }

      var mode = _driver["default"]._validateSessionMode(accessMode);

      var connectionHolder = this._connectionHolderWithMode(mode);

      connectionHolder.initializeConnection();
      this._hasTx = true;
      var tx = new _transaction["default"]({
        connectionHolder: connectionHolder,
        onClose: this._transactionClosed.bind(this),
        onBookmark: this._updateBookmark.bind(this),
        onConnection: this._assertSessionIsOpen.bind(this),
        reactive: this._reactive,
        fetchSize: this._fetchSize
      });

      tx._begin(this._lastBookmark, txConfig);

      return tx;
    }
  }, {
    key: "_assertSessionIsOpen",
    value: function _assertSessionIsOpen() {
      if (!this._open) {
        throw (0, _error.newError)('You cannot run more transactions on a closed session.');
      }
    }
  }, {
    key: "_transactionClosed",
    value: function _transactionClosed() {
      this._hasTx = false;
    }
    /**
     * Return the bookmark received following the last completed {@link Transaction}.
     *
     * @return {string[]} A reference to a previous transaction.
     */

  }, {
    key: "lastBookmark",
    value: function lastBookmark() {
      return this._lastBookmark.values();
    }
    /**
     * Execute given unit of work in a {@link READ} transaction.
     *
     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.
     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial
     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's
     * `maxTransactionRetryTime` property in milliseconds.
     *
     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against
     * a given {@link Transaction}.
     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.
     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given
     * function or commit fails.
     */

  }, {
    key: "readTransaction",
    value: function readTransaction(transactionWork, transactionConfig) {
      var config = new _txConfig["default"](transactionConfig);
      return this._runTransaction(_constants.ACCESS_MODE_READ, config, transactionWork);
    }
    /**
     * Execute given unit of work in a {@link WRITE} transaction.
     *
     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.
     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial
     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's
     * `maxTransactionRetryTime` property in milliseconds.
     *
     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against
     * a given {@link Transaction}.
     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.
     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given
     * function or commit fails.
     */

  }, {
    key: "writeTransaction",
    value: function writeTransaction(transactionWork, transactionConfig) {
      var config = new _txConfig["default"](transactionConfig);
      return this._runTransaction(_constants.ACCESS_MODE_WRITE, config, transactionWork);
    }
  }, {
    key: "_runTransaction",
    value: function _runTransaction(accessMode, transactionConfig, transactionWork) {
      var _this2 = this;

      return this._transactionExecutor.execute(function () {
        return _this2._beginTransaction(accessMode, transactionConfig);
      }, transactionWork);
    }
    /**
     * Update value of the last bookmark.
     * @param {Bookmark} newBookmark - The new bookmark.
     */

  }, {
    key: "_updateBookmark",
    value: function _updateBookmark(newBookmark) {
      if (newBookmark && !newBookmark.isEmpty()) {
        this._lastBookmark = newBookmark;
      }
    }
    /**
     * Close this session.
     * @return {Promise}
     */

  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._open) {
                  _context.next = 7;
                  break;
                }

                this._open = false;

                this._transactionExecutor.close();

                _context.next = 5;
                return this._readConnectionHolder.close();

              case 5:
                _context.next = 7;
                return this._writeConnectionHolder.close();

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "_connectionHolderWithMode",
    value: function _connectionHolderWithMode(mode) {
      if (mode === _constants.ACCESS_MODE_READ) {
        return this._readConnectionHolder;
      } else if (mode === _constants.ACCESS_MODE_WRITE) {
        return this._writeConnectionHolder;
      } else {
        throw (0, _error.newError)('Unknown access mode: ' + mode);
      }
    }
  }, {
    key: "_onCompleteCallback",
    value: function _onCompleteCallback(meta) {
      this._updateBookmark(new _bookmark["default"](meta.bookmark));
    }
  }]);
  return Session;
}();

function _createTransactionExecutor(config) {
  var maxRetryTimeMs = config && config.maxTransactionRetryTime ? config.maxTransactionRetryTime : null;
  return new _transactionExecutor["default"](maxRetryTimeMs);
}

var _default = Session;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/spatial-types.js":
/*!********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/spatial-types.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPoint = isPoint;
exports.Point = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _util = __webpack_require__(/*! ./internal/util */ "./node_modules/neo4j-driver/lib/internal/util.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var POINT_IDENTIFIER_PROPERTY = '__isPoint__';
/**
 * Represents a single two or three-dimensional point in a particular coordinate reference system.
 * Created `Point` objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */

var Point = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Integer|number} srid - The coordinate reference system identifier.
   * @param {number} x - The `x` coordinate of the point.
   * @param {number} y - The `y` coordinate of the point.
   * @param {number} [z=undefined] - The `z` coordinate of the point or `undefined` if point has 2 dimensions.
   */
  function Point(srid, x, y, z) {
    (0, _classCallCheck2["default"])(this, Point);

    /**
     * The coordinate reference system identifier.
     * @type {Integer|number}
     */
    this.srid = (0, _util.assertNumberOrInteger)(srid, 'SRID');
    /**
     * The `x` coordinate of the point.
     * @type {number}
     */

    this.x = (0, _util.assertNumber)(x, 'X coordinate');
    /**
     * The `y` coordinate of the point.
     * @type {number}
     */

    this.y = (0, _util.assertNumber)(y, 'Y coordinate');
    /**
     * The `z` coordinate of the point or `undefined` if point is 2-dimensional.
     * @type {number}
     */

    this.z = z === null || z === undefined ? z : (0, _util.assertNumber)(z, 'Z coordinate');
    Object.freeze(this);
  }
  /**
   * @ignore
   */


  (0, _createClass2["default"])(Point, [{
    key: "toString",
    value: function toString() {
      return this.z || this.z === 0 ? "Point{srid=".concat(formatAsFloat(this.srid), ", x=").concat(formatAsFloat(this.x), ", y=").concat(formatAsFloat(this.y), ", z=").concat(formatAsFloat(this.z), "}") : "Point{srid=".concat(formatAsFloat(this.srid), ", x=").concat(formatAsFloat(this.x), ", y=").concat(formatAsFloat(this.y), "}");
    }
  }]);
  return Point;
}();

exports.Point = Point;

function formatAsFloat(number) {
  return Number.isInteger(number) ? number + '.0' : number.toString();
}

Object.defineProperty(Point.prototype, POINT_IDENTIFIER_PROPERTY, {
  value: true,
  enumerable: false,
  configurable: false,
  writable: false
});
/**
 * Test if given object is an instance of {@link Point} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Point}, `false` otherwise.
 */

function isPoint(obj) {
  return (obj && obj[POINT_IDENTIFIER_PROPERTY]) === true;
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/temporal-types.js":
/*!*********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/temporal-types.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDuration = isDuration;
exports.isLocalTime = isLocalTime;
exports.isTime = isTime;
exports.isDate = isDate;
exports.isLocalDateTime = isLocalDateTime;
exports.isDateTime = isDateTime;
exports.DateTime = exports.LocalDateTime = exports.Date = exports.Time = exports.LocalTime = exports.Duration = void 0;

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var util = _interopRequireWildcard(__webpack_require__(/*! ./internal/temporal-util */ "./node_modules/neo4j-driver/lib/internal/temporal-util.js"));

var _util = __webpack_require__(/*! ./internal/util */ "./node_modules/neo4j-driver/lib/internal/util.js");

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var IDENTIFIER_PROPERTY_ATTRIBUTES = {
  value: true,
  enumerable: false,
  configurable: false,
  writable: false
};
var DURATION_IDENTIFIER_PROPERTY = '__isDuration__';
var LOCAL_TIME_IDENTIFIER_PROPERTY = '__isLocalTime__';
var TIME_IDENTIFIER_PROPERTY = '__isTime__';
var DATE_IDENTIFIER_PROPERTY = '__isDate__';
var LOCAL_DATE_TIME_IDENTIFIER_PROPERTY = '__isLocalDateTime__';
var DATE_TIME_IDENTIFIER_PROPERTY = '__isDateTime__';
/**
 * Represents an ISO 8601 duration. Contains both date-based values (years, months, days) and time-based values (seconds, nanoseconds).
 * Created `Duration` objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */

var Duration = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Integer|number} months - The number of months for the new duration.
   * @param {Integer|number} days - The number of days for the new duration.
   * @param {Integer|number} seconds - The number of seconds for the new duration.
   * @param {Integer|number} nanoseconds - The number of nanoseconds for the new duration.
   */
  function Duration(months, days, seconds, nanoseconds) {
    (0, _classCallCheck2["default"])(this, Duration);

    /**
     * The number of months.
     * @type {Integer|number}
     */
    this.months = (0, _util.assertNumberOrInteger)(months, 'Months');
    /**
     * The number of days.
     * @type {Integer|number}
     */

    this.days = (0, _util.assertNumberOrInteger)(days, 'Days');
    (0, _util.assertNumberOrInteger)(seconds, 'Seconds');
    (0, _util.assertNumberOrInteger)(nanoseconds, 'Nanoseconds');
    /**
     * The number of seconds.
     * @type {Integer|number}
     */

    this.seconds = util.normalizeSecondsForDuration(seconds, nanoseconds);
    /**
     * The number of nanoseconds.
     * @type {Integer|number}
     */

    this.nanoseconds = util.normalizeNanosecondsForDuration(nanoseconds);
    Object.freeze(this);
  }
  /**
   * @ignore
   */


  (0, _createClass2["default"])(Duration, [{
    key: "toString",
    value: function toString() {
      return util.durationToIsoString(this.months, this.days, this.seconds, this.nanoseconds);
    }
  }]);
  return Duration;
}();

exports.Duration = Duration;
Object.defineProperty(Duration.prototype, DURATION_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Duration} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Duration}, `false` otherwise.
 */

function isDuration(obj) {
  return hasIdentifierProperty(obj, DURATION_IDENTIFIER_PROPERTY);
}
/**
 * Represents an instant capturing the time of day, but not the date, nor the timezone.
 * Created {@link LocalTime} objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */


var LocalTime = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Integer|number} hour - The hour for the new local time.
   * @param {Integer|number} minute - The minute for the new local time.
   * @param {Integer|number} second - The second for the new local time.
   * @param {Integer|number} nanosecond - The nanosecond for the new local time.
   */
  function LocalTime(hour, minute, second, nanosecond) {
    (0, _classCallCheck2["default"])(this, LocalTime);

    /**
     * The hour.
     * @type {Integer|number}
     */
    this.hour = util.assertValidHour(hour);
    /**
     * The minute.
     * @type {Integer|number}
     */

    this.minute = util.assertValidMinute(minute);
    /**
     * The second.
     * @type {Integer|number}
     */

    this.second = util.assertValidSecond(second);
    /**
     * The nanosecond.
     * @type {Integer|number}
     */

    this.nanosecond = util.assertValidNanosecond(nanosecond);
    Object.freeze(this);
  }
  /**
   * Create a {@link LocalTime} object from the given standard JavaScript `Date` and optional nanoseconds.
   * Year, month, day and time zone offset components of the given date are ignored.
   * @param {global.Date} standardDate - The standard JavaScript date to convert.
   * @param {Integer|number|undefined} nanosecond - The optional amount of nanoseconds.
   * @return {LocalTime} New LocalTime.
   */


  (0, _createClass2["default"])(LocalTime, [{
    key: "toString",

    /**
     * @ignore
     */
    value: function toString() {
      return util.timeToIsoString(this.hour, this.minute, this.second, this.nanosecond);
    }
  }], [{
    key: "fromStandardDate",
    value: function fromStandardDate(standardDate, nanosecond) {
      verifyStandardDateAndNanos(standardDate, nanosecond);
      return new LocalTime(standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), util.totalNanoseconds(standardDate, nanosecond));
    }
  }]);
  return LocalTime;
}();

exports.LocalTime = LocalTime;
Object.defineProperty(LocalTime.prototype, LOCAL_TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link LocalTime} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link LocalTime}, `false` otherwise.
 */

function isLocalTime(obj) {
  return hasIdentifierProperty(obj, LOCAL_TIME_IDENTIFIER_PROPERTY);
}
/**
 * Represents an instant capturing the time of day, and the timezone offset in seconds, but not the date.
 * Created {@link Time} objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */


var Time = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Integer|number} hour - The hour for the new local time.
   * @param {Integer|number} minute - The minute for the new local time.
   * @param {Integer|number} second - The second for the new local time.
   * @param {Integer|number} nanosecond - The nanosecond for the new local time.
   * @param {Integer|number} timeZoneOffsetSeconds - The time zone offset in seconds. Value represents the difference, in seconds, from UTC to local time.
   * This is different from standard JavaScript `Date.getTimezoneOffset()` which is the difference, in minutes, from local time to UTC.
   */
  function Time(hour, minute, second, nanosecond, timeZoneOffsetSeconds) {
    (0, _classCallCheck2["default"])(this, Time);

    /**
     * The hour.
     * @type {Integer|number}
     */
    this.hour = util.assertValidHour(hour);
    /**
     * The minute.
     * @type {Integer|number}
     */

    this.minute = util.assertValidMinute(minute);
    /**
     * The second.
     * @type {Integer|number}
     */

    this.second = util.assertValidSecond(second);
    /**
     * The nanosecond.
     * @type {Integer|number}
     */

    this.nanosecond = util.assertValidNanosecond(nanosecond);
    /**
     * The time zone offset in seconds.
     * @type {Integer|number}
     */

    this.timeZoneOffsetSeconds = (0, _util.assertNumberOrInteger)(timeZoneOffsetSeconds, 'Time zone offset in seconds');
    Object.freeze(this);
  }
  /**
   * Create a {@link Time} object from the given standard JavaScript `Date` and optional nanoseconds.
   * Year, month and day components of the given date are ignored.
   * @param {global.Date} standardDate - The standard JavaScript date to convert.
   * @param {Integer|number|undefined} nanosecond - The optional amount of nanoseconds.
   * @return {Time} New Time.
   */


  (0, _createClass2["default"])(Time, [{
    key: "toString",

    /**
     * @ignore
     */
    value: function toString() {
      return util.timeToIsoString(this.hour, this.minute, this.second, this.nanosecond) + util.timeZoneOffsetToIsoString(this.timeZoneOffsetSeconds);
    }
  }], [{
    key: "fromStandardDate",
    value: function fromStandardDate(standardDate, nanosecond) {
      verifyStandardDateAndNanos(standardDate, nanosecond);
      return new Time(standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), util.totalNanoseconds(standardDate, nanosecond), util.timeZoneOffsetInSeconds(standardDate));
    }
  }]);
  return Time;
}();

exports.Time = Time;
Object.defineProperty(Time.prototype, TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Time} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Time}, `false` otherwise.
 */

function isTime(obj) {
  return hasIdentifierProperty(obj, TIME_IDENTIFIER_PROPERTY);
}
/**
 * Represents an instant capturing the date, but not the time, nor the timezone.
 * Created {@link Date} objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */


var Date = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Integer|number} year - The year for the new local date.
   * @param {Integer|number} month - The month for the new local date.
   * @param {Integer|number} day - The day for the new local date.
   */
  function Date(year, month, day) {
    (0, _classCallCheck2["default"])(this, Date);

    /**
     * The year.
     * @type {Integer|number}
     */
    this.year = util.assertValidYear(year);
    /**
     * The month.
     * @type {Integer|number}
     */

    this.month = util.assertValidMonth(month);
    /**
     * The day.
     * @type {Integer|number}
     */

    this.day = util.assertValidDay(day);
    Object.freeze(this);
  }
  /**
   * Create a {@link Date} object from the given standard JavaScript `Date`.
   * Hour, minute, second, millisecond and time zone offset components of the given date are ignored.
   * @param {global.Date} standardDate - The standard JavaScript date to convert.
   * @return {Date} New Date.
   */


  (0, _createClass2["default"])(Date, [{
    key: "toString",

    /**
     * @ignore
     */
    value: function toString() {
      return util.dateToIsoString(this.year, this.month, this.day);
    }
  }], [{
    key: "fromStandardDate",
    value: function fromStandardDate(standardDate) {
      verifyStandardDateAndNanos(standardDate, null);
      return new Date(standardDate.getFullYear(), standardDate.getMonth() + 1, standardDate.getDate());
    }
  }]);
  return Date;
}();

exports.Date = Date;
Object.defineProperty(Date.prototype, DATE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Date} class.
 * @param {Object} obj - The object to test.
 * @return {boolean} `true` if given object is a {@link Date}, `false` otherwise.
 */

function isDate(obj) {
  return hasIdentifierProperty(obj, DATE_IDENTIFIER_PROPERTY);
}
/**
 * Represents an instant capturing the date and the time, but not the timezone.
 * Created {@link LocalDateTime} objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */


var LocalDateTime = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Integer|number} year - The year for the new local date.
   * @param {Integer|number} month - The month for the new local date.
   * @param {Integer|number} day - The day for the new local date.
   * @param {Integer|number} hour - The hour for the new local time.
   * @param {Integer|number} minute - The minute for the new local time.
   * @param {Integer|number} second - The second for the new local time.
   * @param {Integer|number} nanosecond - The nanosecond for the new local time.
   */
  function LocalDateTime(year, month, day, hour, minute, second, nanosecond) {
    (0, _classCallCheck2["default"])(this, LocalDateTime);

    /**
     * The year.
     * @type {Integer|number}
     */
    this.year = util.assertValidYear(year);
    /**
     * The month.
     * @type {Integer|number}
     */

    this.month = util.assertValidMonth(month);
    /**
     * The day.
     * @type {Integer|number}
     */

    this.day = util.assertValidDay(day);
    /**
     * The hour.
     * @type {Integer|number}
     */

    this.hour = util.assertValidHour(hour);
    /**
     * The minute.
     * @type {Integer|number}
     */

    this.minute = util.assertValidMinute(minute);
    /**
     * The second.
     * @type {Integer|number}
     */

    this.second = util.assertValidSecond(second);
    /**
     * The nanosecond.
     * @type {Integer|number}
     */

    this.nanosecond = util.assertValidNanosecond(nanosecond);
    Object.freeze(this);
  }
  /**
   * Create a {@link LocalDateTime} object from the given standard JavaScript `Date` and optional nanoseconds.
   * Time zone offset component of the given date is ignored.
   * @param {global.Date} standardDate - The standard JavaScript date to convert.
   * @param {Integer|number|undefined} nanosecond - The optional amount of nanoseconds.
   * @return {LocalDateTime} New LocalDateTime.
   */


  (0, _createClass2["default"])(LocalDateTime, [{
    key: "toString",

    /**
     * @ignore
     */
    value: function toString() {
      return localDateTimeToString(this.year, this.month, this.day, this.hour, this.minute, this.second, this.nanosecond);
    }
  }], [{
    key: "fromStandardDate",
    value: function fromStandardDate(standardDate, nanosecond) {
      verifyStandardDateAndNanos(standardDate, nanosecond);
      return new LocalDateTime(standardDate.getFullYear(), standardDate.getMonth() + 1, standardDate.getDate(), standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), util.totalNanoseconds(standardDate, nanosecond));
    }
  }]);
  return LocalDateTime;
}();

exports.LocalDateTime = LocalDateTime;
Object.defineProperty(LocalDateTime.prototype, LOCAL_DATE_TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link LocalDateTime} class.
 * @param {Object} obj - The object to test.
 * @return {boolean} `true` if given object is a {@link LocalDateTime}, `false` otherwise.
 */

function isLocalDateTime(obj) {
  return hasIdentifierProperty(obj, LOCAL_DATE_TIME_IDENTIFIER_PROPERTY);
}
/**
 * Represents an instant capturing the date, the time and the timezone identifier.
 * Created {@ DateTime} objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */


var DateTime = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Integer|number} year - The year for the new date-time.
   * @param {Integer|number} month - The month for the new date-time.
   * @param {Integer|number} day - The day for the new date-time.
   * @param {Integer|number} hour - The hour for the new date-time.
   * @param {Integer|number} minute - The minute for the new date-time.
   * @param {Integer|number} second - The second for the new date-time.
   * @param {Integer|number} nanosecond - The nanosecond for the new date-time.
   * @param {Integer|number} timeZoneOffsetSeconds - The time zone offset in seconds. Either this argument or `timeZoneId` should be defined.
   * Value represents the difference, in seconds, from UTC to local time.
   * This is different from standard JavaScript `Date.getTimezoneOffset()` which is the difference, in minutes, from local time to UTC.
   * @param {string|null} timeZoneId - The time zone id for the new date-time. Either this argument or `timeZoneOffsetSeconds` should be defined.
   */
  function DateTime(year, month, day, hour, minute, second, nanosecond, timeZoneOffsetSeconds, timeZoneId) {
    (0, _classCallCheck2["default"])(this, DateTime);

    /**
     * The year.
     * @type {Integer|number}
     */
    this.year = util.assertValidYear(year);
    /**
     * The month.
     * @type {Integer|number}
     */

    this.month = util.assertValidMonth(month);
    /**
     * The day.
     * @type {Integer|number}
     */

    this.day = util.assertValidDay(day);
    /**
     * The hour.
     * @type {Integer|number}
     */

    this.hour = util.assertValidHour(hour);
    /**
     * The minute.
     * @type {Integer|number}
     */

    this.minute = util.assertValidMinute(minute);
    /**
     * The second.
     * @type {Integer|number}
     */

    this.second = util.assertValidSecond(second);
    /**
     * The nanosecond.
     * @type {Integer|number}
     */

    this.nanosecond = util.assertValidNanosecond(nanosecond);

    var _verifyTimeZoneArgume = verifyTimeZoneArguments(timeZoneOffsetSeconds, timeZoneId),
        _verifyTimeZoneArgume2 = (0, _slicedToArray2["default"])(_verifyTimeZoneArgume, 2),
        offset = _verifyTimeZoneArgume2[0],
        id = _verifyTimeZoneArgume2[1];
    /**
     * The time zone offset in seconds.
     *
     * *Either this or {@link timeZoneId} is defined.*
     *
     * @type {Integer|number}
     */


    this.timeZoneOffsetSeconds = offset;
    /**
     * The time zone id.
     *
     * *Either this or {@link timeZoneOffsetSeconds} is defined.*
     *
     * @type {string}
     */

    this.timeZoneId = id;
    Object.freeze(this);
  }
  /**
   * Create a {@link DateTime} object from the given standard JavaScript `Date` and optional nanoseconds.
   * @param {global.Date} standardDate - The standard JavaScript date to convert.
   * @param {Integer|number|undefined} nanosecond - The optional amount of nanoseconds.
   * @return {DateTime} New DateTime.
   */


  (0, _createClass2["default"])(DateTime, [{
    key: "toString",

    /**
     * @ignore
     */
    value: function toString() {
      var localDateTimeStr = localDateTimeToString(this.year, this.month, this.day, this.hour, this.minute, this.second, this.nanosecond);
      var timeZoneStr = this.timeZoneId ? "[".concat(this.timeZoneId, "]") : util.timeZoneOffsetToIsoString(this.timeZoneOffsetSeconds);
      return localDateTimeStr + timeZoneStr;
    }
  }], [{
    key: "fromStandardDate",
    value: function fromStandardDate(standardDate, nanosecond) {
      verifyStandardDateAndNanos(standardDate, nanosecond);
      return new DateTime(standardDate.getFullYear(), standardDate.getMonth() + 1, standardDate.getDate(), standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), util.totalNanoseconds(standardDate, nanosecond), util.timeZoneOffsetInSeconds(standardDate), null
      /* no time zone id */
      );
    }
  }]);
  return DateTime;
}();

exports.DateTime = DateTime;
Object.defineProperty(DateTime.prototype, DATE_TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link DateTime} class.
 * @param {Object} obj - The object to test.
 * @return {boolean} `true` if given object is a {@link DateTime}, `false` otherwise.
 */

function isDateTime(obj) {
  return hasIdentifierProperty(obj, DATE_TIME_IDENTIFIER_PROPERTY);
}

function hasIdentifierProperty(obj, property) {
  return (obj && obj[property]) === true;
}

function localDateTimeToString(year, month, day, hour, minute, second, nanosecond) {
  return util.dateToIsoString(year, month, day) + 'T' + util.timeToIsoString(hour, minute, second, nanosecond);
}

function verifyTimeZoneArguments(timeZoneOffsetSeconds, timeZoneId) {
  var offsetDefined = timeZoneOffsetSeconds || timeZoneOffsetSeconds === 0;
  var idDefined = timeZoneId && timeZoneId !== '';

  if (offsetDefined && !idDefined) {
    (0, _util.assertNumberOrInteger)(timeZoneOffsetSeconds, 'Time zone offset in seconds');
    return [timeZoneOffsetSeconds, null];
  } else if (!offsetDefined && idDefined) {
    (0, _util.assertString)(timeZoneId, 'Time zone ID');
    return [null, timeZoneId];
  } else if (offsetDefined && idDefined) {
    throw (0, _error.newError)("Unable to create DateTime with both time zone offset and id. Please specify either of them. Given offset: ".concat(timeZoneOffsetSeconds, " and id: ").concat(timeZoneId));
  } else {
    throw (0, _error.newError)("Unable to create DateTime without either time zone offset or id. Please specify either of them. Given offset: ".concat(timeZoneOffsetSeconds, " and id: ").concat(timeZoneId));
  }
}

function verifyStandardDateAndNanos(standardDate, nanosecond) {
  (0, _util.assertValidDate)(standardDate, 'Standard date');

  if (nanosecond !== null && nanosecond !== undefined) {
    (0, _util.assertNumberOrInteger)(nanosecond, 'Nanosecond');
  }
}

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/transaction-rx.js":
/*!*********************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/transaction-rx.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");

var _resultRx = _interopRequireDefault(__webpack_require__(/*! ./result-rx */ "./node_modules/neo4j-driver/lib/result-rx.js"));

var _transaction = _interopRequireDefault(__webpack_require__(/*! ./transaction */ "./node_modules/neo4j-driver/lib/transaction.js"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A reactive transaction, which provides the same functionality as {@link Transaction} but through a Reactive API.
 */
var RxTransaction = /*#__PURE__*/function () {
  /**
   * @constructor
   * @protected
   * @param {Transaction} txc - The underlying transaction instance to relay requests
   */
  function RxTransaction(txc) {
    (0, _classCallCheck2["default"])(this, RxTransaction);
    this._txc = txc;
  }
  /**
   * Creates a reactive result that will execute the query in this transaction, with the provided parameters.
   *
   * @public
   * @param {string} query - Query to be executed.
   * @param {Object} parameters - Parameter values to use in query execution.
   * @returns {RxResult} - A reactive result
   */


  (0, _createClass2["default"])(RxTransaction, [{
    key: "run",
    value: function run(query, parameters) {
      var _this = this;

      return new _resultRx["default"](new _rxjs.Observable(function (observer) {
        try {
          observer.next(_this._txc.run(query, parameters));
          observer.complete();
        } catch (err) {
          observer.error(err);
        }

        return function () {};
      }));
    }
    /**
     *  Commits the transaction.
     *
     * @public
     * @returns {Observable} - An empty observable
     */

  }, {
    key: "commit",
    value: function commit() {
      var _this2 = this;

      return new _rxjs.Observable(function (observer) {
        _this2._txc.commit().then(function () {
          observer.complete();
        })["catch"](function (err) {
          return observer.error(err);
        });
      });
    }
    /**
     *  Rolls back the transaction.
     *
     * @public
     * @returns {Observable} - An empty observable
     */

  }, {
    key: "rollback",
    value: function rollback() {
      var _this3 = this;

      return new _rxjs.Observable(function (observer) {
        _this3._txc.rollback().then(function () {
          observer.complete();
        })["catch"](function (err) {
          return observer.error(err);
        });
      });
    }
  }]);
  return RxTransaction;
}();

exports["default"] = RxTransaction;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/transaction.js":
/*!******************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/transaction.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _result = _interopRequireDefault(__webpack_require__(/*! ./result */ "./node_modules/neo4j-driver/lib/result.js"));

var _util = __webpack_require__(/*! ./internal/util */ "./node_modules/neo4j-driver/lib/internal/util.js");

var _connectionHolder = _interopRequireWildcard(__webpack_require__(/*! ./internal/connection-holder */ "./node_modules/neo4j-driver/lib/internal/connection-holder.js"));

var _bookmark = _interopRequireDefault(__webpack_require__(/*! ./internal/bookmark */ "./node_modules/neo4j-driver/lib/internal/bookmark.js"));

var _txConfig = _interopRequireDefault(__webpack_require__(/*! ./internal/tx-config */ "./node_modules/neo4j-driver/lib/internal/tx-config.js"));

var _streamObservers = __webpack_require__(/*! ./internal/stream-observers */ "./node_modules/neo4j-driver/lib/internal/stream-observers.js");

var _error = __webpack_require__(/*! ./error */ "./node_modules/neo4j-driver/lib/error.js");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Represents a transaction in the Neo4j database.
 *
 * @access public
 */
var Transaction = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {ConnectionHolder} connectionHolder - the connection holder to get connection from.
   * @param {function()} onClose - Function to be called when transaction is committed or rolled back.
   * @param {function(bookmark: Bookmark)} onBookmark callback invoked when new bookmark is produced.
   * * @param {function()} onConnection - Function to be called when a connection is obtained to ensure the conneciton
   * is not yet released.
   * @param {boolean} reactive whether this transaction generates reactive streams
   * @param {number} fetchSize - the record fetch size in each pulling batch.
   */
  function Transaction(_ref) {
    var connectionHolder = _ref.connectionHolder,
        onClose = _ref.onClose,
        onBookmark = _ref.onBookmark,
        onConnection = _ref.onConnection,
        reactive = _ref.reactive,
        fetchSize = _ref.fetchSize;
    (0, _classCallCheck2["default"])(this, Transaction);
    this._connectionHolder = connectionHolder;
    this._reactive = reactive;
    this._state = _states.ACTIVE;
    this._onClose = onClose;
    this._onBookmark = onBookmark;
    this._onConnection = onConnection;
    this._onError = this._onErrorCallback.bind(this);
    this._onComplete = this._onCompleteCallback.bind(this);
    this._fetchSize = fetchSize;
    this._results = [];
  }

  (0, _createClass2["default"])(Transaction, [{
    key: "_begin",
    value: function _begin(bookmark, txConfig) {
      var _this = this;

      this._connectionHolder.getConnection().then(function (conn) {
        _this._onConnection();

        return conn.protocol().beginTransaction({
          bookmark: bookmark,
          txConfig: txConfig,
          mode: _this._connectionHolder.mode(),
          database: _this._connectionHolder.database(),
          beforeError: _this._onError,
          afterComplete: _this._onComplete
        });
      })["catch"](function (error) {
        return _this._onError(error);
      });
    }
    /**
     * Run Cypher query
     * Could be called with a query object i.e.: `{text: "MATCH ...", parameters: {param: 1}}`
     * or with the query and parameters as separate arguments.
     * @param {mixed} query - Cypher query to execute
     * @param {Object} parameters - Map with parameters to use in query
     * @return {Result} New Result
     */

  }, {
    key: "run",
    value: function run(query, parameters) {
      var _validateQueryAndPara = (0, _util.validateQueryAndParameters)(query, parameters),
          validatedQuery = _validateQueryAndPara.validatedQuery,
          params = _validateQueryAndPara.params;

      var result = this._state.run(validatedQuery, params, {
        connectionHolder: this._connectionHolder,
        onError: this._onError,
        onComplete: this._onComplete,
        onConnection: this._onConnection,
        reactive: this._reactive,
        fetchSize: this._fetchSize
      });

      this._results.push(result);

      return result;
    }
    /**
     * Commits the transaction and returns the result.
     *
     * After committing the transaction can no longer be used.
     *
     * @returns {Promise<void>} An empty promise if committed successfully or error if any error happened during commit.
     */

  }, {
    key: "commit",
    value: function commit() {
      var committed = this._state.commit({
        connectionHolder: this._connectionHolder,
        onError: this._onError,
        onComplete: this._onComplete,
        onConnection: this._onConnection,
        pendingResults: this._results
      });

      this._state = committed.state; // clean up

      this._onClose();

      return new Promise(function (resolve, reject) {
        committed.result.subscribe({
          onCompleted: function onCompleted() {
            return resolve();
          },
          onError: function onError(error) {
            return reject(error);
          }
        });
      });
    }
    /**
     * Rollbacks the transaction.
     *
     * After rolling back, the transaction can no longer be used.
     *
     * @returns {Promise<void>} An empty promise if rolled back successfully or error if any error happened during
     * rollback.
     */

  }, {
    key: "rollback",
    value: function rollback() {
      var rolledback = this._state.rollback({
        connectionHolder: this._connectionHolder,
        onError: this._onError,
        onComplete: this._onComplete,
        onConnection: this._onConnection,
        pendingResults: this._results
      });

      this._state = rolledback.state; // clean up

      this._onClose();

      return new Promise(function (resolve, reject) {
        rolledback.result.subscribe({
          onCompleted: function onCompleted() {
            return resolve();
          },
          onError: function onError(error) {
            return reject(error);
          }
        });
      });
    }
    /**
     * Check if this transaction is active, which means commit and rollback did not happen.
     * @return {boolean} `true` when not committed and not rolled back, `false` otherwise.
     */

  }, {
    key: "isOpen",
    value: function isOpen() {
      return this._state === _states.ACTIVE;
    }
  }, {
    key: "_onErrorCallback",
    value: function _onErrorCallback(err) {
      // error will be "acknowledged" by sending a RESET message
      // database will then forget about this transaction and cleanup all corresponding resources
      // it is thus safe to move this transaction to a FAILED state and disallow any further interactions with it
      this._state = _states.FAILED;

      this._onClose(); // release connection back to the pool


      return this._connectionHolder.releaseConnection();
    }
  }, {
    key: "_onCompleteCallback",
    value: function _onCompleteCallback(meta) {
      this._onBookmark(new _bookmark["default"](meta.bookmark));
    }
  }]);
  return Transaction;
}();

var _states = {
  // The transaction is running with no explicit success or failure marked
  ACTIVE: {
    commit: function commit(_ref2) {
      var connectionHolder = _ref2.connectionHolder,
          onError = _ref2.onError,
          onComplete = _ref2.onComplete,
          onConnection = _ref2.onConnection,
          pendingResults = _ref2.pendingResults;
      return {
        result: finishTransaction(true, connectionHolder, onError, onComplete, onConnection, pendingResults),
        state: _states.SUCCEEDED
      };
    },
    rollback: function rollback(_ref3) {
      var connectionHolder = _ref3.connectionHolder,
          onError = _ref3.onError,
          onComplete = _ref3.onComplete,
          onConnection = _ref3.onConnection,
          pendingResults = _ref3.pendingResults;
      return {
        result: finishTransaction(false, connectionHolder, onError, onComplete, onConnection, pendingResults),
        state: _states.ROLLED_BACK
      };
    },
    run: function run(query, parameters, _ref4) {
      var connectionHolder = _ref4.connectionHolder,
          onError = _ref4.onError,
          onComplete = _ref4.onComplete,
          onConnection = _ref4.onConnection,
          reactive = _ref4.reactive,
          fetchSize = _ref4.fetchSize;
      // RUN in explicit transaction can't contain bookmarks and transaction configuration
      // No need to include mode and database name as it shall be inclued in begin
      var observerPromise = connectionHolder.getConnection().then(function (conn) {
        onConnection();
        return conn.protocol().run(query, parameters, {
          bookmark: _bookmark["default"].empty(),
          txConfig: _txConfig["default"].empty(),
          beforeError: onError,
          afterComplete: onComplete,
          reactive: reactive,
          fetchSize: fetchSize
        });
      })["catch"](function (error) {
        return new _streamObservers.FailedObserver({
          error: error,
          onError: onError
        });
      });
      return newCompletedResult(observerPromise, query, parameters);
    }
  },
  // An error has occurred, transaction can no longer be used and no more messages will
  // be sent for this transaction.
  FAILED: {
    commit: function commit(_ref5) {
      var connectionHolder = _ref5.connectionHolder,
          onError = _ref5.onError,
          onComplete = _ref5.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot commit this transaction, because it has been rolled back either because of an error or explicit termination.'),
          onError: onError
        }), 'COMMIT', {}),
        state: _states.FAILED
      };
    },
    rollback: function rollback(_ref6) {
      var connectionHolder = _ref6.connectionHolder,
          onError = _ref6.onError,
          onComplete = _ref6.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.CompletedObserver(), 'ROLLBACK', {}),
        state: _states.FAILED
      };
    },
    run: function run(query, parameters, _ref7) {
      var connectionHolder = _ref7.connectionHolder,
          onError = _ref7.onError,
          onComplete = _ref7.onComplete;
      return newCompletedResult(new _streamObservers.FailedObserver({
        error: (0, _error.newError)('Cannot run query in this transaction, because it has been rolled back either because of an error or explicit termination.'),
        onError: onError
      }), query, parameters);
    }
  },
  // This transaction has successfully committed
  SUCCEEDED: {
    commit: function commit(_ref8) {
      var connectionHolder = _ref8.connectionHolder,
          onError = _ref8.onError,
          onComplete = _ref8.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot commit this transaction, because it has already been committed.'),
          onError: onError
        }), 'COMMIT', {}),
        state: _states.SUCCEEDED
      };
    },
    rollback: function rollback(_ref9) {
      var connectionHolder = _ref9.connectionHolder,
          onError = _ref9.onError,
          onComplete = _ref9.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot rollback this transaction, because it has already been committed.'),
          onError: onError
        }), 'ROLLBACK', {}),
        state: _states.SUCCEEDED
      };
    },
    run: function run(query, parameters, _ref10) {
      var connectionHolder = _ref10.connectionHolder,
          onError = _ref10.onError,
          onComplete = _ref10.onComplete;
      return newCompletedResult(new _streamObservers.FailedObserver({
        error: (0, _error.newError)('Cannot run query in this transaction, because it has already been committed.'),
        onError: onError
      }), query, parameters);
    }
  },
  // This transaction has been rolled back
  ROLLED_BACK: {
    commit: function commit(_ref11) {
      var connectionHolder = _ref11.connectionHolder,
          onError = _ref11.onError,
          onComplete = _ref11.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot commit this transaction, because it has already been rolled back.'),
          onError: onError
        }), 'COMMIT', {}),
        state: _states.ROLLED_BACK
      };
    },
    rollback: function rollback(_ref12) {
      var connectionHolder = _ref12.connectionHolder,
          onError = _ref12.onError,
          onComplete = _ref12.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot rollback this transaction, because it has already been rolled back.')
        }), 'ROLLBACK', {}),
        state: _states.ROLLED_BACK
      };
    },
    run: function run(query, parameters, _ref13) {
      var connectionHolder = _ref13.connectionHolder,
          onError = _ref13.onError,
          onComplete = _ref13.onComplete;
      return newCompletedResult(new _streamObservers.FailedObserver({
        error: (0, _error.newError)('Cannot run query in this transaction, because it has already been rolled back.'),
        onError: onError
      }), query, parameters);
    }
  }
};
/**
 *
 * @param {boolean} commit
 * @param {ConnectionHolder} connectionHolder
 * @param {function(err:Error): any} onError
 * @param {function(metadata:object): any} onComplete
 * @param {function() : any} onConnection
 * @param {list<Result>>}pendingResults all run results in this transaction
 */

function finishTransaction(commit, connectionHolder, onError, onComplete, onConnection, pendingResults) {
  var observerPromise = connectionHolder.getConnection().then(function (connection) {
    onConnection();
    pendingResults.forEach(function (r) {
      return r._cancel();
    });
    return Promise.all(pendingResults).then(function (results) {
      if (commit) {
        return connection.protocol().commitTransaction({
          beforeError: onError,
          afterComplete: onComplete
        });
      } else {
        return connection.protocol().rollbackTransaction({
          beforeError: onError,
          afterComplete: onComplete
        });
      }
    });
  })["catch"](function (error) {
    return new _streamObservers.FailedObserver({
      error: error,
      onError: onError
    });
  }); // for commit & rollback we need result that uses real connection holder and notifies it when
  // connection is not needed and can be safely released to the pool

  return new _result["default"](observerPromise, commit ? 'COMMIT' : 'ROLLBACK', {}, connectionHolder);
}
/**
 * Creates a {@link Result} with empty connection holder.
 * For cases when result represents an intermediate or failed action, does not require any metadata and does not
 * need to influence real connection holder to release connections.
 * @param {ResultStreamObserver} observer - an observer for the created result.
 * @param {string} query - the cypher query that produced the result.
 * @param {Object} parameters - the parameters for cypher query that produced the result.
 * @return {Result} new result.
 * @private
 */


function newCompletedResult(observerPromise, query, parameters) {
  return new _result["default"](Promise.resolve(observerPromise), query, parameters, _connectionHolder.EMPTY_CONNECTION_HOLDER);
}

var _default = Transaction;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/neo4j-driver/lib/version.js":
/*!**************************************************!*\
  !*** ./node_modules/neo4j-driver/lib/version.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// DO NOT CHANGE THE VERSION BELOW HERE
// This is set by the build system at release time, using
//   gulp set --version <releaseversion>
//
// This is set up this way to keep the version in the code in
// sync with the npm package version, and to allow the build
// system to control version names at packaging time.
var _default = '0.0.0-dev';
exports["default"] = _default;

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9kcml2ZXIuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvZXJyb3IuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvZ3JhcGgtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZWdlci5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9ib2x0LXByb3RvY29sLXV0aWwuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvYm9sdC1wcm90b2NvbC12MS5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9ib2x0LXByb3RvY29sLXYyLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL2JvbHQtcHJvdG9jb2wtdjMuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvYm9sdC1wcm90b2NvbC12NHgwLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL2JvbHQtcHJvdG9jb2wtdjR4MS5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9ib29rbWFyay5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9icm93c2VyL2Jyb3dzZXItYnVmLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL2Jyb3dzZXIvYnJvd3Nlci1jaGFubmVsLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL2Jyb3dzZXIvYnJvd3Nlci1ob3N0LW5hbWUtcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvYnJvd3Nlci9icm93c2VyLXV0ZjguanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvYnJvd3Nlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9idWYvYmFzZS1idWYuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvYnVmL2NvbWJpbmVkLWJ1Zi5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9jaGFubmVsLWNvbmZpZy5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9jaHVua2luZy5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9jb25uZWN0aW9uLWNoYW5uZWwuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvY29ubmVjdGlvbi1kZWxlZ2F0ZS5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9jb25uZWN0aW9uLWVycm9yLWhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvY29ubmVjdGlvbi1ob2xkZXIuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvY29ubmVjdGlvbi1wcm92aWRlci1kaXJlY3QuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvY29ubmVjdGlvbi1wcm92aWRlci1wb29sZWQuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvY29ubmVjdGlvbi1wcm92aWRlci1yb3V0aW5nLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL2Nvbm5lY3Rpb24tcHJvdmlkZXItc2luZ2xlLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL2Nvbm5lY3Rpb24tcHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvY29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9jb25uZWN0aXZpdHktdmVyaWZpZXIuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvY29uc3RhbnRzLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL2xlYXN0LWNvbm5lY3RlZC1sb2FkLWJhbGFuY2luZy1zdHJhdGVneS5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9sb2FkLWJhbGFuY2luZy1zdHJhdGVneS5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9sb2dnZXIuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvcGFja3N0cmVhbS12MS5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9wYWNrc3RyZWFtLXYyLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL3Bvb2wtY29uZmlnLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL3Bvb2wuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvcHJvdG9jb2wtaGFuZHNoYWtlci5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9yZWRpc2NvdmVyeS5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9yZXF1ZXN0LW1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvcmVzb2x2ZXIvYmFzZS1ob3N0LW5hbWUtcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvcmVzb2x2ZXIvY29uZmlndXJlZC1jdXN0b20tcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvcmV0cnktbG9naWMtcnguanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvcm91bmQtcm9iaW4tYXJyYXktaW5kZXguanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvcm91dGluZy10YWJsZS5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC9yb3V0aW5nLXV0aWwuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvc2VydmVyLWFkZHJlc3MuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvc2VydmVyLXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvaW50ZXJuYWwvc3RyZWFtLW9ic2VydmVycy5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC90ZW1wb3JhbC11dGlsLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL3RyYW5zYWN0aW9uLWV4ZWN1dG9yLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL2ludGVybmFsL3R4LWNvbmZpZy5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC91cmwtdXRpbC5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9pbnRlcm5hbC91dGlsLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL3JlY29yZC5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9yZXN1bHQtcnguanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvcmVzdWx0LXN1bW1hcnkuanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvcmVzdWx0LmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL3JvdXRpbmctZHJpdmVyLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL3Nlc3Npb24tcnguanMiLCJ3ZWJwYWNrOi8vTmVvNGpWaXN1YWxpemF0aW9uLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci9saWIvc2Vzc2lvbi5qcyIsIndlYnBhY2s6Ly9OZW80alZpc3VhbGl6YXRpb24vLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyL2xpYi9zcGF0aWFsLXR5cGVzLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL3RlbXBvcmFsLXR5cGVzLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL3RyYW5zYWN0aW9uLXJ4LmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL3RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovL05lbzRqVmlzdWFsaXphdGlvbi8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXIvbGliL3ZlcnNpb24uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLG9IQUE4Qzs7QUFFbkY7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSw4Q0FBOEMsbUJBQU8sQ0FBQyxzR0FBdUM7O0FBRTdG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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsaUJBQWlCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FB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QTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYLDBDQUEwQzs7O0FBRzFDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRTs7QUFFbkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFD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QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxH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bkY7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEI7Ozs7Ozs7Ozs7OztBQ2pjYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QiIsImZpbGUiOiJuZW80ai1kcml2ZXIuaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4cG9ydHMuV1JJVEUgPSBleHBvcnRzLlJFQUQgPSBleHBvcnRzLkRyaXZlciA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuXG52YXIgX2Nvbm5lY3Rpb25Qcm92aWRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW50ZXJuYWwvY29ubmVjdGlvbi1wcm92aWRlclwiKSk7XG5cbnZhciBfYm9va21hcmsgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL2Jvb2ttYXJrXCIpKTtcblxudmFyIF9jb25uZWN0aW9uUHJvdmlkZXJEaXJlY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL2Nvbm5lY3Rpb24tcHJvdmlkZXItZGlyZWN0XCIpKTtcblxudmFyIF9jb25uZWN0aXZpdHlWZXJpZmllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW50ZXJuYWwvY29ubmVjdGl2aXR5LXZlcmlmaWVyXCIpKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9jb25zdGFudHNcIik7XG5cbnZhciBfbG9nZ2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC9sb2dnZXJcIikpO1xuXG52YXIgX3Bvb2xDb25maWcgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9wb29sLWNvbmZpZ1wiKTtcblxudmFyIF9zZXNzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zZXNzaW9uXCIpKTtcblxudmFyIF9zZXNzaW9uUnggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Nlc3Npb24tcnhcIikpO1xuXG52YXIgX3JlcXVlc3RNZXNzYWdlID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvcmVxdWVzdC1tZXNzYWdlXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC91dGlsXCIpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBERUZBVUxUX01BWF9DT05ORUNUSU9OX0xJRkVUSU1FID0gNjAgKiA2MCAqIDEwMDA7IC8vIDEgaG91clxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHJlY29yZCBmZXRjaCBzaXplLiBUaGlzIGlzIHVzZWQgaW4gQm9sdCBWNCBwcm90b2NvbCB0byBwdWxsIHF1ZXJ5IGV4ZWN1dGlvbiByZXN1bHQgaW4gYmF0Y2hlcy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cblxudmFyIERFRkFVTFRfRkVUQ0hfU0laRSA9IDEwMDA7XG4vKipcbiAqIENvbnN0YW50IHRoYXQgcmVwcmVzZW50cyByZWFkIHNlc3Npb24gYWNjZXNzIG1vZGUuXG4gKiBTaG91bGQgYmUgdXNlZCBsaWtlIHRoaXM6IGBkcml2ZXIuc2Vzc2lvbih7IGRlZmF1bHRBY2Nlc3NNb2RlOiBuZW80ai5zZXNzaW9uLlJFQUQgfSlgLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuXG52YXIgUkVBRCA9IF9jb25zdGFudHMuQUNDRVNTX01PREVfUkVBRDtcbi8qKlxuICogQ29uc3RhbnQgdGhhdCByZXByZXNlbnRzIHdyaXRlIHNlc3Npb24gYWNjZXNzIG1vZGUuXG4gKiBTaG91bGQgYmUgdXNlZCBsaWtlIHRoaXM6IGBkcml2ZXIuc2Vzc2lvbih7IGRlZmF1bHRBY2Nlc3NNb2RlOiBuZW80ai5zZXNzaW9uLldSSVRFIH0pYC5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblxuZXhwb3J0cy5SRUFEID0gUkVBRDtcbnZhciBXUklURSA9IF9jb25zdGFudHMuQUNDRVNTX01PREVfV1JJVEU7XG5leHBvcnRzLldSSVRFID0gV1JJVEU7XG52YXIgaWRHZW5lcmF0b3IgPSAwO1xuLyoqXG4gKiBBIGRyaXZlciBtYWludGFpbnMgb25lIG9yIG1vcmUge0BsaW5rIFNlc3Npb259cyB3aXRoIGEgcmVtb3RlXG4gKiBOZW80aiBpbnN0YW5jZS4gVGhyb3VnaCB0aGUge0BsaW5rIFNlc3Npb259cyB5b3UgY2FuIHNlbmQgcXVlcmllc1xuICogYW5kIHJldHJpZXZlIHJlc3VsdHMgZnJvbSB0aGUgZGF0YWJhc2UuXG4gKlxuICogRHJpdmVycyBhcmUgcmVhc29uYWJseSBleHBlbnNpdmUgdG8gY3JlYXRlIC0geW91IHNob3VsZCBzdHJpdmUgdG8ga2VlcCBvbmVcbiAqIGRyaXZlciBpbnN0YW5jZSBhcm91bmQgcGVyIE5lbzRqIEluc3RhbmNlIHlvdSBjb25uZWN0IHRvLlxuICpcbiAqIEBhY2Nlc3MgcHVibGljXG4gKi9cblxudmFyIERyaXZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBZb3Ugc2hvdWxkIG5vdCBiZSBjYWxsaW5nIHRoaXMgZGlyZWN0bHksIGluc3RlYWQgdXNlIHtAbGluayBkcml2ZXJ9LlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge1NlcnZlckFkZHJlc3N9IGFkZHJlc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJBZ2VudFxuICAgKiBAcGFyYW0ge09iamVjdH0gYXV0aFRva2VuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICovXG4gIGZ1bmN0aW9uIERyaXZlcihhZGRyZXNzLCB1c2VyQWdlbnQpIHtcbiAgICB2YXIgYXV0aFRva2VuID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIERyaXZlcik7XG4gICAgc2FuaXRpemVDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9pZCA9IGlkR2VuZXJhdG9yKys7XG4gICAgdGhpcy5fYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgdGhpcy5fdXNlckFnZW50ID0gdXNlckFnZW50O1xuICAgIHRoaXMuX2F1dGhUb2tlbiA9IGF1dGhUb2tlbjtcbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5fbG9nID0gX2xvZ2dlcltcImRlZmF1bHRcIl0uY3JlYXRlKGNvbmZpZyk7XG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBjb25uZWN0aW9uIHByb3ZpZGVyLiBJbml0aWFsaXplZCBsYXppbHkgYnkge0BsaW5rIF9nZXRPckNyZWF0ZUNvbm5lY3Rpb25Qcm92aWRlcn0uXG4gICAgICogQHR5cGUge0Nvbm5lY3Rpb25Qcm92aWRlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG5cbiAgICB0aGlzLl9jb25uZWN0aW9uUHJvdmlkZXIgPSBudWxsO1xuXG4gICAgdGhpcy5fYWZ0ZXJDb25zdHJ1Y3Rpb24oKTtcbiAgfVxuICAvKipcbiAgICogVmVyaWZpZXMgY29ubmVjdGl2aXR5IG9mIHRoaXMgZHJpdmVyIGJ5IHRyeWluZyB0byBvcGVuIGEgY29ubmVjdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBkcml2ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gLSBUaGUgb2JqZWN0IHBhcmFtZXRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0uZGF0YWJhc2UgLSBUaGUgdGFyZ2V0IGRhdGFiYXNlIHRvIHZlcmlmeSBjb25uZWN0aXZpdHkgZm9yLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gcHJvbWlzZSByZXNvbHZlZCB3aXRoIHNlcnZlciBpbmZvIG9yIHJlamVjdGVkIHdpdGggZXJyb3IuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShEcml2ZXIsIFt7XG4gICAga2V5OiBcInZlcmlmeUNvbm5lY3Rpdml0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnlDb25uZWN0aXZpdHkoKSB7XG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgX3JlZiRkYXRhYmFzZSA9IF9yZWYuZGF0YWJhc2UsXG4gICAgICAgICAgZGF0YWJhc2UgPSBfcmVmJGRhdGFiYXNlID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkZGF0YWJhc2U7XG5cbiAgICAgIHZhciBjb25uZWN0aW9uUHJvdmlkZXIgPSB0aGlzLl9nZXRPckNyZWF0ZUNvbm5lY3Rpb25Qcm92aWRlcigpO1xuXG4gICAgICB2YXIgY29ubmVjdGl2aXR5VmVyaWZpZXIgPSBuZXcgX2Nvbm5lY3Rpdml0eVZlcmlmaWVyW1wiZGVmYXVsdFwiXShjb25uZWN0aW9uUHJvdmlkZXIpO1xuICAgICAgcmV0dXJuIGNvbm5lY3Rpdml0eVZlcmlmaWVyLnZlcmlmeSh7XG4gICAgICAgIGRhdGFiYXNlOiBkYXRhYmFzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgc2VydmVyIHN1cHBvcnRzIG11bHRpIGRhdGFiYXNlIGNhcGFiaWxpdGllcyBiYXNlZCBvbiB0aGUgcHJvdG9jb2xcbiAgICAgKiB2ZXJzaW9uIG5lZ290aWF0ZWQgdmlhIGhhbmRzaGFrZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGNhbGwgX2Fsd2F5c18gY2F1c2VzIGEgcm91bmQtdHJpcCB0byB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHByb21pc2UgcmVzb2x2ZWQgd2l0aCBhIGJvb2xlYW4gb3IgcmVqZWN0ZWQgd2l0aCBlcnJvci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN1cHBvcnRzTXVsdGlEYlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdXBwb3J0c011bHRpRGIoKSB7XG4gICAgICB2YXIgY29ubmVjdGlvblByb3ZpZGVyID0gdGhpcy5fZ2V0T3JDcmVhdGVDb25uZWN0aW9uUHJvdmlkZXIoKTtcblxuICAgICAgcmV0dXJuIGNvbm5lY3Rpb25Qcm92aWRlci5zdXBwb3J0c011bHRpRGIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgdHJhbnNhY3Rpb24gY29uZmlnIGNhcGFiaWxpdGllcyBiYXNlZCBvbiB0aGUgcHJvdG9jb2xcbiAgICAgKiB2ZXJzaW9uIG5lZ290aWF0ZWQgdmlhIGhhbmRzaGFrZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGNhbGwgX2Fsd2F5c18gY2F1c2VzIGEgcm91bmQtdHJpcCB0byB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHByb21pc2UgcmVzb2x2ZWQgd2l0aCBhIGJvb2xlYW4gb3IgcmVqZWN0ZWQgd2l0aCBlcnJvci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN1cHBvcnRzVHJhbnNhY3Rpb25Db25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VwcG9ydHNUcmFuc2FjdGlvbkNvbmZpZygpIHtcbiAgICAgIHZhciBjb25uZWN0aW9uUHJvdmlkZXIgPSB0aGlzLl9nZXRPckNyZWF0ZUNvbm5lY3Rpb25Qcm92aWRlcigpO1xuXG4gICAgICByZXR1cm4gY29ubmVjdGlvblByb3ZpZGVyLnN1cHBvcnRzVHJhbnNhY3Rpb25Db25maWcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N1cHBvcnRzUm91dGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3VwcG9ydHNSb3V0aW5nKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGJvb2xlYW4gdG8gaW5kaWNhdGUgaWYgZHJpdmVyIGhhcyBiZWVuIGNvbmZpZ3VyZWQgd2l0aCBlbmNyeXB0aW9uIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaXNFbmNyeXB0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzRW5jcnlwdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5lbmNyeXB0ZWQgPT09IF91dGlsLkVOQ1JZUFRJT05fT047XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmZpZ3VyZWQgdHJ1c3Qgc3RyYXRlZ3kgdGhhdCB0aGUgZHJpdmVyIGhhcyBiZWVuIGNvbmZpZ3VyZWQgd2l0aC5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7VHJ1c3RTdHJhdGVneX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRUcnVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VHJ1c3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uZmlnLnRydXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3F1aXJlIGEgc2Vzc2lvbiB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBkYXRhYmFzZS4gVGhlIHNlc3Npb24gd2lsbFxuICAgICAqIGJvcnJvdyBjb25uZWN0aW9ucyBmcm9tIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24gcG9vbCBhcyByZXF1aXJlZCBhbmRcbiAgICAgKiBzaG91bGQgYmUgY29uc2lkZXJlZCBsaWdodHdlaWdodCBhbmQgZGlzcG9zYWJsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgY29tZXMgd2l0aCBzb21lIHJlc3BvbnNpYmlsaXR5IC0gbWFrZSBzdXJlIHlvdSBhbHdheXMgY2FsbFxuICAgICAqIHtAbGluayBjbG9zZX0gd2hlbiB5b3UgYXJlIGRvbmUgdXNpbmcgYSBzZXNzaW9uLCBhbmQgbGlrZXdpc2UsXG4gICAgICogbWFrZSBzdXJlIHlvdSBkb24ndCBjbG9zZSB5b3VyIHNlc3Npb24gYmVmb3JlIHlvdSBhcmUgZG9uZSB1c2luZyBpdC4gT25jZVxuICAgICAqIGl0IGlzIGNsb3NlZCwgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbiB3aWxsIGJlIHJlbGVhc2VkIHRvIHRoZSBjb25uZWN0aW9uXG4gICAgICogcG9vbCBhbmQgbWFkZSBhdmFpbGFibGUgZm9yIG90aGVycyB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIC0gVGhlIG9iamVjdCBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0uZGVmYXVsdEFjY2Vzc01vZGU9V1JJVEUgLSBUaGUgYWNjZXNzIG1vZGUgb2YgdGhpcyBzZXNzaW9uLCBhbGxvd2VkIHZhbHVlcyBhcmUge0BsaW5rIFJFQUR9IGFuZCB7QGxpbmsgV1JJVEV9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXJhbS5ib29rbWFya3MgLSBUaGUgaW5pdGlhbCByZWZlcmVuY2Ugb3IgcmVmZXJlbmNlcyB0byBzb21lIHByZXZpb3VzXG4gICAgICogdHJhbnNhY3Rpb25zLiBWYWx1ZSBpcyBvcHRpb25hbCBhbmQgYWJzZW5jZSBpbmRpY2F0ZXMgdGhhdCB0aGF0IHRoZSBib29rbWFya3MgZG8gbm90IGV4aXN0IG9yIGFyZSB1bmtub3duLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbS5mZXRjaFNpemUgLSBUaGUgcmVjb3JkIGZldGNoIHNpemUgb2YgZWFjaCBiYXRjaCBvZiB0aGlzIHNlc3Npb24uXG4gICAgICogVXNlIHtAbGluayBBTEx9IHRvIGFsd2F5cyBwdWxsIGFsbCByZWNvcmRzIGluIG9uZSBiYXRjaC4gVGhpcyB3aWxsIG92ZXJyaWRlIHRoZSBjb25maWcgdmFsdWUgc2V0IG9uIGRyaXZlciBjb25maWcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtLmRhdGFiYXNlIC0gVGhlIGRhdGFiYXNlIHRoaXMgc2Vzc2lvbiB3aWxsIG9wZXJhdGUgb24uXG4gICAgICogQHJldHVybiB7U2Vzc2lvbn0gbmV3IHNlc3Npb24uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXNzaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlc3Npb24oKSB7XG4gICAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIF9yZWYyJGRlZmF1bHRBY2Nlc3NNbyA9IF9yZWYyLmRlZmF1bHRBY2Nlc3NNb2RlLFxuICAgICAgICAgIGRlZmF1bHRBY2Nlc3NNb2RlID0gX3JlZjIkZGVmYXVsdEFjY2Vzc01vID09PSB2b2lkIDAgPyBXUklURSA6IF9yZWYyJGRlZmF1bHRBY2Nlc3NNbyxcbiAgICAgICAgICBib29rbWFya09yQm9va21hcmtzID0gX3JlZjIuYm9va21hcmtzLFxuICAgICAgICAgIF9yZWYyJGRhdGFiYXNlID0gX3JlZjIuZGF0YWJhc2UsXG4gICAgICAgICAgZGF0YWJhc2UgPSBfcmVmMiRkYXRhYmFzZSA9PT0gdm9pZCAwID8gJycgOiBfcmVmMiRkYXRhYmFzZSxcbiAgICAgICAgICBmZXRjaFNpemUgPSBfcmVmMi5mZXRjaFNpemU7XG5cbiAgICAgIHJldHVybiB0aGlzLl9uZXdTZXNzaW9uKHtcbiAgICAgICAgZGVmYXVsdEFjY2Vzc01vZGU6IGRlZmF1bHRBY2Nlc3NNb2RlLFxuICAgICAgICBib29rbWFya09yQm9va21hcmtzOiBib29rbWFya09yQm9va21hcmtzLFxuICAgICAgICBkYXRhYmFzZTogZGF0YWJhc2UsXG4gICAgICAgIHJlYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgZmV0Y2hTaXplOiB2YWxpZGF0ZUZldGNoU2l6ZVZhbHVlKGZldGNoU2l6ZSwgdGhpcy5fY29uZmlnLmZldGNoU2l6ZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3F1aXJlIGEgcmVhY3RpdmUgc2Vzc2lvbiB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBkYXRhYmFzZS4gVGhlIHNlc3Npb24gd2lsbFxuICAgICAqIGJvcnJvdyBjb25uZWN0aW9ucyBmcm9tIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24gcG9vbCBhcyByZXF1aXJlZCBhbmRcbiAgICAgKiBzaG91bGQgYmUgY29uc2lkZXJlZCBsaWdodHdlaWdodCBhbmQgZGlzcG9zYWJsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgY29tZXMgd2l0aCBzb21lIHJlc3BvbnNpYmlsaXR5IC0gbWFrZSBzdXJlIHlvdSBhbHdheXMgY2FsbFxuICAgICAqIHtAbGluayBjbG9zZX0gd2hlbiB5b3UgYXJlIGRvbmUgdXNpbmcgYSBzZXNzaW9uLCBhbmQgbGlrZXdpc2UsXG4gICAgICogbWFrZSBzdXJlIHlvdSBkb24ndCBjbG9zZSB5b3VyIHNlc3Npb24gYmVmb3JlIHlvdSBhcmUgZG9uZSB1c2luZyBpdC4gT25jZVxuICAgICAqIGl0IGlzIGNsb3NlZCwgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbiB3aWxsIGJlIHJlbGVhc2VkIHRvIHRoZSBjb25uZWN0aW9uXG4gICAgICogcG9vbCBhbmQgbWFkZSBhdmFpbGFibGUgZm9yIG90aGVycyB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtLmRlZmF1bHRBY2Nlc3NNb2RlPVdSSVRFIC0gVGhlIGFjY2VzcyBtb2RlIG9mIHRoaXMgc2Vzc2lvbiwgYWxsb3dlZCB2YWx1ZXMgYXJlIHtAbGluayBSRUFEfSBhbmQge0BsaW5rIFdSSVRFfS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGFyYW0uYm9va21hcmtzIC0gVGhlIGluaXRpYWwgcmVmZXJlbmNlIG9yIHJlZmVyZW5jZXMgdG8gc29tZSBwcmV2aW91cyB0cmFuc2FjdGlvbnMuIFZhbHVlIGlzIG9wdGlvbmFsIGFuZFxuICAgICAqIGFic2VuY2UgaW5kaWNhdGVzIHRoYXQgdGhlIGJvb2ttYXJrcyBkbyBub3QgZXhpc3Qgb3IgYXJlIHVua25vd24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtLmRhdGFiYXNlIC0gVGhlIGRhdGFiYXNlIHRoaXMgc2Vzc2lvbiB3aWxsIG9wZXJhdGUgb24uXG4gICAgICogQHJldHVybnMge1J4U2Vzc2lvbn0gbmV3IHJlYWN0aXZlIHNlc3Npb24uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyeFNlc3Npb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnhTZXNzaW9uKCkge1xuICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBfcmVmMyRkZWZhdWx0QWNjZXNzTW8gPSBfcmVmMy5kZWZhdWx0QWNjZXNzTW9kZSxcbiAgICAgICAgICBkZWZhdWx0QWNjZXNzTW9kZSA9IF9yZWYzJGRlZmF1bHRBY2Nlc3NNbyA9PT0gdm9pZCAwID8gV1JJVEUgOiBfcmVmMyRkZWZhdWx0QWNjZXNzTW8sXG4gICAgICAgICAgYm9va21hcmtzID0gX3JlZjMuYm9va21hcmtzLFxuICAgICAgICAgIF9yZWYzJGRhdGFiYXNlID0gX3JlZjMuZGF0YWJhc2UsXG4gICAgICAgICAgZGF0YWJhc2UgPSBfcmVmMyRkYXRhYmFzZSA9PT0gdm9pZCAwID8gJycgOiBfcmVmMyRkYXRhYmFzZSxcbiAgICAgICAgICBmZXRjaFNpemUgPSBfcmVmMy5mZXRjaFNpemU7XG5cbiAgICAgIHJldHVybiBuZXcgX3Nlc3Npb25SeFtcImRlZmF1bHRcIl0oe1xuICAgICAgICBzZXNzaW9uOiB0aGlzLl9uZXdTZXNzaW9uKHtcbiAgICAgICAgICBkZWZhdWx0QWNjZXNzTW9kZTogZGVmYXVsdEFjY2Vzc01vZGUsXG4gICAgICAgICAgYm9va21hcmtzOiBib29rbWFya3MsXG4gICAgICAgICAgZGF0YWJhc2U6IGRhdGFiYXNlLFxuICAgICAgICAgIHJlYWN0aXZlOiB0cnVlLFxuICAgICAgICAgIGZldGNoU2l6ZTogdmFsaWRhdGVGZXRjaFNpemVWYWx1ZShmZXRjaFNpemUsIHRoaXMuX2NvbmZpZy5mZXRjaFNpemUpXG4gICAgICAgIH0pLFxuICAgICAgICBjb25maWc6IHRoaXMuX2NvbmZpZ1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIGFsbCBvcGVuIHNlc3Npb25zIGFuZCBvdGhlciBhc3NvY2lhdGVkIHJlc291cmNlcy4gWW91IHNob3VsZFxuICAgICAqIG1ha2Ugc3VyZSB0byB1c2UgdGhpcyB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgZHJpdmVyIGluc3RhbmNlLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSBwcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRyaXZlciBpcyBjbG9zZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHRoaXMuX2xvZy5pbmZvKFwiRHJpdmVyIFwiLmNvbmNhdCh0aGlzLl9pZCwgXCIgY2xvc2luZ1wiKSk7XG5cbiAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9uUHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25Qcm92aWRlci5jbG9zZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hZnRlckNvbnN0cnVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWZ0ZXJDb25zdHJ1Y3Rpb24oKSB7XG4gICAgICB0aGlzLl9sb2cuaW5mbyhcIkRpcmVjdCBkcml2ZXIgXCIuY29uY2F0KHRoaXMuX2lkLCBcIiBjcmVhdGVkIGZvciBzZXJ2ZXIgYWRkcmVzcyBcIikuY29uY2F0KHRoaXMuX2FkZHJlc3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUNvbm5lY3Rpb25Qcm92aWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQ29ubmVjdGlvblByb3ZpZGVyKGFkZHJlc3MsIHVzZXJBZ2VudCwgYXV0aFRva2VuKSB7XG4gICAgICByZXR1cm4gbmV3IF9jb25uZWN0aW9uUHJvdmlkZXJEaXJlY3RbXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgICBjb25maWc6IHRoaXMuX2NvbmZpZyxcbiAgICAgICAgbG9nOiB0aGlzLl9sb2csXG4gICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgIHVzZXJBZ2VudDogdXNlckFnZW50LFxuICAgICAgICBhdXRoVG9rZW46IGF1dGhUb2tlblxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9uZXdTZXNzaW9uXCIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV3U2Vzc2lvbihfcmVmNCkge1xuICAgICAgdmFyIGRlZmF1bHRBY2Nlc3NNb2RlID0gX3JlZjQuZGVmYXVsdEFjY2Vzc01vZGUsXG4gICAgICAgICAgYm9va21hcmtPckJvb2ttYXJrcyA9IF9yZWY0LmJvb2ttYXJrT3JCb29rbWFya3MsXG4gICAgICAgICAgZGF0YWJhc2UgPSBfcmVmNC5kYXRhYmFzZSxcbiAgICAgICAgICByZWFjdGl2ZSA9IF9yZWY0LnJlYWN0aXZlLFxuICAgICAgICAgIGZldGNoU2l6ZSA9IF9yZWY0LmZldGNoU2l6ZTtcblxuICAgICAgdmFyIHNlc3Npb25Nb2RlID0gRHJpdmVyLl92YWxpZGF0ZVNlc3Npb25Nb2RlKGRlZmF1bHRBY2Nlc3NNb2RlKTtcblxuICAgICAgdmFyIGNvbm5lY3Rpb25Qcm92aWRlciA9IHRoaXMuX2dldE9yQ3JlYXRlQ29ubmVjdGlvblByb3ZpZGVyKCk7XG5cbiAgICAgIHZhciBib29rbWFyayA9IGJvb2ttYXJrT3JCb29rbWFya3MgPyBuZXcgX2Jvb2ttYXJrW1wiZGVmYXVsdFwiXShib29rbWFya09yQm9va21hcmtzKSA6IF9ib29rbWFya1tcImRlZmF1bHRcIl0uZW1wdHkoKTtcbiAgICAgIHJldHVybiBuZXcgX3Nlc3Npb25bXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgbW9kZTogc2Vzc2lvbk1vZGUsXG4gICAgICAgIGRhdGFiYXNlOiBkYXRhYmFzZSxcbiAgICAgICAgY29ubmVjdGlvblByb3ZpZGVyOiBjb25uZWN0aW9uUHJvdmlkZXIsXG4gICAgICAgIGJvb2ttYXJrOiBib29rbWFyayxcbiAgICAgICAgY29uZmlnOiB0aGlzLl9jb25maWcsXG4gICAgICAgIHJlYWN0aXZlOiByZWFjdGl2ZSxcbiAgICAgICAgZmV0Y2hTaXplOiBmZXRjaFNpemVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldE9yQ3JlYXRlQ29ubmVjdGlvblByb3ZpZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRPckNyZWF0ZUNvbm5lY3Rpb25Qcm92aWRlcigpIHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvblByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm92aWRlciA9IHRoaXMuX2NyZWF0ZUNvbm5lY3Rpb25Qcm92aWRlcih0aGlzLl9hZGRyZXNzLCB0aGlzLl91c2VyQWdlbnQsIHRoaXMuX2F1dGhUb2tlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUHJvdmlkZXI7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiX3ZhbGlkYXRlU2Vzc2lvbk1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZhbGlkYXRlU2Vzc2lvbk1vZGUocmF3TW9kZSkge1xuICAgICAgdmFyIG1vZGUgPSByYXdNb2RlIHx8IFdSSVRFO1xuXG4gICAgICBpZiAobW9kZSAhPT0gX2NvbnN0YW50cy5BQ0NFU1NfTU9ERV9SRUFEICYmIG1vZGUgIT09IF9jb25zdGFudHMuQUNDRVNTX01PREVfV1JJVEUpIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ0lsbGVnYWwgc2Vzc2lvbiBtb2RlICcgKyBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1vZGU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEcml2ZXI7XG59KCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5leHBvcnRzLkRyaXZlciA9IERyaXZlcjtcblxuZnVuY3Rpb24gc2FuaXRpemVDb25maWcoY29uZmlnKSB7XG4gIGNvbmZpZy5tYXhDb25uZWN0aW9uTGlmZXRpbWUgPSBzYW5pdGl6ZUludFZhbHVlKGNvbmZpZy5tYXhDb25uZWN0aW9uTGlmZXRpbWUsIERFRkFVTFRfTUFYX0NPTk5FQ1RJT05fTElGRVRJTUUpO1xuICBjb25maWcubWF4Q29ubmVjdGlvblBvb2xTaXplID0gc2FuaXRpemVJbnRWYWx1ZShjb25maWcubWF4Q29ubmVjdGlvblBvb2xTaXplLCBfcG9vbENvbmZpZy5ERUZBVUxUX01BWF9TSVpFKTtcbiAgY29uZmlnLmNvbm5lY3Rpb25BY3F1aXNpdGlvblRpbWVvdXQgPSBzYW5pdGl6ZUludFZhbHVlKGNvbmZpZy5jb25uZWN0aW9uQWNxdWlzaXRpb25UaW1lb3V0LCBfcG9vbENvbmZpZy5ERUZBVUxUX0FDUVVJU0lUSU9OX1RJTUVPVVQpO1xuICBjb25maWcuZmV0Y2hTaXplID0gdmFsaWRhdGVGZXRjaFNpemVWYWx1ZShjb25maWcuZmV0Y2hTaXplLCBERUZBVUxUX0ZFVENIX1NJWkUpO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2FuaXRpemVJbnRWYWx1ZShyYXdWYWx1ZSwgZGVmYXVsdFdoZW5BYnNlbnQpIHtcbiAgdmFyIHNhbml0aXplZFZhbHVlID0gcGFyc2VJbnQocmF3VmFsdWUsIDEwKTtcblxuICBpZiAoc2FuaXRpemVkVmFsdWUgPiAwIHx8IHNhbml0aXplZFZhbHVlID09PSAwKSB7XG4gICAgcmV0dXJuIHNhbml0aXplZFZhbHVlO1xuICB9IGVsc2UgaWYgKHNhbml0aXplZFZhbHVlIDwgMCkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVmYXVsdFdoZW5BYnNlbnQ7XG4gIH1cbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRmV0Y2hTaXplVmFsdWUocmF3VmFsdWUsIGRlZmF1bHRXaGVuQWJzZW50KSB7XG4gIHZhciBmZXRjaFNpemUgPSBwYXJzZUludChyYXdWYWx1ZSwgMTApO1xuXG4gIGlmIChmZXRjaFNpemUgPiAwIHx8IGZldGNoU2l6ZSA9PT0gX3JlcXVlc3RNZXNzYWdlLkFMTCkge1xuICAgIHJldHVybiBmZXRjaFNpemU7XG4gIH0gZWxzZSBpZiAoZmV0Y2hTaXplID09PSAwIHx8IGZldGNoU2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmZXRjaCBzaXplIGNhbiBvbmx5IGJlIGEgcG9zaXRpdmUgdmFsdWUgb3IgLTEgZm9yIEFMTC4gSG93ZXZlciBmZXRjaFNpemUgPSAnICsgZmV0Y2hTaXplKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVmYXVsdFdoZW5BYnNlbnQ7XG4gIH1cbn1cblxudmFyIF9kZWZhdWx0ID0gRHJpdmVyO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm5ld0Vycm9yID0gbmV3RXJyb3I7XG5leHBvcnRzLlBST1RPQ09MX0VSUk9SID0gZXhwb3J0cy5TRVNTSU9OX0VYUElSRUQgPSBleHBvcnRzLlNFUlZJQ0VfVU5BVkFJTEFCTEUgPSBleHBvcnRzLk5lbzRqRXJyb3IgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX3dyYXBOYXRpdmVTdXBlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlclwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yW1wiZGVmYXVsdFwiXSkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gQSBjb21tb24gcGxhY2UgZm9yIGNvbnN0cnVjdGluZyBlcnJvciBvYmplY3RzLCB0byBrZWVwIHRoZW1cbi8vIHVuaWZvcm0gYWNyb3NzIHRoZSBkcml2ZXIgc3VyZmFjZS5cblxuLyoqXG4gKiBFcnJvciBjb2RlIHJlcHJlc2VudGluZyBjb21wbGV0ZSBsb3NzIG9mIHNlcnZpY2UuIFVzZWQgYnkge0BsaW5rIE5lbzRqRXJyb3IjY29kZX0uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgU0VSVklDRV9VTkFWQUlMQUJMRSA9ICdTZXJ2aWNlVW5hdmFpbGFibGUnO1xuLyoqXG4gKiBFcnJvciBjb2RlIHJlcHJlc2VudGluZyB0cmFuc2llbnQgbG9zcyBvZiBzZXJ2aWNlLiBVc2VkIGJ5IHtAbGluayBOZW80akVycm9yI2NvZGV9LlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuXG5leHBvcnRzLlNFUlZJQ0VfVU5BVkFJTEFCTEUgPSBTRVJWSUNFX1VOQVZBSUxBQkxFO1xudmFyIFNFU1NJT05fRVhQSVJFRCA9ICdTZXNzaW9uRXhwaXJlZCc7XG4vKipcbiAqIEVycm9yIGNvZGUgcmVwcmVzZW50aW5nIHNlcmlhbGl6YXRpb24vZGVzZXJpYWxpemF0aW9uIGlzc3VlIGluIHRoZSBCb2x0IHByb3RvY29sLiBVc2VkIGJ5IHtAbGluayBOZW80akVycm9yI2NvZGV9LlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuXG5leHBvcnRzLlNFU1NJT05fRVhQSVJFRCA9IFNFU1NJT05fRVhQSVJFRDtcbnZhciBQUk9UT0NPTF9FUlJPUiA9ICdQcm90b2NvbEVycm9yJztcbi8qKlxuICogQ3JlYXRlIGEgbmV3IGVycm9yIGZyb20gYSBtZXNzYWdlIGFuZCBlcnJvciBjb2RlXG4gKiBAcGFyYW0gbWVzc2FnZSB0aGUgZXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIGNvZGUgdGhlIGVycm9yIGNvZGVcbiAqIEByZXR1cm4ge05lbzRqRXJyb3J9IGFuIHtAbGluayBOZW80akVycm9yfVxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLlBST1RPQ09MX0VSUk9SID0gUFJPVE9DT0xfRVJST1I7XG5cbmZ1bmN0aW9uIG5ld0Vycm9yKG1lc3NhZ2UpIHtcbiAgdmFyIGNvZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdOL0EnO1xuICAvLyBUT0RPOiBJZGVhIGlzIHRoYXQgd2UgY2FuIGNoZWNrIHRoZSBjb2RlIGhlcmUgYW5kIHRocm93IHN1Yi1jbGFzc2VzXG4gIC8vIG9mIE5lbzRqRXJyb3IgYXMgYXBwcm9wcmlhdGVcbiAgcmV0dXJuIG5ldyBOZW80akVycm9yKG1lc3NhZ2UsIGNvZGUpO1xufVxuLyoqXG4gKiBDbGFzcyBmb3IgYWxsIGVycm9ycyB0aHJvd24vcmV0dXJuZWQgYnkgdGhlIGRyaXZlci5cbiAqL1xuXG5cbnZhciBOZW80akVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShOZW80akVycm9yLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTmVvNGpFcnJvcik7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZSAtIE9wdGlvbmFsIGVycm9yIGNvZGUuIFdpbGwgYmUgcG9wdWxhdGVkIHdoZW4gZXJyb3Igb3JpZ2luYXRlcyBpbiB0aGUgZGF0YWJhc2UuXG4gICAqL1xuICBmdW5jdGlvbiBOZW80akVycm9yKG1lc3NhZ2UpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgY29kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ04vQSc7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBOZW80akVycm9yKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIC8qKlxuICAgICAqIFRoZSBlcnJvciBtZXNzYWdlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICAgIF90aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIGVycm9yIGNvZGUuIFdpbGwgYmUgcG9wdWxhdGVkIHdoZW4gZXJyb3Igb3JpZ2luYXRlcyBpbiB0aGUgZGF0YWJhc2UuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBlcnJvci5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gICAgX3RoaXMubmFtZSA9ICdOZW80akVycm9yJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gTmVvNGpFcnJvcjtcbn0oIC8qI19fUFVSRV9fKi8oMCwgX3dyYXBOYXRpdmVTdXBlcjJbXCJkZWZhdWx0XCJdKShFcnJvcikpO1xuXG5leHBvcnRzLk5lbzRqRXJyb3IgPSBOZW80akVycm9yOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNOb2RlID0gaXNOb2RlO1xuZXhwb3J0cy5pc1JlbGF0aW9uc2hpcCA9IGlzUmVsYXRpb25zaGlwO1xuZXhwb3J0cy5pc1VuYm91bmRSZWxhdGlvbnNoaXAgPSBpc1VuYm91bmRSZWxhdGlvbnNoaXA7XG5leHBvcnRzLmlzUGF0aCA9IGlzUGF0aDtcbmV4cG9ydHMuaXNQYXRoU2VnbWVudCA9IGlzUGF0aFNlZ21lbnQ7XG5leHBvcnRzLlBhdGhTZWdtZW50ID0gZXhwb3J0cy5QYXRoID0gZXhwb3J0cy5VbmJvdW5kUmVsYXRpb25zaGlwID0gZXhwb3J0cy5SZWxhdGlvbnNoaXAgPSBleHBvcnRzLk5vZGUgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIElERU5USUZJRVJfUFJPUEVSVFlfQVRUUklCVVRFUyA9IHtcbiAgdmFsdWU6IHRydWUsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogZmFsc2Vcbn07XG52YXIgTk9ERV9JREVOVElGSUVSX1BST1BFUlRZID0gJ19faXNOb2RlX18nO1xudmFyIFJFTEFUSU9OU0hJUF9JREVOVElGSUVSX1BST1BFUlRZID0gJ19faXNSZWxhdGlvbnNoaXBfXyc7XG52YXIgVU5CT1VORF9SRUxBVElPTlNISVBfSURFTlRJRklFUl9QUk9QRVJUWSA9ICdfX2lzVW5ib3VuZFJlbGF0aW9uc2hpcF9fJztcbnZhciBQQVRIX0lERU5USUZJRVJfUFJPUEVSVFkgPSAnX19pc1BhdGhfXyc7XG52YXIgUEFUSF9TRUdNRU5UX0lERU5USUZJRVJfUFJPUEVSVFkgPSAnX19pc1BhdGhTZWdtZW50X18nO1xuXG5mdW5jdGlvbiBoYXNJZGVudGlmaWVyUHJvcGVydHkob2JqLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gKG9iaiAmJiBvYmpbcHJvcGVydHldKSA9PT0gdHJ1ZTtcbn1cbi8qKlxuICogQ2xhc3MgZm9yIE5vZGUgVHlwZS5cbiAqL1xuXG5cbnZhciBOb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gaWRlbnRpdHkgLSBVbmlxdWUgaWRlbnRpdHlcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBsYWJlbHMgLSBBcnJheSBmb3IgYWxsIGxhYmVsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIE1hcCB3aXRoIG5vZGUgcHJvcGVydGllc1xuICAgKi9cbiAgZnVuY3Rpb24gTm9kZShpZGVudGl0eSwgbGFiZWxzLCBwcm9wZXJ0aWVzKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBOb2RlKTtcblxuICAgIC8qKlxuICAgICAqIElkZW50aXR5IG9mIHRoZSBub2RlLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfVxuICAgICAqL1xuICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICAvKipcbiAgICAgKiBMYWJlbHMgb2YgdGhlIG5vZGUuXG4gICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAqL1xuXG4gICAgdGhpcy5sYWJlbHMgPSBsYWJlbHM7XG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiB0aGUgbm9kZS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgfVxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoTm9kZSwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgcyA9ICcoJyArIHRoaXMuaWRlbnRpdHk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcyArPSAnOicgKyB0aGlzLmxhYmVsc1tpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnByb3BlcnRpZXMpO1xuXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHMgKz0gJyB7JztcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwga2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBpZiAoX2kgPiAwKSBzICs9ICcsJztcbiAgICAgICAgICBzICs9IGtleXNbX2ldICsgJzonICsgSlNPTi5zdHJpbmdpZnkodGhpcy5wcm9wZXJ0aWVzW2tleXNbX2ldXSk7XG4gICAgICAgIH1cblxuICAgICAgICBzICs9ICd9JztcbiAgICAgIH1cblxuICAgICAgcyArPSAnKSc7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE5vZGU7XG59KCk7XG5cbmV4cG9ydHMuTm9kZSA9IE5vZGU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsIE5PREVfSURFTlRJRklFUl9QUk9QRVJUWSwgSURFTlRJRklFUl9QUk9QRVJUWV9BVFRSSUJVVEVTKTtcbi8qKlxuICogVGVzdCBpZiBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIE5vZGV9IGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgZ2l2ZW4gb2JqZWN0IGlzIGEge0BsaW5rIE5vZGV9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc05vZGUob2JqKSB7XG4gIHJldHVybiBoYXNJZGVudGlmaWVyUHJvcGVydHkob2JqLCBOT0RFX0lERU5USUZJRVJfUFJPUEVSVFkpO1xufVxuLyoqXG4gKiBDbGFzcyBmb3IgUmVsYXRpb25zaGlwIFR5cGUuXG4gKi9cblxuXG52YXIgUmVsYXRpb25zaGlwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gaWRlbnRpdHkgLSBVbmlxdWUgaWRlbnRpdHlcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBzdGFydCAtIElkZW50aXR5IG9mIHN0YXJ0IE5vZGVcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBlbmQgLSBJZGVudGl0eSBvZiBlbmQgTm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFJlbGF0aW9uc2hpcCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gTWFwIHdpdGggcmVsYXRpb25zaGlwIHByb3BlcnRpZXNcbiAgICovXG4gIGZ1bmN0aW9uIFJlbGF0aW9uc2hpcChpZGVudGl0eSwgc3RhcnQsIGVuZCwgdHlwZSwgcHJvcGVydGllcykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUmVsYXRpb25zaGlwKTtcblxuICAgIC8qKlxuICAgICAqIElkZW50aXR5IG9mIHRoZSByZWxhdGlvbnNoaXAuXG4gICAgICogQHR5cGUge0ludGVnZXJ9XG4gICAgICovXG4gICAgdGhpcy5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIC8qKlxuICAgICAqIElkZW50aXR5IG9mIHRoZSBzdGFydCBub2RlLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfVxuICAgICAqL1xuXG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIC8qKlxuICAgICAqIElkZW50aXR5IG9mIHRoZSBlbmQgbm9kZS5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgdGhlIHJlbGF0aW9uc2hpcC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIHRoZSByZWxhdGlvbnNoaXAuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblxuICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gIH1cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFJlbGF0aW9uc2hpcCwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgcyA9ICcoJyArIHRoaXMuc3RhcnQgKyAnKS1bOicgKyB0aGlzLnR5cGU7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMucHJvcGVydGllcyk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcyArPSAnIHsnO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChpID4gMCkgcyArPSAnLCc7XG4gICAgICAgICAgcyArPSBrZXlzW2ldICsgJzonICsgSlNPTi5zdHJpbmdpZnkodGhpcy5wcm9wZXJ0aWVzW2tleXNbaV1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMgKz0gJ30nO1xuICAgICAgfVxuXG4gICAgICBzICs9ICddLT4oJyArIHRoaXMuZW5kICsgJyknO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSZWxhdGlvbnNoaXA7XG59KCk7XG5cbmV4cG9ydHMuUmVsYXRpb25zaGlwID0gUmVsYXRpb25zaGlwO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbGF0aW9uc2hpcC5wcm90b3R5cGUsIFJFTEFUSU9OU0hJUF9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgUmVsYXRpb25zaGlwfSBjbGFzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIG9iamVjdCBpcyBhIHtAbGluayBSZWxhdGlvbnNoaXB9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc1JlbGF0aW9uc2hpcChvYmopIHtcbiAgcmV0dXJuIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIFJFTEFUSU9OU0hJUF9JREVOVElGSUVSX1BST1BFUlRZKTtcbn1cbi8qKlxuICogQ2xhc3MgZm9yIFVuYm91bmRSZWxhdGlvbnNoaXAgVHlwZS5cbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICovXG5cblxudmFyIFVuYm91bmRSZWxhdGlvbnNoaXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBpZGVudGl0eSAtIFVuaXF1ZSBpZGVudGl0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFJlbGF0aW9uc2hpcCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gTWFwIHdpdGggcmVsYXRpb25zaGlwIHByb3BlcnRpZXNcbiAgICovXG4gIGZ1bmN0aW9uIFVuYm91bmRSZWxhdGlvbnNoaXAoaWRlbnRpdHksIHR5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFVuYm91bmRSZWxhdGlvbnNoaXApO1xuXG4gICAgLyoqXG4gICAgICogSWRlbnRpdHkgb2YgdGhlIHJlbGF0aW9uc2hpcC5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgLyoqXG4gICAgICogVHlwZSBvZiB0aGUgcmVsYXRpb25zaGlwLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgdGhlIHJlbGF0aW9uc2hpcC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgfVxuICAvKipcbiAgICogQmluZCByZWxhdGlvbnNoaXBcbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IHN0YXJ0IC0gSWRlbnRpdHkgb2Ygc3RhcnQgbm9kZVxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IGVuZCAtIElkZW50aXR5IG9mIGVuZCBub2RlXG4gICAqIEByZXR1cm4ge1JlbGF0aW9uc2hpcH0gLSBDcmVhdGVkIHJlbGF0aW9uc2hpcFxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoVW5ib3VuZFJlbGF0aW9uc2hpcCwgW3tcbiAgICBrZXk6IFwiYmluZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiBuZXcgUmVsYXRpb25zaGlwKHRoaXMuaWRlbnRpdHksIHN0YXJ0LCBlbmQsIHRoaXMudHlwZSwgdGhpcy5wcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgcyA9ICctWzonICsgdGhpcy50eXBlO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnByb3BlcnRpZXMpO1xuXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHMgKz0gJyB7JztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSA+IDApIHMgKz0gJywnO1xuICAgICAgICAgIHMgKz0ga2V5c1tpXSArICc6JyArIEpTT04uc3RyaW5naWZ5KHRoaXMucHJvcGVydGllc1trZXlzW2ldXSk7XG4gICAgICAgIH1cblxuICAgICAgICBzICs9ICd9JztcbiAgICAgIH1cblxuICAgICAgcyArPSAnXS0+JztcbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVW5ib3VuZFJlbGF0aW9uc2hpcDtcbn0oKTtcblxuZXhwb3J0cy5VbmJvdW5kUmVsYXRpb25zaGlwID0gVW5ib3VuZFJlbGF0aW9uc2hpcDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbmJvdW5kUmVsYXRpb25zaGlwLnByb3RvdHlwZSwgVU5CT1VORF9SRUxBVElPTlNISVBfSURFTlRJRklFUl9QUk9QRVJUWSwgSURFTlRJRklFUl9QUk9QRVJUWV9BVFRSSUJVVEVTKTtcbi8qKlxuICogVGVzdCBpZiBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFVuYm91bmRSZWxhdGlvbnNoaXB9IGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgZ2l2ZW4gb2JqZWN0IGlzIGEge0BsaW5rIFVuYm91bmRSZWxhdGlvbnNoaXB9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc1VuYm91bmRSZWxhdGlvbnNoaXAob2JqKSB7XG4gIHJldHVybiBoYXNJZGVudGlmaWVyUHJvcGVydHkob2JqLCBVTkJPVU5UX1JFTEFUSU9OU0hJUF9JREVOVElGSUVSX1BST1BFUlRZKTtcbn1cbi8qKlxuICogQ2xhc3MgZm9yIFBhdGhTZWdtZW50IFR5cGUuXG4gKi9cblxuXG52YXIgUGF0aFNlZ21lbnQgPVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7Tm9kZX0gc3RhcnQgLSBzdGFydCBub2RlXG4gKiBAcGFyYW0ge1JlbGF0aW9uc2hpcH0gcmVsIC0gcmVsYXRpb25zaGlwIHRoYXQgY29ubmVjdHMgc3RhcnQgYW5kIGVuZCBub2RlXG4gKiBAcGFyYW0ge05vZGV9IGVuZCAtIGVuZCBub2RlXG4gKi9cbmZ1bmN0aW9uIFBhdGhTZWdtZW50KHN0YXJ0LCByZWwsIGVuZCkge1xuICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFBhdGhTZWdtZW50KTtcblxuICAvKipcbiAgICogU3RhcnQgbm9kZS5cbiAgICogQHR5cGUge05vZGV9XG4gICAqL1xuICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gIC8qKlxuICAgKiBSZWxhdGlvbnNoaXAuXG4gICAqIEB0eXBlIHtSZWxhdGlvbnNoaXB9XG4gICAqL1xuXG4gIHRoaXMucmVsYXRpb25zaGlwID0gcmVsO1xuICAvKipcbiAgICogRW5kIG5vZGUuXG4gICAqIEB0eXBlIHtOb2RlfVxuICAgKi9cblxuICB0aGlzLmVuZCA9IGVuZDtcbn07XG5cbmV4cG9ydHMuUGF0aFNlZ21lbnQgPSBQYXRoU2VnbWVudDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXRoU2VnbWVudC5wcm90b3R5cGUsIFBBVEhfU0VHTUVOVF9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgUGF0aFNlZ21lbnR9IGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgZ2l2ZW4gb2JqZWN0IGlzIGEge0BsaW5rIFBhdGhTZWdtZW50fSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNQYXRoU2VnbWVudChvYmopIHtcbiAgcmV0dXJuIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIFBBVEhfU0VHTUVOVF9JREVOVElGSUVSX1BST1BFUlRZKTtcbn1cbi8qKlxuICogQ2xhc3MgZm9yIFBhdGggVHlwZS5cbiAqL1xuXG5cbnZhciBQYXRoID1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge05vZGV9IHN0YXJ0ICAtIHN0YXJ0IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gZW5kIC0gZW5kIG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8UGF0aFNlZ21lbnQ+fSBzZWdtZW50cyAtIEFycmF5IG9mIFNlZ21lbnRzXG4gKi9cbmZ1bmN0aW9uIFBhdGgoc3RhcnQsIGVuZCwgc2VnbWVudHMpIHtcbiAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBQYXRoKTtcblxuICAvKipcbiAgICogU3RhcnQgbm9kZS5cbiAgICogQHR5cGUge05vZGV9XG4gICAqL1xuICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gIC8qKlxuICAgKiBFbmQgbm9kZS5cbiAgICogQHR5cGUge05vZGV9XG4gICAqL1xuXG4gIHRoaXMuZW5kID0gZW5kO1xuICAvKipcbiAgICogU2VnbWVudHMuXG4gICAqIEB0eXBlIHtBcnJheTxQYXRoU2VnbWVudD59XG4gICAqL1xuXG4gIHRoaXMuc2VnbWVudHMgPSBzZWdtZW50cztcbiAgLyoqXG4gICAqIExlbmd0aCBvZiB0aGUgc2VnbWVudHMuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMubGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoO1xufTtcblxuZXhwb3J0cy5QYXRoID0gUGF0aDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXRoLnByb3RvdHlwZSwgUEFUSF9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgUGF0aH0gY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBvYmplY3QgaXMgYSB7QGxpbmsgUGF0aH0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzUGF0aChvYmopIHtcbiAgcmV0dXJuIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIFBBVEhfSURFTlRJRklFUl9QUk9QRVJUWSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kcml2ZXIgPSBkcml2ZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVnZXJbXCJpbnRcIl07XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNJbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVnZXIuaXNJbnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmVvNGpFcnJvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZXJyb3IuTmVvNGpFcnJvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1BvaW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zcGF0aWFsVHlwZXMuaXNQb2ludDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0RhdGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3RlbXBvcmFsVHlwZXMuaXNEYXRlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzRGF0ZVRpbWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3RlbXBvcmFsVHlwZXMuaXNEYXRlVGltZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0R1cmF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90ZW1wb3JhbFR5cGVzLmlzRHVyYXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNMb2NhbERhdGVUaW1lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90ZW1wb3JhbFR5cGVzLmlzTG9jYWxEYXRlVGltZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0xvY2FsVGltZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdGVtcG9yYWxUeXBlcy5pc0xvY2FsVGltZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1RpbWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3RlbXBvcmFsVHlwZXMuaXNUaW1lO1xuICB9XG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZXhwb3J0cy50ZW1wb3JhbCA9IGV4cG9ydHMuc3BhdGlhbCA9IGV4cG9ydHMuZXJyb3IgPSBleHBvcnRzLnNlc3Npb24gPSBleHBvcnRzLnR5cGVzID0gZXhwb3J0cy5sb2dnaW5nID0gZXhwb3J0cy5hdXRoID0gZXhwb3J0cy5pbnRlZ2VyID0gdm9pZCAwO1xuXG52YXIgX2ludGVnZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9pbnRlZ2VyXCIpKTtcblxudmFyIF9ncmFwaFR5cGVzID0gcmVxdWlyZShcIi4vZ3JhcGgtdHlwZXNcIik7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcblxudmFyIF9yZXN1bHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Jlc3VsdFwiKSk7XG5cbnZhciBfcmVzdWx0U3VtbWFyeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVzdWx0LXN1bW1hcnlcIikpO1xuXG52YXIgX3JlY29yZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVjb3JkXCIpKTtcblxudmFyIF9kcml2ZXIgPSByZXF1aXJlKFwiLi9kcml2ZXJcIik7XG5cbnZhciBfcm91dGluZ0RyaXZlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm91dGluZy1kcml2ZXJcIikpO1xuXG52YXIgX3ZlcnNpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZlcnNpb25cIikpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC91dGlsXCIpO1xuXG52YXIgX3VybFV0aWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL3VybC11dGlsXCIpKTtcblxudmFyIF9zcGF0aWFsVHlwZXMgPSByZXF1aXJlKFwiLi9zcGF0aWFsLXR5cGVzXCIpO1xuXG52YXIgX3RlbXBvcmFsVHlwZXMgPSByZXF1aXJlKFwiLi90ZW1wb3JhbC10eXBlc1wiKTtcblxudmFyIF9zZXJ2ZXJBZGRyZXNzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC9zZXJ2ZXItYWRkcmVzc1wiKSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdCBhIG5ldyBOZW80aiBEcml2ZXIuIFRoaXMgaXMgeW91ciBtYWluIGVudHJ5IHBvaW50IGZvciB0aGlzXG4gKiBsaWJyYXJ5LlxuICpcbiAqICMjIENvbmZpZ3VyYXRpb25cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG9wdGlvbmFsbHkgdGFrZXMgYSBjb25maWd1cmF0aW9uIGFyZ3VtZW50LiBBdmFpbGFibGUgY29uZmlndXJhdGlvblxuICogb3B0aW9ucyBhcmUgYXMgZm9sbG93czpcbiAqXG4gKiAgICAge1xuICogICAgICAgLy8gRW5jcnlwdGlvbiBsZXZlbDogRU5DUllQVElPTl9PTiBvciBFTkNSWVBUSU9OX09GRi5cbiAqICAgICAgIGVuY3J5cHRlZDogRU5DUllQVElPTl9PTnxFTkNSWVBUSU9OX09GRlxuICpcbiAqICAgICAgIC8vIFRydXN0IHN0cmF0ZWd5IHRvIHVzZSBpZiBlbmNyeXB0aW9uIGlzIGVuYWJsZWQuIFRoZXJlIGlzIG5vIG1vZGUgdG8gZGlzYWJsZVxuICogICAgICAgLy8gdHJ1c3Qgb3RoZXIgdGhhbiBkaXNhYmxpbmcgZW5jcnlwdGlvbiBhbHRvZ2V0aGVyLiBUaGUgcmVhc29uIGZvclxuICogICAgICAgLy8gdGhpcyBpcyB0aGF0IGlmIHlvdSBkb24ndCBrbm93IHdobyB5b3UgYXJlIHRhbGtpbmcgdG8sIGl0IGlzIGVhc3kgZm9yIGFuXG4gKiAgICAgICAvLyBhdHRhY2tlciB0byBoaWphY2sgeW91ciBlbmNyeXB0ZWQgY29ubmVjdGlvbiwgcmVuZGVyaW5nIGVuY3J5cHRpb24gcG9pbnRsZXNzLlxuICogICAgICAgLy9cbiAqICAgICAgIC8vIFRSVVNUX1NZU1RFTV9DQV9TSUdORURfQ0VSVElGSUNBVEVTIGlzIHRoZSBkZWZhdWx0IGNob2ljZS4gRm9yIE5vZGVKUyBlbnZpcm9ubWVudHMsIHRoaXNcbiAqICAgICAgIC8vIG1lYW5zIHRoYXQgeW91IHRydXN0IHdoYXRldmVyIGNlcnRpZmljYXRlcyBhcmUgaW4gdGhlIGRlZmF1bHQgdHJ1c3RlZCBjZXJ0aWZpY2F0ZVxuICogICAgICAgLy8gc3RvcmUgb2YgdGhlIHVuZGVybHlpbmcgc3lzdGVtLiBGb3IgQnJvd3NlciBlbnZpcm9ubWVudHMsIHRoZSB0cnVzdGVkIGNlcnRpZmljYXRlXG4gKiAgICAgICAvLyBzdG9yZSBpcyB1c3VhbGx5IG1hbmFnZWQgYnkgdGhlIGJyb3dzZXIuIFJlZmVyIHRvIHlvdXIgc3lzdGVtIG9yIGJyb3dzZXIgZG9jdW1lbnRhdGlvblxuICogICAgICAgLy8gaWYgeW91IHdhbnQgdG8gZXhwbGljaXRseSBhZGQgYSBjZXJ0aWZpY2F0ZSBhcyB0cnVzdGVkLlxuICogICAgICAgLy9cbiAqICAgICAgIC8vIFRSVVNUX0NVU1RPTV9DQV9TSUdORURfQ0VSVElGSUNBVEVTIGlzIGFub3RoZXIgb3B0aW9uIGZvciB0cnVzdCB2ZXJpZmljYXRpb24gLVxuICogICAgICAgLy8gd2hlbmV2ZXIgd2UgZXN0YWJsaXNoIGFuIGVuY3J5cHRlZCBjb25uZWN0aW9uLCB3ZSBlbnN1cmUgdGhlIGhvc3QgaXMgdXNpbmdcbiAqICAgICAgIC8vIGFuIGVuY3J5cHRpb24gY2VydGlmaWNhdGUgdGhhdCBpcyBpbiwgb3IgaXMgc2lnbmVkIGJ5LCBhIGNlcnRpZmljYXRlIGdpdmVuXG4gKiAgICAgICAvLyBhcyB0cnVzdGVkIHRocm91Z2ggY29uZmlndXJhdGlvbi4gVGhpcyBvcHRpb24gaXMgb25seSBhdmFpbGFibGUgZm9yIE5vZGVKUyBlbnZpcm9ubWVudHMuXG4gKiAgICAgICAvL1xuICogICAgICAgLy8gVFJVU1RfQUxMX0NFUlRJRklDQVRFUyBtZWFucyB0aGF0IHlvdSB0cnVzdCBldmVyeXRoaW5nIHdpdGhvdXQgYW55IHZlcmlmaWNhdGlvbnNcbiAqICAgICAgIC8vIHN0ZXBzIGNhcnJpZWQgb3V0LiAgVGhpcyBvcHRpb24gaXMgb25seSBhdmFpbGFibGUgZm9yIE5vZGVKUyBlbnZpcm9ubWVudHMgYW5kIHNob3VsZCBub3RcbiAqICAgICAgIC8vIGJlIHVzZWQgb24gcHJvZHVjdGlvbiBzeXN0ZW1zLlxuICogICAgICAgdHJ1c3Q6IFwiVFJVU1RfU1lTVEVNX0NBX1NJR05FRF9DRVJUSUZJQ0FURVNcIiB8IFwiVFJVU1RfQ1VTVE9NX0NBX1NJR05FRF9DRVJUSUZJQ0FURVNcIiB8XG4gKiAgICAgICBcIlRSVVNUX0FMTF9DRVJUSUZJQ0FURVNcIixcbiAqXG4gKiAgICAgICAvLyBMaXN0IG9mIG9uZSBvciBtb3JlIHBhdGhzIHRvIHRydXN0ZWQgZW5jcnlwdGlvbiBjZXJ0aWZpY2F0ZXMuIFRoaXMgb25seVxuICogICAgICAgLy8gd29ya3MgaW4gdGhlIE5vZGVKUyBidW5kbGUsIGFuZCBvbmx5IG1hdHRlcnMgaWYgeW91IHVzZSBcIlRSVVNUX0NVU1RPTV9DQV9TSUdORURfQ0VSVElGSUNBVEVTXCIuXG4gKiAgICAgICAvLyBUaGUgY2VydGlmaWNhdGUgZmlsZXMgc2hvdWxkIGJlIGluIHJlZ3VsYXIgWC41MDkgUEVNIGZvcm1hdC5cbiAqICAgICAgIC8vIEZvciBpbnN0YW5jZSwgWycuL3RydXN0ZWQucGVtJ11cbiAqICAgICAgIHRydXN0ZWRDZXJ0aWZpY2F0ZXM6IFtdLFxuICpcbiAqICAgICAgIC8vIFRoZSBtYXhpbXVtIHRvdGFsIG51bWJlciBvZiBjb25uZWN0aW9ucyBhbGxvd2VkIHRvIGJlIG1hbmFnZWQgYnkgdGhlIGNvbm5lY3Rpb24gcG9vbCwgcGVyIGhvc3QuXG4gKiAgICAgICAvLyBUaGlzIGluY2x1ZGVzIGJvdGggaW4tdXNlIGFuZCBpZGxlIGNvbm5lY3Rpb25zLiBObyBtYXhpbXVtIGNvbm5lY3Rpb24gcG9vbCBzaXplIGlzIGltcG9zZWRcbiAqICAgICAgIC8vIGJ5IGRlZmF1bHQuXG4gKiAgICAgICBtYXhDb25uZWN0aW9uUG9vbFNpemU6IDEwMCxcbiAqXG4gKiAgICAgICAvLyBUaGUgbWF4aW11bSBhbGxvd2VkIGxpZmV0aW1lIGZvciBhIHBvb2xlZCBjb25uZWN0aW9uIGluIG1pbGxpc2Vjb25kcy4gUG9vbGVkIGNvbm5lY3Rpb25zIG9sZGVyIHRoYW4gdGhpc1xuICogICAgICAgLy8gdGhyZXNob2xkIHdpbGwgYmUgY2xvc2VkIGFuZCByZW1vdmVkIGZyb20gdGhlIHBvb2wuIFN1Y2ggZGlzY2FyZGluZyBoYXBwZW5zIGR1cmluZyBjb25uZWN0aW9uIGFjcXVpc2l0aW9uXG4gKiAgICAgICAvLyBzbyB0aGF0IG5ldyBzZXNzaW9uIGlzIG5ldmVyIGJhY2tlZCBieSBhbiBvbGQgY29ubmVjdGlvbi4gU2V0dGluZyB0aGlzIG9wdGlvbiB0byBhIGxvdyB2YWx1ZSB3aWxsIGNhdXNlXG4gKiAgICAgICAvLyBhIGhpZ2ggY29ubmVjdGlvbiBjaHVybiBhbmQgbWlnaHQgcmVzdWx0IGluIGEgcGVyZm9ybWFuY2UgaGl0LiBJdCBpcyByZWNvbW1lbmRlZCB0byBzZXQgbWF4aW11bSBsaWZldGltZVxuICogICAgICAgLy8gdG8gYSBzbGlnaHRseSBzbWFsbGVyIHZhbHVlIHRoYW4gdGhlIG9uZSBjb25maWd1cmVkIGluIG5ldHdvcmsgZXF1aXBtZW50IChsb2FkIGJhbGFuY2VyLCBwcm94eSwgZmlyZXdhbGwsXG4gKiAgICAgICAvLyBldGMuIGNhbiBhbHNvIGxpbWl0IG1heGltdW0gY29ubmVjdGlvbiBsaWZldGltZSkuIE5vIG1heGltdW0gbGlmZXRpbWUgbGltaXQgaXMgaW1wb3NlZCBieSBkZWZhdWx0LiBaZXJvXG4gKiAgICAgICAvLyBhbmQgbmVnYXRpdmUgdmFsdWVzIHJlc3VsdCBpbiBsaWZldGltZSBub3QgYmVpbmcgY2hlY2tlZC5cbiAqICAgICAgIG1heENvbm5lY3Rpb25MaWZldGltZTogNjAgKiA2MCAqIDEwMDAsIC8vIDEgaG91clxuICpcbiAqICAgICAgIC8vIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgdG8gYWNxdWlyZSBhIGNvbm5lY3Rpb24gZnJvbSB0aGUgcG9vbCAodG8gZWl0aGVyIGNyZWF0ZSBhIG5ld1xuICogICAgICAgLy8gY29ubmVjdGlvbiBvciBib3Jyb3cgYW4gZXhpc3Rpbmcgb25lLlxuICogICAgICAgY29ubmVjdGlvbkFjcXVpc2l0aW9uVGltZW91dDogNjAwMDAsIC8vIDEgbWludXRlXG4gKlxuICogICAgICAgLy8gU3BlY2lmeSB0aGUgbWF4aW11bSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0cmFuc2FjdGlvbnMgYXJlIGFsbG93ZWQgdG8gcmV0cnkgdmlhXG4gKiAgICAgICAvLyBgU2Vzc2lvbiNyZWFkVHJhbnNhY3Rpb24oKWAgYW5kIGBTZXNzaW9uI3dyaXRlVHJhbnNhY3Rpb24oKWAgZnVuY3Rpb25zLlxuICogICAgICAgLy8gVGhlc2UgZnVuY3Rpb25zIHdpbGwgcmV0cnkgdGhlIGdpdmVuIHVuaXQgb2Ygd29yayBvbiBgU2VydmljZVVuYXZhaWxhYmxlYCwgYFNlc3Npb25FeHBpcmVkYCBhbmQgdHJhbnNpZW50XG4gKiAgICAgICAvLyBlcnJvcnMgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmIHVzaW5nIGluaXRpYWwgZGVsYXkgb2YgMSBzZWNvbmQuXG4gKiAgICAgICAvLyBEZWZhdWx0IHZhbHVlIGlzIDMwMDAwIHdoaWNoIGlzIDMwIHNlY29uZHMuXG4gKiAgICAgICBtYXhUcmFuc2FjdGlvblJldHJ5VGltZTogMzAwMDAsIC8vIDMwIHNlY29uZHNcbiAqXG4gKiAgICAgICAvLyBTcGVjaWZ5IHNvY2tldCBjb25uZWN0aW9uIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLiBOdW1lcmljIHZhbHVlcyBhcmUgZXhwZWN0ZWQuIE5lZ2F0aXZlIGFuZCB6ZXJvIHZhbHVlc1xuICogICAgICAgLy8gcmVzdWx0IGluIG5vIHRpbWVvdXQgYmVpbmcgYXBwbGllZC4gQ29ubmVjdGlvbiBlc3RhYmxpc2htZW50IHdpbGwgYmUgdGhlbiBib3VuZCBieSB0aGUgdGltZW91dCBjb25maWd1cmVkXG4gKiAgICAgICAvLyBvbiB0aGUgb3BlcmF0aW5nIHN5c3RlbSBsZXZlbC4gRGVmYXVsdCB2YWx1ZSBpcyAzMDAwMCwgd2hpY2ggaXMgMzAgc2Vjb25kcy5cbiAqICAgICAgIGNvbm5lY3Rpb25UaW1lb3V0OiAzMDAwMCwgLy8gMzAgc2Vjb25kc1xuICpcbiAqICAgICAgIC8vIE1ha2UgdGhpcyBkcml2ZXIgYWx3YXlzIHJldHVybiBuYXRpdmUgSmF2YVNjcmlwdCBudW1iZXJzIGZvciBpbnRlZ2VyIHZhbHVlcywgaW5zdGVhZCBvZiB0aGVcbiAqICAgICAgIC8vIGRlZGljYXRlZCB7QGxpbmsgSW50ZWdlcn0gY2xhc3MuIFZhbHVlcyB0aGF0IGRvIG5vdCBmaXQgaW4gbmF0aXZlIG51bWJlciBiaXQgcmFuZ2Ugd2lsbCBiZSByZXByZXNlbnRlZCBhc1xuICogICAgICAgLy8gYE51bWJlci5ORUdBVElWRV9JTkZJTklUWWAgb3IgYE51bWJlci5QT1NJVElWRV9JTkZJTklUWWAuXG4gKiAgICAgICAvLyAqKldhcm5pbmc6KiogUmVzdWx0U3VtbWFyeSBJdCBpcyBub3QgYWx3YXlzIHNhZmUgdG8gZW5hYmxlIHRoaXMgc2V0dGluZyB3aGVuIEphdmFTY3JpcHQgYXBwbGljYXRpb25zIGFyZSBub3QgdGhlIG9ubHkgb25lc1xuICogICAgICAgLy8gaW50ZXJhY3Rpbmcgd2l0aCB0aGUgZGF0YWJhc2UuIFN0b3JlZCBudW1iZXJzIG1pZ2h0IGluIHN1Y2ggY2FzZSBiZSBub3QgcmVwcmVzZW50YWJsZSBieSBuYXRpdmVcbiAqICAgICAgIC8vIHtAbGluayBOdW1iZXJ9IHR5cGUgYW5kIHRodXMgZHJpdmVyIHdpbGwgcmV0dXJuIGxvc3N5IHZhbHVlcy4gVGhpcyBtaWdodCBhbHNvIGhhcHBlbiB3aGVuIGRhdGEgd2FzXG4gKiAgICAgICAvLyBpbml0aWFsbHkgaW1wb3J0ZWQgdXNpbmcgbmVvNGogaW1wb3J0IHRvb2wgYW5kIGNvbnRhaW5lZCBudW1iZXJzIGxhcmdlciB0aGFuXG4gKiAgICAgICAvLyBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLiBEcml2ZXIgd2lsbCB0aGVuIHJldHVybiBwb3NpdGl2ZSBpbmZpbml0eSwgd2hpY2ggaXMgbG9zc3kuXG4gKiAgICAgICAvLyBEZWZhdWx0IHZhbHVlIGZvciB0aGlzIG9wdGlvbiBpcyBgZmFsc2VgIGJlY2F1c2UgbmF0aXZlIEphdmFTY3JpcHQgbnVtYmVycyBtaWdodCByZXN1bHRcbiAqICAgICAgIC8vIGluIGxvc3Mgb2YgcHJlY2lzaW9uIGluIHRoZSBnZW5lcmFsIGNhc2UuXG4gKiAgICAgICBkaXNhYmxlTG9zc2xlc3NJbnRlZ2VyczogZmFsc2UsXG4gKlxuICogICAgICAgLy8gU3BlY2lmeSB0aGUgbG9nZ2luZyBjb25maWd1cmF0aW9uIGZvciB0aGUgZHJpdmVyLiBPYmplY3Qgc2hvdWxkIGhhdmUgdHdvIHByb3BlcnRpZXMgYGxldmVsYCBhbmQgYGxvZ2dlcmAuXG4gKiAgICAgICAvL1xuICogICAgICAgLy8gUHJvcGVydHkgYGxldmVsYCByZXByZXNlbnRzIHRoZSBsb2dnaW5nIGxldmVsIHdoaWNoIHNob3VsZCBiZSBvbmUgb2Y6ICdlcnJvcicsICd3YXJuJywgJ2luZm8nIG9yICdkZWJ1ZycuIFRoaXMgcHJvcGVydHkgaXMgb3B0aW9uYWwgYW5kXG4gKiAgICAgICAvLyBpdHMgZGVmYXVsdCB2YWx1ZSBpcyAnaW5mbycuIExldmVscyBoYXZlIHByaW9yaXRpZXM6ICdlcnJvcic6IDAsICd3YXJuJzogMSwgJ2luZm8nOiAyLCAnZGVidWcnOiAzLiBFbmFibGluZyBhIGNlcnRhaW4gbGV2ZWwgYWxzbyBlbmFibGVzIGFsbFxuICogICAgICAgLy8gbGV2ZWxzIHdpdGggbG93ZXIgcHJpb3JpdHkuIEZvciBleGFtcGxlOiAnZXJyb3InLCAnd2FybicgYW5kICdpbmZvJyB3aWxsIGJlIGxvZ2dlZCB3aGVuICdpbmZvJyBsZXZlbCBpcyBjb25maWd1cmVkLlxuICogICAgICAgLy9cbiAqICAgICAgIC8vIFByb3BlcnR5IGBsb2dnZXJgIHJlcHJlc2VudHMgdGhlIGxvZ2dpbmcgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBpbnZva2VkIGZvciBldmVyeSBsb2cgY2FsbCB3aXRoIGFuIGFjY2VwdGFibGUgbGV2ZWwuIFRoZSBmdW5jdGlvbiBzaG91bGRcbiAqICAgICAgIC8vIHRha2UgdHdvIHN0cmluZyBhcmd1bWVudHMgYGxldmVsYCBhbmQgYG1lc3NhZ2VgLiBUaGUgZnVuY3Rpb24gc2hvdWxkIG5vdCBleGVjdXRlIGFueSBibG9ja2luZyBvciBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uc1xuICogICAgICAgLy8gYmVjYXVzZSBpdCBpcyBvZnRlbiBleGVjdXRlZCBvbiBhIGhvdCBwYXRoLlxuICogICAgICAgLy9cbiAqICAgICAgIC8vIE5vIGxvZ2dpbmcgaXMgZG9uZSBieSBkZWZhdWx0LiBTZWUgYG5lbzRqLmxvZ2dpbmdgIG9iamVjdCB0aGF0IGNvbnRhaW5zIHByZWRlZmluZWQgbG9nZ2luZyBpbXBsZW1lbnRhdGlvbnMuXG4gKiAgICAgICBsb2dnaW5nOiB7XG4gKiAgICAgICAgIGxldmVsOiAnaW5mbycsXG4gKiAgICAgICAgIGxvZ2dlcjogKGxldmVsLCBtZXNzYWdlKSA9PiBjb25zb2xlLmxvZyhsZXZlbCArICcgJyArIG1lc3NhZ2UpXG4gKiAgICAgICB9LFxuICpcbiAqICAgICAgIC8vIFNwZWNpZnkgYSBjdXN0b20gc2VydmVyIGFkZHJlc3MgcmVzb2x2ZXIgZnVuY3Rpb24gdXNlZCBieSB0aGUgcm91dGluZyBkcml2ZXIgdG8gcmVzb2x2ZSB0aGUgaW5pdGlhbCBhZGRyZXNzIHVzZWQgdG8gY3JlYXRlIHRoZSBkcml2ZXIuXG4gKiAgICAgICAvLyBTdWNoIHJlc29sdXRpb24gaGFwcGVuczpcbiAqICAgICAgIC8vICAqIGR1cmluZyB0aGUgdmVyeSBmaXJzdCByZWRpc2NvdmVyeSB3aGVuIGRyaXZlciBpcyBjcmVhdGVkXG4gKiAgICAgICAvLyAgKiB3aGVuIGFsbCB0aGUga25vd24gcm91dGVycyBmcm9tIHRoZSBjdXJyZW50IHJvdXRpbmcgdGFibGUgaGF2ZSBmYWlsZWQgYW5kIGRyaXZlciBuZWVkcyB0byBmYWxsYmFjayB0byB0aGUgaW5pdGlhbCBhZGRyZXNzXG4gKiAgICAgICAvL1xuICogICAgICAgLy8gSW4gTm9kZUpTIGVudmlyb25tZW50IGRyaXZlciBkZWZhdWx0cyB0byBwZXJmb3JtaW5nIGEgRE5TIHJlc29sdXRpb24gb2YgdGhlIGluaXRpYWwgYWRkcmVzcyB1c2luZyAnZG5zJyBtb2R1bGUuXG4gKiAgICAgICAvLyBJbiBicm93c2VyIGVudmlyb25tZW50IGRyaXZlciB1c2VzIHRoZSBpbml0aWFsIGFkZHJlc3MgYXMtaXMuXG4gKiAgICAgICAvLyBWYWx1ZSBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc2luZ2xlIHN0cmluZyBhcmd1bWVudCAtIHRoZSBpbml0aWFsIGFkZHJlc3MuIEl0IHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2YgbmV3IGFkZHJlc3Nlcy5cbiAqICAgICAgIC8vIEFkZHJlc3MgaXMgYSBzdHJpbmcgb2Ygc2hhcGUgJzxob3N0Pjo8cG9ydD4nLiBQcm92aWRlZCBmdW5jdGlvbiBjYW4gcmV0dXJuIGVpdGhlciBhIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBhbiBhcnJheSBvZiBhZGRyZXNzZXNcbiAqICAgICAgIC8vIG9yIGFycmF5IG9mIGFkZHJlc3NlcyBkaXJlY3RseS5cbiAqICAgICAgIHJlc29sdmVyOiBmdW5jdGlvbihhZGRyZXNzKSB7XG4gKiAgICAgICAgIHJldHVybiBbJzEyNy4wLjAuMTo4ODg4JywgJ2ZhbGxiYWNrLmRiLmNvbTo3Njg3J107XG4gKiAgICAgICB9LFxuICpcbiAqICAgICAgLy8gT3B0aW9uYWxseSBvdmVycmlkZSB0aGUgZGVmYXVsdCB1c2VyIGFnZW50IG5hbWUuXG4gKiAgICAgICB1c2VyQWdlbnQ6IFVTRVJfQUdFTlRcbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIGZvciB0aGUgTmVvNGogZGF0YWJhc2UsIGZvciBpbnN0YW5jZSBcIm5lbzRqOi8vbG9jYWxob3N0XCIgYW5kL29yIFwiYm9sdDovL2xvY2FsaG9zdFwiXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsc3RyaW5nPn0gYXV0aFRva2VuIEF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzLiBTZWUge0BsaW5rIGF1dGh9IGZvciBoZWxwZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdC4gU2VlIHRoZSBjb25maWd1cmF0aW9uIHNlY3Rpb24gYWJvdmUgZm9yIGRldGFpbHMuXG4gKiBAcmV0dXJucyB7RHJpdmVyfVxuICovXG5mdW5jdGlvbiBkcml2ZXIodXJsLCBhdXRoVG9rZW4pIHtcbiAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICgwLCBfdXRpbC5hc3NlcnRTdHJpbmcpKHVybCwgJ0JvbHQgVVJMJyk7XG5cbiAgdmFyIHBhcnNlZFVybCA9IF91cmxVdGlsW1wiZGVmYXVsdFwiXS5wYXJzZURhdGFiYXNlVXJsKHVybCk7IC8vIERldGVybWluZSBlbnRyeXB0aW9uL3RydXN0IG9wdGlvbnMgZnJvbSB0aGUgVVJMLlxuXG5cbiAgdmFyIHJvdXRpbmcgPSBmYWxzZTtcbiAgdmFyIGVuY3J5cHRlZCA9IGZhbHNlO1xuICB2YXIgdHJ1c3Q7XG5cbiAgc3dpdGNoIChwYXJzZWRVcmwuc2NoZW1lKSB7XG4gICAgY2FzZSAnYm9sdCc6XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JvbHQrcyc6XG4gICAgICBlbmNyeXB0ZWQgPSB0cnVlO1xuICAgICAgdHJ1c3QgPSAnVFJVU1RfU1lTVEVNX0NBX1NJR05FRF9DRVJUSUZJQ0FURVMnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdib2x0K3NzYyc6XG4gICAgICBlbmNyeXB0ZWQgPSB0cnVlO1xuICAgICAgdHJ1c3QgPSAnVFJVU1RfQUxMX0NFUlRJRklDQVRFUyc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ25lbzRqJzpcbiAgICAgIHJvdXRpbmcgPSB0cnVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICduZW80aitzJzpcbiAgICAgIGVuY3J5cHRlZCA9IHRydWU7XG4gICAgICB0cnVzdCA9ICdUUlVTVF9TWVNURU1fQ0FfU0lHTkVEX0NFUlRJRklDQVRFUyc7XG4gICAgICByb3V0aW5nID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbmVvNGorc3NjJzpcbiAgICAgIGVuY3J5cHRlZCA9IHRydWU7XG4gICAgICB0cnVzdCA9ICdUUlVTVF9BTExfQ0VSVElGSUNBVEVTJztcbiAgICAgIHJvdXRpbmcgPSB0cnVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzY2hlbWU6IFwiLmNvbmNhdChwYXJzZWRVcmwuc2NoZW1lKSk7XG4gIH0gLy8gRW5jcnlwdGlvbiBlbmFibGVkIG9uIFVSTCwgcHJvcGFnYXRlIHRydXN0IHRvIHRoZSBjb25maWcuXG5cblxuICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGNvbmZpZ3VyYXRpb24gY29uZmxpY3QgYmV0d2VlbiBVUkwgYW5kIGNvbmZpZy5cbiAgICBpZiAoJ2VuY3J5cHRlZCcgaW4gY29uZmlnIHx8ICd0cnVzdCcgaW4gY29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24vdHJ1c3QgY2FuIG9ubHkgYmUgY29uZmlndXJlZCBlaXRoZXIgdGhyb3VnaCBVUkwgb3IgY29uZmlnLCBub3QgYm90aCcpO1xuICAgIH1cblxuICAgIGNvbmZpZy5lbmNyeXB0ZWQgPSBfdXRpbC5FTkNSWVBUSU9OX09OO1xuICAgIGNvbmZpZy50cnVzdCA9IHRydXN0O1xuICB9IC8vIFNhbml0aXplIGF1dGhvcml0eSB0b2tlbi4gTmljZXIgZXJyb3IgZnJvbSBzZXJ2ZXIgd2hlbiBhIHNjaGVtZSBpcyBzZXQuXG5cblxuICBhdXRoVG9rZW4gPSBhdXRoVG9rZW4gfHwge307XG4gIGF1dGhUb2tlbi5zY2hlbWUgPSBhdXRoVG9rZW4uc2NoZW1lIHx8ICdub25lJzsgLy8gVXNlIGRlZmF1bHQgdXNlciBhZ2VudCBvciB1c2VyIGFnZW50IHNwZWNpZmllZCBieSB1c2VyLlxuXG4gIGNvbmZpZy51c2VyQWdlbnQgPSBjb25maWcudXNlckFnZW50IHx8IFVTRVJfQUdFTlQ7XG5cbiAgaWYgKHJvdXRpbmcpIHtcbiAgICByZXR1cm4gbmV3IF9yb3V0aW5nRHJpdmVyW1wiZGVmYXVsdFwiXShfc2VydmVyQWRkcmVzc1tcImRlZmF1bHRcIl0uZnJvbVVybChwYXJzZWRVcmwuaG9zdEFuZFBvcnQpLCBwYXJzZWRVcmwucXVlcnksIGNvbmZpZy51c2VyQWdlbnQsIGF1dGhUb2tlbiwgY29uZmlnKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoISgwLCBfdXRpbC5pc0VtcHR5T2JqZWN0T3JOdWxsKShwYXJzZWRVcmwucXVlcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXJzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbm9uZSByb3V0ZWQgc2NoZW1lLiBHaXZlbiBVUkw6ICdcIi5jb25jYXQodXJsLCBcIidcIikpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgX2RyaXZlci5Ecml2ZXIoX3NlcnZlckFkZHJlc3NbXCJkZWZhdWx0XCJdLmZyb21VcmwocGFyc2VkVXJsLmhvc3RBbmRQb3J0KSwgY29uZmlnLnVzZXJBZ2VudCwgYXV0aFRva2VuLCBjb25maWcpO1xuICB9XG59XG4vKipcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24odXNlcm5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZywgcmVhbG06ID9zdHJpbmcpfSBiYXNpYyB0aGUgZnVuY3Rpb24gdG8gY3JlYXRlIGFcbiAqIGJhc2ljIGF1dGhlbnRpY2F0aW9uIHRva2VuLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihiYXNlNjRFbmNvZGVkVGlja2V0OiBzdHJpbmcpfSBrZXJiZXJvcyB0aGUgZnVuY3Rpb24gdG8gY3JlYXRlIGEgS2VyYmVyb3MgYXV0aGVudGljYXRpb24gdG9rZW4uXG4gKiBBY2NlcHRzIGEgc2luZ2xlIHN0cmluZyBhcmd1bWVudCAtIGJhc2U2NCBlbmNvZGVkIEtlcmJlcm9zIHRpY2tldC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24ocHJpbmNpcGFsOiBzdHJpbmcsIGNyZWRlbnRpYWxzOiBzdHJpbmcsIHJlYWxtOiBzdHJpbmcsIHNjaGVtZTogc3RyaW5nLCBwYXJhbWV0ZXJzOiA/b2JqZWN0KX0gY3VzdG9tXG4gKiB0aGUgZnVuY3Rpb24gdG8gY3JlYXRlIGEgY3VzdG9tIGF1dGhlbnRpY2F0aW9uIHRva2VuLlxuICovXG5cblxudmFyIGF1dGggPSB7XG4gIGJhc2ljOiBmdW5jdGlvbiBiYXNpYyh1c2VybmFtZSwgcGFzc3dvcmQpIHtcbiAgICB2YXIgcmVhbG0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChyZWFsbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1lOiAnYmFzaWMnLFxuICAgICAgICBwcmluY2lwYWw6IHVzZXJuYW1lLFxuICAgICAgICBjcmVkZW50aWFsczogcGFzc3dvcmQsXG4gICAgICAgIHJlYWxtOiByZWFsbVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1lOiAnYmFzaWMnLFxuICAgICAgICBwcmluY2lwYWw6IHVzZXJuYW1lLFxuICAgICAgICBjcmVkZW50aWFsczogcGFzc3dvcmRcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBrZXJiZXJvczogZnVuY3Rpb24ga2VyYmVyb3MoYmFzZTY0RW5jb2RlZFRpY2tldCkge1xuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWU6ICdrZXJiZXJvcycsXG4gICAgICBwcmluY2lwYWw6ICcnLFxuICAgICAgLy8gVGhpcyBlbXB0eSBzdHJpbmcgaXMgcmVxdWlyZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAgY3JlZGVudGlhbHM6IGJhc2U2NEVuY29kZWRUaWNrZXRcbiAgICB9O1xuICB9LFxuICBjdXN0b206IGZ1bmN0aW9uIGN1c3RvbShwcmluY2lwYWwsIGNyZWRlbnRpYWxzLCByZWFsbSwgc2NoZW1lKSB7XG4gICAgdmFyIHBhcmFtZXRlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChwYXJhbWV0ZXJzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6IHNjaGVtZSxcbiAgICAgICAgcHJpbmNpcGFsOiBwcmluY2lwYWwsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBjcmVkZW50aWFscyxcbiAgICAgICAgcmVhbG06IHJlYWxtLFxuICAgICAgICBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6IHNjaGVtZSxcbiAgICAgICAgcHJpbmNpcGFsOiBwcmluY2lwYWwsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBjcmVkZW50aWFscyxcbiAgICAgICAgcmVhbG06IHJlYWxtXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcbmV4cG9ydHMuYXV0aCA9IGF1dGg7XG52YXIgVVNFUl9BR0VOVCA9ICduZW80ai1qYXZhc2NyaXB0LycgKyBfdmVyc2lvbltcImRlZmF1bHRcIl07XG4vKipcbiAqIE9iamVjdCBjb250YWluaW5nIHByZWRlZmluZWQgbG9nZ2luZyBjb25maWd1cmF0aW9ucy4gVGhlc2UgYXJlIGV4cGVjdGVkIHRvIGJlIHVzZWQgYXMgdmFsdWVzIG9mIHRoZSBkcml2ZXIgY29uZmlnJ3MgYGxvZ2dpbmdgIHByb3BlcnR5LlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihsZXZlbDogP3N0cmluZyk6IG9iamVjdH0gY29uc29sZSB0aGUgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbG9nZ2luZyBjb25maWcgdGhhdCBwcmludHMgYWxsIG1lc3NhZ2VzIHRvIGBjb25zb2xlLmxvZ2Agd2l0aFxuICogdGltZXN0YW1wLCBsZXZlbCBhbmQgbWVzc2FnZS4gSXQgdGFrZXMgYW4gb3B0aW9uYWwgYGxldmVsYCBwYXJhbWV0ZXIgd2hpY2ggcmVwcmVzZW50cyB0aGUgbWF4aW11bSBsb2cgbGV2ZWwgdG8gYmUgbG9nZ2VkLiBEZWZhdWx0IHZhbHVlIGlzICdpbmZvJy5cbiAqL1xuXG52YXIgbG9nZ2luZyA9IHtcbiAgY29uc29sZTogZnVuY3Rpb24gKF9jb25zb2xlKSB7XG4gICAgZnVuY3Rpb24gY29uc29sZShfeCkge1xuICAgICAgcmV0dXJuIF9jb25zb2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgY29uc29sZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfY29uc29sZS50b1N0cmluZygpO1xuICAgIH07XG5cbiAgICByZXR1cm4gY29uc29sZTtcbiAgfShmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgbG9nZ2VyOiBmdW5jdGlvbiBsb2dnZXIobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKFwiXCIuY29uY2F0KGdsb2JhbC5EYXRlLm5vdygpLCBcIiBcIikuY29uY2F0KGxldmVsLnRvVXBwZXJDYXNlKCksIFwiIFwiKS5jb25jYXQobWVzc2FnZSkpO1xuICAgICAgfVxuICAgIH07XG4gIH0pXG59O1xuLyoqXG4gKiBPYmplY3QgY29udGFpbmluZyBjb25zdHJ1Y3RvcnMgZm9yIGFsbCBuZW80aiB0eXBlcy5cbiAqL1xuXG5leHBvcnRzLmxvZ2dpbmcgPSBsb2dnaW5nO1xudmFyIHR5cGVzID0ge1xuICBOb2RlOiBfZ3JhcGhUeXBlcy5Ob2RlLFxuICBSZWxhdGlvbnNoaXA6IF9ncmFwaFR5cGVzLlJlbGF0aW9uc2hpcCxcbiAgVW5ib3VuZFJlbGF0aW9uc2hpcDogX2dyYXBoVHlwZXMuVW5ib3VuZFJlbGF0aW9uc2hpcCxcbiAgUGF0aFNlZ21lbnQ6IF9ncmFwaFR5cGVzLlBhdGhTZWdtZW50LFxuICBQYXRoOiBfZ3JhcGhUeXBlcy5QYXRoLFxuICBSZXN1bHQ6IF9yZXN1bHRbXCJkZWZhdWx0XCJdLFxuICBSZXN1bHRTdW1tYXJ5OiBfcmVzdWx0U3VtbWFyeVtcImRlZmF1bHRcIl0sXG4gIFJlY29yZDogX3JlY29yZFtcImRlZmF1bHRcIl0sXG4gIFBvaW50OiBfc3BhdGlhbFR5cGVzLlBvaW50LFxuICBEYXRlOiBfdGVtcG9yYWxUeXBlcy5EYXRlLFxuICBEYXRlVGltZTogX3RlbXBvcmFsVHlwZXMuRGF0ZVRpbWUsXG4gIER1cmF0aW9uOiBfdGVtcG9yYWxUeXBlcy5EdXJhdGlvbixcbiAgTG9jYWxEYXRlVGltZTogX3RlbXBvcmFsVHlwZXMuTG9jYWxEYXRlVGltZSxcbiAgTG9jYWxUaW1lOiBfdGVtcG9yYWxUeXBlcy5Mb2NhbFRpbWUsXG4gIFRpbWU6IF90ZW1wb3JhbFR5cGVzLlRpbWUsXG4gIEludGVnZXI6IF9pbnRlZ2VyW1wiZGVmYXVsdFwiXVxufTtcbi8qKlxuICogT2JqZWN0IGNvbnRhaW5pbmcgc3RyaW5nIGNvbnN0YW50cyByZXByZXNlbnRpbmcgc2Vzc2lvbiBhY2Nlc3MgbW9kZXMuXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IHR5cGVzO1xudmFyIHNlc3Npb24gPSB7XG4gIFJFQUQ6IF9kcml2ZXIuUkVBRCxcbiAgV1JJVEU6IF9kcml2ZXIuV1JJVEVcbn07XG4vKipcbiAqIE9iamVjdCBjb250YWluaW5nIHN0cmluZyBjb25zdGFudHMgcmVwcmVzZW50aW5nIHByZWRlZmluZWQge0BsaW5rIE5lbzRqRXJyb3J9IGNvZGVzLlxuICovXG5cbmV4cG9ydHMuc2Vzc2lvbiA9IHNlc3Npb247XG52YXIgZXJyb3IgPSB7XG4gIFNFUlZJQ0VfVU5BVkFJTEFCTEU6IF9lcnJvci5TRVJWSUNFX1VOQVZBSUxBQkxFLFxuICBTRVNTSU9OX0VYUElSRUQ6IF9lcnJvci5TRVNTSU9OX0VYUElSRUQsXG4gIFBST1RPQ09MX0VSUk9SOiBfZXJyb3IuUFJPVE9DT0xfRVJST1Jcbn07XG4vKipcbiAqIE9iamVjdCBjb250YWluaW5nIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGgge0BsaW5rIEludGVnZXJ9IG9iamVjdHMuXG4gKi9cblxuZXhwb3J0cy5lcnJvciA9IGVycm9yO1xudmFyIGludGVnZXIgPSB7XG4gIHRvTnVtYmVyOiBfaW50ZWdlci50b051bWJlcixcbiAgdG9TdHJpbmc6IF9pbnRlZ2VyLnRvU3RyaW5nLFxuICBpblNhZmVSYW5nZTogX2ludGVnZXIuaW5TYWZlUmFuZ2Vcbn07XG4vKipcbiAqIE9iamVjdCBjb250YWluaW5nIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggc3BhdGlhbCB0eXBlcywgbGlrZSB7QGxpbmsgUG9pbnR9LlxuICovXG5cbmV4cG9ydHMuaW50ZWdlciA9IGludGVnZXI7XG52YXIgc3BhdGlhbCA9IHtcbiAgaXNQb2ludDogX3NwYXRpYWxUeXBlcy5pc1BvaW50XG59O1xuLyoqXG4gKiBPYmplY3QgY29udGFpbmluZyBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRlbXBvcmFsIHR5cGVzLCBsaWtlIHtAbGluayBUaW1lfSBvciB7QGxpbmsgRHVyYXRpb259LlxuICovXG5cbmV4cG9ydHMuc3BhdGlhbCA9IHNwYXRpYWw7XG52YXIgdGVtcG9yYWwgPSB7XG4gIGlzRHVyYXRpb246IF90ZW1wb3JhbFR5cGVzLmlzRHVyYXRpb24sXG4gIGlzTG9jYWxUaW1lOiBfdGVtcG9yYWxUeXBlcy5pc0xvY2FsVGltZSxcbiAgaXNUaW1lOiBfdGVtcG9yYWxUeXBlcy5pc1RpbWUsXG4gIGlzRGF0ZTogX3RlbXBvcmFsVHlwZXMuaXNEYXRlLFxuICBpc0xvY2FsRGF0ZVRpbWU6IF90ZW1wb3JhbFR5cGVzLmlzTG9jYWxEYXRlVGltZSxcbiAgaXNEYXRlVGltZTogX3RlbXBvcmFsVHlwZXMuaXNEYXRlVGltZVxufTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnRlbXBvcmFsID0gdGVtcG9yYWw7XG52YXIgZm9yRXhwb3J0ID0ge1xuICBkcml2ZXI6IGRyaXZlcixcbiAgXCJpbnRcIjogX2ludGVnZXJbXCJpbnRcIl0sXG4gIGlzSW50OiBfaW50ZWdlci5pc0ludCxcbiAgaXNQb2ludDogX3NwYXRpYWxUeXBlcy5pc1BvaW50LFxuICBpc0R1cmF0aW9uOiBfdGVtcG9yYWxUeXBlcy5pc0R1cmF0aW9uLFxuICBpc0xvY2FsVGltZTogX3RlbXBvcmFsVHlwZXMuaXNMb2NhbFRpbWUsXG4gIGlzVGltZTogX3RlbXBvcmFsVHlwZXMuaXNUaW1lLFxuICBpc0RhdGU6IF90ZW1wb3JhbFR5cGVzLmlzRGF0ZSxcbiAgaXNMb2NhbERhdGVUaW1lOiBfdGVtcG9yYWxUeXBlcy5pc0xvY2FsRGF0ZVRpbWUsXG4gIGlzRGF0ZVRpbWU6IF90ZW1wb3JhbFR5cGVzLmlzRGF0ZVRpbWUsXG4gIGludGVnZXI6IGludGVnZXIsXG4gIE5lbzRqRXJyb3I6IF9lcnJvci5OZW80akVycm9yLFxuICBhdXRoOiBhdXRoLFxuICBsb2dnaW5nOiBsb2dnaW5nLFxuICB0eXBlczogdHlwZXMsXG4gIHNlc3Npb246IHNlc3Npb24sXG4gIGVycm9yOiBlcnJvcixcbiAgc3BhdGlhbDogc3BhdGlhbCxcbiAgdGVtcG9yYWw6IHRlbXBvcmFsXG59O1xudmFyIF9kZWZhdWx0ID0gZm9yRXhwb3J0O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4cG9ydHMudG9TdHJpbmcgPSBleHBvcnRzLnRvTnVtYmVyID0gZXhwb3J0cy5pblNhZmVSYW5nZSA9IGV4cG9ydHMuaXNJbnQgPSBleHBvcnRzW1wiaW50XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gNjQtYml0IEludGVnZXIgbGlicmFyeSwgb3JpZ2luYWxseSBmcm9tIExvbmcuanMgYnkgZGNvZGVJT1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vTG9uZy5qc1xuLy8gTGljZW5zZSBBcGFjaGUgMlxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXG4gKiBTZWUgZXhwb3J0ZWQgZnVuY3Rpb25zIGZvciBtb3JlIGNvbnZlbmllbnQgd2F5cyBvZiBvcGVyYXRpbmcgaW50ZWdlcnMuXG4gKiBVc2UgYGludCgpYCBmdW5jdGlvbiB0byBjcmVhdGUgbmV3IGludGVnZXJzLCBgaXNJbnQoKWAgdG8gY2hlY2sgaWYgZ2l2ZW4gb2JqZWN0IGlzIGludGVnZXIsXG4gKiBgaW5TYWZlUmFuZ2UoKWAgdG8gY2hlY2sgaWYgaXQgaXMgc2FmZSB0byBjb252ZXJ0IGdpdmVuIHZhbHVlIHRvIG5hdGl2ZSBudW1iZXIsXG4gKiBgdG9OdW1iZXIoKWAgYW5kIGB0b1N0cmluZygpYCB0byBjb252ZXJ0IGdpdmVuIGludGVnZXIgdG8gbnVtYmVyIG9yIHN0cmluZyByZXNwZWN0aXZlbHkuXG4gKiBAYWNjZXNzIHB1YmxpY1xuICogQGV4cG9ydHMgSW50ZWdlclxuICogQGNsYXNzIEEgSW50ZWdlciBjbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgVGhlIGxvdyAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEludGVnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnRlZ2VyKGxvdywgaGlnaCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgSW50ZWdlcik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcbiAgfSAvLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYW4gSW50ZWdlciBpcyB0aGUgdHdvIGdpdmVuIHNpZ25lZCwgMzItYml0IHZhbHVlcy5cbiAgLy8gV2UgdXNlIDMyLWJpdCBwaWVjZXMgYmVjYXVzZSB0aGVzZSBhcmUgdGhlIHNpemUgb2YgaW50ZWdlcnMgb24gd2hpY2hcbiAgLy8gSmF2YVNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXG4gIC8vIG11bHRpcGxpY2F0aW9uLCB3ZSBzcGxpdCBlYWNoIG51bWJlciBpbnRvIDE2IGJpdCBwaWVjZXMsIHdoaWNoIGNhbiBlYXNpbHkgYmVcbiAgLy8gbXVsdGlwbGllZCB3aXRoaW4gSmF2YVNjcmlwdCdzIGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgb3ZlcmZsb3dcbiAgLy8gb3IgY2hhbmdlIGluIHNpZ24uXG4gIC8vXG4gIC8vIEluIHRoZSBhbGdvcml0aG1zIGJlbG93LCB3ZSBmcmVxdWVudGx5IHJlZHVjZSB0aGUgbmVnYXRpdmUgY2FzZSB0byB0aGVcbiAgLy8gcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXG4gIC8vIE5vdGUgdGhhdCB3ZSBtdXN0IEFMV0FZUyBjaGVjayBzcGVjaWFsbHkgd2hldGhlciB0aG9zZSB2YWx1ZXMgYXJlIE1JTl9WQUxVRVxuICAvLyAoLTJeNjMpIGJlY2F1c2UgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUUgKHNpbmNlIDJeNjMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzXG4gIC8vIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcbiAgLy8gY2FzZSB3b3VsZCBvZnRlbiByZXN1bHQgaW4gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAvL1xuICAvLyBDb21tb24gY29uc3RhbnQgdmFsdWVzIFpFUk8sIE9ORSwgTkVHX09ORSwgZXRjLiBhcmUgZGVmaW5lZCBiZWxvdyB0aGUgZnJvbSpcbiAgLy8gbWV0aG9kcyBvbiB3aGljaCB0aGV5IGRlcGVuZC5cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoSW50ZWdlciwgW3tcbiAgICBrZXk6IFwiaW5TYWZlUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5TYWZlUmFuZ2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ncmVhdGVyVGhhbk9yRXF1YWwoSW50ZWdlci5NSU5fU0FGRV9WQUxVRSkgJiYgdGhpcy5sZXNzVGhhbk9yRXF1YWwoSW50ZWdlci5NQVhfU0FGRV9WQUxVRSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBJbnRlZ2VyIHRvIGFuIGV4YWN0IGphdmFzY3JpcHQgTnVtYmVyLCBhc3N1bWluZyBpdCBpcyBhIDMyIGJpdCBpbnRlZ2VyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9JbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9JbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb3c7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBJbnRlZ2VyIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9OdW1iZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9OdW1iZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgSW50ZWdlciB0byBuYXRpdmUgbnVtYmVyIG9yIC1JbmZpbml0eS8rSW5maW5pdHkgd2hlbiBpdCBkb2VzIG5vdCBmaXQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b051bWJlck9ySW5maW5pdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9OdW1iZXJPckluZmluaXR5KCkge1xuICAgICAgaWYgKHRoaXMubGVzc1RoYW4oSW50ZWdlci5NSU5fU0FGRV9WQUxVRSkpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5ncmVhdGVyVGhhbihJbnRlZ2VyLk1BWF9TQUZFX1ZBTFVFKSkge1xuICAgICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9OdW1iZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIEludGVnZXIgdG8gYSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkge1xuICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDtcblxuICAgICAgaWYgKHJhZGl4IDwgMiB8fCByYWRpeCA+IDM2KSB7XG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4IG91dCBvZiByYW5nZTogJyArIHJhZGl4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgcmV0dXJuICcwJztcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbTtcblxuICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgIGlmICh0aGlzLmVxdWFscyhJbnRlZ2VyLk1JTl9WQUxVRSkpIHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgSW50ZWdlciB2YWx1ZSBiZWZvcmUgaXQgY2FuIGJlIG5lZ2F0ZWQsIHNvIHdlIHJlbW92ZVxuICAgICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cbiAgICAgICAgICB2YXIgcmFkaXhJbnRlZ2VyID0gSW50ZWdlci5mcm9tTnVtYmVyKHJhZGl4KTtcbiAgICAgICAgICB2YXIgZGl2ID0gdGhpcy5kaXYocmFkaXhJbnRlZ2VyKTtcbiAgICAgICAgICByZW0gPSBkaXYubXVsdGlwbHkocmFkaXhJbnRlZ2VyKS5zdWJ0cmFjdCh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJy0nICsgdGhpcy5uZWdhdGUoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xuICAgICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXG5cblxuICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IEludGVnZXIuZnJvbU51bWJlcihNYXRoLnBvdyhyYWRpeCwgNikpO1xuICAgICAgcmVtID0gdGhpcztcbiAgICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKTtcbiAgICAgICAgdmFyIGludHZhbCA9IHJlbS5zdWJ0cmFjdChyZW1EaXYubXVsdGlwbHkocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMDtcbiAgICAgICAgdmFyIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XG4gICAgICAgIHJlbSA9IHJlbURpdjtcblxuICAgICAgICBpZiAocmVtLmlzWmVybygpKSB7XG4gICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAgIGRpZ2l0cyA9ICcwJyArIGRpZ2l0cztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgaGlnaCBiaXRzXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SGlnaEJpdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGlnaEJpdHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaWdoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBsb3cgYml0c1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldExvd0JpdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TG93Qml0cygpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBJbnRlZ2VyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TnVtQml0c0Fic1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xuICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhJbnRlZ2VyLk1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnYXRlKCkuZ2V0TnVtQml0c0FicygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9PSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XG5cbiAgICAgIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSkge1xuICAgICAgICBpZiAoKHZhbCAmIDEgPDwgYml0KSAhPT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmhpZ2ggIT09IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgSW50ZWdlcidzIHZhbHVlIGVxdWFscyB6ZXJvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzWmVyb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1plcm8oKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIEludGVnZXIncyB2YWx1ZSBpcyBuZWdhdGl2ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc05lZ2F0aXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaWdoIDwgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBJbnRlZ2VyJ3MgdmFsdWUgaXMgcG9zaXRpdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNQb3NpdGl2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGlnaCA+PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIEludGVnZXIncyB2YWx1ZSBpcyBvZGQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNPZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNPZGQoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgSW50ZWdlcidzIHZhbHVlIGlzIGV2ZW4uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNFdmVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRXZlbigpIHtcbiAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBJbnRlZ2VyJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXF1YWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgICAgaWYgKCFJbnRlZ2VyLmlzSW50ZWdlcihvdGhlcikpIHtcbiAgICAgICAgb3RoZXIgPSBJbnRlZ2VyLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBJbnRlZ2VyJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibm90RXF1YWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikge1xuICAgICAgcmV0dXJuICF0aGlzLmVxdWFscyhcbiAgICAgIC8qIHZhbGlkYXRlcyAqL1xuICAgICAgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIEludGVnZXIncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsZXNzVGhhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShcbiAgICAgIC8qIHZhbGlkYXRlcyAqL1xuICAgICAgb3RoZXIpIDwgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBJbnRlZ2VyJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGVzc1RoYW5PckVxdWFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlc3NUaGFuT3JFcXVhbChvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShcbiAgICAgIC8qIHZhbGlkYXRlcyAqL1xuICAgICAgb3RoZXIpIDw9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgSW50ZWdlcidzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdyZWF0ZXJUaGFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wYXJlKFxuICAgICAgLyogdmFsaWRhdGVzICovXG4gICAgICBvdGhlcikgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIEludGVnZXIncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJncmVhdGVyVGhhbk9yRXF1YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wYXJlKFxuICAgICAgLyogdmFsaWRhdGVzICovXG4gICAgICBvdGhlcikgPj0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdGhpcyBJbnRlZ2VyJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcbiAgICAgKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGFyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XG4gICAgICBpZiAoIUludGVnZXIuaXNJbnRlZ2VyKG90aGVyKSkge1xuICAgICAgICBvdGhlciA9IEludGVnZXIuZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZXF1YWxzKG90aGVyKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKTtcbiAgICAgIHZhciBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcblxuICAgICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXG5cblxuICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3Qob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmVnYXRlcyB0aGlzIEludGVnZXIncyB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9IE5lZ2F0ZWQgSW50ZWdlclxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5lZ2F0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZWdhdGUoKSB7XG4gICAgICBpZiAodGhpcy5lcXVhbHMoSW50ZWdlci5NSU5fVkFMVUUpKSB7XG4gICAgICAgIHJldHVybiBJbnRlZ2VyLk1JTl9WQUxVRTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKEludGVnZXIuT05FKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZWdlci5cbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9IFN1bVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XG4gICAgICBpZiAoIUludGVnZXIuaXNJbnRlZ2VyKGFkZGVuZCkpIHtcbiAgICAgICAgYWRkZW5kID0gSW50ZWdlci5mcm9tVmFsdWUoYWRkZW5kKTtcbiAgICAgIH0gLy8gRGl2aWRlIGVhY2ggbnVtYmVyIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gc3VtIHRoZSBjaHVua3MuXG5cblxuICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhmZmZmO1xuICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4ZmZmZjtcbiAgICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XG4gICAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweGZmZmY7XG4gICAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XG4gICAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4ZmZmZjtcbiAgICAgIHZhciBjNDggPSAwO1xuICAgICAgdmFyIGMzMiA9IDA7XG4gICAgICB2YXIgYzE2ID0gMDtcbiAgICAgIHZhciBjMDAgPSAwO1xuICAgICAgYzAwICs9IGEwMCArIGIwMDtcbiAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgICAgYzAwICY9IDB4ZmZmZjtcbiAgICAgIGMxNiArPSBhMTYgKyBiMTY7XG4gICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICAgIGMxNiAmPSAweGZmZmY7XG4gICAgICBjMzIgKz0gYTMyICsgYjMyO1xuICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICBjMzIgJj0gMHhmZmZmO1xuICAgICAgYzQ4ICs9IGE0OCArIGI0ODtcbiAgICAgIGM0OCAmPSAweGZmZmY7XG4gICAgICByZXR1cm4gSW50ZWdlci5mcm9tQml0cyhjMTYgPDwgMTYgfCBjMDAsIGM0OCA8PCAxNiB8IGMzMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBJbnRlZ2VyLlxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gICAgICogQHJldHVybnMgeyFJbnRlZ2VyfSBEaWZmZXJlbmNlXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3VidHJhY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkge1xuICAgICAgaWYgKCFJbnRlZ2VyLmlzSW50ZWdlcihzdWJ0cmFoZW5kKSkge1xuICAgICAgICBzdWJ0cmFoZW5kID0gSW50ZWdlci5mcm9tVmFsdWUoc3VidHJhaGVuZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZ2F0ZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIEludGVnZXIuXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9IFByb2R1Y3RcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtdWx0aXBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtdWx0aXBseShtdWx0aXBsaWVyKSB7XG4gICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICByZXR1cm4gSW50ZWdlci5aRVJPO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUludGVnZXIuaXNJbnRlZ2VyKG11bHRpcGxpZXIpKSB7XG4gICAgICAgIG11bHRpcGxpZXIgPSBJbnRlZ2VyLmZyb21WYWx1ZShtdWx0aXBsaWVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgcmV0dXJuIEludGVnZXIuWkVSTztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZXF1YWxzKEludGVnZXIuTUlOX1ZBTFVFKSkge1xuICAgICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gSW50ZWdlci5NSU5fVkFMVUUgOiBJbnRlZ2VyLlpFUk87XG4gICAgICB9XG5cbiAgICAgIGlmIChtdWx0aXBsaWVyLmVxdWFscyhJbnRlZ2VyLk1JTl9WQUxVRSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IEludGVnZXIuTUlOX1ZBTFVFIDogSW50ZWdlci5aRVJPO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCkubXVsdGlwbHkobXVsdGlwbGllci5uZWdhdGUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCkubXVsdGlwbHkobXVsdGlwbGllcikubmVnYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkobXVsdGlwbGllci5uZWdhdGUoKSkubmVnYXRlKCk7XG4gICAgICB9IC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cblxuXG4gICAgICBpZiAodGhpcy5sZXNzVGhhbihUV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmxlc3NUaGFuKFRXT19QV1JfMjQpKSB7XG4gICAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpKTtcbiAgICAgIH0gLy8gRGl2aWRlIGVhY2ggbG9uZyBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIGFkZCB1cCA0eDQgcHJvZHVjdHMuXG4gICAgICAvLyBXZSBjYW4gc2tpcCBwcm9kdWN0cyB0aGF0IHdvdWxkIG92ZXJmbG93LlxuXG5cbiAgICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4ZmZmZjtcbiAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweGZmZmY7XG4gICAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcbiAgICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweGZmZmY7XG4gICAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xuICAgICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhmZmZmO1xuICAgICAgdmFyIGM0OCA9IDA7XG4gICAgICB2YXIgYzMyID0gMDtcbiAgICAgIHZhciBjMTYgPSAwO1xuICAgICAgdmFyIGMwMCA9IDA7XG4gICAgICBjMDAgKz0gYTAwICogYjAwO1xuICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgICBjMDAgJj0gMHhmZmZmO1xuICAgICAgYzE2ICs9IGExNiAqIGIwMDtcbiAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgICAgYzE2ICY9IDB4ZmZmZjtcbiAgICAgIGMxNiArPSBhMDAgKiBiMTY7XG4gICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICAgIGMxNiAmPSAweGZmZmY7XG4gICAgICBjMzIgKz0gYTMyICogYjAwO1xuICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICBjMzIgJj0gMHhmZmZmO1xuICAgICAgYzMyICs9IGExNiAqIGIxNjtcbiAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgIGMzMiArPSBhMDAgKiBiMzI7XG4gICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgIGMzMiAmPSAweGZmZmY7XG4gICAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xuICAgICAgYzQ4ICY9IDB4ZmZmZjtcbiAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIEludGVnZXIgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAgICogQHJldHVybnMgeyFJbnRlZ2VyfSBRdW90aWVudFxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpdlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXYoZGl2aXNvcikge1xuICAgICAgaWYgKCFJbnRlZ2VyLmlzSW50ZWdlcihkaXZpc29yKSkge1xuICAgICAgICBkaXZpc29yID0gSW50ZWdlci5mcm9tVmFsdWUoZGl2aXNvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXZpc29yLmlzWmVybygpKSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdkaXZpc2lvbiBieSB6ZXJvJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgIHJldHVybiBJbnRlZ2VyLlpFUk87XG4gICAgICB9XG5cbiAgICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xuXG4gICAgICBpZiAodGhpcy5lcXVhbHMoSW50ZWdlci5NSU5fVkFMVUUpKSB7XG4gICAgICAgIGlmIChkaXZpc29yLmVxdWFscyhJbnRlZ2VyLk9ORSkgfHwgZGl2aXNvci5lcXVhbHMoSW50ZWdlci5ORUdfT05FKSkge1xuICAgICAgICAgIHJldHVybiBJbnRlZ2VyLk1JTl9WQUxVRTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXZpc29yLmVxdWFscyhJbnRlZ2VyLk1JTl9WQUxVRSkpIHtcbiAgICAgICAgICByZXR1cm4gSW50ZWdlci5PTkU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxuICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hpZnRSaWdodCgxKTtcbiAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hpZnRMZWZ0KDEpO1xuXG4gICAgICAgICAgaWYgKGFwcHJveC5lcXVhbHMoSW50ZWdlci5aRVJPKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gSW50ZWdlci5PTkUgOiBJbnRlZ2VyLk5FR19PTkU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbSA9IHRoaXMuc3VidHJhY3QoZGl2aXNvci5tdWx0aXBseShhcHByb3gpKTtcbiAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxdWFscyhJbnRlZ2VyLk1JTl9WQUxVRSkpIHtcbiAgICAgICAgcmV0dXJuIEludGVnZXIuWkVSTztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpLmRpdihkaXZpc29yLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpLmRpdihkaXZpc29yKS5uZWdhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnYXRlKCkpLm5lZ2F0ZSgpO1xuICAgICAgfSAvLyBSZXBlYXQgdGhlIGZvbGxvd2luZyB1bnRpbCB0aGUgcmVtYWluZGVyIGlzIGxlc3MgdGhhbiBvdGhlcjogIGZpbmQgYVxuICAgICAgLy8gZmxvYXRpbmctcG9pbnQgdGhhdCBhcHByb3hpbWF0ZXMgcmVtYWluZGVyIC8gb3RoZXIgKmZyb20gYmVsb3cqLCBhZGQgdGhpc1xuICAgICAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxuICAgICAgLy8gdGhlIGFwcHJveGltYXRlIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcmVhbCB2YWx1ZSBzbyB0aGF0IHRoZVxuICAgICAgLy8gcmVtYWluZGVyIG5ldmVyIGJlY29tZXMgbmVnYXRpdmUuXG5cblxuICAgICAgcmVzID0gSW50ZWdlci5aRVJPO1xuICAgICAgcmVtID0gdGhpcztcblxuICAgICAgd2hpbGUgKHJlbS5ncmVhdGVyVGhhbk9yRXF1YWwoZGl2aXNvcikpIHtcbiAgICAgICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxuICAgICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cbiAgICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpOyAvLyBXZSB3aWxsIHR3ZWFrIHRoZSBhcHByb3hpbWF0ZSByZXN1bHQgYnkgY2hhbmdpbmcgaXQgaW4gdGhlIDQ4LXRoIGRpZ2l0IG9yXG4gICAgICAgIC8vIHRoZSBzbWFsbGVzdCBub24tZnJhY3Rpb25hbCBkaWdpdCwgd2hpY2hldmVyIGlzIGxhcmdlci5cblxuICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpO1xuICAgICAgICB2YXIgZGVsdGEgPSBsb2cyIDw9IDQ4ID8gMSA6IE1hdGgucG93KDIsIGxvZzIgLSA0OCk7IC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxuICAgICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cblxuICAgICAgICB2YXIgYXBwcm94UmVzID0gSW50ZWdlci5mcm9tTnVtYmVyKGFwcHJveCk7XG4gICAgICAgIHZhciBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsdGlwbHkoZGl2aXNvcik7XG5cbiAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmdyZWF0ZXJUaGFuKHJlbSkpIHtcbiAgICAgICAgICBhcHByb3ggLT0gZGVsdGE7XG4gICAgICAgICAgYXBwcm94UmVzID0gSW50ZWdlci5mcm9tTnVtYmVyKGFwcHJveCk7XG4gICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bHRpcGx5KGRpdmlzb3IpO1xuICAgICAgICB9IC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxuICAgICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cblxuXG4gICAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhcHByb3hSZXMgPSBJbnRlZ2VyLk9ORTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcbiAgICAgICAgcmVtID0gcmVtLnN1YnRyYWN0KGFwcHJveFJlbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBJbnRlZ2VyIG1vZHVsbyB0aGUgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAgICogQHJldHVybnMgeyFJbnRlZ2VyfSBSZW1haW5kZXJcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtb2R1bG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHtcbiAgICAgIGlmICghSW50ZWdlci5pc0ludGVnZXIoZGl2aXNvcikpIHtcbiAgICAgICAgZGl2aXNvciA9IEludGVnZXIuZnJvbVZhbHVlKGRpdmlzb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdCh0aGlzLmRpdihkaXZpc29yKS5tdWx0aXBseShkaXZpc29yKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgSW50ZWdlci5cbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibm90XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vdCgpIHtcbiAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgQU5EIG9mIHRoaXMgSW50ZWdlciBhbmQgdGhlIHNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIEludGVnZXJcbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuZChvdGhlcikge1xuICAgICAgaWYgKCFJbnRlZ2VyLmlzSW50ZWdlcihvdGhlcikpIHtcbiAgICAgICAgb3RoZXIgPSBJbnRlZ2VyLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21CaXRzKHRoaXMubG93ICYgb3RoZXIubG93LCB0aGlzLmhpZ2ggJiBvdGhlci5oaWdoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIEludGVnZXIgYW5kIHRoZSBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBJbnRlZ2VyXG4gICAgICogQHJldHVybnMgeyFJbnRlZ2VyfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9yKG90aGVyKSB7XG4gICAgICBpZiAoIUludGVnZXIuaXNJbnRlZ2VyKG90aGVyKSkge1xuICAgICAgICBvdGhlciA9IEludGVnZXIuZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEludGVnZXIuZnJvbUJpdHModGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIEludGVnZXIgYW5kIHRoZSBnaXZlbiBvbmUuXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBJbnRlZ2VyXG4gICAgICogQHJldHVybnMgeyFJbnRlZ2VyfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInhvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB4b3Iob3RoZXIpIHtcbiAgICAgIGlmICghSW50ZWdlci5pc0ludGVnZXIob3RoZXIpKSB7XG4gICAgICAgIG90aGVyID0gSW50ZWdlci5mcm9tVmFsdWUob3RoZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gSW50ZWdlci5mcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBJbnRlZ2VyIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUludGVnZXJ9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9IFNoaWZ0ZWQgSW50ZWdlclxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0TGVmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xuICAgICAgaWYgKEludGVnZXIuaXNJbnRlZ2VyKG51bUJpdHMpKSB7XG4gICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKG51bUJpdHMgPCAzMikge1xuICAgICAgICByZXR1cm4gSW50ZWdlci5mcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzLCB0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiAzMiAtIG51bUJpdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEludGVnZXIuZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgbnVtQml0cyAtIDMyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIEludGVnZXIgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUludGVnZXJ9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9IFNoaWZ0ZWQgSW50ZWdlclxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0UmlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XG4gICAgICBpZiAoSW50ZWdlci5pc0ludGVnZXIobnVtQml0cykpIHtcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA8IDMyKSB7XG4gICAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21CaXRzKHRoaXMubG93ID4+PiBudW1CaXRzIHwgdGhpcy5oaWdoIDw8IDMyIC0gbnVtQml0cywgdGhpcy5oaWdoID4+IG51bUJpdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEludGVnZXIuZnJvbUJpdHModGhpcy5oaWdoID4+IG51bUJpdHMgLSAzMiwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSW50ZWdlcjtcbn0oKTtcbi8qKlxuICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEludGVnZXIgb3Igbm90LlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAY29uc3RcbiAqIEBleHBvc2VcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5JbnRlZ2VyLl9faXNJbnRlZ2VyX18gPSB0cnVlO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEludGVnZXIucHJvdG90eXBlLCAnX19pc0ludGVnZXJfXycsIHtcbiAgdmFsdWU6IHRydWUsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59KTtcbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBJbnRlZ2VyLlxuICogQGFjY2VzcyBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQGV4cG9zZVxuICovXG5cbkludGVnZXIuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gKG9iaiAmJiBvYmouX19pc0ludGVnZXJfXykgPT09IHRydWU7XG59O1xuLyoqXG4gKiBBIGNhY2hlIG9mIHRoZSBJbnRlZ2VyIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCBpbnRlZ2VyIHZhbHVlcy5cbiAqIEB0eXBlIHshT2JqZWN0fVxuICogQGlubmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cblxudmFyIElOVF9DQUNIRSA9IHt9O1xuLyoqXG4gKiBSZXR1cm5zIGEgSW50ZWdlciByZXByZXNlbnRpbmcgdGhlIGdpdmVuIDMyIGJpdCBpbnRlZ2VyIHZhbHVlLlxuICogQGFjY2VzcyBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIDMyIGJpdCBpbnRlZ2VyIGluIHF1ZXN0aW9uXG4gKiBAcmV0dXJucyB7IUludGVnZXJ9IFRoZSBjb3JyZXNwb25kaW5nIEludGVnZXIgdmFsdWVcbiAqIEBleHBvc2VcbiAqL1xuXG5JbnRlZ2VyLmZyb21JbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIG9iaiwgY2FjaGVkT2JqO1xuICB2YWx1ZSA9IHZhbHVlIHwgMDtcblxuICBpZiAodmFsdWUgPj0gLTEyOCAmJiB2YWx1ZSA8IDEyOCkge1xuICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XG5cbiAgICBpZiAoY2FjaGVkT2JqKSB7XG4gICAgICByZXR1cm4gY2FjaGVkT2JqO1xuICAgIH1cbiAgfVxuXG4gIG9iaiA9IG5ldyBJbnRlZ2VyKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTtcblxuICBpZiAodmFsdWUgPj0gLTEyOCAmJiB2YWx1ZSA8IDEyOCkge1xuICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcbi8qKlxuICogUmV0dXJucyBhIEludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cbiAqIEByZXR1cm5zIHshSW50ZWdlcn0gVGhlIGNvcnJlc3BvbmRpbmcgSW50ZWdlciB2YWx1ZVxuICogQGV4cG9zZVxuICovXG5cblxuSW50ZWdlci5mcm9tTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkge1xuICAgIHJldHVybiBJbnRlZ2VyLlpFUk87XG4gIH1cblxuICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKSB7XG4gICAgcmV0dXJuIEludGVnZXIuTUlOX1ZBTFVFO1xuICB9XG5cbiAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTCkge1xuICAgIHJldHVybiBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA8IDApIHtcbiAgICByZXR1cm4gSW50ZWdlci5mcm9tTnVtYmVyKC12YWx1ZSkubmVnYXRlKCk7XG4gIH1cblxuICByZXR1cm4gbmV3IEludGVnZXIodmFsdWUgJSBUV09fUFdSXzMyX0RCTCB8IDAsIHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwgfCAwKTtcbn07XG4vKipcbiAqIFJldHVybnMgYSBJbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xuICogIGFzc3VtZWQgdG8gdXNlIDMyIGJpdHMuXG4gKiBAYWNjZXNzIHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzIFRoZSBoaWdoIDMyIGJpdHNcbiAqIEByZXR1cm5zIHshSW50ZWdlcn0gVGhlIGNvcnJlc3BvbmRpbmcgSW50ZWdlciB2YWx1ZVxuICogQGV4cG9zZVxuICovXG5cblxuSW50ZWdlci5mcm9tQml0cyA9IGZ1bmN0aW9uIChsb3dCaXRzLCBoaWdoQml0cykge1xuICByZXR1cm4gbmV3IEludGVnZXIobG93Qml0cywgaGlnaEJpdHMpO1xufTtcbi8qKlxuICogUmV0dXJucyBhIEludGVnZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICogQGFjY2VzcyBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBJbnRlZ2VyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcbiAqIEByZXR1cm5zIHshSW50ZWdlcn0gVGhlIGNvcnJlc3BvbmRpbmcgSW50ZWdlciB2YWx1ZVxuICogQGV4cG9zZVxuICovXG5cblxuSW50ZWdlci5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0ciwgcmFkaXgpIHtcbiAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnbnVtYmVyIGZvcm1hdCBlcnJvcjogZW1wdHkgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAoc3RyID09PSAnTmFOJyB8fCBzdHIgPT09ICdJbmZpbml0eScgfHwgc3RyID09PSAnK0luZmluaXR5JyB8fCBzdHIgPT09ICctSW5maW5pdHknKSB7XG4gICAgcmV0dXJuIEludGVnZXIuWkVSTztcbiAgfVxuXG4gIHJhZGl4ID0gcmFkaXggfHwgMTA7XG5cbiAgaWYgKHJhZGl4IDwgMiB8fCByYWRpeCA+IDM2KSB7XG4gICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ3JhZGl4IG91dCBvZiByYW5nZTogJyArIHJhZGl4KTtcbiAgfVxuXG4gIHZhciBwO1xuXG4gIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMCkge1xuICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdudW1iZXIgZm9ybWF0IGVycm9yOiBpbnRlcmlvciBcIi1cIiBjaGFyYWN0ZXI6ICcgKyBzdHIpO1xuICB9IGVsc2UgaWYgKHAgPT09IDApIHtcbiAgICByZXR1cm4gSW50ZWdlci5mcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHJhZGl4KS5uZWdhdGUoKTtcbiAgfSAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXG4gIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxuXG5cbiAgdmFyIHJhZGl4VG9Qb3dlciA9IEludGVnZXIuZnJvbU51bWJlcihNYXRoLnBvdyhyYWRpeCwgOCkpO1xuICB2YXIgcmVzdWx0ID0gSW50ZWdlci5aRVJPO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSk7XG4gICAgdmFyIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcblxuICAgIGlmIChzaXplIDwgOCkge1xuICAgICAgdmFyIHBvd2VyID0gSW50ZWdlci5mcm9tTnVtYmVyKE1hdGgucG93KHJhZGl4LCBzaXplKSk7XG4gICAgICByZXN1bHQgPSByZXN1bHQubXVsdGlwbHkocG93ZXIpLmFkZChJbnRlZ2VyLmZyb21OdW1iZXIodmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bHRpcGx5KHJhZGl4VG9Qb3dlcik7XG4gICAgICByZXN1bHQgPSByZXN1bHQuYWRkKEludGVnZXIuZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgSW50ZWdlci5cbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlcn19IHZhbCBWYWx1ZVxuICogQHJldHVybnMgeyFJbnRlZ2VyfVxuICogQGV4cG9zZVxuICovXG5cblxuSW50ZWdlci5mcm9tVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIGlmICh2YWxcbiAgLyogaXMgY29tcGF0aWJsZSAqL1xuICBpbnN0YW5jZW9mIEludGVnZXIpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIEludGVnZXIuZnJvbU51bWJlcih2YWwpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIEludGVnZXIuZnJvbVN0cmluZyh2YWwpO1xuICB9IC8vIFRocm93cyBmb3Igbm9uLW9iamVjdHMsIGNvbnZlcnRzIG5vbi1pbnN0YW5jZW9mIEludGVnZXI6XG5cblxuICByZXR1cm4gbmV3IEludGVnZXIodmFsLmxvdywgdmFsLmhpZ2gpO1xufTtcbi8qKlxuICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIG51bWJlci5cbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlcn19IHZhbCBWYWx1ZVxuICogQHJldHVybnMge251bWJlcn1cbiAqIEBleHBvc2VcbiAqL1xuXG5cbkludGVnZXIudG9OdW1iZXIgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiBJbnRlZ2VyLmZyb21WYWx1ZSh2YWwpLnRvTnVtYmVyKCk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgc3RyaW5nLlxuICogQGFjY2VzcyBwcml2YXRlXG4gKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyfX0gdmFsIFZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXggb3B0aW9uYWwgcmFkaXggZm9yIHN0cmluZyBjb252ZXJzaW9uLCBkZWZhdWx0cyB0byAxMFxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBleHBvc2VcbiAqL1xuXG5cbkludGVnZXIudG9TdHJpbmcgPSBmdW5jdGlvbiAodmFsLCByYWRpeCkge1xuICByZXR1cm4gSW50ZWdlci5mcm9tVmFsdWUodmFsKS50b1N0cmluZyhyYWRpeCk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGluIHRoZSBzYWZlIHJhbmdlIGluIG9yZGVyIHRvIGJlIGNvbnZlcnRlZCB0byBhIG5hdGl2ZSBudW1iZXJcbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlcn19IHZhbCBWYWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl4IG9wdGlvbmFsIHJhZGl4IGZvciBzdHJpbmcgY29udmVyc2lvbiwgZGVmYXVsdHMgdG8gMTBcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQGV4cG9zZVxuICovXG5cblxuSW50ZWdlci5pblNhZmVSYW5nZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIEludGVnZXIuZnJvbVZhbHVlKHZhbCkuaW5TYWZlUmFuZ2UoKTtcbn07XG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqIEBpbm5lclxuICogQHByaXZhdGVcbiAqL1xuXG5cbnZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqIEBpbm5lclxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKiBAaW5uZXJcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDtcbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqIEBpbm5lclxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XG4vKipcbiAqIEB0eXBlIHshSW50ZWdlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBUV09fUFdSXzI0ID0gSW50ZWdlci5mcm9tSW50KFRXT19QV1JfMjRfREJMKTtcbi8qKlxuICogU2lnbmVkIHplcm8uXG4gKiBAdHlwZSB7IUludGVnZXJ9XG4gKiBAZXhwb3NlXG4gKi9cblxuSW50ZWdlci5aRVJPID0gSW50ZWdlci5mcm9tSW50KDApO1xuLyoqXG4gKiBTaWduZWQgb25lLlxuICogQHR5cGUgeyFJbnRlZ2VyfVxuICogQGV4cG9zZVxuICovXG5cbkludGVnZXIuT05FID0gSW50ZWdlci5mcm9tSW50KDEpO1xuLyoqXG4gKiBTaWduZWQgbmVnYXRpdmUgb25lLlxuICogQHR5cGUgeyFJbnRlZ2VyfVxuICogQGV4cG9zZVxuICovXG5cbkludGVnZXIuTkVHX09ORSA9IEludGVnZXIuZnJvbUludCgtMSk7XG4vKipcbiAqIE1heGltdW0gc2lnbmVkIHZhbHVlLlxuICogQHR5cGUgeyFJbnRlZ2VyfVxuICogQGV4cG9zZVxuICovXG5cbkludGVnZXIuTUFYX1ZBTFVFID0gSW50ZWdlci5mcm9tQml0cygweGZmZmZmZmZmIHwgMCwgMHg3ZmZmZmZmZiB8IDAsIGZhbHNlKTtcbi8qKlxuICogTWluaW11bSBzaWduZWQgdmFsdWUuXG4gKiBAdHlwZSB7IUludGVnZXJ9XG4gKiBAZXhwb3NlXG4gKi9cblxuSW50ZWdlci5NSU5fVkFMVUUgPSBJbnRlZ2VyLmZyb21CaXRzKDAsIDB4ODAwMDAwMDAgfCAwLCBmYWxzZSk7XG4vKipcbiAqIE1pbmltdW0gc2FmZSB2YWx1ZS5cbiAqIEB0eXBlIHshSW50ZWdlcn1cbiAqIEBleHBvc2VcbiAqL1xuXG5JbnRlZ2VyLk1JTl9TQUZFX1ZBTFVFID0gSW50ZWdlci5mcm9tQml0cygweDEgfCAwLCAweGZmZmZmZmZmZmZlMDAwMDAgfCAwKTtcbi8qKlxuICogTWF4aW11bSBzYWZlIHZhbHVlLlxuICogQHR5cGUgeyFJbnRlZ2VyfVxuICogQGV4cG9zZVxuICovXG5cbkludGVnZXIuTUFYX1NBRkVfVkFMVUUgPSBJbnRlZ2VyLmZyb21CaXRzKDB4ZmZmZmZmZmYgfCAwLCAweDFmZmZmZiB8IDApO1xuLyoqXG4gKiBDYXN0IHZhbHVlIHRvIEludGVnZXIgdHlwZS5cbiAqIEBhY2Nlc3MgcHVibGljXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB1c2UuXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfSAtIEFuIG9iamVjdCBvZiB0eXBlIEludGVnZXIuXG4gKi9cblxudmFyIF9pbnQgPSBJbnRlZ2VyLmZyb21WYWx1ZTtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YXJpYWJsZSBpcyBvZiBJbnRlZ2VyIHR5cGUuXG4gKiBAYWNjZXNzIHB1YmxpY1xuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgLSBUaGUgdmFyaWFibGUgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIElzIGl0IG9mIHRoZSBJbnRlZ2VyIHR5cGU/XG4gKi9cblxuZXhwb3J0c1tcImludFwiXSA9IF9pbnQ7XG52YXIgaXNJbnQgPSBJbnRlZ2VyLmlzSW50ZWdlcjtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YXJpYWJsZSBjYW4gYmUgc2FmZWx5IGNvbnZlcnRlZCB0byBhIG51bWJlclxuICogQGFjY2VzcyBwdWJsaWNcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIC0gVGhlIHZhcmlhYmxlIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgaXQgaXMgc2FmZSB0byBjYWxsIHRvTnVtYmVyIG9uIHZhcmlhYmxlIG90aGVyd2lzZSBmYWxzZVxuICovXG5cbmV4cG9ydHMuaXNJbnQgPSBpc0ludDtcbnZhciBpblNhZmVSYW5nZSA9IEludGVnZXIuaW5TYWZlUmFuZ2U7XG4vKipcbiAqIENvbnZlcnRzIGEgdmFyaWFibGUgdG8gYSBudW1iZXJcbiAqIEBhY2Nlc3MgcHVibGljXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAtIFRoZSB2YXJpYWJsZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0gdGhlIHZhcmlhYmxlIGFzIGEgbnVtYmVyXG4gKi9cblxuZXhwb3J0cy5pblNhZmVSYW5nZSA9IGluU2FmZVJhbmdlO1xudmFyIHRvTnVtYmVyID0gSW50ZWdlci50b051bWJlcjtcbi8qKlxuICogQ29udmVydHMgdGhlIGludGVnZXIgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIEBhY2Nlc3MgcHVibGljXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAtIFRoZSB2YXJpYWJsZSB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXggLSByYWRpeCB0byB1c2UgaW4gc3RyaW5nIGNvbnZlcnNpb24sIGRlZmF1bHRzIHRvIDEwXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW50ZWdlclxuICovXG5cbmV4cG9ydHMudG9OdW1iZXIgPSB0b051bWJlcjtcbnZhciB0b1N0cmluZyA9IEludGVnZXIudG9TdHJpbmc7XG5leHBvcnRzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG52YXIgX2RlZmF1bHQgPSBJbnRlZ2VyO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYXNzZXJ0RGF0YWJhc2VJc0VtcHR5ID0gYXNzZXJ0RGF0YWJhc2VJc0VtcHR5O1xuZXhwb3J0cy5hc3NlcnRUeENvbmZpZ0lzRW1wdHkgPSBhc3NlcnRUeENvbmZpZ0lzRW1wdHk7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG5cbnZhciBfc3RyZWFtT2JzZXJ2ZXJzID0gcmVxdWlyZShcIi4vc3RyZWFtLW9ic2VydmVyc1wiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtUeENvbmZpZ30gdHhDb25maWcgdGhlIGF1dG8tY29tbWl0IHRyYW5zYWN0aW9uIGNvbmZpZ3VyYXRpb24uXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb24gdGhlIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge1Jlc3VsdFN0cmVhbU9ic2VydmVyfSBvYnNlcnZlciB0aGUgcmVzcG9uc2Ugb2JzZXJ2ZXIuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFR4Q29uZmlnSXNFbXB0eSh0eENvbmZpZywgY29ubmVjdGlvbiwgb2JzZXJ2ZXIpIHtcbiAgaWYgKHR4Q29uZmlnICYmICF0eENvbmZpZy5pc0VtcHR5KCkpIHtcbiAgICB2YXIgZXJyb3IgPSAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnRHJpdmVyIGlzIGNvbm5lY3RlZCB0byB0aGUgZGF0YWJhc2UgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRyYW5zYWN0aW9uIGNvbmZpZ3VyYXRpb24uICcgKyAnUGxlYXNlIHVwZ3JhZGUgdG8gbmVvNGogMy41LjAgb3IgbGF0ZXIgaW4gb3JkZXIgdG8gdXNlIHRoaXMgZnVuY3Rpb25hbGl0eScpOyAvLyB1bnN1cHBvcnRlZCBBUEkgd2FzIHVzZWQsIGNvbnNpZGVyIHRoaXMgYSBmYXRhbCBlcnJvciBmb3IgdGhlIGN1cnJlbnQgY29ubmVjdGlvblxuXG4gICAgY29ubmVjdGlvbi5faGFuZGxlRmF0YWxFcnJvcihlcnJvcik7XG5cbiAgICBvYnNlcnZlci5vbkVycm9yKGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIHBhc3NlZC1pbiBkYXRhYmFzZSBuYW1lIGlzIGVtcHR5LlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VydERhdGFiYXNlSXNFbXB0eShkYXRhYmFzZSwgY29ubmVjdGlvbiwgb2JzZXJ2ZXIpIHtcbiAgaWYgKGRhdGFiYXNlKSB7XG4gICAgdmFyIGVycm9yID0gKDAsIF9lcnJvci5uZXdFcnJvcikoJ0RyaXZlciBpcyBjb25uZWN0ZWQgdG8gdGhlIGRhdGFiYXNlIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCBtdWx0aXBsZSBkYXRhYmFzZXMuICcgKyAnUGxlYXNlIHVwZ3JhZGUgdG8gbmVvNGogNC4wLjAgb3IgbGF0ZXIgaW4gb3JkZXIgdG8gdXNlIHRoaXMgZnVuY3Rpb25hbGl0eScpOyAvLyB1bnN1cHBvcnRlZCBBUEkgd2FzIHVzZWQsIGNvbnNpZGVyIHRoaXMgYSBmYXRhbCBlcnJvciBmb3IgdGhlIGN1cnJlbnQgY29ubmVjdGlvblxuXG4gICAgY29ubmVjdGlvbi5faGFuZGxlRmF0YWxFcnJvcihlcnJvcik7XG5cbiAgICBvYnNlcnZlci5vbkVycm9yKGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkXCIpO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2JvbHRQcm90b2NvbFV0aWwgPSByZXF1aXJlKFwiLi9ib2x0LXByb3RvY29sLXV0aWxcIik7XG5cbnZhciBfYm9va21hcmsgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jvb2ttYXJrXCIpKTtcblxudmFyIF9jaHVua2luZyA9IHJlcXVpcmUoXCIuL2NodW5raW5nXCIpO1xuXG52YXIgX2Nvbm5lY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb25cIikpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcblxudmFyIHYxID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vcGFja3N0cmVhbS12MVwiKSk7XG5cbnZhciBfcmVxdWVzdE1lc3NhZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JlcXVlc3QtbWVzc2FnZVwiKSk7XG5cbnZhciBfc3RyZWFtT2JzZXJ2ZXJzID0gcmVxdWlyZShcIi4vc3RyZWFtLW9ic2VydmVyc1wiKTtcblxudmFyIF90eENvbmZpZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdHgtY29uZmlnXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQm9sdFByb3RvY29sID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb24gdGhlIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7Q2h1bmtlcn0gY2h1bmtlciB0aGUgY2h1bmtlci5cbiAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlTG9zc2xlc3NJbnRlZ2VycyBpZiB0aGlzIGNvbm5lY3Rpb24gc2hvdWxkIGNvbnZlcnQgYWxsIHJlY2VpdmVkIGludGVnZXJzIHRvIG5hdGl2ZSBKUyBudW1iZXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gQm9sdFByb3RvY29sKGNvbm5lY3Rpb24sIGNodW5rZXIsIGRpc2FibGVMb3NzbGVzc0ludGVnZXJzKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBCb2x0UHJvdG9jb2wpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIHRoaXMuX3BhY2tlciA9IHRoaXMuX2NyZWF0ZVBhY2tlcihjaHVua2VyKTtcbiAgICB0aGlzLl91bnBhY2tlciA9IHRoaXMuX2NyZWF0ZVVucGFja2VyKGRpc2FibGVMb3NzbGVzc0ludGVnZXJzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtZXJpY2FsIHZlcnNpb24gaWRlbnRpZmllciBmb3IgdGhpcyBwcm90b2NvbFxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQm9sdFByb3RvY29sLCBbe1xuICAgIGtleTogXCJwYWNrZXJcIixcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGFja2VyLlxuICAgICAqIEByZXR1cm4ge1BhY2tlcn0gdGhlIHByb3RvY29sJ3MgcGFja2VyLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWNrZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFja2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVucGFja2VyLlxuICAgICAqIEByZXR1cm4ge1VucGFja2VyfSB0aGUgcHJvdG9jb2wncyB1bnBhY2tlci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVucGFja2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucGFja2VyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VucGFja2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gbWV0YWRhdGEgcmVjZWl2ZWQgaW4gU1VDQ0VTUyBtZXNzYWdlIGJlZm9yZSBpdCBpcyBwYXNzZWQgdG8gdGhlIGhhbmRsZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFkYXRhIHRoZSByZWNlaXZlZCBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRyYW5zZm9ybWVkIG1ldGFkYXRhLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtTWV0YWRhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBpbml0aWFsaXphdGlvbiBhbmQgYXV0aGVudGljYXRpb24gb2YgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0udXNlckFnZW50IHRoZSB1c2VyIGFnZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbS5hdXRoVG9rZW4gdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBFcnJvcil9IHBhcmFtLm9uRXJyb3IgdGhlIGNhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IHBhcmFtLm9uQ29tcGxldGUgdGhlIGNhbGxiYWNrIHRvIGludm9rZSBvbiBjb21wbGV0aW9uLlxuICAgICAqIEByZXR1cm5zIHtTdHJlYW1PYnNlcnZlcn0gdGhlIHN0cmVhbSBvYnNlcnZlciB0aGF0IG1vbml0b3JzIHRoZSBjb3JyZXNwb25kaW5nIHNlcnZlciByZXNwb25zZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICB1c2VyQWdlbnQgPSBfcmVmLnVzZXJBZ2VudCxcbiAgICAgICAgICBhdXRoVG9rZW4gPSBfcmVmLmF1dGhUb2tlbixcbiAgICAgICAgICBvbkVycm9yID0gX3JlZi5vbkVycm9yLFxuICAgICAgICAgIG9uQ29tcGxldGUgPSBfcmVmLm9uQ29tcGxldGU7XG5cbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBfc3RyZWFtT2JzZXJ2ZXJzLkxvZ2luT2JzZXJ2ZXIoe1xuICAgICAgICBjb25uZWN0aW9uOiB0aGlzLl9jb25uZWN0aW9uLFxuICAgICAgICBhZnRlckVycm9yOiBvbkVycm9yLFxuICAgICAgICBhZnRlckNvbXBsZXRlOiBvbkNvbXBsZXRlXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fY29ubmVjdGlvbi53cml0ZShfcmVxdWVzdE1lc3NhZ2VbXCJkZWZhdWx0XCJdLmluaXQodXNlckFnZW50LCBhdXRoVG9rZW4pLCBvYnNlcnZlciwgdHJ1ZSk7XG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBwcm90b2NvbCByZWxhdGVkIG9wZXJhdGlvbnMgZm9yIGNsb3NpbmcgdGhpcyBjb25uZWN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcmVwYXJlVG9DbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwYXJlVG9DbG9zZSgpIHt9IC8vIG5vIG5lZWQgdG8gbm90aWZ5IHRoZSBkYXRhYmFzZSBpbiB0aGlzIHByb3RvY29sIHZlcnNpb25cblxuICAgIC8qKlxuICAgICAqIEJlZ2luIGFuIGV4cGxpY2l0IHRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxuICAgICAqIEBwYXJhbSB7Qm9va21hcmt9IHBhcmFtLmJvb2ttYXJrIHRoZSBib29rbWFyay5cbiAgICAgKiBAcGFyYW0ge1R4Q29uZmlnfSBwYXJhbS50eENvbmZpZyB0aGUgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0uZGF0YWJhc2UgdGhlIHRhcmdldCBkYXRhYmFzZSBuYW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbS5tb2RlIHRoZSBhY2Nlc3MgbW9kZS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycjogRXJyb3IpfSBwYXJhbS5iZWZvcmVFcnJvciB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIGJlZm9yZSBoYW5kbGluZyB0aGUgZXJyb3IuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IEVycm9yKX0gcGFyYW0uYWZ0ZXJFcnJvciB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIGhhbmRsaW5nIHRoZSBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IHBhcmFtLmJlZm9yZUNvbXBsZXRlIHRoZSBjYWxsYmFjayB0byBpbnZva2UgYmVmb3JlIGhhbmRsaW5nIHRoZSBjb21wbGV0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gcGFyYW0uYWZ0ZXJDb21wbGV0ZSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIGhhbmRsaW5nIHRoZSBjb21wbGV0aW9uLlxuICAgICAqIEByZXR1cm5zIHtTdHJlYW1PYnNlcnZlcn0gdGhlIHN0cmVhbSBvYnNlcnZlciB0aGF0IG1vbml0b3JzIHRoZSBjb3JyZXNwb25kaW5nIHNlcnZlciByZXNwb25zZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImJlZ2luVHJhbnNhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVnaW5UcmFuc2FjdGlvbigpIHtcbiAgICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgYm9va21hcmsgPSBfcmVmMi5ib29rbWFyayxcbiAgICAgICAgICB0eENvbmZpZyA9IF9yZWYyLnR4Q29uZmlnLFxuICAgICAgICAgIGRhdGFiYXNlID0gX3JlZjIuZGF0YWJhc2UsXG4gICAgICAgICAgbW9kZSA9IF9yZWYyLm1vZGUsXG4gICAgICAgICAgYmVmb3JlRXJyb3IgPSBfcmVmMi5iZWZvcmVFcnJvcixcbiAgICAgICAgICBhZnRlckVycm9yID0gX3JlZjIuYWZ0ZXJFcnJvcixcbiAgICAgICAgICBiZWZvcmVDb21wbGV0ZSA9IF9yZWYyLmJlZm9yZUNvbXBsZXRlLFxuICAgICAgICAgIGFmdGVyQ29tcGxldGUgPSBfcmVmMi5hZnRlckNvbXBsZXRlO1xuXG4gICAgICByZXR1cm4gdGhpcy5ydW4oJ0JFR0lOJywgYm9va21hcmsgPyBib29rbWFyay5hc0JlZ2luVHJhbnNhY3Rpb25QYXJhbWV0ZXJzKCkgOiB7fSwge1xuICAgICAgICBib29rbWFyazogYm9va21hcmssXG4gICAgICAgIHR4Q29uZmlnOiB0eENvbmZpZyxcbiAgICAgICAgZGF0YWJhc2U6IGRhdGFiYXNlLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICBiZWZvcmVFcnJvcjogYmVmb3JlRXJyb3IsXG4gICAgICAgIGFmdGVyRXJyb3I6IGFmdGVyRXJyb3IsXG4gICAgICAgIGJlZm9yZUNvbXBsZXRlOiBiZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgYWZ0ZXJDb21wbGV0ZTogYWZ0ZXJDb21wbGV0ZSxcbiAgICAgICAgZmx1c2g6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tbWl0IHRoZSBleHBsaWNpdCB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycjogRXJyb3IpfSBwYXJhbS5iZWZvcmVFcnJvciB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIGJlZm9yZSBoYW5kbGluZyB0aGUgZXJyb3IuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IEVycm9yKX0gcGFyYW0uYWZ0ZXJFcnJvciB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIGhhbmRsaW5nIHRoZSBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IHBhcmFtLmJlZm9yZUNvbXBsZXRlIHRoZSBjYWxsYmFjayB0byBpbnZva2UgYmVmb3JlIGhhbmRsaW5nIHRoZSBjb21wbGV0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gcGFyYW0uYWZ0ZXJDb21wbGV0ZSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIGhhbmRsaW5nIHRoZSBjb21wbGV0aW9uLlxuICAgICAqIEByZXR1cm5zIHtTdHJlYW1PYnNlcnZlcn0gdGhlIHN0cmVhbSBvYnNlcnZlciB0aGF0IG1vbml0b3JzIHRoZSBjb3JyZXNwb25kaW5nIHNlcnZlciByZXNwb25zZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbW1pdFRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbW1pdFRyYW5zYWN0aW9uKCkge1xuICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBiZWZvcmVFcnJvciA9IF9yZWYzLmJlZm9yZUVycm9yLFxuICAgICAgICAgIGFmdGVyRXJyb3IgPSBfcmVmMy5hZnRlckVycm9yLFxuICAgICAgICAgIGJlZm9yZUNvbXBsZXRlID0gX3JlZjMuYmVmb3JlQ29tcGxldGUsXG4gICAgICAgICAgYWZ0ZXJDb21wbGV0ZSA9IF9yZWYzLmFmdGVyQ29tcGxldGU7XG5cbiAgICAgIC8vIFdSSVRFIGFjY2VzcyBtb2RlIGlzIHVzZWQgYXMgYSBwbGFjZSBob2xkZXIgaGVyZSwgaXQgaGFzXG4gICAgICAvLyBubyBlZmZlY3Qgb24gYmVoYXZpb3VyIGZvciBCb2x0IFYxICYgVjJcbiAgICAgIHJldHVybiB0aGlzLnJ1bignQ09NTUlUJywge30sIHtcbiAgICAgICAgYm9va21hcms6IF9ib29rbWFya1tcImRlZmF1bHRcIl0uZW1wdHkoKSxcbiAgICAgICAgdHhDb25maWc6IF90eENvbmZpZ1tcImRlZmF1bHRcIl0uZW1wdHkoKSxcbiAgICAgICAgbW9kZTogX2NvbnN0YW50cy5BQ0NFU1NfTU9ERV9XUklURSxcbiAgICAgICAgYmVmb3JlRXJyb3I6IGJlZm9yZUVycm9yLFxuICAgICAgICBhZnRlckVycm9yOiBhZnRlckVycm9yLFxuICAgICAgICBiZWZvcmVDb21wbGV0ZTogYmVmb3JlQ29tcGxldGUsXG4gICAgICAgIGFmdGVyQ29tcGxldGU6IGFmdGVyQ29tcGxldGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb2xsYmFjayB0aGUgZXhwbGljaXQgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IEVycm9yKX0gcGFyYW0uYmVmb3JlRXJyb3IgdGhlIGNhbGxiYWNrIHRvIGludm9rZSBiZWZvcmUgaGFuZGxpbmcgdGhlIGVycm9yLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBFcnJvcil9IHBhcmFtLmFmdGVyRXJyb3IgdGhlIGNhbGxiYWNrIHRvIGludm9rZSBhZnRlciBoYW5kbGluZyB0aGUgZXJyb3IuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBwYXJhbS5iZWZvcmVDb21wbGV0ZSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIGJlZm9yZSBoYW5kbGluZyB0aGUgY29tcGxldGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IHBhcmFtLmFmdGVyQ29tcGxldGUgdGhlIGNhbGxiYWNrIHRvIGludm9rZSBhZnRlciBoYW5kbGluZyB0aGUgY29tcGxldGlvbi5cbiAgICAgKiBAcmV0dXJucyB7U3RyZWFtT2JzZXJ2ZXJ9IHRoZSBzdHJlYW0gb2JzZXJ2ZXIgdGhhdCBtb25pdG9ycyB0aGUgY29ycmVzcG9uZGluZyBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyb2xsYmFja1RyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvbGxiYWNrVHJhbnNhY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIGJlZm9yZUVycm9yID0gX3JlZjQuYmVmb3JlRXJyb3IsXG4gICAgICAgICAgYWZ0ZXJFcnJvciA9IF9yZWY0LmFmdGVyRXJyb3IsXG4gICAgICAgICAgYmVmb3JlQ29tcGxldGUgPSBfcmVmNC5iZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgICBhZnRlckNvbXBsZXRlID0gX3JlZjQuYWZ0ZXJDb21wbGV0ZTtcblxuICAgICAgLy8gV1JJVEUgYWNjZXNzIG1vZGUgaXMgdXNlZCBhcyBhIHBsYWNlIGhvbGRlciBoZXJlLCBpdCBoYXNcbiAgICAgIC8vIG5vIGVmZmVjdCBvbiBiZWhhdmlvdXIgZm9yIEJvbHQgVjEgJiBWMlxuICAgICAgcmV0dXJuIHRoaXMucnVuKCdST0xMQkFDSycsIHt9LCB7XG4gICAgICAgIGJvb2ttYXJrOiBfYm9va21hcmtbXCJkZWZhdWx0XCJdLmVtcHR5KCksXG4gICAgICAgIHR4Q29uZmlnOiBfdHhDb25maWdbXCJkZWZhdWx0XCJdLmVtcHR5KCksXG4gICAgICAgIG1vZGU6IF9jb25zdGFudHMuQUNDRVNTX01PREVfV1JJVEUsXG4gICAgICAgIGJlZm9yZUVycm9yOiBiZWZvcmVFcnJvcixcbiAgICAgICAgYWZ0ZXJFcnJvcjogYWZ0ZXJFcnJvcixcbiAgICAgICAgYmVmb3JlQ29tcGxldGU6IGJlZm9yZUNvbXBsZXRlLFxuICAgICAgICBhZnRlckNvbXBsZXRlOiBhZnRlckNvbXBsZXRlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIEN5cGhlciBxdWVyeSB0aHJvdWdoIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IHRoZSBjeXBoZXIgcXVlcnkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgdGhlIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gICAgICogQHBhcmFtIHtCb29rbWFya30gcGFyYW0uYm9va21hcmsgdGhlIGJvb2ttYXJrLlxuICAgICAqIEBwYXJhbSB7VHhDb25maWd9IHBhcmFtLnR4Q29uZmlnIHRoZSB0cmFuc2FjdGlvbiBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbS5kYXRhYmFzZSB0aGUgdGFyZ2V0IGRhdGFiYXNlIG5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtLm1vZGUgdGhlIGFjY2VzcyBtb2RlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oa2V5czogc3RyaW5nW10pfSBwYXJhbS5iZWZvcmVLZXlzIHRoZSBjYWxsYmFjayB0byBpbnZva2UgYmVmb3JlIGhhbmRsaW5nIHRoZSBrZXlzLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oa2V5czogc3RyaW5nW10pfSBwYXJhbS5hZnRlcktleXMgdGhlIGNhbGxiYWNrIHRvIGludm9rZSBhZnRlciBoYW5kbGluZyB0aGUga2V5cy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycjogRXJyb3IpfSBwYXJhbS5iZWZvcmVFcnJvciB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIGJlZm9yZSBoYW5kbGluZyB0aGUgZXJyb3IuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IEVycm9yKX0gcGFyYW0uYWZ0ZXJFcnJvciB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIGhhbmRsaW5nIHRoZSBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IHBhcmFtLmJlZm9yZUNvbXBsZXRlIHRoZSBjYWxsYmFjayB0byBpbnZva2UgYmVmb3JlIGhhbmRsaW5nIHRoZSBjb21wbGV0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gcGFyYW0uYWZ0ZXJDb21wbGV0ZSB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIGhhbmRsaW5nIHRoZSBjb21wbGV0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW0uZmx1c2ggd2hldGhlciB0byBmbHVzaCB0aGUgYnVmZmVyZWQgbWVzc2FnZXMuXG4gICAgICogQHJldHVybnMge1N0cmVhbU9ic2VydmVyfSB0aGUgc3RyZWFtIG9ic2VydmVyIHRoYXQgbW9uaXRvcnMgdGhlIGNvcnJlc3BvbmRpbmcgc2VydmVyIHJlc3BvbnNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicnVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bihxdWVyeSwgcGFyYW1ldGVycykge1xuICAgICAgdmFyIF9yZWY1ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgICAgICBib29rbWFyayA9IF9yZWY1LmJvb2ttYXJrLFxuICAgICAgICAgIHR4Q29uZmlnID0gX3JlZjUudHhDb25maWcsXG4gICAgICAgICAgZGF0YWJhc2UgPSBfcmVmNS5kYXRhYmFzZSxcbiAgICAgICAgICBtb2RlID0gX3JlZjUubW9kZSxcbiAgICAgICAgICBiZWZvcmVLZXlzID0gX3JlZjUuYmVmb3JlS2V5cyxcbiAgICAgICAgICBhZnRlcktleXMgPSBfcmVmNS5hZnRlcktleXMsXG4gICAgICAgICAgYmVmb3JlRXJyb3IgPSBfcmVmNS5iZWZvcmVFcnJvcixcbiAgICAgICAgICBhZnRlckVycm9yID0gX3JlZjUuYWZ0ZXJFcnJvcixcbiAgICAgICAgICBiZWZvcmVDb21wbGV0ZSA9IF9yZWY1LmJlZm9yZUNvbXBsZXRlLFxuICAgICAgICAgIGFmdGVyQ29tcGxldGUgPSBfcmVmNS5hZnRlckNvbXBsZXRlLFxuICAgICAgICAgIF9yZWY1JGZsdXNoID0gX3JlZjUuZmx1c2gsXG4gICAgICAgICAgZmx1c2ggPSBfcmVmNSRmbHVzaCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWY1JGZsdXNoO1xuXG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgX3N0cmVhbU9ic2VydmVycy5SZXN1bHRTdHJlYW1PYnNlcnZlcih7XG4gICAgICAgIGNvbm5lY3Rpb246IHRoaXMuX2Nvbm5lY3Rpb24sXG4gICAgICAgIGJlZm9yZUtleXM6IGJlZm9yZUtleXMsXG4gICAgICAgIGFmdGVyS2V5czogYWZ0ZXJLZXlzLFxuICAgICAgICBiZWZvcmVFcnJvcjogYmVmb3JlRXJyb3IsXG4gICAgICAgIGFmdGVyRXJyb3I6IGFmdGVyRXJyb3IsXG4gICAgICAgIGJlZm9yZUNvbXBsZXRlOiBiZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgYWZ0ZXJDb21wbGV0ZTogYWZ0ZXJDb21wbGV0ZVxuICAgICAgfSk7IC8vIGJvb2ttYXJrIGFuZCBtb2RlIGFyZSBpZ25vcmVkIGluIHRoaXMgdmVyc2lvbiBvZiB0aGUgcHJvdG9jb2xcblxuICAgICAgKDAsIF9ib2x0UHJvdG9jb2xVdGlsLmFzc2VydFR4Q29uZmlnSXNFbXB0eSkodHhDb25maWcsIHRoaXMuX2Nvbm5lY3Rpb24sIG9ic2VydmVyKTsgLy8gcGFzc2luZyBpbiBhIGRhdGFiYXNlIG5hbWUgb24gdGhpcyBwcm90b2NvbCB2ZXJzaW9uIHRocm93cyBhbiBlcnJvclxuXG4gICAgICAoMCwgX2JvbHRQcm90b2NvbFV0aWwuYXNzZXJ0RGF0YWJhc2VJc0VtcHR5KShkYXRhYmFzZSwgdGhpcy5fY29ubmVjdGlvbiwgb2JzZXJ2ZXIpO1xuXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLndyaXRlKF9yZXF1ZXN0TWVzc2FnZVtcImRlZmF1bHRcIl0ucnVuKHF1ZXJ5LCBwYXJhbWV0ZXJzKSwgb2JzZXJ2ZXIsIGZhbHNlKTtcblxuICAgICAgdGhpcy5fY29ubmVjdGlvbi53cml0ZShfcmVxdWVzdE1lc3NhZ2VbXCJkZWZhdWx0XCJdLnB1bGxBbGwoKSwgb2JzZXJ2ZXIsIGZsdXNoKTtcblxuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgUkVTRVQgdGhyb3VnaCB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBFcnJvcil9IHBhcmFtLm9uRXJyb3IgdGhlIGNhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IHBhcmFtLm9uQ29tcGxldGUgdGhlIGNhbGxiYWNrIHRvIGludm9rZSBvbiBjb21wbGV0aW9uLlxuICAgICAqIEByZXR1cm5zIHtTdHJlYW1PYnNlcnZlcn0gdGhlIHN0cmVhbSBvYnNlcnZlciB0aGF0IG1vbml0b3JzIHRoZSBjb3JyZXNwb25kaW5nIHNlcnZlciByZXNwb25zZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdmFyIF9yZWY2ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBvbkVycm9yID0gX3JlZjYub25FcnJvcixcbiAgICAgICAgICBvbkNvbXBsZXRlID0gX3JlZjYub25Db21wbGV0ZTtcblxuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IF9zdHJlYW1PYnNlcnZlcnMuUmVzZXRPYnNlcnZlcih7XG4gICAgICAgIGNvbm5lY3Rpb246IHRoaXMuX2Nvbm5lY3Rpb24sXG4gICAgICAgIG9uRXJyb3I6IG9uRXJyb3IsXG4gICAgICAgIG9uQ29tcGxldGU6IG9uQ29tcGxldGVcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLndyaXRlKF9yZXF1ZXN0TWVzc2FnZVtcImRlZmF1bHRcIl0ucmVzZXQoKSwgb2JzZXJ2ZXIsIHRydWUpO1xuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVQYWNrZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVBhY2tlcihjaHVua2VyKSB7XG4gICAgICByZXR1cm4gbmV3IHYxLlBhY2tlcihjaHVua2VyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVVucGFja2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVVbnBhY2tlcihkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycykge1xuICAgICAgcmV0dXJuIG5ldyB2MS5VbnBhY2tlcihkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZlcnNpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29uc3RhbnRzLkJPTFRfUFJPVE9DT0xfVjE7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb2x0UHJvdG9jb2w7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQm9sdFByb3RvY29sOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkXCIpO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9ib2x0UHJvdG9jb2xWID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ib2x0LXByb3RvY29sLXYxXCIpKTtcblxudmFyIHYyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vcGFja3N0cmVhbS12MlwiKSk7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgQm9sdFByb3RvY29sID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQm9sdFByb3RvY29sVikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKEJvbHRQcm90b2NvbCwgX0JvbHRQcm90b2NvbFYpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQm9sdFByb3RvY29sKTtcblxuICBmdW5jdGlvbiBCb2x0UHJvdG9jb2woKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBCb2x0UHJvdG9jb2wpO1xuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQm9sdFByb3RvY29sLCBbe1xuICAgIGtleTogXCJfY3JlYXRlUGFja2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVQYWNrZXIoY2h1bmtlcikge1xuICAgICAgcmV0dXJuIG5ldyB2Mi5QYWNrZXIoY2h1bmtlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVVbnBhY2tlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlVW5wYWNrZXIoZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpIHtcbiAgICAgIHJldHVybiBuZXcgdjIuVW5wYWNrZXIoZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2ZXJzaW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2NvbnN0YW50cy5CT0xUX1BST1RPQ09MX1YyO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQm9sdFByb3RvY29sO1xufShfYm9sdFByb3RvY29sVltcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEJvbHRQcm90b2NvbDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfYm9sdFByb3RvY29sViA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYm9sdC1wcm90b2NvbC12MlwiKSk7XG5cbnZhciBfcmVxdWVzdE1lc3NhZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JlcXVlc3QtbWVzc2FnZVwiKSk7XG5cbnZhciBfYm9sdFByb3RvY29sVXRpbCA9IHJlcXVpcmUoXCIuL2JvbHQtcHJvdG9jb2wtdXRpbFwiKTtcblxudmFyIF9zdHJlYW1PYnNlcnZlcnMgPSByZXF1aXJlKFwiLi9zdHJlYW0tb2JzZXJ2ZXJzXCIpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIG5vT3BPYnNlcnZlciA9IG5ldyBfc3RyZWFtT2JzZXJ2ZXJzLlN0cmVhbU9ic2VydmVyKCk7XG5cbnZhciBCb2x0UHJvdG9jb2wgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Cb2x0UHJvdG9jb2xWKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoQm9sdFByb3RvY29sLCBfQm9sdFByb3RvY29sVik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihCb2x0UHJvdG9jb2wpO1xuXG4gIGZ1bmN0aW9uIEJvbHRQcm90b2NvbCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIEJvbHRQcm90b2NvbCk7XG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShCb2x0UHJvdG9jb2wsIFt7XG4gICAga2V5OiBcInRyYW5zZm9ybU1ldGFkYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZm9ybU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICBpZiAoJ3RfZmlyc3QnIGluIG1ldGFkYXRhKSB7XG4gICAgICAgIC8vIEJvbHQgVjMgdXNlcyBzaG9ydGVyIGtleSAndF9maXJzdCcgdG8gcmVwcmVzZW50ICdyZXN1bHRfYXZhaWxhYmxlX2FmdGVyJ1xuICAgICAgICAvLyBhZGp1c3QgdGhlIGtleSB0byBiZSB0aGUgc2FtZSBhcyBpbiBCb2x0IFYxIHNvIHRoYXQgUmVzdWx0U3VtbWFyeSBjYW4gcmV0cmlldmUgdGhlIHZhbHVlXG4gICAgICAgIG1ldGFkYXRhLnJlc3VsdF9hdmFpbGFibGVfYWZ0ZXIgPSBtZXRhZGF0YS50X2ZpcnN0O1xuICAgICAgICBkZWxldGUgbWV0YWRhdGEudF9maXJzdDtcbiAgICAgIH1cblxuICAgICAgaWYgKCd0X2xhc3QnIGluIG1ldGFkYXRhKSB7XG4gICAgICAgIC8vIEJvbHQgVjMgdXNlcyBzaG9ydGVyIGtleSAndF9sYXN0JyB0byByZXByZXNlbnQgJ3Jlc3VsdF9jb25zdW1lZF9hZnRlcidcbiAgICAgICAgLy8gYWRqdXN0IHRoZSBrZXkgdG8gYmUgdGhlIHNhbWUgYXMgaW4gQm9sdCBWMSBzbyB0aGF0IFJlc3VsdFN1bW1hcnkgY2FuIHJldHJpZXZlIHRoZSB2YWx1ZVxuICAgICAgICBtZXRhZGF0YS5yZXN1bHRfY29uc3VtZWRfYWZ0ZXIgPSBtZXRhZGF0YS50X2xhc3Q7XG4gICAgICAgIGRlbGV0ZSBtZXRhZGF0YS50X2xhc3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIHVzZXJBZ2VudCA9IF9yZWYudXNlckFnZW50LFxuICAgICAgICAgIGF1dGhUb2tlbiA9IF9yZWYuYXV0aFRva2VuLFxuICAgICAgICAgIG9uRXJyb3IgPSBfcmVmLm9uRXJyb3IsXG4gICAgICAgICAgb25Db21wbGV0ZSA9IF9yZWYub25Db21wbGV0ZTtcblxuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IF9zdHJlYW1PYnNlcnZlcnMuTG9naW5PYnNlcnZlcih7XG4gICAgICAgIGNvbm5lY3Rpb246IHRoaXMuX2Nvbm5lY3Rpb24sXG4gICAgICAgIGFmdGVyRXJyb3I6IG9uRXJyb3IsXG4gICAgICAgIGFmdGVyQ29tcGxldGU6IG9uQ29tcGxldGVcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLndyaXRlKF9yZXF1ZXN0TWVzc2FnZVtcImRlZmF1bHRcIl0uaGVsbG8odXNlckFnZW50LCBhdXRoVG9rZW4pLCBvYnNlcnZlciwgdHJ1ZSk7XG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGFyZVRvQ2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyZVRvQ2xvc2UoKSB7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uLndyaXRlKF9yZXF1ZXN0TWVzc2FnZVtcImRlZmF1bHRcIl0uZ29vZGJ5ZSgpLCBub09wT2JzZXJ2ZXIsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiZWdpblRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZ2luVHJhbnNhY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIGJvb2ttYXJrID0gX3JlZjIuYm9va21hcmssXG4gICAgICAgICAgdHhDb25maWcgPSBfcmVmMi50eENvbmZpZyxcbiAgICAgICAgICBkYXRhYmFzZSA9IF9yZWYyLmRhdGFiYXNlLFxuICAgICAgICAgIG1vZGUgPSBfcmVmMi5tb2RlLFxuICAgICAgICAgIGJlZm9yZUVycm9yID0gX3JlZjIuYmVmb3JlRXJyb3IsXG4gICAgICAgICAgYWZ0ZXJFcnJvciA9IF9yZWYyLmFmdGVyRXJyb3IsXG4gICAgICAgICAgYmVmb3JlQ29tcGxldGUgPSBfcmVmMi5iZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgICBhZnRlckNvbXBsZXRlID0gX3JlZjIuYWZ0ZXJDb21wbGV0ZTtcblxuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IF9zdHJlYW1PYnNlcnZlcnMuUmVzdWx0U3RyZWFtT2JzZXJ2ZXIoe1xuICAgICAgICBjb25uZWN0aW9uOiB0aGlzLl9jb25uZWN0aW9uLFxuICAgICAgICBiZWZvcmVFcnJvcjogYmVmb3JlRXJyb3IsXG4gICAgICAgIGFmdGVyRXJyb3I6IGFmdGVyRXJyb3IsXG4gICAgICAgIGJlZm9yZUNvbXBsZXRlOiBiZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgYWZ0ZXJDb21wbGV0ZTogYWZ0ZXJDb21wbGV0ZVxuICAgICAgfSk7XG4gICAgICBvYnNlcnZlci5wcmVwYXJlVG9IYW5kbGVTaW5nbGVSZXNwb25zZSgpOyAvLyBwYXNzaW5nIGluIGEgZGF0YWJhc2UgbmFtZSBvbiB0aGlzIHByb3RvY29sIHZlcnNpb24gdGhyb3dzIGFuIGVycm9yXG5cbiAgICAgICgwLCBfYm9sdFByb3RvY29sVXRpbC5hc3NlcnREYXRhYmFzZUlzRW1wdHkpKGRhdGFiYXNlLCB0aGlzLl9jb25uZWN0aW9uLCBvYnNlcnZlcik7XG5cbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24ud3JpdGUoX3JlcXVlc3RNZXNzYWdlW1wiZGVmYXVsdFwiXS5iZWdpbih7XG4gICAgICAgIGJvb2ttYXJrOiBib29rbWFyayxcbiAgICAgICAgdHhDb25maWc6IHR4Q29uZmlnLFxuICAgICAgICBtb2RlOiBtb2RlXG4gICAgICB9KSwgb2JzZXJ2ZXIsIHRydWUpO1xuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbW1pdFRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbW1pdFRyYW5zYWN0aW9uKCkge1xuICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBiZWZvcmVFcnJvciA9IF9yZWYzLmJlZm9yZUVycm9yLFxuICAgICAgICAgIGFmdGVyRXJyb3IgPSBfcmVmMy5hZnRlckVycm9yLFxuICAgICAgICAgIGJlZm9yZUNvbXBsZXRlID0gX3JlZjMuYmVmb3JlQ29tcGxldGUsXG4gICAgICAgICAgYWZ0ZXJDb21wbGV0ZSA9IF9yZWYzLmFmdGVyQ29tcGxldGU7XG5cbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBfc3RyZWFtT2JzZXJ2ZXJzLlJlc3VsdFN0cmVhbU9ic2VydmVyKHtcbiAgICAgICAgY29ubmVjdGlvbjogdGhpcy5fY29ubmVjdGlvbixcbiAgICAgICAgYmVmb3JlRXJyb3I6IGJlZm9yZUVycm9yLFxuICAgICAgICBhZnRlckVycm9yOiBhZnRlckVycm9yLFxuICAgICAgICBiZWZvcmVDb21wbGV0ZTogYmVmb3JlQ29tcGxldGUsXG4gICAgICAgIGFmdGVyQ29tcGxldGU6IGFmdGVyQ29tcGxldGVcbiAgICAgIH0pO1xuICAgICAgb2JzZXJ2ZXIucHJlcGFyZVRvSGFuZGxlU2luZ2xlUmVzcG9uc2UoKTtcblxuICAgICAgdGhpcy5fY29ubmVjdGlvbi53cml0ZShfcmVxdWVzdE1lc3NhZ2VbXCJkZWZhdWx0XCJdLmNvbW1pdCgpLCBvYnNlcnZlciwgdHJ1ZSk7XG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm9sbGJhY2tUcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb2xsYmFja1RyYW5zYWN0aW9uKCkge1xuICAgICAgdmFyIF9yZWY0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBiZWZvcmVFcnJvciA9IF9yZWY0LmJlZm9yZUVycm9yLFxuICAgICAgICAgIGFmdGVyRXJyb3IgPSBfcmVmNC5hZnRlckVycm9yLFxuICAgICAgICAgIGJlZm9yZUNvbXBsZXRlID0gX3JlZjQuYmVmb3JlQ29tcGxldGUsXG4gICAgICAgICAgYWZ0ZXJDb21wbGV0ZSA9IF9yZWY0LmFmdGVyQ29tcGxldGU7XG5cbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBfc3RyZWFtT2JzZXJ2ZXJzLlJlc3VsdFN0cmVhbU9ic2VydmVyKHtcbiAgICAgICAgY29ubmVjdGlvbjogdGhpcy5fY29ubmVjdGlvbixcbiAgICAgICAgYmVmb3JlRXJyb3I6IGJlZm9yZUVycm9yLFxuICAgICAgICBhZnRlckVycm9yOiBhZnRlckVycm9yLFxuICAgICAgICBiZWZvcmVDb21wbGV0ZTogYmVmb3JlQ29tcGxldGUsXG4gICAgICAgIGFmdGVyQ29tcGxldGU6IGFmdGVyQ29tcGxldGVcbiAgICAgIH0pO1xuICAgICAgb2JzZXJ2ZXIucHJlcGFyZVRvSGFuZGxlU2luZ2xlUmVzcG9uc2UoKTtcblxuICAgICAgdGhpcy5fY29ubmVjdGlvbi53cml0ZShfcmVxdWVzdE1lc3NhZ2VbXCJkZWZhdWx0XCJdLnJvbGxiYWNrKCksIG9ic2VydmVyLCB0cnVlKTtcblxuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJydW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuKHF1ZXJ5LCBwYXJhbWV0ZXJzKSB7XG4gICAgICB2YXIgX3JlZjUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgICAgIGJvb2ttYXJrID0gX3JlZjUuYm9va21hcmssXG4gICAgICAgICAgdHhDb25maWcgPSBfcmVmNS50eENvbmZpZyxcbiAgICAgICAgICBkYXRhYmFzZSA9IF9yZWY1LmRhdGFiYXNlLFxuICAgICAgICAgIG1vZGUgPSBfcmVmNS5tb2RlLFxuICAgICAgICAgIGJlZm9yZUtleXMgPSBfcmVmNS5iZWZvcmVLZXlzLFxuICAgICAgICAgIGFmdGVyS2V5cyA9IF9yZWY1LmFmdGVyS2V5cyxcbiAgICAgICAgICBiZWZvcmVFcnJvciA9IF9yZWY1LmJlZm9yZUVycm9yLFxuICAgICAgICAgIGFmdGVyRXJyb3IgPSBfcmVmNS5hZnRlckVycm9yLFxuICAgICAgICAgIGJlZm9yZUNvbXBsZXRlID0gX3JlZjUuYmVmb3JlQ29tcGxldGUsXG4gICAgICAgICAgYWZ0ZXJDb21wbGV0ZSA9IF9yZWY1LmFmdGVyQ29tcGxldGUsXG4gICAgICAgICAgX3JlZjUkZmx1c2ggPSBfcmVmNS5mbHVzaCxcbiAgICAgICAgICBmbHVzaCA9IF9yZWY1JGZsdXNoID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjUkZmx1c2g7XG5cbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBfc3RyZWFtT2JzZXJ2ZXJzLlJlc3VsdFN0cmVhbU9ic2VydmVyKHtcbiAgICAgICAgY29ubmVjdGlvbjogdGhpcy5fY29ubmVjdGlvbixcbiAgICAgICAgYmVmb3JlS2V5czogYmVmb3JlS2V5cyxcbiAgICAgICAgYWZ0ZXJLZXlzOiBhZnRlcktleXMsXG4gICAgICAgIGJlZm9yZUVycm9yOiBiZWZvcmVFcnJvcixcbiAgICAgICAgYWZ0ZXJFcnJvcjogYWZ0ZXJFcnJvcixcbiAgICAgICAgYmVmb3JlQ29tcGxldGU6IGJlZm9yZUNvbXBsZXRlLFxuICAgICAgICBhZnRlckNvbXBsZXRlOiBhZnRlckNvbXBsZXRlXG4gICAgICB9KTsgLy8gcGFzc2luZyBpbiBhIGRhdGFiYXNlIG5hbWUgb24gdGhpcyBwcm90b2NvbCB2ZXJzaW9uIHRocm93cyBhbiBlcnJvclxuXG4gICAgICAoMCwgX2JvbHRQcm90b2NvbFV0aWwuYXNzZXJ0RGF0YWJhc2VJc0VtcHR5KShkYXRhYmFzZSwgdGhpcy5fY29ubmVjdGlvbiwgb2JzZXJ2ZXIpO1xuXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLndyaXRlKF9yZXF1ZXN0TWVzc2FnZVtcImRlZmF1bHRcIl0ucnVuV2l0aE1ldGFkYXRhKHF1ZXJ5LCBwYXJhbWV0ZXJzLCB7XG4gICAgICAgIGJvb2ttYXJrOiBib29rbWFyayxcbiAgICAgICAgdHhDb25maWc6IHR4Q29uZmlnLFxuICAgICAgICBtb2RlOiBtb2RlXG4gICAgICB9KSwgb2JzZXJ2ZXIsIGZhbHNlKTtcblxuICAgICAgdGhpcy5fY29ubmVjdGlvbi53cml0ZShfcmVxdWVzdE1lc3NhZ2VbXCJkZWZhdWx0XCJdLnB1bGxBbGwoKSwgb2JzZXJ2ZXIsIGZsdXNoKTtcblxuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2ZXJzaW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2NvbnN0YW50cy5CT0xUX1BST1RPQ09MX1YzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQm9sdFByb3RvY29sO1xufShfYm9sdFByb3RvY29sVltcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEJvbHRQcm90b2NvbDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZFwiKTtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfYm9sdFByb3RvY29sViA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYm9sdC1wcm90b2NvbC12M1wiKSk7XG5cbnZhciBfcmVxdWVzdE1lc3NhZ2UgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9yZXF1ZXN0LW1lc3NhZ2VcIikpO1xuXG52YXIgX3N0cmVhbU9ic2VydmVycyA9IHJlcXVpcmUoXCIuL3N0cmVhbS1vYnNlcnZlcnNcIik7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgQm9sdFByb3RvY29sID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQm9sdFByb3RvY29sVikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKEJvbHRQcm90b2NvbCwgX0JvbHRQcm90b2NvbFYpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQm9sdFByb3RvY29sKTtcblxuICBmdW5jdGlvbiBCb2x0UHJvdG9jb2woKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBCb2x0UHJvdG9jb2wpO1xuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQm9sdFByb3RvY29sLCBbe1xuICAgIGtleTogXCJiZWdpblRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZ2luVHJhbnNhY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgYm9va21hcmsgPSBfcmVmLmJvb2ttYXJrLFxuICAgICAgICAgIHR4Q29uZmlnID0gX3JlZi50eENvbmZpZyxcbiAgICAgICAgICBkYXRhYmFzZSA9IF9yZWYuZGF0YWJhc2UsXG4gICAgICAgICAgbW9kZSA9IF9yZWYubW9kZSxcbiAgICAgICAgICBiZWZvcmVFcnJvciA9IF9yZWYuYmVmb3JlRXJyb3IsXG4gICAgICAgICAgYWZ0ZXJFcnJvciA9IF9yZWYuYWZ0ZXJFcnJvcixcbiAgICAgICAgICBiZWZvcmVDb21wbGV0ZSA9IF9yZWYuYmVmb3JlQ29tcGxldGUsXG4gICAgICAgICAgYWZ0ZXJDb21wbGV0ZSA9IF9yZWYuYWZ0ZXJDb21wbGV0ZTtcblxuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IF9zdHJlYW1PYnNlcnZlcnMuUmVzdWx0U3RyZWFtT2JzZXJ2ZXIoe1xuICAgICAgICBjb25uZWN0aW9uOiB0aGlzLl9jb25uZWN0aW9uLFxuICAgICAgICBiZWZvcmVFcnJvcjogYmVmb3JlRXJyb3IsXG4gICAgICAgIGFmdGVyRXJyb3I6IGFmdGVyRXJyb3IsXG4gICAgICAgIGJlZm9yZUNvbXBsZXRlOiBiZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgYWZ0ZXJDb21wbGV0ZTogYWZ0ZXJDb21wbGV0ZVxuICAgICAgfSk7XG4gICAgICBvYnNlcnZlci5wcmVwYXJlVG9IYW5kbGVTaW5nbGVSZXNwb25zZSgpO1xuXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLndyaXRlKF9yZXF1ZXN0TWVzc2FnZVtcImRlZmF1bHRcIl0uYmVnaW4oe1xuICAgICAgICBib29rbWFyazogYm9va21hcmssXG4gICAgICAgIHR4Q29uZmlnOiB0eENvbmZpZyxcbiAgICAgICAgZGF0YWJhc2U6IGRhdGFiYXNlLFxuICAgICAgICBtb2RlOiBtb2RlXG4gICAgICB9KSwgb2JzZXJ2ZXIsIHRydWUpO1xuXG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJ1blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW4ocXVlcnksIHBhcmFtZXRlcnMpIHtcbiAgICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICAgICAgYm9va21hcmsgPSBfcmVmMi5ib29rbWFyayxcbiAgICAgICAgICB0eENvbmZpZyA9IF9yZWYyLnR4Q29uZmlnLFxuICAgICAgICAgIGRhdGFiYXNlID0gX3JlZjIuZGF0YWJhc2UsXG4gICAgICAgICAgbW9kZSA9IF9yZWYyLm1vZGUsXG4gICAgICAgICAgYmVmb3JlS2V5cyA9IF9yZWYyLmJlZm9yZUtleXMsXG4gICAgICAgICAgYWZ0ZXJLZXlzID0gX3JlZjIuYWZ0ZXJLZXlzLFxuICAgICAgICAgIGJlZm9yZUVycm9yID0gX3JlZjIuYmVmb3JlRXJyb3IsXG4gICAgICAgICAgYWZ0ZXJFcnJvciA9IF9yZWYyLmFmdGVyRXJyb3IsXG4gICAgICAgICAgYmVmb3JlQ29tcGxldGUgPSBfcmVmMi5iZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgICBhZnRlckNvbXBsZXRlID0gX3JlZjIuYWZ0ZXJDb21wbGV0ZSxcbiAgICAgICAgICBfcmVmMiRmbHVzaCA9IF9yZWYyLmZsdXNoLFxuICAgICAgICAgIGZsdXNoID0gX3JlZjIkZmx1c2ggPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMiRmbHVzaCxcbiAgICAgICAgICBfcmVmMiRyZWFjdGl2ZSA9IF9yZWYyLnJlYWN0aXZlLFxuICAgICAgICAgIHJlYWN0aXZlID0gX3JlZjIkcmVhY3RpdmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIkcmVhY3RpdmUsXG4gICAgICAgICAgX3JlZjIkZmV0Y2hTaXplID0gX3JlZjIuZmV0Y2hTaXplLFxuICAgICAgICAgIGZldGNoU2l6ZSA9IF9yZWYyJGZldGNoU2l6ZSA9PT0gdm9pZCAwID8gX3JlcXVlc3RNZXNzYWdlLkFMTCA6IF9yZWYyJGZldGNoU2l6ZTtcblxuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IF9zdHJlYW1PYnNlcnZlcnMuUmVzdWx0U3RyZWFtT2JzZXJ2ZXIoe1xuICAgICAgICBjb25uZWN0aW9uOiB0aGlzLl9jb25uZWN0aW9uLFxuICAgICAgICByZWFjdGl2ZTogcmVhY3RpdmUsXG4gICAgICAgIGZldGNoU2l6ZTogZmV0Y2hTaXplLFxuICAgICAgICBtb3JlRnVuY3Rpb246IHRoaXMuX3JlcXVlc3RNb3JlLFxuICAgICAgICBkaXNjYXJkRnVuY3Rpb246IHRoaXMuX3JlcXVlc3REaXNjYXJkLFxuICAgICAgICBiZWZvcmVLZXlzOiBiZWZvcmVLZXlzLFxuICAgICAgICBhZnRlcktleXM6IGFmdGVyS2V5cyxcbiAgICAgICAgYmVmb3JlRXJyb3I6IGJlZm9yZUVycm9yLFxuICAgICAgICBhZnRlckVycm9yOiBhZnRlckVycm9yLFxuICAgICAgICBiZWZvcmVDb21wbGV0ZTogYmVmb3JlQ29tcGxldGUsXG4gICAgICAgIGFmdGVyQ29tcGxldGU6IGFmdGVyQ29tcGxldGVcbiAgICAgIH0pO1xuICAgICAgdmFyIGZsdXNoUnVuID0gcmVhY3RpdmU7XG5cbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24ud3JpdGUoX3JlcXVlc3RNZXNzYWdlW1wiZGVmYXVsdFwiXS5ydW5XaXRoTWV0YWRhdGEocXVlcnksIHBhcmFtZXRlcnMsIHtcbiAgICAgICAgYm9va21hcms6IGJvb2ttYXJrLFxuICAgICAgICB0eENvbmZpZzogdHhDb25maWcsXG4gICAgICAgIGRhdGFiYXNlOiBkYXRhYmFzZSxcbiAgICAgICAgbW9kZTogbW9kZVxuICAgICAgfSksIG9ic2VydmVyLCBmbHVzaFJ1biAmJiBmbHVzaCk7XG5cbiAgICAgIGlmICghcmVhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi53cml0ZShfcmVxdWVzdE1lc3NhZ2VbXCJkZWZhdWx0XCJdLnB1bGwoe1xuICAgICAgICAgIG46IGZldGNoU2l6ZVxuICAgICAgICB9KSwgb2JzZXJ2ZXIsIGZsdXNoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVxdWVzdE1vcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcXVlc3RNb3JlKGNvbm5lY3Rpb24sIHN0bXRJZCwgbiwgb2JzZXJ2ZXIpIHtcbiAgICAgIGNvbm5lY3Rpb24ud3JpdGUoX3JlcXVlc3RNZXNzYWdlW1wiZGVmYXVsdFwiXS5wdWxsKHtcbiAgICAgICAgc3RtdElkOiBzdG10SWQsXG4gICAgICAgIG46IG5cbiAgICAgIH0pLCBvYnNlcnZlciwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZXF1ZXN0RGlzY2FyZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVxdWVzdERpc2NhcmQoY29ubmVjdGlvbiwgc3RtdElkLCBvYnNlcnZlcikge1xuICAgICAgY29ubmVjdGlvbi53cml0ZShfcmVxdWVzdE1lc3NhZ2VbXCJkZWZhdWx0XCJdLmRpc2NhcmQoe1xuICAgICAgICBzdG10SWQ6IHN0bXRJZFxuICAgICAgfSksIG9ic2VydmVyLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX25vT3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25vT3AoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInZlcnNpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29uc3RhbnRzLkJPTFRfUFJPVE9DT0xfVjRfMDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJvbHRQcm90b2NvbDtcbn0oX2JvbHRQcm90b2NvbFZbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBCb2x0UHJvdG9jb2w7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2JvbHRQcm90b2NvbFY0eCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYm9sdC1wcm90b2NvbC12NHgwXCIpKTtcblxudmFyIF9yZXF1ZXN0TWVzc2FnZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3JlcXVlc3QtbWVzc2FnZVwiKSk7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXG52YXIgX3N0cmVhbU9ic2VydmVycyA9IHJlcXVpcmUoXCIuL3N0cmVhbS1vYnNlcnZlcnNcIik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yW1wiZGVmYXVsdFwiXSkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBCb2x0UHJvdG9jb2wgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Cb2x0UHJvdG9jb2xWKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoQm9sdFByb3RvY29sLCBfQm9sdFByb3RvY29sVik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihCb2x0UHJvdG9jb2wpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge0NodW5rZXJ9IGNodW5rZXIgdGhlIGNodW5rZXIuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMgaWYgdGhpcyBjb25uZWN0aW9uIHNob3VsZCBjb252ZXJ0IGFsbCByZWNlaXZlZCBpbnRlZ2VycyB0byBuYXRpdmUgSlMgbnVtYmVycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNlcnZlcnNpZGVSb3V0aW5nXG4gICAqL1xuICBmdW5jdGlvbiBCb2x0UHJvdG9jb2woY29ubmVjdGlvbiwgY2h1bmtlciwgZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMsIHNlcnZlcnNpZGVSb3V0aW5nKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBCb2x0UHJvdG9jb2wpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29ubmVjdGlvbiwgY2h1bmtlciwgZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xuICAgIF90aGlzLl9zZXJ2ZXJzaWRlUm91dGluZyA9IHNlcnZlcnNpZGVSb3V0aW5nO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQm9sdFByb3RvY29sLCBbe1xuICAgIGtleTogXCJpbml0aWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgdXNlckFnZW50ID0gX3JlZi51c2VyQWdlbnQsXG4gICAgICAgICAgYXV0aFRva2VuID0gX3JlZi5hdXRoVG9rZW4sXG4gICAgICAgICAgb25FcnJvciA9IF9yZWYub25FcnJvcixcbiAgICAgICAgICBvbkNvbXBsZXRlID0gX3JlZi5vbkNvbXBsZXRlO1xuXG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgX3N0cmVhbU9ic2VydmVycy5Mb2dpbk9ic2VydmVyKHtcbiAgICAgICAgY29ubmVjdGlvbjogdGhpcy5fY29ubmVjdGlvbixcbiAgICAgICAgYWZ0ZXJFcnJvcjogb25FcnJvcixcbiAgICAgICAgYWZ0ZXJDb21wbGV0ZTogb25Db21wbGV0ZVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24ud3JpdGUoX3JlcXVlc3RNZXNzYWdlW1wiZGVmYXVsdFwiXS5oZWxsbyh1c2VyQWdlbnQsIGF1dGhUb2tlbiwgdGhpcy5fc2VydmVyc2lkZVJvdXRpbmcpLCBvYnNlcnZlciwgdHJ1ZSk7XG5cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmVyc2lvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jb25zdGFudHMuQk9MVF9QUk9UT0NPTF9WNF8xO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQm9sdFByb3RvY29sO1xufShfYm9sdFByb3RvY29sVjR4W1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQm9sdFByb3RvY29sOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkXCIpO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgdXRpbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3V0aWxcIikpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBCT09LTUFSS1NfS0VZID0gJ2Jvb2ttYXJrcyc7XG5cbnZhciBCb29rbWFyayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHZhbHVlcyBzaW5nbGUgYm9va21hcmsgYXMgc3RyaW5nIG9yIG11bHRpcGxlIGJvb2ttYXJrcyBhcyBhIHN0cmluZyBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIEJvb2ttYXJrKHZhbHVlcykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgQm9va21hcmspO1xuICAgIHRoaXMuX3ZhbHVlcyA9IGFzU3RyaW5nQXJyYXkodmFsdWVzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQm9va21hcmssIFt7XG4gICAga2V5OiBcImlzRW1wdHlcIixcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBib29rbWFyayBpcyBtZWFuaW5nZnVsIGFuZCBjYW4gYmUgc2VuZCB0byB0aGUgZGF0YWJhc2UuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gcmV0dXJucyBgdHJ1ZWAgYm9va21hcmsgaGFzIGEgdmFsdWUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgYm9va21hcmsgdmFsdWVzIGFzIGFuIGFycmF5LlxuICAgICAqIEByZXR1cm4ge3N0cmluZ1tdfSBhbGwgdmFsdWVzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGlzIGJvb2ttYXJrIGFzIGFuIG9iamVjdCBmb3IgYmVnaW4gdHJhbnNhY3Rpb24gY2FsbC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSB2YWx1ZSBvZiB0aGlzIGJvb2ttYXJrIGFzIG9iamVjdC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFzQmVnaW5UcmFuc2FjdGlvblBhcmFtZXRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNCZWdpblRyYW5zYWN0aW9uUGFyYW1ldGVycygpIHtcbiAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9IC8vIERyaXZlciBzZW5kcyB7Ym9va21hcms6IFwibWF4XCIsIGJvb2ttYXJrczogW1wib25lXCIsIFwidHdvXCIsIFwibWF4XCJdfSBpbnN0ZWFkIG9mIHNpbXBsZVxuICAgICAgLy8ge2Jvb2ttYXJrczogW1wib25lXCIsIFwidHdvXCIsIFwibWF4XCJdfSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29ucy4gT2xkIHNlcnZlcnMgY2FuIG9ubHkgYWNjZXB0IHNpbmdsZVxuICAgICAgLy8gYm9va21hcmsgdGhhdCBpcyB3aHkgZHJpdmVyIGhhcyB0byBwYXJzZSBhbmQgY29tcGFyZSBnaXZlbiBsaXN0IG9mIGJvb2ttYXJrcy4gVGhpcyBmdW5jdGlvbmFsaXR5IHdpbGxcbiAgICAgIC8vIGV2ZW50dWFsbHkgYmUgcmVtb3ZlZC5cblxuXG4gICAgICByZXR1cm4gKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSh7fSwgQk9PS01BUktTX0tFWSwgdGhpcy5fdmFsdWVzKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJlbXB0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgICAgIHJldHVybiBFTVBUWV9CT09LTUFSSztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJvb2ttYXJrO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEJvb2ttYXJrO1xudmFyIEVNUFRZX0JPT0tNQVJLID0gbmV3IEJvb2ttYXJrKG51bGwpO1xuLyoqXG4gKiBDb252ZXJ0cyBnaXZlbiB2YWx1ZSB0byBhbiBhcnJheS5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfEFycmF5fSBbdmFsdWU9dW5kZWZpbmVkXSBhcmd1bWVudCB0byBjb252ZXJ0LlxuICogQHJldHVybiB7c3RyaW5nW119IHZhbHVlIGNvbnZlcnRlZCB0byBhbiBhcnJheS5cbiAqL1xuXG5mdW5jdGlvbiBhc1N0cmluZ0FycmF5KHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgZmxhdHRlbmVkVmFsdWUgPSBmbGF0dGVuQXJyYXkodmFsdWUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbGF0dGVuZWRWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZW1lbnQgPSBmbGF0dGVuZWRWYWx1ZVtpXTsgLy8gaWYgaXQgaXMgdW5kZWZpbmVkIG9yIG51bGwsIGlnbm9yZSBpdFxuXG4gICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKGVsZW1lbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkJvb2ttYXJrIHZhbHVlIHNob3VsZCBiZSBhIHN0cmluZywgZ2l2ZW46ICdcIi5jb25jYXQoZWxlbWVudCwgXCInXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQm9va21hcmsgc2hvdWxkIGVpdGhlciBiZSBhIHN0cmluZyBvciBhIHN0cmluZyBhcnJheSwgZ2l2ZW46ICdcIi5jb25jYXQodmFsdWUsIFwiJ1wiKSk7XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGFuIGFycmF5IHNvIHRoYXQgdGhlIHJlc3VsdCBiZWNvbWVzIGEgc2luZ2xlIGFycmF5XG4gKiBvZiB2YWx1ZXMsIHdoaWNoIGRvZXMgbm90IGluY2x1ZGUgYW55IHN1Yi1hcnJheXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZVxuICovXG5cblxuZnVuY3Rpb24gZmxhdHRlbkFycmF5KHZhbHVlcykge1xuICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoZGVzdCwgdmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBkZXN0LmNvbmNhdChmbGF0dGVuQXJyYXkodmFsdWUpKSA6IGRlc3QuY29uY2F0KHZhbHVlKTtcbiAgfSwgW10pO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9iYXNlQnVmID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vYnVmL2Jhc2UtYnVmXCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIEhlYXBCdWZmZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQnVmZmVyKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoSGVhcEJ1ZmZlciwgX0Jhc2VCdWZmZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSGVhcEJ1ZmZlcik7XG5cbiAgZnVuY3Rpb24gSGVhcEJ1ZmZlcihhcmcpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIEhlYXBCdWZmZXIpO1xuICAgIHZhciBidWZmZXIgPSBhcmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IGFyZyA6IG5ldyBBcnJheUJ1ZmZlcihhcmcpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgIF90aGlzLl9idWZmZXIgPSBidWZmZXI7XG4gICAgX3RoaXMuX3ZpZXcgPSBuZXcgRGF0YVZpZXcoX3RoaXMuX2J1ZmZlcik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShIZWFwQnVmZmVyLCBbe1xuICAgIGtleTogXCJwdXRVSW50OFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXRVSW50OChwb3NpdGlvbiwgdmFsKSB7XG4gICAgICB0aGlzLl92aWV3LnNldFVpbnQ4KHBvc2l0aW9uLCB2YWwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRVSW50OFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVSW50OChwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcuZ2V0VWludDgocG9zaXRpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwdXRJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1dEludDgocG9zaXRpb24sIHZhbCkge1xuICAgICAgdGhpcy5fdmlldy5zZXRJbnQ4KHBvc2l0aW9uLCB2YWwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEludDgocG9zaXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl92aWV3LmdldEludDgocG9zaXRpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGbG9hdDY0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZsb2F0NjQocG9zaXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl92aWV3LmdldEZsb2F0NjQocG9zaXRpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwdXRGbG9hdDY0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1dEZsb2F0NjQocG9zaXRpb24sIHZhbCkge1xuICAgICAgdGhpcy5fdmlldy5zZXRGbG9hdDY0KHBvc2l0aW9uLCB2YWwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTbGljZShzdGFydCwgbGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fYnVmZmVyLnNsaWNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGVhcEJ1ZmZlcih0aGlzLl9idWZmZXIuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgbGVuZ3RoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTb21lIHBsYXRmb3JtcyAoZWcuIHBoYW50b21qcykgZG9uJ3Qgc3VwcG9ydCBzbGljZSwgc28gZmFsbCBiYWNrIHRvIGEgY29weVxuICAgICAgICAvLyBXZSBkbyB0aGlzIHJhdGhlciB0aGFuIHJldHVybiBhIFNsaWNlQnVmZmVyLCBiZWNhdXNlIHNsaWNlQnVmZmVyIGNhbm5vdFxuICAgICAgICAvLyBiZSBwYXNzZWQgdG8gbmF0aXZlIG5ldHdvcmsgd3JpdGUgb3BzIGV0YyAtIHdlIG5lZWQgQXJyYXlCdWZmZXIgZm9yIHRoYXRcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgSGVhcEJ1ZmZlcihsZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb3B5LnB1dFVJbnQ4KGksIHRoaXMuZ2V0VUludDgoaSArIHN0YXJ0KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29weTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWMgdG8gSGVhcEJ1ZmZlciwgdGhpcyBnZXRzIGEgRGF0YVZpZXcgZnJvbSB0aGVcbiAgICAgKiBjdXJyZW50IHBvc2l0aW9uIGFuZCBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRWaWV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRWaWV3KGxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyh0aGlzLl9idWZmZXIsIHRoaXMuX3VwZGF0ZVBvcyhsZW5ndGgpLCBsZW5ndGgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSGVhcEJ1ZmZlcjtcbn0oX2Jhc2VCdWZbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBIZWFwQnVmZmVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2Jyb3dzZXJCdWYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jyb3dzZXItYnVmXCIpKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvclwiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gSnVzdCB0byBiZSBzdXJlIHRoYXQgdGhlc2UgdmFsdWVzIGFyZSB3aXRoIHVzIGV2ZW4gYWZ0ZXIgV2ViU29ja2V0IGlzIGluamVjdGVkXG4vLyBmb3IgdGVzdHMuXG52YXIgV1NfQ09OTkVDVElORyA9IDA7XG52YXIgV1NfT1BFTiA9IDE7XG52YXIgV1NfQ0xPU0lORyA9IDI7XG52YXIgV1NfQ0xPU0VEID0gMztcbi8qKlxuICogQ3JlYXRlIGEgbmV3IFdlYlNvY2tldENoYW5uZWwgdG8gYmUgdXNlZCBpbiB3ZWIgYnJvd3NlcnMuXG4gKiBAYWNjZXNzIHByaXZhdGVcbiAqL1xuXG52YXIgV2ViU29ja2V0Q2hhbm5lbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgbmV3IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7Q2hhbm5lbENvbmZpZ30gY29uZmlnIC0gY29uZmlndXJhdGlvbiBmb3IgdGhpcyBjaGFubmVsLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHN0cmluZ30gcHJvdG9jb2xTdXBwbGllciAtIGZ1bmN0aW9uIHRoYXQgZGV0ZWN0cyBwcm90b2NvbCBvZiB0aGUgd2ViIHBhZ2UuIFNob3VsZCBvbmx5IGJlIHVzZWQgaW4gdGVzdHMuXG4gICAqL1xuICBmdW5jdGlvbiBXZWJTb2NrZXRDaGFubmVsKGNvbmZpZykge1xuICAgIHZhciBwcm90b2NvbFN1cHBsaWVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBkZXRlY3RXZWJQYWdlUHJvdG9jb2w7XG4gICAgdmFyIHNvY2tldEZhY3RvcnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgIHJldHVybiBuZXcgV2ViU29ja2V0KHVybCk7XG4gICAgfTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFdlYlNvY2tldENoYW5uZWwpO1xuICAgIHRoaXMuX29wZW4gPSB0cnVlO1xuICAgIHRoaXMuX3BlbmRpbmcgPSBbXTtcbiAgICB0aGlzLl9lcnJvciA9IG51bGw7XG4gICAgdGhpcy5faGFuZGxlQ29ubmVjdGlvbkVycm9yID0gdGhpcy5faGFuZGxlQ29ubmVjdGlvbkVycm9yLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuXG4gICAgdmFyIF9kZXRlcm1pbmVXZWJTb2NrZXRTYyA9IGRldGVybWluZVdlYlNvY2tldFNjaGVtZShjb25maWcsIHByb3RvY29sU3VwcGxpZXIpLFxuICAgICAgICBzY2hlbWUgPSBfZGV0ZXJtaW5lV2ViU29ja2V0U2Muc2NoZW1lLFxuICAgICAgICBlcnJvciA9IF9kZXRlcm1pbmVXZWJTb2NrZXRTYy5lcnJvcjtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl93cyA9IGNyZWF0ZVdlYlNvY2tldChzY2hlbWUsIGNvbmZpZy5hZGRyZXNzLCBzb2NrZXRGYWN0b3J5KTtcbiAgICB0aGlzLl93cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIEFsbCBjb25uZWN0aW9uIGVycm9ycyBhcmUgbm90IHNlbnQgdG8gdGhlIGVycm9yIGhhbmRsZXJcbiAgICAvLyB3ZSBtdXN0IGFsc28gY2hlY2sgZm9yIGRpcnR5IGNsb3NlIGNhbGxzXG5cbiAgICB0aGlzLl93cy5vbmNsb3NlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlICYmICFlLndhc0NsZWFuKSB7XG4gICAgICAgIHNlbGYuX2hhbmRsZUNvbm5lY3Rpb25FcnJvcigpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl93cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDb25uZWN0ZWQhIENhbmNlbCB0aGUgY29ubmVjdGlvbiB0aW1lb3V0XG4gICAgICBzZWxmLl9jbGVhckNvbm5lY3Rpb25UaW1lb3V0KCk7IC8vIERyYWluIGFsbCBwZW5kaW5nIG1lc3NhZ2VzXG5cblxuICAgICAgdmFyIHBlbmRpbmcgPSBzZWxmLl9wZW5kaW5nO1xuICAgICAgc2VsZi5fcGVuZGluZyA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGVuZGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLndyaXRlKHBlbmRpbmdbaV0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl93cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChzZWxmLm9ubWVzc2FnZSkge1xuICAgICAgICB2YXIgYiA9IG5ldyBfYnJvd3NlckJ1ZltcImRlZmF1bHRcIl0oZXZlbnQuZGF0YSk7XG4gICAgICAgIHNlbGYub25tZXNzYWdlKGIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl93cy5vbmVycm9yID0gdGhpcy5faGFuZGxlQ29ubmVjdGlvbkVycm9yO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25UaW1lb3V0RmlyZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jb25uZWN0aW9uVGltZW91dElkID0gdGhpcy5fc2V0dXBDb25uZWN0aW9uVGltZW91dCgpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShXZWJTb2NrZXRDaGFubmVsLCBbe1xuICAgIGtleTogXCJfaGFuZGxlQ29ubmVjdGlvbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDb25uZWN0aW9uRXJyb3IoKSB7XG4gICAgICBpZiAodGhpcy5fY29ubmVjdGlvblRpbWVvdXRGaXJlZCkge1xuICAgICAgICAvLyB0aW1lb3V0IGZpcmVkIC0gbm90IGNvbm5lY3RlZCB3aXRoaW4gY29uZmlndXJlZCB0aW1lXG4gICAgICAgIHRoaXMuX2Vycm9yID0gKDAsIF9lcnJvci5uZXdFcnJvcikoXCJGYWlsZWQgdG8gZXN0YWJsaXNoIGNvbm5lY3Rpb24gaW4gXCIuY29uY2F0KHRoaXMuX2NvbmZpZy5jb25uZWN0aW9uVGltZW91dCwgXCJtc1wiKSwgdGhpcy5fY29uZmlnLmNvbm5lY3Rpb25FcnJvckNvZGUpO1xuXG4gICAgICAgIGlmICh0aGlzLm9uZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLm9uZXJyb3IodGhpcy5fZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBvbmVycm9yIHRyaWdnZXJzIG9uIHdlYnNvY2tldCBjbG9zZSBhcyB3ZWxsLi4gZG9uJ3QgZ2V0IG1lIHN0YXJ0ZWQuXG5cblxuICAgICAgaWYgKHRoaXMuX29wZW4pIHtcbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNTc3OTgzMS9ob3ctdG8tY2F0Y2gtd2Vic29ja2V0LWNvbm5lY3Rpb24tdG8td3MteHh4bm4tZmFpbGVkLWNvbm5lY3Rpb24tY2xvc2VkLWJlXG4gICAgICAgIHRoaXMuX2Vycm9yID0gKDAsIF9lcnJvci5uZXdFcnJvcikoJ1dlYlNvY2tldCBjb25uZWN0aW9uIGZhaWx1cmUuIER1ZSB0byBzZWN1cml0eSAnICsgJ2NvbnN0cmFpbnRzIGluIHlvdXIgd2ViIGJyb3dzZXIsIHRoZSByZWFzb24gZm9yIHRoZSBmYWlsdXJlIGlzIG5vdCBhdmFpbGFibGUgJyArICd0byB0aGlzIE5lbzRqIERyaXZlci4gUGxlYXNlIHVzZSB5b3VyIGJyb3dzZXJzIGRldmVsb3BtZW50IGNvbnNvbGUgdG8gZGV0ZXJtaW5lICcgKyAndGhlIHJvb3QgY2F1c2Ugb2YgdGhlIGZhaWx1cmUuIENvbW1vbiByZWFzb25zIGluY2x1ZGUgdGhlIGRhdGFiYXNlIGJlaW5nICcgKyAndW5hdmFpbGFibGUsIHVzaW5nIHRoZSB3cm9uZyBjb25uZWN0aW9uIFVSTCBvciB0ZW1wb3JhcnkgbmV0d29yayBwcm9ibGVtcy4gJyArICdJZiB5b3UgaGF2ZSBlbmFibGVkIGVuY3J5cHRpb24sIGVuc3VyZSB5b3VyIGJyb3dzZXIgaXMgY29uZmlndXJlZCB0byB0cnVzdCB0aGUgJyArICdjZXJ0aWZpY2F0ZSBOZW80aiBpcyBjb25maWd1cmVkIHRvIHVzZS4gV2ViU29ja2V0IGByZWFkeVN0YXRlYCBpczogJyArIHRoaXMuX3dzLnJlYWR5U3RhdGUsIHRoaXMuX2NvbmZpZy5jb25uZWN0aW9uRXJyb3JDb2RlKTtcblxuICAgICAgICBpZiAodGhpcy5vbmVycm9yKSB7XG4gICAgICAgICAgdGhpcy5vbmVycm9yKHRoaXMuX2Vycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0aGUgcGFzc2VkIGluIGJ1ZmZlciB0byBjb25uZWN0aW9uXG4gICAgICogQHBhcmFtIHtIZWFwQnVmZmVyfSBidWZmZXIgLSBCdWZmZXIgdG8gd3JpdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlKGJ1ZmZlcikge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwZW5kaW5nIHF1ZXVlLCBwdXNoIHRoaXMgb24gdGhhdCBxdWV1ZS4gVGhpcyBtZWFuc1xuICAgICAgLy8gd2UgYXJlIG5vdCB5ZXQgY29ubmVjdGVkLCBzbyB3ZSBxdWV1ZSB0aGluZ3MgbG9jYWxseS5cbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmcucHVzaChidWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChidWZmZXIgaW5zdGFuY2VvZiBfYnJvd3NlckJ1ZltcImRlZmF1bHRcIl0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLl93cy5zZW5kKGJ1ZmZlci5fYnVmZmVyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAodGhpcy5fd3MucmVhZHlTdGF0ZSAhPT0gV1NfT1BFTikge1xuICAgICAgICAgICAgLy8gV2Vic29ja2V0IGhhcyBiZWVuIGNsb3NlZFxuICAgICAgICAgICAgdGhpcy5faGFuZGxlQ29ubmVjdGlvbkVycm9yKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNvbWUgb3RoZXIgZXJyb3Igb2NjdXJlZFxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKShcIkRvbid0IGtub3cgaG93IHRvIHNlbmQgYnVmZmVyOiBcIiArIGJ1ZmZlcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBjb25uZWN0aW9uXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgYWZ0ZXIgY2hhbm5lbCBpcyBjbG9zZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKF90aGlzLl93cyAmJiBfdGhpcy5fd3MucmVhZHlTdGF0ZSAhPT0gV1NfQ0xPU0VEKSB7XG4gICAgICAgICAgX3RoaXMuX29wZW4gPSBmYWxzZTtcblxuICAgICAgICAgIF90aGlzLl9jbGVhckNvbm5lY3Rpb25UaW1lb3V0KCk7XG5cbiAgICAgICAgICBfdGhpcy5fd3Mub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzLl93cy5jbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBjb25uZWN0aW9uIHRpbWVvdXQgb24gdGhlIGdpdmVuIFdlYlNvY2tldCwgaWYgY29uZmlndXJlZC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSB0aW1lb3V0IGlkIG9yIG51bGwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXR1cENvbm5lY3Rpb25UaW1lb3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cENvbm5lY3Rpb25UaW1lb3V0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fY29uZmlnLmNvbm5lY3Rpb25UaW1lb3V0O1xuXG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICB2YXIgd2ViU29ja2V0ID0gdGhpcy5fd3M7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAod2ViU29ja2V0LnJlYWR5U3RhdGUgIT09IFdTX09QRU4pIHtcbiAgICAgICAgICAgIF90aGlzMi5fY29ubmVjdGlvblRpbWVvdXRGaXJlZCA9IHRydWU7XG4gICAgICAgICAgICB3ZWJTb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFjdGl2ZSBjb25uZWN0aW9uIHRpbWVvdXQsIGlmIGFueS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsZWFyQ29ubmVjdGlvblRpbWVvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFyQ29ubmVjdGlvblRpbWVvdXQoKSB7XG4gICAgICB2YXIgdGltZW91dElkID0gdGhpcy5fY29ubmVjdGlvblRpbWVvdXRJZDtcblxuICAgICAgaWYgKHRpbWVvdXRJZCB8fCB0aW1lb3V0SWQgPT09IDApIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblRpbWVvdXRGaXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBXZWJTb2NrZXRDaGFubmVsO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFdlYlNvY2tldENoYW5uZWw7XG5cbmZ1bmN0aW9uIGNyZWF0ZVdlYlNvY2tldChzY2hlbWUsIGFkZHJlc3MsIHNvY2tldEZhY3RvcnkpIHtcbiAgdmFyIHVybCA9IHNjaGVtZSArICc6Ly8nICsgYWRkcmVzcy5hc0hvc3RQb3J0KCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gc29ja2V0RmFjdG9yeSh1cmwpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0lQdjZBZGRyZXNzSXNzdWVPbldpbmRvd3MoZXJyb3IsIGFkZHJlc3MpKSB7XG4gICAgICAvLyBXZWJTb2NrZXQgaW4gSUUgYW5kIEVkZ2UgYnJvd3NlcnMgb24gV2luZG93cyBkbyBub3Qgc3VwcG9ydCByZWd1bGFyIElQdjYgYWRkcmVzcyBzeW50YXggYmVjYXVzZSB0aGV5IGNvbnRhaW4gJzonLlxuICAgICAgLy8gSXQncyBhbiBpbnZhbGlkIGNoYXJhY3RlciBmb3IgVU5DIChodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JUHY2X2FkZHJlc3MjTGl0ZXJhbF9JUHY2X2FkZHJlc3Nlc19pbl9VTkNfcGF0aF9uYW1lcylcbiAgICAgIC8vIGFuZCBXaW5kb3dzIHJlcXVpcmVzIElQdjYgdG8gYmUgY2hhbmdlcyBpbiB0aGUgZm9sbG93aW5nIHdheTpcbiAgICAgIC8vICAgMSkgcmVwbGFjZSBhbGwgJzonIHdpdGggJy0nXG4gICAgICAvLyAgIDIpIHJlcGxhY2UgJyUnIHdpdGggJ3MnIGZvciBsaW5rLWxvY2FsIGFkZHJlc3NcbiAgICAgIC8vICAgMykgYXBwZW5kICcuaXB2Ni1saXRlcmFsLm5ldCcgc3VmZml4XG4gICAgICAvLyBvbmx5IHRoZW4gcmVzdWx0aW5nIHN0cmluZyBjYW4gYmUgY29uc2lkZXJlZCBhIHZhbGlkIElQdjYgYWRkcmVzcy4gWWVzLCB0aGlzIGlzIGV4dHJlbWVseSB3ZWlyZCFcbiAgICAgIC8vIEZvciBtb3JlIGRldGFpbHMgc2VlOlxuICAgICAgLy8gICBodHRwczovL3NvY2lhbC5tc2RuLm1pY3Jvc29mdC5jb20vRm9ydW1zL2llL2VuLVVTLzA2Y2NhNzNiLTYzYzItNGJmOS04OTliLWIyMjljNTA0NDlmZi93aGV0aGVyLWllMTAtd2Vic29ja2V0LXN1cHBvcnQtaXB2Nj9mb3J1bT1pZXdlYmRldmVsb3BtZW50XG4gICAgICAvLyAgIGh0dHBzOi8vd3d3Lml0ZG9qby5jb20vaXB2Ni1hZGRyZXNzZXMtYW5kLXVuYy1wYXRoLW5hbWVzLW92ZXJjb21pbmctaWxsZWdhbC9cbiAgICAgIC8vIENyZWF0aW9uIG9mIFdlYlNvY2tldCB3aXRoIHVuY29udmVydGVkIGFkZHJlc3MgcmVzdWx0cyBpbiBTeW50YXhFcnJvciB3aXRob3V0IG1lc3NhZ2Ugb3Igc3RhY2t0cmFjZS5cbiAgICAgIC8vIFRoYXQgaXMgd2h5IGhlcmUgd2UgXCJjYXRjaFwiIFN5bnRheEVycm9yIGFuZCByZXdyaXRlIElQdjYgYWRkcmVzcyBpZiBuZWVkZWQuXG4gICAgICB2YXIgd2luZG93c0ZyaWVuZGx5VXJsID0gYXNXaW5kb3dzRnJpZW5kbHlJUHY2QWRkcmVzcyhzY2hlbWUsIGFkZHJlc3MpO1xuICAgICAgcmV0dXJuIHNvY2tldEZhY3Rvcnkod2luZG93c0ZyaWVuZGx5VXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzSVB2NkFkZHJlc3NJc3N1ZU9uV2luZG93cyhlcnJvciwgYWRkcmVzcykge1xuICByZXR1cm4gZXJyb3IubmFtZSA9PT0gJ1N5bnRheEVycm9yJyAmJiBpc0lQdjZBZGRyZXNzKGFkZHJlc3MuYXNIb3N0UG9ydCgpKTtcbn1cblxuZnVuY3Rpb24gaXNJUHY2QWRkcmVzcyhob3N0QW5kUG9ydCkge1xuICByZXR1cm4gaG9zdEFuZFBvcnQuY2hhckF0KDApID09PSAnWycgJiYgaG9zdEFuZFBvcnQuaW5kZXhPZignXScpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gYXNXaW5kb3dzRnJpZW5kbHlJUHY2QWRkcmVzcyhzY2hlbWUsIGFkZHJlc3MpIHtcbiAgLy8gcmVwbGFjZSBhbGwgJzonIHdpdGggJy0nXG4gIHZhciBob3N0V2l0aG91dENvbG9ucyA9IGFkZHJlc3MuaG9zdCgpLnJlcGxhY2UobmV3IFJlZ0V4cCgnOicsICdnJyksICctJyk7IC8vIHJlcGxhY2UgJyUnIHdpdGggJ3MnIGZvciBsaW5rLWxvY2FsIElQdjYgYWRkcmVzcyBsaWtlICdmZTgwOjoxJWxvMCdcblxuICB2YXIgaG9zdFdpdGhvdXRQZXJjZW50ID0gaG9zdFdpdGhvdXRDb2xvbnMucmVwbGFjZSgnJScsICdzJyk7IC8vIGFwcGVuZCBtYWdpYyAnLmlwdjYtbGl0ZXJhbC5uZXQnIHN1ZmZpeFxuXG4gIHZhciBpcHY2SG9zdCA9IGhvc3RXaXRob3V0UGVyY2VudCArICcuaXB2Ni1saXRlcmFsLm5ldCc7XG4gIHJldHVybiBcIlwiLmNvbmNhdChzY2hlbWUsIFwiOi8vXCIpLmNvbmNhdChpcHY2SG9zdCwgXCI6XCIpLmNvbmNhdChhZGRyZXNzLnBvcnQoKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7Q2hhbm5lbENvbmZpZ30gY29uZmlnIC0gY29uZmlndXJhdGlvbiBmb3IgdGhlIGNoYW5uZWwuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHN0cmluZ30gcHJvdG9jb2xTdXBwbGllciAtIGZ1bmN0aW9uIHRoYXQgZGV0ZWN0cyBwcm90b2NvbCBvZiB0aGUgd2ViIHBhZ2UuXG4gKiBAcmV0dXJuIHt7c2NoZW1lOiBzdHJpbmd8bnVsbCwgZXJyb3I6IE5lbzRqRXJyb3J8bnVsbH19IG9iamVjdCBjb250YWluaW5nIGVpdGhlciBzY2hlbWUgb3IgZXJyb3IuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXRlcm1pbmVXZWJTb2NrZXRTY2hlbWUoY29uZmlnLCBwcm90b2NvbFN1cHBsaWVyKSB7XG4gIHZhciBlbmNyeXB0aW9uT24gPSBpc0VuY3J5cHRpb25FeHBsaWNpdGx5VHVybmVkT24oY29uZmlnKTtcbiAgdmFyIGVuY3J5cHRpb25PZmYgPSBpc0VuY3J5cHRpb25FeHBsaWNpdGx5VHVybmVkT2ZmKGNvbmZpZyk7XG4gIHZhciB0cnVzdCA9IGNvbmZpZy50cnVzdDtcbiAgdmFyIHNlY3VyZVByb3RvY29sID0gaXNQcm90b2NvbFNlY3VyZShwcm90b2NvbFN1cHBsaWVyKTtcbiAgdmVyaWZ5RW5jcnlwdGlvblNldHRpbmdzKGVuY3J5cHRpb25PbiwgZW5jcnlwdGlvbk9mZiwgc2VjdXJlUHJvdG9jb2wpO1xuXG4gIGlmIChlbmNyeXB0aW9uT2ZmKSB7XG4gICAgLy8gZW5jcnlwdGlvbiBleHBsaWNpdGx5IHR1cm5lZCBvZmYgaW4gdGhlIGNvbmZpZ1xuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWU6ICd3cycsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH07XG4gIH1cblxuICBpZiAoc2VjdXJlUHJvdG9jb2wpIHtcbiAgICAvLyBkcml2ZXIgaXMgdXNlZCBpbiBhIHNlY3VyZSBodHRwcyB3ZWIgcGFnZSwgdXNlICd3c3MnXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtZTogJ3dzcycsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH07XG4gIH1cblxuICBpZiAoZW5jcnlwdGlvbk9uKSB7XG4gICAgLy8gZW5jcnlwdGlvbiBleHBsaWNpdGx5IHJlcXVlc3RlZCBpbiB0aGUgY29uZmlnXG4gICAgaWYgKCF0cnVzdCB8fCB0cnVzdCA9PT0gJ1RSVVNUX1NZU1RFTV9DQV9TSUdORURfQ0VSVElGSUNBVEVTJykge1xuICAgICAgLy8gdHJ1c3Qgc3RyYXRlZ3kgbm90IHNwZWNpZmllZCBvciB0aGUgb25seSBzdXBwb3J0ZWQgc3RyYXRlZ3kgaXMgc3BlY2lmaWVkXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6ICd3c3MnLFxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVycm9yID0gKDAsIF9lcnJvci5uZXdFcnJvcikoJ1RoZSBicm93c2VyIHZlcnNpb24gb2YgdGhpcyBkcml2ZXIgb25seSBzdXBwb3J0cyBvbmUgdHJ1c3QgJyArIFwic3RyYXRlZ3ksICdUUlVTVF9TWVNURU1fQ0FfU0lHTkVEX0NFUlRJRklDQVRFUycuIFwiICsgdHJ1c3QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSAnICsgJ2VpdGhlciB1c2UgVFJVU1RfU1lTVEVNX0NBX1NJR05FRF9DRVJUSUZJQ0FURVMgb3IgZGlzYWJsZSBlbmNyeXB0aW9uIGJ5IHNldHRpbmcgJyArICdgZW5jcnlwdGVkOlwiJyArIF91dGlsLkVOQ1JZUFRJT05fT0ZGICsgJ1wiYCBpbiB0aGUgZHJpdmVyIGNvbmZpZ3VyYXRpb24uJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6IG51bGwsXG4gICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gZGVmYXVsdCB0byB1bmVuY3J5cHRlZCB3ZWIgc29ja2V0XG5cblxuICByZXR1cm4ge1xuICAgIHNjaGVtZTogJ3dzJyxcbiAgICBlcnJvcjogbnVsbFxuICB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge0NoYW5uZWxDb25maWd9IGNvbmZpZyAtIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBjaGFubmVsLlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGVuY3J5cHRpb24gZW5hYmxlZCBpbiB0aGUgY29uZmlnLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRW5jcnlwdGlvbkV4cGxpY2l0bHlUdXJuZWRPbihjb25maWcpIHtcbiAgcmV0dXJuIGNvbmZpZy5lbmNyeXB0ZWQgPT09IHRydWUgfHwgY29uZmlnLmVuY3J5cHRlZCA9PT0gX3V0aWwuRU5DUllQVElPTl9PTjtcbn1cbi8qKlxuICogQHBhcmFtIHtDaGFubmVsQ29uZmlnfSBjb25maWcgLSBjb25maWd1cmF0aW9uIGZvciB0aGUgY2hhbm5lbC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBlbmNyeXB0aW9uIGRpc2FibGVkIGluIHRoZSBjb25maWcsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5cblxuZnVuY3Rpb24gaXNFbmNyeXB0aW9uRXhwbGljaXRseVR1cm5lZE9mZihjb25maWcpIHtcbiAgcmV0dXJuIGNvbmZpZy5lbmNyeXB0ZWQgPT09IGZhbHNlIHx8IGNvbmZpZy5lbmNyeXB0ZWQgPT09IF91dGlsLkVOQ1JZUFRJT05fT0ZGO1xufVxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHN0cmluZ30gcHJvdG9jb2xTdXBwbGllciAtIGZ1bmN0aW9uIHRoYXQgZGV0ZWN0cyBwcm90b2NvbCBvZiB0aGUgd2ViIHBhZ2UuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgcHJvdG9jb2wgcmV0dXJuZWQgYnkgdGhlIGdpdmVuIGZ1bmN0aW9uIGlzIHNlY3VyZSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cblxuXG5mdW5jdGlvbiBpc1Byb3RvY29sU2VjdXJlKHByb3RvY29sU3VwcGxpZXIpIHtcbiAgdmFyIHByb3RvY29sID0gdHlwZW9mIHByb3RvY29sU3VwcGxpZXIgPT09ICdmdW5jdGlvbicgPyBwcm90b2NvbFN1cHBsaWVyKCkgOiAnJztcbiAgcmV0dXJuIHByb3RvY29sICYmIHByb3RvY29sLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaHR0cHMnKSA+PSAwO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlFbmNyeXB0aW9uU2V0dGluZ3MoZW5jcnlwdGlvbk9uLCBlbmNyeXB0aW9uT2ZmLCBzZWN1cmVQcm90b2NvbCkge1xuICBpZiAoZW5jcnlwdGlvbk9uICYmICFzZWN1cmVQcm90b2NvbCkge1xuICAgIC8vIGVuY3J5cHRpb24gZXhwbGljaXRseSB0dXJuZWQgb24gZm9yIGEgZHJpdmVyIHVzZWQgb24gYSBIVFRQIHdlYiBwYWdlXG4gICAgY29uc29sZS53YXJuKCdOZW80aiBkcml2ZXIgaXMgY29uZmlndXJlZCB0byB1c2Ugc2VjdXJlIFdlYlNvY2tldCBvbiBhIEhUVFAgd2ViIHBhZ2UuICcgKyAnV2ViU29ja2V0cyBtaWdodCBub3Qgd29yayBpbiBhIG1peGVkIGNvbnRlbnQgZW52aXJvbm1lbnQuICcgKyAnUGxlYXNlIGNvbnNpZGVyIGNvbmZpZ3VyaW5nIGRyaXZlciB0byBub3QgdXNlIGVuY3J5cHRpb24uJyk7XG4gIH0gZWxzZSBpZiAoZW5jcnlwdGlvbk9mZiAmJiBzZWN1cmVQcm90b2NvbCkge1xuICAgIC8vIGVuY3J5cHRpb24gZXhwbGljaXRseSB0dXJuZWQgb2ZmIGZvciBhIGRyaXZlciB1c2VkIG9uIGEgSFRUUFMgd2ViIHBhZ2VcbiAgICBjb25zb2xlLndhcm4oJ05lbzRqIGRyaXZlciBpcyBjb25maWd1cmVkIHRvIHVzZSBpbnNlY3VyZSBXZWJTb2NrZXQgb24gYSBIVFRQUyB3ZWIgcGFnZS4gJyArICdXZWJTb2NrZXRzIG1pZ2h0IG5vdCB3b3JrIGluIGEgbWl4ZWQgY29udGVudCBlbnZpcm9ubWVudC4gJyArICdQbGVhc2UgY29uc2lkZXIgY29uZmlndXJpbmcgZHJpdmVyIHRvIHVzZSBlbmNyeXB0aW9uLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGVjdFdlYlBhZ2VQcm90b2NvbCgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhdGlvbiA/IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA6IG51bGw7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2Jhc2VIb3N0TmFtZVJlc29sdmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcmVzb2x2ZXIvYmFzZS1ob3N0LW5hbWUtcmVzb2x2ZXJcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgQnJvd3Nlckhvc3ROYW1lUmVzb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlSG9zdE5hbWVSZXNvbHZlcikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKEJyb3dzZXJIb3N0TmFtZVJlc29sdmVyLCBfQmFzZUhvc3ROYW1lUmVzb2x2ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQnJvd3Nlckhvc3ROYW1lUmVzb2x2ZXIpO1xuXG4gIGZ1bmN0aW9uIEJyb3dzZXJIb3N0TmFtZVJlc29sdmVyKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgQnJvd3Nlckhvc3ROYW1lUmVzb2x2ZXIpO1xuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQnJvd3Nlckhvc3ROYW1lUmVzb2x2ZXIsIFt7XG4gICAga2V5OiBcInJlc29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZShhZGRyZXNzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVRvSXRzZWxmKGFkZHJlc3MpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQnJvd3Nlckhvc3ROYW1lUmVzb2x2ZXI7XG59KF9iYXNlSG9zdE5hbWVSZXNvbHZlcltcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEJyb3dzZXJIb3N0TmFtZVJlc29sdmVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2Jyb3dzZXJCdWYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9icm93c2VyL2Jyb3dzZXItYnVmXCIpKTtcblxudmFyIF90ZXh0RW5jb2RpbmdVdGYgPSByZXF1aXJlKFwidGV4dC1lbmNvZGluZy11dGYtOFwiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgZW5jb2RlciA9IG5ldyBfdGV4dEVuY29kaW5nVXRmLlRleHRFbmNvZGVyKCd1dGYtOCcpO1xudmFyIGRlY29kZXIgPSBuZXcgX3RleHRFbmNvZGluZ1V0Zi5UZXh0RGVjb2RlcigndXRmLTgnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHN0cikge1xuICByZXR1cm4gbmV3IF9icm93c2VyQnVmW1wiZGVmYXVsdFwiXShlbmNvZGVyLmVuY29kZShzdHIpLmJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGRlY29kZShidWZmZXIsIGxlbmd0aCkge1xuICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgX2Jyb3dzZXJCdWZbXCJkZWZhdWx0XCJdKSB7XG4gICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5yZWFkVmlldyhNYXRoLm1pbihsZW5ndGgsIGJ1ZmZlci5sZW5ndGggLSBidWZmZXIucG9zaXRpb24pKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29weSB0aGUgZ2l2ZW4gYnVmZmVyIGludG8gYSByZWd1bGFyIGJ1ZmZlciBhbmQgZGVjb2RlIHRoYXRcbiAgICB2YXIgdG1wQnVmID0gbmV3IF9icm93c2VyQnVmW1wiZGVmYXVsdFwiXShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdG1wQnVmLndyaXRlVUludDgoYnVmZmVyLnJlYWRVSW50OCgpKTtcbiAgICB9XG5cbiAgICB0bXBCdWYucmVzZXQoKTtcbiAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUodG1wQnVmLnJlYWRWaWV3KGxlbmd0aCkpO1xuICB9XG59XG5cbnZhciBfZGVmYXVsdCA9IHtcbiAgZW5jb2RlOiBlbmNvZGUsXG4gIGRlY29kZTogZGVjb2RlXG59O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnV0ZjggPSBleHBvcnRzLkhvc3ROYW1lUmVzb2x2ZXIgPSBleHBvcnRzLkNoYW5uZWwgPSBleHBvcnRzLmFsbG9jID0gdm9pZCAwO1xuXG52YXIgX2Jyb3dzZXJCdWYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jyb3dzZXItYnVmXCIpKTtcblxudmFyIF9icm93c2VyQ2hhbm5lbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYnJvd3Nlci1jaGFubmVsXCIpKTtcblxudmFyIF9icm93c2VySG9zdE5hbWVSZXNvbHZlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYnJvd3Nlci1ob3N0LW5hbWUtcmVzb2x2ZXJcIikpO1xuXG52YXIgX2Jyb3dzZXJVdGYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jyb3dzZXItdXRmOFwiKSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKlxuXG5UaGlzIG1vZHVsZSBleHBvcnRzIGEgc2V0IG9mIGNvbXBvbmVudHMgdG8gYmUgdXNlZCBpbiBicm93c2VyIGVudmlyb25tZW50LlxuVGhleSBhcmUgbm90IGNvbXBhdGlibGUgd2l0aCBOb2RlSlMgZW52aXJvbm1lbnQuXG5BbGwgZmlsZXMgaW1wb3J0L3JlcXVpcmUgQVBJcyBmcm9tIGBub2RlL2luZGV4LmpzYCBieSBkZWZhdWx0LlxuU3VjaCBpbXBvcnRzIGFyZSByZXBsYWNlZCBhdCBidWlsZCB0aW1lIHdpdGggYGJyb3dzZXIvaW5kZXguanNgIHdoZW4gYnVpbGRpbmcgYSBicm93c2VyIGJ1bmRsZS5cblxuTk9URTogZXhwb3J0cyBpbiB0aGlzIG1vZHVsZSBzaG91bGQgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIG5hbWVzL3N0cnVjdHVyZSBhcyBleHBvcnRzIGluIGBub2RlL2luZGV4LmpzYC5cblxuICovXG52YXIgYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhhcmcpIHtcbiAgcmV0dXJuIG5ldyBfYnJvd3NlckJ1ZltcImRlZmF1bHRcIl0oYXJnKTtcbn07XG5cbmV4cG9ydHMuYWxsb2MgPSBhbGxvYztcbnZhciBDaGFubmVsID0gX2Jyb3dzZXJDaGFubmVsW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuQ2hhbm5lbCA9IENoYW5uZWw7XG52YXIgSG9zdE5hbWVSZXNvbHZlciA9IF9icm93c2VySG9zdE5hbWVSZXNvbHZlcltcImRlZmF1bHRcIl07XG5leHBvcnRzLkhvc3ROYW1lUmVzb2x2ZXIgPSBIb3N0TmFtZVJlc29sdmVyO1xudmFyIHV0ZjggPSBfYnJvd3NlclV0ZltcImRlZmF1bHRcIl07XG5leHBvcnRzLnV0ZjggPSB1dGY4OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQ29tbW9uIGJhc2Ugd2l0aCBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBtb3N0IGJ1ZmZlciBtZXRob2RzLlxuICogQnVmZmVycyBhcmUgc3RhdGVmdWwgLSB0aGV5IHRyYWNrIGEgY3VycmVudCBcInBvc2l0aW9uXCIsIHRoaXMgaGVscHMgZ3JlYXRseVxuICogd2hlbiByZWFkaW5nIGFuZCB3cml0aW5nIGZyb20gdGhlbSBpbmNyZW1lbnRhbGx5LiBZb3UgY2FuIGFsc28gaWdub3JlIHRoZVxuICogc3RhdGVmdWwgcmVhZC93cml0ZSBtZXRob2RzLlxuICogcmVhZFhYWCBhbmQgd3JpdGVYWFgtbWV0aG9kcyBtb3ZlIHRoZSBpbm5lciBwb3NpdGlvbiBvZiB0aGUgYnVmZmVyLlxuICogcHV0WFhYIGFuZCBnZXRYWFgtbWV0aG9kcyBkbyBub3QuXG4gKiBAYWNjZXNzIHByaXZhdGVcbiAqL1xudmFyIEJhc2VCdWZmZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgaW5zdGFuY2Ugd2l0aCB0aGUgaW5qZWN0ZWQgc2l6ZS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gc2l6ZVxuICAgKi9cbiAgZnVuY3Rpb24gQmFzZUJ1ZmZlcihzaXplKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBCYXNlQnVmZmVyKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICB0aGlzLmxlbmd0aCA9IHNpemU7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKEJhc2VCdWZmZXIsIFt7XG4gICAga2V5OiBcImdldFVJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVJbnQ4KHBvc2l0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEludDgocG9zaXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZsb2F0NjRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmxvYXQ2NChwb3NpdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHV0VUludDhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0VUludDgocG9zaXRpb24sIHZhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHV0SW50OFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXRJbnQ4KHBvc2l0aW9uLCB2YWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1dEZsb2F0NjRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0RmxvYXQ2NChwb3NpdGlvbiwgdmFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW50MTZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW50MTYocCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50OChwKSA8PCA4IHwgdGhpcy5nZXRVSW50OChwICsgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRVSW50MTZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VUludDE2KHApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFVJbnQ4KHApIDw8IDggfCB0aGlzLmdldFVJbnQ4KHAgKyAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEludDMyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEludDMyKHApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEludDgocCkgPDwgMjQgfCB0aGlzLmdldFVJbnQ4KHAgKyAxKSA8PCAxNiB8IHRoaXMuZ2V0VUludDgocCArIDIpIDw8IDggfCB0aGlzLmdldFVJbnQ4KHAgKyAzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFVJbnQzMlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVSW50MzIocCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VUludDgocCkgPDwgMjQgfCB0aGlzLmdldFVJbnQ4KHAgKyAxKSA8PCAxNiB8IHRoaXMuZ2V0VUludDgocCArIDIpIDw8IDggfCB0aGlzLmdldFVJbnQ4KHAgKyAzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEludDY0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEludDY0KHApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEludDgocCkgPDwgNTYgfCB0aGlzLmdldFVJbnQ4KHAgKyAxKSA8PCA0OCB8IHRoaXMuZ2V0VUludDgocCArIDIpIDw8IDQwIHwgdGhpcy5nZXRVSW50OChwICsgMykgPDwgMzIgfCB0aGlzLmdldFVJbnQ4KHAgKyA0KSA8PCAyNCB8IHRoaXMuZ2V0VUludDgocCArIDUpIDw8IDE2IHwgdGhpcy5nZXRVSW50OChwICsgNikgPDwgOCB8IHRoaXMuZ2V0VUludDgocCArIDcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzbGljZSBvZiB0aGlzIGJ1ZmZlci4gVGhpcyBtZXRob2QgZG9lcyBub3QgY29weSBhbnkgZGF0YSxcbiAgICAgKiBidXQgc2ltcGx5IHByb3ZpZGVzIGEgc2xpY2UgdmlldyBvZiB0aGlzIGJ1ZmZlclxuICAgICAqIEBwYXJhbSBzdGFydFxuICAgICAqIEBwYXJhbSBsZW5ndGhcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNsaWNlKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZXcgU2xpY2VCdWZmZXIoc3RhcnQsIGxlbmd0aCwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwXG4gICAgICogQHBhcmFtIHZhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHV0SW50MTZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0SW50MTYocCwgdmFsKSB7XG4gICAgICB0aGlzLnB1dEludDgocCwgdmFsID4+IDgpO1xuICAgICAgdGhpcy5wdXRVSW50OChwICsgMSwgdmFsICYgMHhmZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwXG4gICAgICogQHBhcmFtIHZhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHV0VUludDE2XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1dFVJbnQxNihwLCB2YWwpIHtcbiAgICAgIHRoaXMucHV0VUludDgocCwgdmFsID4+IDggJiAweGZmKTtcbiAgICAgIHRoaXMucHV0VUludDgocCArIDEsIHZhbCAmIDB4ZmYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcFxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1dEludDMyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1dEludDMyKHAsIHZhbCkge1xuICAgICAgdGhpcy5wdXRJbnQ4KHAsIHZhbCA+PiAyNCk7XG4gICAgICB0aGlzLnB1dFVJbnQ4KHAgKyAxLCB2YWwgPj4gMTYgJiAweGZmKTtcbiAgICAgIHRoaXMucHV0VUludDgocCArIDIsIHZhbCA+PiA4ICYgMHhmZik7XG4gICAgICB0aGlzLnB1dFVJbnQ4KHAgKyAzLCB2YWwgJiAweGZmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBcbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdXRVSW50MzJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0VUludDMyKHAsIHZhbCkge1xuICAgICAgdGhpcy5wdXRVSW50OChwLCB2YWwgPj4gMjQgJiAweGZmKTtcbiAgICAgIHRoaXMucHV0VUludDgocCArIDEsIHZhbCA+PiAxNiAmIDB4ZmYpO1xuICAgICAgdGhpcy5wdXRVSW50OChwICsgMiwgdmFsID4+IDggJiAweGZmKTtcbiAgICAgIHRoaXMucHV0VUludDgocCArIDMsIHZhbCAmIDB4ZmYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcFxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1dEludDY0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1dEludDY0KHAsIHZhbCkge1xuICAgICAgdGhpcy5wdXRJbnQ4KHAsIHZhbCA+PiA0OCk7XG4gICAgICB0aGlzLnB1dFVJbnQ4KHAgKyAxLCB2YWwgPj4gNDIgJiAweGZmKTtcbiAgICAgIHRoaXMucHV0VUludDgocCArIDIsIHZhbCA+PiAzNiAmIDB4ZmYpO1xuICAgICAgdGhpcy5wdXRVSW50OChwICsgMywgdmFsID4+IDMwICYgMHhmZik7XG4gICAgICB0aGlzLnB1dFVJbnQ4KHAgKyA0LCB2YWwgPj4gMjQgJiAweGZmKTtcbiAgICAgIHRoaXMucHV0VUludDgocCArIDUsIHZhbCA+PiAxNiAmIDB4ZmYpO1xuICAgICAgdGhpcy5wdXRVSW50OChwICsgNiwgdmFsID4+IDggJiAweGZmKTtcbiAgICAgIHRoaXMucHV0VUludDgocCArIDcsIHZhbCAmIDB4ZmYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gb3RoZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1dEJ5dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1dEJ5dGVzKHBvc2l0aW9uLCBvdGhlcikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGVuZCA9IG90aGVyLnJlbWFpbmluZygpOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgdGhpcy5wdXRVSW50OChwb3NpdGlvbiArIGksIG90aGVyLnJlYWRVSW50OCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBmcm9tIHN0YXRlIHBvc2l0aW9uLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFVJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRVSW50OCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFVJbnQ4KHRoaXMuX3VwZGF0ZVBvcygxKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgZnJvbSBzdGF0ZSBwb3NpdGlvbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRJbnQ4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50OCh0aGlzLl91cGRhdGVQb3MoMSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGZyb20gc3RhdGUgcG9zaXRpb24uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWFkVUludDE2XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRVSW50MTYoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRVSW50MTYodGhpcy5fdXBkYXRlUG9zKDIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBmcm9tIHN0YXRlIHBvc2l0aW9uLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFVJbnQzMlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkVUludDMyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VUludDMyKHRoaXMuX3VwZGF0ZVBvcyg0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgZnJvbSBzdGF0ZSBwb3NpdGlvbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRJbnQxNlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkSW50MTYoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnQxNih0aGlzLl91cGRhdGVQb3MoMikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGZyb20gc3RhdGUgcG9zaXRpb24uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWFkSW50MzJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZEludDMyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50MzIodGhpcy5fdXBkYXRlUG9zKDQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBmcm9tIHN0YXRlIHBvc2l0aW9uLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZEludDY0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRJbnQ2NCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEludDMyKHRoaXMuX3VwZGF0ZVBvcyg4KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgZnJvbSBzdGF0ZSBwb3NpdGlvbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRGbG9hdDY0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRGbG9hdDY0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RmxvYXQ2NCh0aGlzLl91cGRhdGVQb3MoOCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0byBzdGF0ZSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZVVJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlVUludDgodmFsKSB7XG4gICAgICB0aGlzLnB1dFVJbnQ4KHRoaXMuX3VwZGF0ZVBvcygxKSwgdmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgdG8gc3RhdGUgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHZhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlSW50OCh2YWwpIHtcbiAgICAgIHRoaXMucHV0SW50OCh0aGlzLl91cGRhdGVQb3MoMSksIHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIHRvIHN0YXRlIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlSW50MTZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVJbnQxNih2YWwpIHtcbiAgICAgIHRoaXMucHV0SW50MTYodGhpcy5fdXBkYXRlUG9zKDIpLCB2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0byBzdGF0ZSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZUludDMyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlSW50MzIodmFsKSB7XG4gICAgICB0aGlzLnB1dEludDMyKHRoaXMuX3VwZGF0ZVBvcyg0KSwgdmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgdG8gc3RhdGUgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHZhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVVSW50MzJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVVSW50MzIodmFsKSB7XG4gICAgICB0aGlzLnB1dFVJbnQzMih0aGlzLl91cGRhdGVQb3MoNCksIHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIHRvIHN0YXRlIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlSW50NjRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVJbnQ2NCh2YWwpIHtcbiAgICAgIHRoaXMucHV0SW50NjQodGhpcy5fdXBkYXRlUG9zKDgpLCB2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0byBzdGF0ZSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZUZsb2F0NjRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVGbG9hdDY0KHZhbCkge1xuICAgICAgdGhpcy5wdXRGbG9hdDY0KHRoaXMuX3VwZGF0ZVBvcyg4KSwgdmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgdG8gc3RhdGUgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHZhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVCeXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZUJ5dGVzKHZhbCkge1xuICAgICAgdGhpcy5wdXRCeXRlcyh0aGlzLl91cGRhdGVQb3ModmFsLnJlbWFpbmluZygpKSwgdmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc2xpY2Ugb2YgdGhpcyBidWZmZXIuIFRoaXMgbWV0aG9kIGRvZXMgbm90IGNvcHkgYW55IGRhdGEsXG4gICAgICogYnV0IHNpbXBseSBwcm92aWRlcyBhIHNsaWNlIHZpZXcgb2YgdGhpcyBidWZmZXJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWFkU2xpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZFNsaWNlKGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U2xpY2UodGhpcy5fdXBkYXRlUG9zKGxlbmd0aCksIGxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVQb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVBvcyhsZW5ndGgpIHtcbiAgICAgIHZhciBwID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgIHRoaXMucG9zaXRpb24gKz0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCByZW1haW5pbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbWFpbmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1haW5pbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggLSB0aGlzLnBvc2l0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYXMgcmVtYWluaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoYXNSZW1haW5pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUmVtYWluaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nKCkgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCBwb3NpdGlvbiBzdGF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBidWZmZXIgYW5kIGl0J3Mgc3RhdGUuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBCdWZmZXIgYXMgYSBzdHJpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcoIHBvc2l0aW9uPScgKyB0aGlzLnBvc2l0aW9uICsgJyApXFxuICAnICsgdGhpcy50b0hleCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGJ1ZmZlci5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJ1ZmZlciBhcyBhIHN0cmluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9IZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXgoKSB7XG4gICAgICB2YXIgb3V0ID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaGV4Qnl0ZSA9IHRoaXMuZ2V0VUludDgoaSkudG9TdHJpbmcoMTYpO1xuXG4gICAgICAgIGlmIChoZXhCeXRlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGhleEJ5dGUgPSAnMCcgKyBoZXhCeXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0ICs9IGhleEJ5dGU7XG5cbiAgICAgICAgaWYgKGkgIT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG91dCArPSAnICc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJhc2VCdWZmZXI7XG59KCk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSB2aWV3IGFzIHNsaWNlIG9mIGFub3RoZXIgYnVmZmVyLlxuICogQGFjY2VzcyBwcml2YXRlXG4gKi9cblxuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEJhc2VCdWZmZXI7XG5cbnZhciBTbGljZUJ1ZmZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VCdWZmZXIpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShTbGljZUJ1ZmZlciwgX0Jhc2VCdWZmZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU2xpY2VCdWZmZXIpO1xuXG4gIGZ1bmN0aW9uIFNsaWNlQnVmZmVyKHN0YXJ0LCBsZW5ndGgsIGlubmVyKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBTbGljZUJ1ZmZlcik7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZW5ndGgpO1xuICAgIF90aGlzLl9zdGFydCA9IHN0YXJ0O1xuICAgIF90aGlzLl9pbm5lciA9IGlubmVyO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoU2xpY2VCdWZmZXIsIFt7XG4gICAga2V5OiBcInB1dFVJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1dFVJbnQ4KHBvc2l0aW9uLCB2YWwpIHtcbiAgICAgIHRoaXMuX2lubmVyLnB1dFVJbnQ4KHRoaXMuX3N0YXJ0ICsgcG9zaXRpb24sIHZhbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFVJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVJbnQ4KHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5uZXIuZ2V0VUludDgodGhpcy5fc3RhcnQgKyBwb3NpdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1dEludDhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0SW50OChwb3NpdGlvbiwgdmFsKSB7XG4gICAgICB0aGlzLl9pbm5lci5wdXRJbnQ4KHRoaXMuX3N0YXJ0ICsgcG9zaXRpb24sIHZhbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1dEZsb2F0NjRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0RmxvYXQ2NChwb3NpdGlvbiwgdmFsKSB7XG4gICAgICB0aGlzLl9pbm5lci5wdXRGbG9hdDY0KHRoaXMuX3N0YXJ0ICsgcG9zaXRpb24sIHZhbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEludDhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW50OChwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX2lubmVyLmdldEludDgodGhpcy5fc3RhcnQgKyBwb3NpdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZsb2F0NjRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmxvYXQ2NChwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX2lubmVyLmdldEZsb2F0NjQodGhpcy5fc3RhcnQgKyBwb3NpdGlvbik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTbGljZUJ1ZmZlcjtcbn0oQmFzZUJ1ZmZlcik7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2Jhc2VCdWYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jhc2UtYnVmXCIpKTtcblxudmFyIF9ub2RlID0gcmVxdWlyZShcIi4uL25vZGVcIik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yW1wiZGVmYXVsdFwiXSkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQnVmZmVyIHRoYXQgY29tYmluZXMgbXVsdGlwbGUgYnVmZmVycywgZXhwb3NpbmcgdGhlbSBhcyBvbmUgc2luZ2xlIGJ1ZmZlci5cbiAqL1xudmFyIENvbWJpbmVkQnVmZmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUJ1ZmZlcikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKENvbWJpbmVkQnVmZmVyLCBfQmFzZUJ1ZmZlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDb21iaW5lZEJ1ZmZlcik7XG5cbiAgZnVuY3Rpb24gQ29tYmluZWRCdWZmZXIoYnVmZmVycykge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgQ29tYmluZWRCdWZmZXIpO1xuICAgIHZhciBsZW5ndGggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZW5ndGggKz0gYnVmZmVyc1tpXS5sZW5ndGg7XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZW5ndGgpO1xuICAgIF90aGlzLl9idWZmZXJzID0gYnVmZmVycztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKENvbWJpbmVkQnVmZmVyLCBbe1xuICAgIGtleTogXCJnZXRVSW50OFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVSW50OChwb3NpdGlvbikge1xuICAgICAgLy8gU3VyZWx5IHRoZXJlJ3MgYSBmYXN0ZXIgd2F5IHRvIGRvIHRoaXMuLiBzb21lIHNvcnQgb2YgbG9va3VwIHRhYmxlIHRoaW5nP1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLl9idWZmZXJzW2ldOyAvLyBJZiB0aGUgcG9zaXRpb24gaXMgbm90IGluIHRoZSBjdXJyZW50IGJ1ZmZlciwgc2tpcCB0aGUgY3VycmVudCBidWZmZXJcblxuICAgICAgICBpZiAocG9zaXRpb24gPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgIHBvc2l0aW9uIC09IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGJ1ZmZlci5nZXRVSW50OChwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW50OFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnQ4KHBvc2l0aW9uKSB7XG4gICAgICAvLyBTdXJlbHkgdGhlcmUncyBhIGZhc3RlciB3YXkgdG8gZG8gdGhpcy4uIHNvbWUgc29ydCBvZiBsb29rdXAgdGFibGUgdGhpbmc/XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2J1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcnNbaV07IC8vIElmIHRoZSBwb3NpdGlvbiBpcyBub3QgaW4gdGhlIGN1cnJlbnQgYnVmZmVyLCBza2lwIHRoZSBjdXJyZW50IGJ1ZmZlclxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcG9zaXRpb24gLT0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYnVmZmVyLmdldEludDgocG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZsb2F0NjRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmxvYXQ2NChwb3NpdGlvbikge1xuICAgICAgLy8gQXQgc29tZSBwb2ludCwgYSBtb3JlIGVmZmljaWVudCBpbXBsLiBGb3Igbm93LCB3ZSBjb3B5IHRoZSA4IGJ5dGVzXG4gICAgICAvLyB3ZSB3YW50IHRvIHJlYWQgYW5kIGRlcGVuZCBvbiB0aGUgcGxhdGZvcm0gaW1wbCBvZiBJRUVFIDc1NC5cbiAgICAgIHZhciBiID0gKDAsIF9ub2RlLmFsbG9jKSg4KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgYi5wdXRVSW50OChpLCB0aGlzLmdldFVJbnQ4KHBvc2l0aW9uICsgaSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYi5nZXRGbG9hdDY0KDApO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29tYmluZWRCdWZmZXI7XG59KF9iYXNlQnVmW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ29tYmluZWRCdWZmZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIERFRkFVTFRfQ09OTkVDVElPTl9USU1FT1VUX01JTExJUyA9IDMwMDAwOyAvLyAzMCBzZWNvbmRzIGJ5IGRlZmF1bHRcblxudmFyIEFMTE9XRURfVkFMVUVTX0VOQ1JZUFRFRCA9IFtudWxsLCB1bmRlZmluZWQsIHRydWUsIGZhbHNlLCBfdXRpbC5FTkNSWVBUSU9OX09OLCBfdXRpbC5FTkNSWVBUSU9OX09GRl07XG52YXIgQUxMT1dFRF9WQUxVRVNfVFJVU1QgPSBbbnVsbCwgdW5kZWZpbmVkLCAnVFJVU1RfQUxMX0NFUlRJRklDQVRFUycsICdUUlVTVF9DVVNUT01fQ0FfU0lHTkVEX0NFUlRJRklDQVRFUycsICdUUlVTVF9TWVNURU1fQ0FfU0lHTkVEX0NFUlRJRklDQVRFUyddO1xuXG52YXIgQ2hhbm5lbENvbmZpZyA9XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTZXJ2ZXJBZGRyZXNzfSBhZGRyZXNzIHRoZSBhZGRyZXNzIGZvciB0aGUgY2hhbm5lbCB0byBjb25uZWN0IHRvLlxuICogQHBhcmFtIHtPYmplY3R9IGRyaXZlckNvbmZpZyB0aGUgZHJpdmVyIGNvbmZpZyBwcm92aWRlZCBieSB0aGUgdXNlciB3aGVuIGRyaXZlciBpcyBjcmVhdGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbm5lY3Rpb25FcnJvckNvZGUgdGhlIGRlZmF1bHQgZXJyb3IgY29kZSB0byB1c2Ugb24gY29ubmVjdGlvbiBlcnJvcnMuXG4gKi9cbmZ1bmN0aW9uIENoYW5uZWxDb25maWcoYWRkcmVzcywgZHJpdmVyQ29uZmlnLCBjb25uZWN0aW9uRXJyb3JDb2RlKSB7XG4gICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgQ2hhbm5lbENvbmZpZyk7XG4gIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gIHRoaXMuZW5jcnlwdGVkID0gZXh0cmFjdEVuY3J5cHRlZChkcml2ZXJDb25maWcpO1xuICB0aGlzLnRydXN0ID0gZXh0cmFjdFRydXN0KGRyaXZlckNvbmZpZyk7XG4gIHRoaXMudHJ1c3RlZENlcnRpZmljYXRlcyA9IGV4dHJhY3RUcnVzdGVkQ2VydGlmaWNhdGVzKGRyaXZlckNvbmZpZyk7XG4gIHRoaXMua25vd25Ib3N0c1BhdGggPSBleHRyYWN0S25vd25Ib3N0c1BhdGgoZHJpdmVyQ29uZmlnKTtcbiAgdGhpcy5jb25uZWN0aW9uRXJyb3JDb2RlID0gY29ubmVjdGlvbkVycm9yQ29kZSB8fCBfZXJyb3IuU0VSVklDRV9VTkFWQUlMQUJMRTtcbiAgdGhpcy5jb25uZWN0aW9uVGltZW91dCA9IGV4dHJhY3RDb25uZWN0aW9uVGltZW91dChkcml2ZXJDb25maWcpO1xufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDaGFubmVsQ29uZmlnO1xuXG5mdW5jdGlvbiBleHRyYWN0RW5jcnlwdGVkKGRyaXZlckNvbmZpZykge1xuICB2YXIgdmFsdWUgPSBkcml2ZXJDb25maWcuZW5jcnlwdGVkO1xuXG4gIGlmIChBTExPV0VEX1ZBTFVFU19FTkNSWVBURUQuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoXCJJbGxlZ2FsIHZhbHVlIG9mIHRoZSBlbmNyeXB0ZWQgc2V0dGluZyBcIi5jb25jYXQodmFsdWUsIFwiLiBFeHBlY3RlZCBvbmUgb2YgXCIpLmNvbmNhdChBTExPV0VEX1ZBTFVFU19FTkNSWVBURUQpKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRydXN0KGRyaXZlckNvbmZpZykge1xuICB2YXIgdmFsdWUgPSBkcml2ZXJDb25maWcudHJ1c3Q7XG5cbiAgaWYgKEFMTE9XRURfVkFMVUVTX1RSVVNULmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKFwiSWxsZWdhbCB2YWx1ZSBvZiB0aGUgdHJ1c3Qgc2V0dGluZyBcIi5jb25jYXQodmFsdWUsIFwiLiBFeHBlY3RlZCBvbmUgb2YgXCIpLmNvbmNhdChBTExPV0VEX1ZBTFVFU19UUlVTVCkpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJ1c3RlZENlcnRpZmljYXRlcyhkcml2ZXJDb25maWcpIHtcbiAgcmV0dXJuIGRyaXZlckNvbmZpZy50cnVzdGVkQ2VydGlmaWNhdGVzIHx8IFtdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0S25vd25Ib3N0c1BhdGgoZHJpdmVyQ29uZmlnKSB7XG4gIHJldHVybiBkcml2ZXJDb25maWcua25vd25Ib3N0cyB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0Q29ubmVjdGlvblRpbWVvdXQoZHJpdmVyQ29uZmlnKSB7XG4gIHZhciBjb25maWd1cmVkVGltZW91dCA9IHBhcnNlSW50KGRyaXZlckNvbmZpZy5jb25uZWN0aW9uVGltZW91dCwgMTApO1xuXG4gIGlmIChjb25maWd1cmVkVGltZW91dCA9PT0gMCkge1xuICAgIC8vIHRpbWVvdXQgZXhwbGljaXRseSBjb25maWd1cmVkIHRvIDBcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChjb25maWd1cmVkVGltZW91dCAmJiBjb25maWd1cmVkVGltZW91dCA8IDApIHtcbiAgICAvLyB0aW1lb3V0IGV4cGxpY2l0bHkgY29uZmlndXJlZCB0byBhIG5lZ2F0aXZlIHZhbHVlXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIWNvbmZpZ3VyZWRUaW1lb3V0KSB7XG4gICAgLy8gdGltZW91dCBub3QgY29uZmlndXJlZCwgdXNlIGRlZmF1bHQgdmFsdWVcbiAgICByZXR1cm4gREVGQVVMVF9DT05ORUNUSU9OX1RJTUVPVVRfTUlMTElTO1xuICB9IGVsc2Uge1xuICAgIC8vIHRpbWVvdXQgY29uZmlndXJlZCwgdXNlIHRoZSBwcm92aWRlZCB2YWx1ZVxuICAgIHJldHVybiBjb25maWd1cmVkVGltZW91dDtcbiAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRGVjaHVua2VyID0gZXhwb3J0cy5DaHVua2VyID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9iYXNlQnVmID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9idWYvYmFzZS1idWZcIikpO1xuXG52YXIgX25vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuXG52YXIgX2NvbWJpbmVkQnVmID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9idWYvY29tYmluZWQtYnVmXCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIF9DSFVOS19IRUFERVJfU0laRSA9IDI7XG52YXIgX01FU1NBR0VfQk9VTkRBUlkgPSAweDAwO1xudmFyIF9ERUZBVUxUX0JVRkZFUl9TSVpFID0gMTQwMDsgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjEzNzM0L21heGltdW0tcGFja2V0LXNpemUtZm9yLWEtdGNwLWNvbm5lY3Rpb25cblxuLyoqXG4gKiBMb29rcyBsaWtlIGEgd3JpdGFibGUgYnVmZmVyLCBjaHVua3Mgb3V0cHV0IHRyYW5zcGFyZW50bHkgaW50byBhIGNoYW5uZWwgYmVsb3cuXG4gKiBAYWNjZXNzIHByaXZhdGVcbiAqL1xuXG52YXIgQ2h1bmtlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VCdWZmZXIpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShDaHVua2VyLCBfQmFzZUJ1ZmZlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDaHVua2VyKTtcblxuICBmdW5jdGlvbiBDaHVua2VyKGNoYW5uZWwsIGJ1ZmZlclNpemUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIENodW5rZXIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgMCk7XG4gICAgX3RoaXMuX2J1ZmZlclNpemUgPSBidWZmZXJTaXplIHx8IF9ERUZBVUxUX0JVRkZFUl9TSVpFO1xuICAgIF90aGlzLl9jaCA9IGNoYW5uZWw7XG4gICAgX3RoaXMuX2J1ZmZlciA9ICgwLCBfbm9kZS5hbGxvYykoX3RoaXMuX2J1ZmZlclNpemUpO1xuICAgIF90aGlzLl9jdXJyZW50Q2h1bmtTdGFydCA9IDA7XG4gICAgX3RoaXMuX2NodW5rT3BlbiA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQ2h1bmtlciwgW3tcbiAgICBrZXk6IFwicHV0VUludDhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0VUludDgocG9zaXRpb24sIHZhbCkge1xuICAgICAgdGhpcy5fZW5zdXJlKDEpO1xuXG4gICAgICB0aGlzLl9idWZmZXIud3JpdGVVSW50OCh2YWwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwdXRJbnQ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1dEludDgocG9zaXRpb24sIHZhbCkge1xuICAgICAgdGhpcy5fZW5zdXJlKDEpO1xuXG4gICAgICB0aGlzLl9idWZmZXIud3JpdGVJbnQ4KHZhbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1dEZsb2F0NjRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0RmxvYXQ2NChwb3NpdGlvbiwgdmFsKSB7XG4gICAgICB0aGlzLl9lbnN1cmUoOCk7XG5cbiAgICAgIHRoaXMuX2J1ZmZlci53cml0ZUZsb2F0NjQodmFsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHV0Qnl0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHV0Qnl0ZXMocG9zaXRpb24sIGRhdGEpIHtcbiAgICAgIC8vIFRPRE86IElmIGRhdGEgaXMgbGFyZ2VyIHRoYW4gb3VyIGNodW5rIHNpemUgb3Igc28sIHdlJ3JlIHZlcnkgbGlrZWx5IGJldHRlciBvZmYganVzdCBwYXNzaW5nIHRoaXMgYnVmZmVyIG9uXG4gICAgICAvLyByYXRoZXIgdGhhbiBkb2luZyB0aGUgY29weSBoZXJlIFRPRE86ICpob3dldmVyKiBub3RlIHRoYXQgd2UgbmVlZCBzb21lIHdheSB0byBmaW5kIG91dCB3aGVuIHRoZSBkYXRhIGhhcyBiZWVuXG4gICAgICAvLyB3cml0dGVuIChhbmQgdGh1cyB0aGUgYnVmZmVyIGNhbiBiZSByZS11c2VkKSBpZiB3ZSB0YWtlIHRoYXQgYXBwcm9hY2hcbiAgICAgIHdoaWxlIChkYXRhLnJlbWFpbmluZygpID4gMCkge1xuICAgICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgYW4gb3BlbiBjaHVuaywgYW5kIHRoYXQgaXQgaGFzIGF0IGxlYXN0IG9uZSBieXRlIG9mIHNwYWNlIGxlZnRcbiAgICAgICAgdGhpcy5fZW5zdXJlKDEpO1xuXG4gICAgICAgIGlmICh0aGlzLl9idWZmZXIucmVtYWluaW5nKCkgPiBkYXRhLnJlbWFpbmluZygpKSB7XG4gICAgICAgICAgdGhpcy5fYnVmZmVyLndyaXRlQnl0ZXMoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fYnVmZmVyLndyaXRlQnl0ZXMoZGF0YS5yZWFkU2xpY2UodGhpcy5fYnVmZmVyLnJlbWFpbmluZygpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZsdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgaWYgKHRoaXMuX2J1ZmZlci5wb3NpdGlvbiA+IDApIHtcbiAgICAgICAgdGhpcy5fY2xvc2VDaHVua0lmT3BlbigpOyAvLyBMb2NhbCBjb3B5IGFuZCBjbGVhciB0aGUgYnVmZmVyIGZpZWxkLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgYnVmZmVyIGlzIG5vdCByZS1yZWxlYXNlZCBpZiB0aGUgZmx1c2ggY2FsbCBmYWlsc1xuXG5cbiAgICAgICAgdmFyIG91dCA9IHRoaXMuX2J1ZmZlcjtcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZShvdXQuZ2V0U2xpY2UoMCwgb3V0LnBvc2l0aW9uKSk7IC8vIEFsbG9jIGEgbmV3IG91dHB1dCBidWZmZXIuIFdlIGFzc3VtZSB3ZSdyZSB1c2luZyBOb2RlSlMncyBidWZmZXIgcG9vbGluZyB1bmRlciB0aGUgaG9vZCBoZXJlIVxuXG5cbiAgICAgICAgdGhpcy5fYnVmZmVyID0gKDAsIF9ub2RlLmFsbG9jKSh0aGlzLl9idWZmZXJTaXplKTtcbiAgICAgICAgdGhpcy5fY2h1bmtPcGVuID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCb2x0IG1lc3NhZ2VzIGFyZSBlbmNvZGVkIGluIG9uZSBvciBtb3JlIGNodW5rcywgYW5kIHRoZSBib3VuZGFyeSBiZXR3ZWVuIHR3byBtZXNzYWdlc1xuICAgICAqIGlzIGVuY29kZWQgYXMgYSAwLWxlbmd0aCBjaHVuaywgYDAwIDAwYC4gVGhpcyBpbnNlcnRzIHN1Y2ggYSBtZXNzYWdlIGJvdW5kYXJ5LCBjbG9zaW5nXG4gICAgICogYW55IGN1cnJlbnRseSBvcGVuIGNodW5rIGFzIG5lZWRlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWVzc2FnZUJvdW5kYXJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lc3NhZ2VCb3VuZGFyeSgpIHtcbiAgICAgIHRoaXMuX2Nsb3NlQ2h1bmtJZk9wZW4oKTtcblxuICAgICAgaWYgKHRoaXMuX2J1ZmZlci5yZW1haW5pbmcoKSA8IF9DSFVOS19IRUFERVJfU0laRSkge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICB9IC8vIFdyaXRlIG1lc3NhZ2UgYm91bmRhcnlcblxuXG4gICAgICB0aGlzLl9idWZmZXIud3JpdGVJbnQxNihfTUVTU0FHRV9CT1VOREFSWSk7XG4gICAgfVxuICAgIC8qKiBFbnN1cmUgYXQgbGVhc3QgdGhlIGdpdmVuIHNpemUgaXMgYXZhaWxhYmxlIGZvciB3cml0aW5nICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZW5zdXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbnN1cmUoc2l6ZSkge1xuICAgICAgdmFyIHRvV3JpdGVTaXplID0gdGhpcy5fY2h1bmtPcGVuID8gc2l6ZSA6IHNpemUgKyBfQ0hVTktfSEVBREVSX1NJWkU7XG5cbiAgICAgIGlmICh0aGlzLl9idWZmZXIucmVtYWluaW5nKCkgPCB0b1dyaXRlU2l6ZSkge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fY2h1bmtPcGVuKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDaHVua1N0YXJ0ID0gdGhpcy5fYnVmZmVyLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLl9idWZmZXIucG9zaXRpb24gPSB0aGlzLl9idWZmZXIucG9zaXRpb24gKyBfQ0hVTktfSEVBREVSX1NJWkU7XG4gICAgICAgIHRoaXMuX2NodW5rT3BlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jbG9zZUNodW5rSWZPcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9zZUNodW5rSWZPcGVuKCkge1xuICAgICAgaWYgKHRoaXMuX2NodW5rT3Blbikge1xuICAgICAgICB2YXIgY2h1bmtTaXplID0gdGhpcy5fYnVmZmVyLnBvc2l0aW9uIC0gKHRoaXMuX2N1cnJlbnRDaHVua1N0YXJ0ICsgX0NIVU5LX0hFQURFUl9TSVpFKTtcblxuICAgICAgICB0aGlzLl9idWZmZXIucHV0VUludDE2KHRoaXMuX2N1cnJlbnRDaHVua1N0YXJ0LCBjaHVua1NpemUpO1xuXG4gICAgICAgIHRoaXMuX2NodW5rT3BlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2h1bmtlcjtcbn0oX2Jhc2VCdWZbXCJkZWZhdWx0XCJdKTtcbi8qKlxuICogQ29tYmluZXMgY2h1bmtzIHVudGlsIGEgY29tcGxldGUgbWVzc2FnZSBpcyBnYXRoZXJlZCB1cCwgYW5kIHRoZW4gZm9yd2FyZHMgdGhhdFxuICogbWVzc2FnZSB0byBhbiAnb25tZXNzYWdlJyBsaXN0ZW5lci5cbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICovXG5cblxuZXhwb3J0cy5DaHVua2VyID0gQ2h1bmtlcjtcblxudmFyIERlY2h1bmtlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERlY2h1bmtlcigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIERlY2h1bmtlcik7XG4gICAgdGhpcy5fY3VycmVudE1lc3NhZ2UgPSBbXTtcbiAgICB0aGlzLl9wYXJ0aWFsQ2h1bmtIZWFkZXIgPSAwO1xuICAgIHRoaXMuX3N0YXRlID0gdGhpcy5BV0FJVElOR19DSFVOSztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoRGVjaHVua2VyLCBbe1xuICAgIGtleTogXCJBV0FJVElOR19DSFVOS1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBBV0FJVElOR19DSFVOSyhidWYpIHtcbiAgICAgIGlmIChidWYucmVtYWluaW5nKCkgPj0gMikge1xuICAgICAgICAvLyBXaG9sZSBoZWFkZXIgYXZhaWxhYmxlLCByZWFkIHRoYXRcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uSGVhZGVyKGJ1Zi5yZWFkVUludDE2KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT25seSBvbmUgYnl0ZSBhdmFpbGFibGUsIHJlYWQgdGhhdCBhbmQgd2FpdCBmb3IgdGhlIHNlY29uZCBieXRlXG4gICAgICAgIHRoaXMuX3BhcnRpYWxDaHVua0hlYWRlciA9IGJ1Zi5yZWFkVUludDgoKSA8PCA4O1xuICAgICAgICByZXR1cm4gdGhpcy5JTl9IRUFERVI7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIklOX0hFQURFUlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBJTl9IRUFERVIoYnVmKSB7XG4gICAgICAvLyBGaXJzdCBoZWFkZXIgYnl0ZSByZWFkLCBub3cgd2UgcmVhZCB0aGUgbmV4dCBvbmVcbiAgICAgIHJldHVybiB0aGlzLl9vbkhlYWRlcigodGhpcy5fcGFydGlhbENodW5rSGVhZGVyIHwgYnVmLnJlYWRVSW50OCgpKSAmIDB4ZmZmZik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIklOX0NIVU5LXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIElOX0NIVU5LKGJ1Zikge1xuICAgICAgaWYgKHRoaXMuX2NodW5rU2l6ZSA8PSBidWYucmVtYWluaW5nKCkpIHtcbiAgICAgICAgLy8gQ3VycmVudCBwYWNrZXQgaXMgbGFyZ2VyIHRoYW4gY3VycmVudCBjaHVuaywgb3Igc2FtZSBzaXplOlxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzc2FnZS5wdXNoKGJ1Zi5yZWFkU2xpY2UodGhpcy5fY2h1bmtTaXplKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuQVdBSVRJTkdfQ0hVTks7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDdXJyZW50IHBhY2tldCBpcyBzbWFsbGVyIHRoYW4gdGhlIGNodW5rIHdlJ3JlIHJlYWRpbmcsIHNwbGl0IHRoZSBjdXJyZW50IGNodW5rIGl0c2VsZiB1cFxuICAgICAgICB0aGlzLl9jaHVua1NpemUgLT0gYnVmLnJlbWFpbmluZygpO1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZXNzYWdlLnB1c2goYnVmLnJlYWRTbGljZShidWYucmVtYWluaW5nKCkpKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5JTl9DSFVOSztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiQ0xPU0VEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIENMT1NFRChidWYpIHt9IC8vIG5vLW9wXG5cbiAgICAvKiogQ2FsbGVkIHdoZW4gYSBjb21wbGV0ZSBjaHVuayBoZWFkZXIgaGFzIGJlZW4gcmVjZWl2ZWQgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9vbkhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25IZWFkZXIoaGVhZGVyKSB7XG4gICAgICBpZiAoaGVhZGVyID09PSAwKSB7XG4gICAgICAgIC8vIE1lc3NhZ2UgYm91bmRhcnlcbiAgICAgICAgdmFyIG1lc3NhZ2U7XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLl9jdXJyZW50TWVzc2FnZS5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAvLyBLZWVwIGFsaXZlIGNodW5rLCBzZW50IGJ5IHNlcnZlciB0byBrZWVwIG5ldHdvcmsgYWxpdmUuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5BV0FJVElOR19DSFVOSztcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIC8vIEFsbCBkYXRhIGluIG9uZSBjaHVuaywgdGhpcyBzaWduYWxzIHRoZSBlbmQgb2YgdGhhdCBjaHVuay5cbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLl9jdXJyZW50TWVzc2FnZVswXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIEEgbGFyZ2UgY2h1bmsgb2YgZGF0YSByZWNlaXZlZCwgdGhpcyBzaWduYWxzIHRoYXQgdGhlIGxhc3QgY2h1bmsgaGFzIGJlZW4gcmVjZWl2ZWQuXG4gICAgICAgICAgICBtZXNzYWdlID0gbmV3IF9jb21iaW5lZEJ1ZltcImRlZmF1bHRcIl0odGhpcy5fY3VycmVudE1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzc2FnZSA9IFtdO1xuICAgICAgICB0aGlzLm9ubWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQVdBSVRJTkdfQ0hVTks7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jaHVua1NpemUgPSBoZWFkZXI7XG4gICAgICAgIHJldHVybiB0aGlzLklOX0NIVU5LO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZShidWYpIHtcbiAgICAgIHdoaWxlIChidWYuaGFzUmVtYWluaW5nKCkpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9zdGF0ZShidWYpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRGVjaHVua2VyO1xufSgpO1xuXG5leHBvcnRzLkRlY2h1bmtlciA9IERlY2h1bmtlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfbm9kZSA9IHJlcXVpcmUoXCIuL25vZGVcIik7XG5cbnZhciBfY2h1bmtpbmcgPSByZXF1aXJlKFwiLi9jaHVua2luZ1wiKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuLi9lcnJvclwiKTtcblxudmFyIF9jaGFubmVsQ29uZmlnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jaGFubmVsLWNvbmZpZ1wiKSk7XG5cbnZhciBfcHJvdG9jb2xIYW5kc2hha2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wcm90b2NvbC1oYW5kc2hha2VyXCIpKTtcblxudmFyIF9jb25uZWN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb25uZWN0aW9uXCIpKTtcblxudmFyIF9ib2x0UHJvdG9jb2xWID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ib2x0LXByb3RvY29sLXYxXCIpKTtcblxudmFyIF9zdHJlYW1PYnNlcnZlcnMgPSByZXF1aXJlKFwiLi9zdHJlYW0tb2JzZXJ2ZXJzXCIpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vLyBTaWduYXR1cmUgYnl0ZXMgZm9yIGVhY2ggcmVzcG9uc2UgbWVzc2FnZSB0eXBlXG52YXIgU1VDQ0VTUyA9IDB4NzA7IC8vIDAxMTEgMDAwMCAvLyBTVUNDRVNTIDxtZXRhZGF0YT5cblxudmFyIFJFQ09SRCA9IDB4NzE7IC8vIDAxMTEgMDAwMSAvLyBSRUNPUkQgPHZhbHVlPlxuXG52YXIgSUdOT1JFRCA9IDB4N2U7IC8vIDAxMTEgMTExMCAvLyBJR05PUkVEIDxtZXRhZGF0YT5cblxudmFyIEZBSUxVUkUgPSAweDdmOyAvLyAwMTExIDExMTEgLy8gRkFJTFVSRSA8bWV0YWRhdGE+XG5cbmZ1bmN0aW9uIE5PX09QKCkge31cblxudmFyIE5PX09QX09CU0VSVkVSID0ge1xuICBvbk5leHQ6IE5PX09QLFxuICBvbkNvbXBsZXRlZDogTk9fT1AsXG4gIG9uRXJyb3I6IE5PX09QXG59O1xudmFyIGlkR2VuZXJhdG9yID0gMDtcblxudmFyIENoYW5uZWxDb25uZWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29ubmVjdGlvbikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKENoYW5uZWxDb25uZWN0aW9uLCBfQ29ubmVjdGlvbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDaGFubmVsQ29ubmVjdGlvbik7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0NoYW5uZWx9IGNoYW5uZWwgLSBjaGFubmVsIHdpdGggYSAnd3JpdGUnIGZ1bmN0aW9uIGFuZCBhICdvbm1lc3NhZ2UnIGNhbGxiYWNrIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25FcnJvckhhbmRsZXJ9IGVycm9ySGFuZGxlciB0aGUgZXJyb3IgaGFuZGxlci5cbiAgICogQHBhcmFtIHtTZXJ2ZXJBZGRyZXNzfSBhZGRyZXNzIC0gdGhlIHNlcnZlciBhZGRyZXNzIHRvIGNvbm5lY3QgdG8uXG4gICAqIEBwYXJhbSB7TG9nZ2VyfSBsb2cgLSB0aGUgY29uZmlndXJlZCBsb2dnZXIuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMgaWYgdGhpcyBjb25uZWN0aW9uIHNob3VsZCBjb252ZXJ0IGFsbCByZWNlaXZlZCBpbnRlZ2VycyB0byBuYXRpdmUgSlMgbnVtYmVycy5cbiAgICovXG4gIGZ1bmN0aW9uIENoYW5uZWxDb25uZWN0aW9uKGNoYW5uZWwsIGVycm9ySGFuZGxlciwgYWRkcmVzcywgbG9nKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIGRpc2FibGVMb3NzbGVzc0ludGVnZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcbiAgICB2YXIgc2VydmVyc2lkZVJvdXRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IG51bGw7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBDaGFubmVsQ29ubmVjdGlvbik7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlcnJvckhhbmRsZXIpO1xuICAgIF90aGlzLl9pZCA9IGlkR2VuZXJhdG9yKys7XG4gICAgX3RoaXMuX2FkZHJlc3MgPSBhZGRyZXNzO1xuICAgIF90aGlzLl9zZXJ2ZXIgPSB7XG4gICAgICBhZGRyZXNzOiBhZGRyZXNzLmFzSG9zdFBvcnQoKVxuICAgIH07XG4gICAgX3RoaXMuY3JlYXRpb25UaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIF90aGlzLl9kaXNhYmxlTG9zc2xlc3NJbnRlZ2VycyA9IGRpc2FibGVMb3NzbGVzc0ludGVnZXJzO1xuICAgIF90aGlzLl9wZW5kaW5nT2JzZXJ2ZXJzID0gW107XG4gICAgX3RoaXMuX2N1cnJlbnRPYnNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICBfdGhpcy5fY2ggPSBjaGFubmVsO1xuICAgIF90aGlzLl9kZWNodW5rZXIgPSBuZXcgX2NodW5raW5nLkRlY2h1bmtlcigpO1xuICAgIF90aGlzLl9jaHVua2VyID0gbmV3IF9jaHVua2luZy5DaHVua2VyKGNoYW5uZWwpO1xuICAgIF90aGlzLl9sb2cgPSBsb2c7XG4gICAgX3RoaXMuX3NlcnZlcnNpZGVSb3V0aW5nID0gc2VydmVyc2lkZVJvdXRpbmc7IC8vIGNvbm5lY3Rpb24gZnJvbSB0aGUgZGF0YWJhc2UsIHJldHVybmVkIGluIHJlc3BvbnNlIGZvciBIRUxMTyBtZXNzYWdlIGFuZCBtaWdodCBub3QgYmUgYXZhaWxhYmxlXG5cbiAgICBfdGhpcy5fZGJDb25uZWN0aW9uSWQgPSBudWxsOyAvLyBib2x0IHByb3RvY29sIGlzIGluaXRpYWxseSBub3QgaW5pdGlhbGl6ZWRcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0JvbHRQcm90b2NvbH1cbiAgICAgKi9cblxuICAgIF90aGlzLl9wcm90b2NvbCA9IG51bGw7IC8vIGVycm9yIGV4dHJhY3RlZCBmcm9tIGEgRkFJTFVSRSBtZXNzYWdlXG5cbiAgICBfdGhpcy5fY3VycmVudEZhaWx1cmUgPSBudWxsOyAvLyBTZXQgdG8gdHJ1ZSBvbiBmYXRhbCBlcnJvcnMsIHRvIGdldCB0aGlzIG91dCBvZiBjb25uZWN0aW9uIHBvb2wuXG5cbiAgICBfdGhpcy5faXNCcm9rZW4gPSBmYWxzZTtcblxuICAgIGlmIChfdGhpcy5fbG9nLmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgIF90aGlzLl9sb2cuZGVidWcoXCJcIi5jb25jYXQoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyW1wiZGVmYXVsdFwiXSkoX3RoaXMpLCBcIiBjcmVhdGVkIHRvd2FyZHMgXCIpLmNvbmNhdChhZGRyZXNzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmV0ZSBuZXcgY29ubmVjdGlvbiB0byB0aGUgcHJvdmlkZWQgYWRkcmVzcy4gUmV0dXJuZWQgY29ubmVjdGlvbiBpcyBub3QgY29ubmVjdGVkLlxuICAgKiBAcGFyYW0ge1NlcnZlckFkZHJlc3N9IGFkZHJlc3MgLSB0aGUgQm9sdCBlbmRwb2ludCB0byBjb25uZWN0IHRvLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gdGhlIGRyaXZlciBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25FcnJvckhhbmRsZXJ9IGVycm9ySGFuZGxlciAtIHRoZSBlcnJvciBoYW5kbGVyIGZvciBjb25uZWN0aW9uIGVycm9ycy5cbiAgICogQHBhcmFtIHtMb2dnZXJ9IGxvZyAtIGNvbmZpZ3VyZWQgbG9nZ2VyLlxuICAgKiBAcmV0dXJuIHtDb25uZWN0aW9ufSAtIG5ldyBjb25uZWN0aW9uLlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQ2hhbm5lbENvbm5lY3Rpb24sIFt7XG4gICAga2V5OiBcImNvbm5lY3RcIixcblxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdG8gdGhlIHRhcmdldCBhZGRyZXNzLCBuZWdvdGlhdGUgQm9sdCBwcm90b2NvbCBhbmQgc2VuZCBpbml0aWFsaXphdGlvbiBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyQWdlbnQgdGhlIHVzZXIgYWdlbnQgZm9yIHRoaXMgZHJpdmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdXRoVG9rZW4gdGhlIG9iamVjdCBjb250YWluaW5nIGF1dGggaW5mb3JtYXRpb24uXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxDb25uZWN0aW9uPn0gcHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gaWYgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsLiBSZWplY3RlZCBwcm9taXNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCh1c2VyQWdlbnQsIGF1dGhUb2tlbikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLl9uZWdvdGlhdGVQcm90b2NvbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLl9pbml0aWFsaXplKHVzZXJBZ2VudCwgYXV0aFRva2VuKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIEJvbHQgcHJvdG9jb2wgaGFuZHNoYWtlIHRvIGluaXRpYWxpemUgdGhlIHByb3RvY29sIHZlcnNpb24uXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxDb25uZWN0aW9uPn0gcHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gaWYgaGFuZHNoYWtlIGlzIHN1Y2Nlc3NmdWwuIFJlamVjdGVkIHByb21pc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX25lZ290aWF0ZVByb3RvY29sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9uZWdvdGlhdGVQcm90b2NvbCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJvdG9jb2xIYW5kc2hha2VyID0gbmV3IF9wcm90b2NvbEhhbmRzaGFrZXJbXCJkZWZhdWx0XCJdKHRoaXMsIHRoaXMuX2NoLCB0aGlzLl9jaHVua2VyLCB0aGlzLl9kaXNhYmxlTG9zc2xlc3NJbnRlZ2VycywgdGhpcy5fbG9nLCB0aGlzLl9zZXJ2ZXJzaWRlUm91dGluZyk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgaGFuZHNoYWtlRXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gaGFuZHNoYWtlRXJyb3JIYW5kbGVyKGVycm9yKSB7XG4gICAgICAgICAgX3RoaXMzLl9oYW5kbGVGYXRhbEVycm9yKGVycm9yKTtcblxuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMzLl9jaC5vbmVycm9yID0gaGFuZHNoYWtlRXJyb3JIYW5kbGVyLmJpbmQoX3RoaXMzKTtcblxuICAgICAgICBpZiAoX3RoaXMzLl9jaC5fZXJyb3IpIHtcbiAgICAgICAgICAvLyBjaGFubmVsIGlzIGFscmVhZHkgYnJva2VuXG4gICAgICAgICAgaGFuZHNoYWtlRXJyb3JIYW5kbGVyKF90aGlzMy5fY2guX2Vycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMy5fY2gub25tZXNzYWdlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyByZWFkIHRoZSByZXNwb25zZSBidWZmZXIgYW5kIGluaXRpYWxpemUgdGhlIHByb3RvY29sXG4gICAgICAgICAgICBfdGhpczMuX3Byb3RvY29sID0gcHJvdG9jb2xIYW5kc2hha2VyLmNyZWF0ZU5lZ290aWF0ZWRQcm90b2NvbChidWZmZXIpOyAvLyByZXNldCB0aGUgZXJyb3IgaGFuZGxlciB0byBqdXN0IGhhbmRsZSBlcnJvcnMgYW5kIGZvcmdldCBhYm91dCB0aGUgaGFuZHNoYWtlIHByb21pc2VcblxuICAgICAgICAgICAgX3RoaXMzLl9jaC5vbmVycm9yID0gX3RoaXMzLl9oYW5kbGVGYXRhbEVycm9yLmJpbmQoX3RoaXMzKTsgLy8gT2ssIHByb3RvY29sIHJ1bm5pbmcuIFNpbXBseSBmb3J3YXJkIGFsbCBtZXNzYWdlcyB0byB0aGUgZGVjaHVua2VyXG5cbiAgICAgICAgICAgIF90aGlzMy5fY2gub25tZXNzYWdlID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLl9kZWNodW5rZXIud3JpdGUoYnVmKTtcbiAgICAgICAgICAgIH07IC8vIHNldHVwIGRlY2h1bmtlciB0byBkZWNodW5rIG1lc3NhZ2VzIGFuZCBmb3J3YXJkIHRoZW0gdG8gdGhlIG1lc3NhZ2UgaGFuZGxlclxuXG5cbiAgICAgICAgICAgIF90aGlzMy5fZGVjaHVua2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLl9oYW5kbGVNZXNzYWdlKF90aGlzMy5fcHJvdG9jb2wudW5wYWNrZXIoKS51bnBhY2soYnVmKSk7XG4gICAgICAgICAgICB9OyAvLyBmb3J3YXJkIGFsbCBwZW5kaW5nIGJ5dGVzIHRvIHRoZSBkZWNodW5rZXJcblxuXG4gICAgICAgICAgICBpZiAoYnVmZmVyLmhhc1JlbWFpbmluZygpKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5fZGVjaHVua2VyLndyaXRlKGJ1ZmZlci5yZWFkU2xpY2UoYnVmZmVyLnJlbWFpbmluZygpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUoX3RoaXMzKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBfdGhpczMuX2hhbmRsZUZhdGFsRXJyb3IoZSk7XG5cbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcHJvdG9jb2xIYW5kc2hha2VyLndyaXRlSGFuZHNoYWtlUmVxdWVzdCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gcHJvdG9jb2wtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gd2hpY2ggaW5jbHVkZXMgYXV0aGVudGljYXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJBZ2VudCB0aGUgdXNlciBhZ2VudCBmb3IgdGhpcyBkcml2ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF1dGhUb2tlbiB0aGUgb2JqZWN0IGNvbnRhaW5pbmcgYXV0aCBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbm5lY3Rpb24+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBpZiBpbml0aWFsaXphdGlvbiBpcyBzdWNjZXNzZnVsLiBSZWplY3RlZCBwcm9taXNlIG90aGVyd2lzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0aWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0aWFsaXplKHVzZXJBZ2VudCwgYXV0aFRva2VuKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXM0Ll9wcm90b2NvbC5pbml0aWFsaXplKHtcbiAgICAgICAgICB1c2VyQWdlbnQ6IHVzZXJBZ2VudCxcbiAgICAgICAgICBhdXRoVG9rZW46IGF1dGhUb2tlbixcbiAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHNlbGYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBCb2x0IHByb3RvY29sIGZvciB0aGUgY29ubmVjdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtCb2x0UHJvdG9jb2x9IHRoZSBwcm90b2NvbC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByb3RvY29sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb3RvY29sKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZVwiLFxuXG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBtZXNzYWdlIHRvIHRoZSBuZXR3b3JrIGNoYW5uZWwuXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0TWVzc2FnZX0gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0ge1Jlc3VsdFN0cmVhbU9ic2VydmVyfSBvYnNlcnZlciB0aGUgcmVzcG9uc2Ugb2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmbHVzaCBgdHJ1ZWAgaWYgZmx1c2ggc2hvdWxkIGhhcHBlbiBhZnRlciB0aGUgbWVzc2FnZSBpcyB3cml0dGVuIHRvIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlKG1lc3NhZ2UsIG9ic2VydmVyLCBmbHVzaCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBxdWV1ZWQgPSB0aGlzLl9xdWV1ZU9ic2VydmVyKG9ic2VydmVyKTtcblxuICAgICAgaWYgKHF1ZXVlZCkge1xuICAgICAgICBpZiAodGhpcy5fbG9nLmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJcIi5jb25jYXQodGhpcywgXCIgQzogXCIpLmNvbmNhdChtZXNzYWdlKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wcm90b2NvbC5wYWNrZXIoKS5wYWNrU3RydWN0KG1lc3NhZ2Uuc2lnbmF0dXJlLCBtZXNzYWdlLmZpZWxkcy5tYXAoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNS5fcGFja2FibGUoZmllbGQpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgdGhpcy5fY2h1bmtlci5tZXNzYWdlQm91bmRhcnkoKTtcblxuICAgICAgICBpZiAoZmx1c2gpIHtcbiAgICAgICAgICB0aGlzLl9jaHVua2VyLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogXCJGYXRhbFwiIG1lYW5zIHRoZSBjb25uZWN0aW9uIGlzIGRlYWQuIE9ubHkgY2FsbCB0aGlzIGlmIHNvbWV0aGluZ1xuICAgICAqIGhhcHBlbnMgdGhhdCBjYW5ub3QgYmUgcmVjb3ZlcmVkIGZyb20uIFRoaXMgd2lsbCBsZWFkIHRvIGFsbCBzdWJzY3JpYmVyc1xuICAgICAqIGZhaWxpbmcsIGFuZCB0aGUgY29ubmVjdGlvbiBnZXR0aW5nIGVqZWN0ZWQgZnJvbSB0aGUgc2Vzc2lvbiBwb29sLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVycm9yIGFuIGVycm9yIG9iamVjdCwgZm9yd2FyZGVkIHRvIGFsbCBjdXJyZW50IGFuZCBmdXR1cmUgc3Vic2NyaWJlcnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVGYXRhbEVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVGYXRhbEVycm9yKGVycm9yKSB7XG4gICAgICB0aGlzLl9pc0Jyb2tlbiA9IHRydWU7XG4gICAgICB0aGlzLl9lcnJvciA9IHRoaXMuaGFuZGxlQW5kVHJhbnNmb3JtRXJyb3IoZXJyb3IsIHRoaXMuX2FkZHJlc3MpO1xuXG4gICAgICBpZiAodGhpcy5fbG9nLmlzRXJyb3JFbmFibGVkKCkpIHtcbiAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwiXCIuY29uY2F0KHRoaXMsIFwiIGV4cGVyaWVuY2VkIGEgZmF0YWwgZXJyb3IgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeSh0aGlzLl9lcnJvcikpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRPYnNlcnZlciAmJiB0aGlzLl9jdXJyZW50T2JzZXJ2ZXIub25FcnJvcikge1xuICAgICAgICB0aGlzLl9jdXJyZW50T2JzZXJ2ZXIub25FcnJvcih0aGlzLl9lcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0aGlzLl9wZW5kaW5nT2JzZXJ2ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5fcGVuZGluZ09ic2VydmVycy5zaGlmdCgpO1xuXG4gICAgICAgIGlmIChvYnNlcnZlciAmJiBvYnNlcnZlci5vbkVycm9yKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIub25FcnJvcih0aGlzLl9lcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZU1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU1lc3NhZ2UobXNnKSB7XG4gICAgICBpZiAodGhpcy5faXNCcm9rZW4pIHtcbiAgICAgICAgLy8gaWdub3JlIGFsbCBpbmNvbWluZyBtZXNzYWdlcyB3aGVuIHRoaXMgY29ubmVjdGlvbiBpcyBicm9rZW4uIGFsbCBwcmV2aW91c2x5IHBlbmRpbmcgb2JzZXJ2ZXJzIGZhaWxlZFxuICAgICAgICAvLyB3aXRoIHRoZSBmYXRhbCBlcnJvci4gYWxsIGZ1dHVyZSBvYnNlcnZlcnMgd2lsbCBmYWlsIHdpdGggc2FtZSBmYXRhbCBlcnJvci5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGF5bG9hZCA9IG1zZy5maWVsZHNbMF07XG5cbiAgICAgIHN3aXRjaCAobXNnLnNpZ25hdHVyZSkge1xuICAgICAgICBjYXNlIFJFQ09SRDpcbiAgICAgICAgICBpZiAodGhpcy5fbG9nLmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIlwiLmNvbmNhdCh0aGlzLCBcIiBTOiBSRUNPUkQgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShtc2cpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fY3VycmVudE9ic2VydmVyLm9uTmV4dChwYXlsb2FkKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU1VDQ0VTUzpcbiAgICAgICAgICBpZiAodGhpcy5fbG9nLmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIlwiLmNvbmNhdCh0aGlzLCBcIiBTOiBTVUNDRVNTIFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkobXNnKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB0aGlzLl9wcm90b2NvbC50cmFuc2Zvcm1NZXRhZGF0YShwYXlsb2FkKTtcblxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE9ic2VydmVyLm9uQ29tcGxldGVkKG1ldGFkYXRhKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ3VycmVudE9ic2VydmVyKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBGQUlMVVJFOlxuICAgICAgICAgIGlmICh0aGlzLl9sb2cuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiXCIuY29uY2F0KHRoaXMsIFwiIFM6IEZBSUxVUkUgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShtc2cpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICgwLCBfZXJyb3IubmV3RXJyb3IpKHBheWxvYWQubWVzc2FnZSwgcGF5bG9hZC5jb2RlKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRGYWlsdXJlID0gdGhpcy5oYW5kbGVBbmRUcmFuc2Zvcm1FcnJvcihlcnJvciwgdGhpcy5fYWRkcmVzcyk7XG5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPYnNlcnZlci5vbkVycm9yKHRoaXMuX2N1cnJlbnRGYWlsdXJlKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ3VycmVudE9ic2VydmVyKCk7IC8vIFRoaW5ncyBhcmUgbm93IGJyb2tlbi4gUGVuZGluZyBvYnNlcnZlcnMgd2lsbCBnZXQgRkFJTFVSRSBtZXNzYWdlcyByb3V0ZWQgdW50aWwgd2UgYXJlIGRvbmUgaGFuZGxpbmcgdGhpcyBmYWlsdXJlLlxuXG5cbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0T25GYWlsdXJlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBJR05PUkVEOlxuICAgICAgICAgIGlmICh0aGlzLl9sb2cuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiXCIuY29uY2F0KHRoaXMsIFwiIFM6IElHTk9SRUQgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShtc2cpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50RmFpbHVyZSAmJiB0aGlzLl9jdXJyZW50T2JzZXJ2ZXIub25FcnJvcikge1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50T2JzZXJ2ZXIub25FcnJvcih0aGlzLl9jdXJyZW50RmFpbHVyZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRPYnNlcnZlci5vbkVycm9yKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPYnNlcnZlci5vbkVycm9yKCgwLCBfZXJyb3IubmV3RXJyb3IpKCdJZ25vcmVkIGVpdGhlciBiZWNhdXNlIG9mIGFuIGVycm9yIG9yIFJFU0VUJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDdXJyZW50T2JzZXJ2ZXIoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMuX2hhbmRsZUZhdGFsRXJyb3IoKDAsIF9lcnJvci5uZXdFcnJvcikoJ1Vua25vd24gQm9sdCBwcm90b2NvbCBtZXNzYWdlOiAnICsgbXNnKSk7XG5cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIFJFU0VULW1lc3NhZ2UgdG8gdGhlIGRhdGFiYXNlLiBNZXNzYWdlIGlzIGltbWVkaWF0ZWx5IGZsdXNoZWQgdG8gdGhlIG5ldHdvcmsuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gcHJvbWlzZSByZXNvbHZlZCB3aGVuIFNVQ0NFU1MtbWVzc2FnZSByZXNwb25zZSBhcnJpdmVzLCBvciBmYWlsZWQgd2hlbiBvdGhlciByZXNwb25zZSBtZXNzYWdlcyBhcnJpdmVzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRBbmRGbHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldEFuZEZsdXNoKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF90aGlzNi5fcHJvdG9jb2wucmVzZXQoe1xuICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczYuX2lzQnJva2VuKSB7XG4gICAgICAgICAgICAgIC8vIGhhbmRsaW5nIGEgZmF0YWwgZXJyb3IsIG5vIG5lZWQgdG8gcmFpc2UgYSBwcm90b2NvbCB2aW9sYXRpb25cbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBuZW80akVycm9yID0gX3RoaXM2Ll9oYW5kbGVQcm90b2NvbEVycm9yKCdSZWNlaXZlZCBGQUlMVVJFIGFzIGEgcmVzcG9uc2UgZm9yIFJFU0VUOiAnICsgZXJyb3IpO1xuXG4gICAgICAgICAgICAgIHJlamVjdChuZW80akVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVzZXRPbkZhaWx1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2V0T25GYWlsdXJlKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX3Byb3RvY29sLnJlc2V0KHtcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcigpIHtcbiAgICAgICAgICBfdGhpczcuX2N1cnJlbnRGYWlsdXJlID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICBfdGhpczcuX2N1cnJlbnRGYWlsdXJlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9xdWV1ZU9ic2VydmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9xdWV1ZU9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgICBpZiAodGhpcy5faXNCcm9rZW4pIHtcbiAgICAgICAgaWYgKG9ic2VydmVyICYmIG9ic2VydmVyLm9uRXJyb3IpIHtcbiAgICAgICAgICBvYnNlcnZlci5vbkVycm9yKHRoaXMuX2Vycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgb2JzZXJ2ZXIgPSBvYnNlcnZlciB8fCBOT19PUF9PQlNFUlZFUjtcbiAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkID0gb2JzZXJ2ZXIub25Db21wbGV0ZWQgfHwgTk9fT1A7XG4gICAgICBvYnNlcnZlci5vbkVycm9yID0gb2JzZXJ2ZXIub25FcnJvciB8fCBOT19PUDtcbiAgICAgIG9ic2VydmVyLm9uTmV4dCA9IG9ic2VydmVyLm9uTmV4dCB8fCBOT19PUDtcblxuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRPYnNlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRPYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ09ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qXG4gICAgICogUG9wIG5leHQgcGVuZGluZyBvYnNlcnZlciBmb3JtIHRoZSBsaXN0IG9mIG9ic2VydmVycyBhbmQgbWFrZSBpdCBjdXJyZW50IG9ic2VydmVyLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVDdXJyZW50T2JzZXJ2ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUN1cnJlbnRPYnNlcnZlcigpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRPYnNlcnZlciA9IHRoaXMuX3BlbmRpbmdPYnNlcnZlcnMuc2hpZnQoKTtcbiAgICB9XG4gICAgLyoqIENoZWNrIGlmIHRoaXMgY29ubmVjdGlvbiBpcyBpbiB3b3JraW5nIGNvbmRpdGlvbiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNPcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3BlbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5faXNCcm9rZW4gJiYgdGhpcy5fY2guX29wZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgY2xvc2Ugb24gdGhlIGNoYW5uZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IC0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZSB1bmRlcmx5aW5nIGNoYW5uZWwgaXMgY2xvc2VkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jbG9zZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb2cuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiXCIuY29uY2F0KHRoaXMsIFwiIGNsb3NpbmdcIikpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcm90b2NvbCAmJiB0aGlzLmlzT3BlbigpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBwcm90b2NvbCBoYXMgYmVlbiBpbml0aWFsaXplZCBhbmQgdGhpcyBjb25uZWN0aW9uIGlzIGhlYWx0aHlcbiAgICAgICAgICAgICAgICAgIC8vIG5vdGlmeSB0aGUgZGF0YWJhc2UgYWJvdXQgdGhlIHVwY29taW5nIGNsb3NlIG9mIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbC5wcmVwYXJlVG9DbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaC5jbG9zZSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbG9nLmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIlwiLmNvbmNhdCh0aGlzLCBcIiBjbG9zZWRcIikpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICByZXR1cm4gX2Nsb3NlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9zZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIkNvbm5lY3Rpb24gW1wiLmNvbmNhdCh0aGlzLmlkLCBcIl1bXCIpLmNvbmNhdCh0aGlzLmRhdGFiYXNlSWQgfHwgJycsIFwiXVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3BhY2thYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYWNrYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sLnBhY2tlcigpLnBhY2thYmxlKHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZVByb3RvY29sRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVByb3RvY29sRXJyb3IobWVzc2FnZSkge1xuICAgICAgdGhpcy5fY3VycmVudEZhaWx1cmUgPSBudWxsO1xuXG4gICAgICB0aGlzLl91cGRhdGVDdXJyZW50T2JzZXJ2ZXIoKTtcblxuICAgICAgdmFyIGVycm9yID0gKDAsIF9lcnJvci5uZXdFcnJvcikobWVzc2FnZSwgX2Vycm9yLlBST1RPQ09MX0VSUk9SKTtcblxuICAgICAgdGhpcy5faGFuZGxlRmF0YWxFcnJvcihlcnJvcik7XG5cbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0YWJhc2VJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RiQ29ubmVjdGlvbklkO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuX2RiQ29ubmVjdGlvbklkID0gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZHJlc3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZlcnNpb24gb2YgdGhlIGNvbm5lY3RlZCBzZXJ2ZXIuXG4gICAgICogQXZhaWxhYmxlIG9ubHkgYWZ0ZXIgaW5pdGlhbGl6YXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTZXJ2ZXJWZXJzaW9ufSB2ZXJzaW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2ZXJzaW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VydmVyLnZlcnNpb247XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5fc2VydmVyLnZlcnNpb24gPSB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VydmVyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VydmVyO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoYWRkcmVzcywgY29uZmlnLCBlcnJvckhhbmRsZXIsIGxvZykge1xuICAgICAgdmFyIHNlcnZlcnNpZGVSb3V0aW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBudWxsO1xuICAgICAgdmFyIGNoYW5uZWxDb25maWcgPSBuZXcgX2NoYW5uZWxDb25maWdbXCJkZWZhdWx0XCJdKGFkZHJlc3MsIGNvbmZpZywgZXJyb3JIYW5kbGVyLmVycm9yQ29kZSgpKTtcbiAgICAgIHJldHVybiBuZXcgQ2hhbm5lbENvbm5lY3Rpb24obmV3IF9ub2RlLkNoYW5uZWwoY2hhbm5lbENvbmZpZyksIGVycm9ySGFuZGxlciwgYWRkcmVzcywgbG9nLCBjb25maWcuZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMsIHNlcnZlcnNpZGVSb3V0aW5nKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENoYW5uZWxDb25uZWN0aW9uO1xufShfY29ubmVjdGlvbltcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENoYW5uZWxDb25uZWN0aW9uOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9jb25uZWN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb25uZWN0aW9uXCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIERlbGVnYXRlQ29ubmVjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Nvbm5lY3Rpb24pIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShEZWxlZ2F0ZUNvbm5lY3Rpb24sIF9Db25uZWN0aW9uKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERlbGVnYXRlQ29ubmVjdGlvbik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBkZWxlZ2F0ZSB7Q29ubmVjdGlvbn0gdGhlIGRlbGVnYXRlZCBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSBlcnJvckhhbmRsZXIge0Nvbm5lY3Rpb25FcnJvckhhbmRsZXJ9IHRoZSBlcnJvciBoYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBEZWxlZ2F0ZUNvbm5lY3Rpb24oZGVsZWdhdGUsIGVycm9ySGFuZGxlcikge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgRGVsZWdhdGVDb25uZWN0aW9uKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGVycm9ySGFuZGxlcik7XG5cbiAgICBpZiAoZXJyb3JIYW5kbGVyKSB7XG4gICAgICBfdGhpcy5fb3JpZ2luYWxFcnJvckhhbmRsZXIgPSBkZWxlZ2F0ZS5fZXJyb3JIYW5kbGVyO1xuICAgICAgZGVsZWdhdGUuX2Vycm9ySGFuZGxlciA9IF90aGlzLl9lcnJvckhhbmRsZXI7XG4gICAgfVxuXG4gICAgX3RoaXMuX2RlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShEZWxlZ2F0ZUNvbm5lY3Rpb24sIFt7XG4gICAga2V5OiBcImlzT3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc09wZW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuaXNPcGVuKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb3RvY29sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb3RvY29sKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLnByb3RvY29sKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCh1c2VyQWdlbnQsIGF1dGhUb2tlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvbm5lY3QodXNlckFnZW50LCBhdXRoVG9rZW4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZShtZXNzYWdlLCBvYnNlcnZlciwgZmx1c2gpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS53cml0ZShtZXNzYWdlLCBvYnNlcnZlciwgZmx1c2gpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNldEFuZEZsdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0QW5kRmx1c2goKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUucmVzZXRBbmRGbHVzaCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5jbG9zZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVsZWFzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVsZWFzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9vcmlnaW5hbEVycm9ySGFuZGxlcikge1xuICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5fZXJyb3JIYW5kbGVyID0gdGhpcy5fb3JpZ2luYWxFcnJvckhhbmRsZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5fcmVsZWFzZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmlkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXRhYmFzZUlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuZGF0YWJhc2VJZDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl9kZWxlZ2F0ZS5kYXRhYmFzZUlkID0gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcnZlclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLnNlcnZlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkcmVzc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmFkZHJlc3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZlcnNpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS52ZXJzaW9uO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuX2RlbGVnYXRlLnZlcnNpb24gPSB2YWx1ZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERlbGVnYXRlQ29ubmVjdGlvbjtcbn0oX2Nvbm5lY3Rpb25bXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBEZWxlZ2F0ZUNvbm5lY3Rpb247IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIENvbm5lY3Rpb25FcnJvckhhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb25uZWN0aW9uRXJyb3JIYW5kbGVyKGVycm9yQ29kZSwgaGFuZGxlVW5hdmFpbGFiaWxpdHksIGhhbmRsZVdyaXRlRmFpbHVyZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgQ29ubmVjdGlvbkVycm9ySGFuZGxlcik7XG4gICAgdGhpcy5fZXJyb3JDb2RlID0gZXJyb3JDb2RlO1xuICAgIHRoaXMuX2hhbmRsZVVuYXZhaWxhYmlsaXR5ID0gaGFuZGxlVW5hdmFpbGFiaWxpdHkgfHwgbm9PcEhhbmRsZXI7XG4gICAgdGhpcy5faGFuZGxlV3JpdGVGYWlsdXJlID0gaGFuZGxlV3JpdGVGYWlsdXJlIHx8IG5vT3BIYW5kbGVyO1xuICB9XG4gIC8qKlxuICAgKiBFcnJvciBjb2RlIHRvIHVzZSBmb3IgbmV0d29yayBlcnJvcnMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVycm9yIGNvZGUuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShDb25uZWN0aW9uRXJyb3JIYW5kbGVyLCBbe1xuICAgIGtleTogXCJlcnJvckNvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXJyb3JDb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yQ29kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFuZCB0cmFuc2Zvcm0gdGhlIGVycm9yLlxuICAgICAqIEBwYXJhbSB7TmVvNGpFcnJvcn0gZXJyb3IgdGhlIG9yaWdpbmFsIGVycm9yLlxuICAgICAqIEBwYXJhbSB7U2VydmVyQWRkcmVzc30gYWRkcmVzcyB0aGUgYWRkcmVzcyBvZiB0aGUgY29ubmVjdGlvbiB3aGVyZSB0aGUgZXJyb3IgaGFwcGVuZWQuXG4gICAgICogQHJldHVybiB7TmVvNGpFcnJvcn0gbmV3IGVycm9yIHRoYXQgc2hvdWxkIGJlIHByb3BhZ2F0ZWQgdG8gdGhlIHVzZXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVBbmRUcmFuc2Zvcm1FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVBbmRUcmFuc2Zvcm1FcnJvcihlcnJvciwgYWRkcmVzcykge1xuICAgICAgaWYgKGlzQXZhaWxhYmlsaXR5RXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVVbmF2YWlsYWJpbGl0eShlcnJvciwgYWRkcmVzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZhaWx1cmVUb1dyaXRlKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlV3JpdGVGYWlsdXJlKGVycm9yLCBhZGRyZXNzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29ubmVjdGlvbkVycm9ySGFuZGxlcjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDb25uZWN0aW9uRXJyb3JIYW5kbGVyO1xuXG5mdW5jdGlvbiBpc0F2YWlsYWJpbGl0eUVycm9yKGVycm9yKSB7XG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5jb2RlID09PSBfZXJyb3IuU0VTU0lPTl9FWFBJUkVEIHx8IGVycm9yLmNvZGUgPT09IF9lcnJvci5TRVJWSUNFX1VOQVZBSUxBQkxFIHx8IGVycm9yLmNvZGUgPT09ICdOZW8uVHJhbnNpZW50RXJyb3IuR2VuZXJhbC5EYXRhYmFzZVVuYXZhaWxhYmxlJztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGYWlsdXJlVG9Xcml0ZShlcnJvcikge1xuICBpZiAoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IuY29kZSA9PT0gJ05lby5DbGllbnRFcnJvci5DbHVzdGVyLk5vdEFMZWFkZXInIHx8IGVycm9yLmNvZGUgPT09ICdOZW8uQ2xpZW50RXJyb3IuR2VuZXJhbC5Gb3JiaWRkZW5PblJlYWRPbmx5RGF0YWJhc2UnO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBub09wSGFuZGxlcihlcnJvcikge1xuICByZXR1cm4gZXJyb3I7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5FTVBUWV9DT05ORUNUSU9OX0hPTERFUiA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuLi9lcnJvclwiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5cbnZhciBfYm9va21hcmsgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jvb2ttYXJrXCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBVdGlsaXR5IHRvIGxhemlseSBpbml0aWFsaXplIGNvbm5lY3Rpb25zIGFuZCByZXR1cm4gdGhlbSBiYWNrIHRvIHRoZSBwb29sIHdoZW4gdW51c2VkLlxuICovXG52YXIgQ29ubmVjdGlvbkhvbGRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSB0aGUgYWNjZXNzIG1vZGUgZm9yIG5ldyBjb25uZWN0aW9uIGhvbGRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlIC0gdGhlIHRhcmdldCBkYXRhYmFzZSBuYW1lLlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25Qcm92aWRlcn0gY29ubmVjdGlvblByb3ZpZGVyIC0gdGhlIGNvbm5lY3Rpb24gcHJvdmlkZXIgdG8gYWNxdWlyZSBjb25uZWN0aW9ucyBmcm9tLlxuICAgKi9cbiAgZnVuY3Rpb24gQ29ubmVjdGlvbkhvbGRlcigpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIF9yZWYkbW9kZSA9IF9yZWYubW9kZSxcbiAgICAgICAgbW9kZSA9IF9yZWYkbW9kZSA9PT0gdm9pZCAwID8gX2NvbnN0YW50cy5BQ0NFU1NfTU9ERV9XUklURSA6IF9yZWYkbW9kZSxcbiAgICAgICAgX3JlZiRkYXRhYmFzZSA9IF9yZWYuZGF0YWJhc2UsXG4gICAgICAgIGRhdGFiYXNlID0gX3JlZiRkYXRhYmFzZSA9PT0gdm9pZCAwID8gJycgOiBfcmVmJGRhdGFiYXNlLFxuICAgICAgICBib29rbWFyayA9IF9yZWYuYm9va21hcmssXG4gICAgICAgIGNvbm5lY3Rpb25Qcm92aWRlciA9IF9yZWYuY29ubmVjdGlvblByb3ZpZGVyO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBDb25uZWN0aW9uSG9sZGVyKTtcbiAgICB0aGlzLl9tb2RlID0gbW9kZTtcbiAgICB0aGlzLl9kYXRhYmFzZSA9IGRhdGFiYXNlID8gKDAsIF91dGlsLmFzc2VydFN0cmluZykoZGF0YWJhc2UsICdkYXRhYmFzZScpIDogJyc7XG4gICAgdGhpcy5fYm9va21hcmsgPSBib29rbWFyayB8fCBfYm9va21hcmtbXCJkZWZhdWx0XCJdLmVtcHR5KCk7XG4gICAgdGhpcy5fY29ubmVjdGlvblByb3ZpZGVyID0gY29ubmVjdGlvblByb3ZpZGVyO1xuICAgIHRoaXMuX3JlZmVyZW5jZUNvdW50ID0gMDtcbiAgICB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXNzaWduZWQgYWNjZXNzIG1vZGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGFjY2VzcyBtb2RlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShDb25uZWN0aW9uSG9sZGVyLCBbe1xuICAgIGtleTogXCJtb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGFyZ2V0IGRhdGFiYXNlIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZGF0YWJhc2UgbmFtZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0YWJhc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0YWJhc2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YWJhc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2UgdGhpcyBob2xkZXIgaW5pdGlhbGl6ZSBuZXcgY29ubmVjdGlvbiBpZiBub25lIGV4aXN0cyBhbHJlYWR5LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsaXplQ29ubmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplQ29ubmVjdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9yZWZlcmVuY2VDb3VudCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZSA9IHRoaXMuX2Nvbm5lY3Rpb25Qcm92aWRlci5hY3F1aXJlQ29ubmVjdGlvbih7XG4gICAgICAgICAgYWNjZXNzTW9kZTogdGhpcy5fbW9kZSxcbiAgICAgICAgICBkYXRhYmFzZTogdGhpcy5fZGF0YWJhc2UsXG4gICAgICAgICAgYm9va21hcms6IHRoaXMuX2Jvb2ttYXJrXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVmZXJlbmNlQ291bnQrKztcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZWZlcmVuY2VDb3VudCsrO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBjb25uZWN0aW9uIHByb21pc2UuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxDb25uZWN0aW9uPn0gcHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb25uZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbm5lY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmeSB0aGlzIGhvbGRlciB0aGF0IHNpbmdsZSBwYXJ0eSBkb2VzIG5vdCByZXF1aXJlIGN1cnJlbnQgY29ubmVjdGlvbiBhbnkgbW9yZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbm5lY3Rpb24+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGN1cnJlbnQgY29ubmVjdGlvbiwgbmV2ZXIgYSByZWplY3RlZCBwcm9taXNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVsZWFzZUNvbm5lY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZUNvbm5lY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fcmVmZXJlbmNlQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZWZlcmVuY2VDb3VudC0tO1xuXG4gICAgICBpZiAodGhpcy5fcmVmZXJlbmNlQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbGVhc2VDb25uZWN0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoaXMgaG9sZGVyIGFuZCByZWxlYXNlcyBjdXJyZW50IGNvbm5lY3Rpb24gKGlmIGFueSkgZGVzcGl0ZSBhbnkgZXhpc3RpbmcgdXNlcnMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxDb25uZWN0aW9uPn0gcHJvbWlzZSByZXNvbHZlZCB3aGVuIGN1cnJlbnQgY29ubmVjdGlvbiBpcyByZWxlYXNlZCB0byB0aGUgcG9vbC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKHRoaXMuX3JlZmVyZW5jZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVmZXJlbmNlQ291bnQgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbGVhc2VDb25uZWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY3VycmVudCBwb29sZWQgY29ubmVjdGlvbiBpbnN0YW5jZSB0byB0aGUgY29ubmVjdGlvbiBwb29sLlxuICAgICAqIFdlIGRvbid0IHBvb2wgU2Vzc2lvbiBpbnN0YW5jZXMsIHRvIGF2b2lkIHVzZXJzIHVzaW5nIHRoZSBTZXNzaW9uIGFmdGVyIHRoZXkndmUgY2FsbGVkIGNsb3NlLlxuICAgICAqIFRoZSBgU2Vzc2lvbmAgb2JqZWN0IGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgYXJvdW5kIENvbm5lY3Rpb24gYW55d2F5LCBzbyBpdCBtYWtlcyBsaXR0bGUgZGlmZmVyZW5jZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHByb21pc2UgcmVzb2x2ZWQgdGhlbiBjb25uZWN0aW9uIGlzIHJldHVybmVkIHRvIHRoZSBwb29sLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVsZWFzZUNvbm5lY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbGVhc2VDb25uZWN0aW9uKCkge1xuICAgICAgdGhpcy5fY29ubmVjdGlvblByb21pc2UgPSB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgIGlmIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24ucmVzZXRBbmRGbHVzaCgpW1wiY2F0Y2hcIl0oaWdub3JlRXJyb3IpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uX3JlbGVhc2UoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pW1wiY2F0Y2hcIl0oaWdub3JlRXJyb3IpO1xuICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29ubmVjdGlvbkhvbGRlcjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDb25uZWN0aW9uSG9sZGVyO1xuXG52YXIgRW1wdHlDb25uZWN0aW9uSG9sZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29ubmVjdGlvbkhvbGRlcikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKEVtcHR5Q29ubmVjdGlvbkhvbGRlciwgX0Nvbm5lY3Rpb25Ib2xkZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRW1wdHlDb25uZWN0aW9uSG9sZGVyKTtcblxuICBmdW5jdGlvbiBFbXB0eUNvbm5lY3Rpb25Ib2xkZXIoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBFbXB0eUNvbm5lY3Rpb25Ib2xkZXIpO1xuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoRW1wdHlDb25uZWN0aW9uSG9sZGVyLCBbe1xuICAgIGtleTogXCJpbml0aWFsaXplQ29ubmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplQ29ubmVjdGlvbigpIHtcbiAgICAgIC8vIG5vdGhpbmcgdG8gaW5pdGlhbGl6ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENvbm5lY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbigpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgoMCwgX2Vycm9yLm5ld0Vycm9yKSgnVGhpcyBjb25uZWN0aW9uIGhvbGRlciBkb2VzIG5vdCBzZXJ2ZSBjb25uZWN0aW9ucycpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVsZWFzZUNvbm5lY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZUNvbm5lY3Rpb24oKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRW1wdHlDb25uZWN0aW9uSG9sZGVyO1xufShDb25uZWN0aW9uSG9sZGVyKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGhhbmRsZS1jYWxsYmFjay1lcnJcblxuXG5mdW5jdGlvbiBpZ25vcmVFcnJvcihlcnJvcikge31cbi8qKlxuICogQ29ubmVjdGlvbiBob2xkZXIgdGhhdCBkb2VzIG5vdCBtYW5hZ2UgYW55IGNvbm5lY3Rpb25zLlxuICogQHR5cGUge0Nvbm5lY3Rpb25Ib2xkZXJ9XG4gKi9cblxuXG52YXIgRU1QVFlfQ09OTkVDVElPTl9IT0xERVIgPSBuZXcgRW1wdHlDb25uZWN0aW9uSG9sZGVyKCk7XG5leHBvcnRzLkVNUFRZX0NPTk5FQ1RJT05fSE9MREVSID0gRU1QVFlfQ09OTkVDVElPTl9IT0xERVI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9jb25uZWN0aW9uUHJvdmlkZXJQb29sZWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tcHJvdmlkZXItcG9vbGVkXCIpKTtcblxudmFyIF9jb25uZWN0aW9uRGVsZWdhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tZGVsZWdhdGVcIikpO1xuXG52YXIgX2Nvbm5lY3Rpb25DaGFubmVsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb25uZWN0aW9uLWNoYW5uZWxcIikpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIERpcmVjdENvbm5lY3Rpb25Qcm92aWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Bvb2xlZENvbm5lY3Rpb25Qcm92KSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoRGlyZWN0Q29ubmVjdGlvblByb3ZpZGVyLCBfUG9vbGVkQ29ubmVjdGlvblByb3YpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGlyZWN0Q29ubmVjdGlvblByb3ZpZGVyKTtcblxuICBmdW5jdGlvbiBEaXJlY3RDb25uZWN0aW9uUHJvdmlkZXIoX3JlZikge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBpZCA9IF9yZWYuaWQsXG4gICAgICAgIGNvbmZpZyA9IF9yZWYuY29uZmlnLFxuICAgICAgICBsb2cgPSBfcmVmLmxvZyxcbiAgICAgICAgYWRkcmVzcyA9IF9yZWYuYWRkcmVzcyxcbiAgICAgICAgdXNlckFnZW50ID0gX3JlZi51c2VyQWdlbnQsXG4gICAgICAgIGF1dGhUb2tlbiA9IF9yZWYuYXV0aFRva2VuO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgRGlyZWN0Q29ubmVjdGlvblByb3ZpZGVyKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgbG9nOiBsb2csXG4gICAgICB1c2VyQWdlbnQ6IHVzZXJBZ2VudCxcbiAgICAgIGF1dGhUb2tlbjogYXV0aFRva2VuXG4gICAgfSk7XG4gICAgX3RoaXMuX2FkZHJlc3MgPSBhZGRyZXNzO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogU2VlIHtAbGluayBDb25uZWN0aW9uUHJvdmlkZXJ9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgbWV0aG9kIGFuZFxuICAgKiBpdHMgYXJndW1lbnRzLlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoRGlyZWN0Q29ubmVjdGlvblByb3ZpZGVyLCBbe1xuICAgIGtleTogXCJhY3F1aXJlQ29ubmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY3F1aXJlQ29ubmVjdGlvbigpIHtcbiAgICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgYWNjZXNzTW9kZSA9IF9yZWYyLmFjY2Vzc01vZGUsXG4gICAgICAgICAgZGF0YWJhc2UgPSBfcmVmMi5kYXRhYmFzZSxcbiAgICAgICAgICBib29rbWFya3MgPSBfcmVmMi5ib29rbWFya3M7XG5cbiAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUG9vbC5hY3F1aXJlKHRoaXMuX2FkZHJlc3MpLnRoZW4oZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfY29ubmVjdGlvbkRlbGVnYXRlW1wiZGVmYXVsdFwiXShjb25uZWN0aW9uLCBudWxsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaGFzUHJvdG9jb2xWZXJzaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfaGFzUHJvdG9jb2xWZXJzaW9uMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKHZlcnNpb25QcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb24sIHByb3RvY29sO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPSBfY29ubmVjdGlvbkNoYW5uZWxbXCJkZWZhdWx0XCJdLmNyZWF0ZSh0aGlzLl9hZGRyZXNzLCB0aGlzLl9jb25maWcsIHRoaXMuX2NyZWF0ZUNvbm5lY3Rpb25FcnJvckhhbmRsZXIoKSwgdGhpcy5fbG9nKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5fbmVnb3RpYXRlUHJvdG9jb2woKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcHJvdG9jb2wgPSBjb25uZWN0aW9uLnByb3RvY29sKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdmVyc2lvblByZWRpY2F0ZShwcm90b2NvbC52ZXJzaW9uKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gODtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uY2xvc2UoKTtcblxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goOCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzEsLCA4LCAxMl1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2hhc1Byb3RvY29sVmVyc2lvbihfeCkge1xuICAgICAgICByZXR1cm4gX2hhc1Byb3RvY29sVmVyc2lvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9oYXNQcm90b2NvbFZlcnNpb247XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic3VwcG9ydHNNdWx0aURiXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc3VwcG9ydHNNdWx0aURiID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3RvY29sVmVyc2lvbihmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb24gPj0gX2NvbnN0YW50cy5CT0xUX1BST1RPQ09MX1Y0XzA7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc3VwcG9ydHNNdWx0aURiKCkge1xuICAgICAgICByZXR1cm4gX3N1cHBvcnRzTXVsdGlEYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3VwcG9ydHNNdWx0aURiO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInN1cHBvcnRzVHJhbnNhY3Rpb25Db25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zdXBwb3J0c1RyYW5zYWN0aW9uQ29uZmlnID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3RvY29sVmVyc2lvbihmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb24gPj0gX2NvbnN0YW50cy5CT0xUX1BST1RPQ09MX1YzO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDMuc2VudCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHN1cHBvcnRzVHJhbnNhY3Rpb25Db25maWcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwcG9ydHNUcmFuc2FjdGlvbkNvbmZpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3VwcG9ydHNUcmFuc2FjdGlvbkNvbmZpZztcbiAgICB9KClcbiAgfV0pO1xuICByZXR1cm4gRGlyZWN0Q29ubmVjdGlvblByb3ZpZGVyO1xufShfY29ubmVjdGlvblByb3ZpZGVyUG9vbGVkW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRGlyZWN0Q29ubmVjdGlvblByb3ZpZGVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9jb25uZWN0aW9uQ2hhbm5lbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29ubmVjdGlvbi1jaGFubmVsXCIpKTtcblxudmFyIF9wb29sID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wb29sXCIpKTtcblxudmFyIF9wb29sQ29uZmlnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wb29sLWNvbmZpZ1wiKSk7XG5cbnZhciBfY29ubmVjdGlvbkVycm9ySGFuZGxlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29ubmVjdGlvbi1lcnJvci1oYW5kbGVyXCIpKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuLi9lcnJvclwiKTtcblxudmFyIF9jb25uZWN0aW9uUHJvdmlkZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tcHJvdmlkZXJcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgUG9vbGVkQ29ubmVjdGlvblByb3ZpZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29ubmVjdGlvblByb3ZpZGVyKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoUG9vbGVkQ29ubmVjdGlvblByb3ZpZGVyLCBfQ29ubmVjdGlvblByb3ZpZGVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFBvb2xlZENvbm5lY3Rpb25Qcm92aWRlcik7XG5cbiAgZnVuY3Rpb24gUG9vbGVkQ29ubmVjdGlvblByb3ZpZGVyKF9yZWYpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgICBjb25maWcgPSBfcmVmLmNvbmZpZyxcbiAgICAgICAgbG9nID0gX3JlZi5sb2csXG4gICAgICAgIHVzZXJBZ2VudCA9IF9yZWYudXNlckFnZW50LFxuICAgICAgICBhdXRoVG9rZW4gPSBfcmVmLmF1dGhUb2tlbjtcbiAgICB2YXIgY3JlYXRlQ2hhbm5lbENvbm5lY3Rpb25Ib29rID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUG9vbGVkQ29ubmVjdGlvblByb3ZpZGVyKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLl9pZCA9IGlkO1xuICAgIF90aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgX3RoaXMuX2xvZyA9IGxvZztcbiAgICBfdGhpcy5fdXNlckFnZW50ID0gdXNlckFnZW50O1xuICAgIF90aGlzLl9hdXRoVG9rZW4gPSBhdXRoVG9rZW47XG5cbiAgICBfdGhpcy5fY3JlYXRlQ2hhbm5lbENvbm5lY3Rpb24gPSBjcmVhdGVDaGFubmVsQ29ubmVjdGlvbkhvb2sgfHwgZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAgIHJldHVybiBfY29ubmVjdGlvbkNoYW5uZWxbXCJkZWZhdWx0XCJdLmNyZWF0ZShhZGRyZXNzLCBfdGhpcy5fY29uZmlnLCBfdGhpcy5fY3JlYXRlQ29ubmVjdGlvbkVycm9ySGFuZGxlcigpLCBfdGhpcy5fbG9nKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuX2Nvbm5lY3Rpb25Qb29sID0gbmV3IF9wb29sW1wiZGVmYXVsdFwiXSh7XG4gICAgICBjcmVhdGU6IF90aGlzLl9jcmVhdGVDb25uZWN0aW9uLmJpbmQoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyW1wiZGVmYXVsdFwiXSkoX3RoaXMpKSxcbiAgICAgIGRlc3Ryb3k6IF90aGlzLl9kZXN0cm95Q29ubmVjdGlvbi5iaW5kKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMltcImRlZmF1bHRcIl0pKF90aGlzKSksXG4gICAgICB2YWxpZGF0ZTogX3RoaXMuX3ZhbGlkYXRlQ29ubmVjdGlvbi5iaW5kKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMltcImRlZmF1bHRcIl0pKF90aGlzKSksXG4gICAgICBpbnN0YWxsSWRsZU9ic2VydmVyOiBQb29sZWRDb25uZWN0aW9uUHJvdmlkZXIuX2luc3RhbGxJZGxlT2JzZXJ2ZXJPbkNvbm5lY3Rpb24uYmluZCgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDJbXCJkZWZhdWx0XCJdKShfdGhpcykpLFxuICAgICAgcmVtb3ZlSWRsZU9ic2VydmVyOiBQb29sZWRDb25uZWN0aW9uUHJvdmlkZXIuX3JlbW92ZUlkbGVPYnNlcnZlck9uQ29ubmVjdGlvbi5iaW5kKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMltcImRlZmF1bHRcIl0pKF90aGlzKSksXG4gICAgICBjb25maWc6IF9wb29sQ29uZmlnW1wiZGVmYXVsdFwiXS5mcm9tRHJpdmVyQ29uZmlnKGNvbmZpZyksXG4gICAgICBsb2c6IF90aGlzLl9sb2dcbiAgICB9KTtcbiAgICBfdGhpcy5fb3BlbkNvbm5lY3Rpb25zID0ge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShQb29sZWRDb25uZWN0aW9uUHJvdmlkZXIsIFt7XG4gICAga2V5OiBcIl9jcmVhdGVDb25uZWN0aW9uRXJyb3JIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVDb25uZWN0aW9uRXJyb3JIYW5kbGVyKCkge1xuICAgICAgcmV0dXJuIG5ldyBfY29ubmVjdGlvbkVycm9ySGFuZGxlcltcImRlZmF1bHRcIl0oX2Vycm9yLlNFUlZJQ0VfVU5BVkFJTEFCTEUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgY29ubmVjdGlvbiBhbmQgaW5pdGlhbGl6ZSBpdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbm5lY3Rpb24+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggYSBuZXcgY29ubmVjdGlvbiBvciByZWplY3RlZCB3aGVuIGZhaWxlZCB0byBjb25uZWN0LlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUNvbm5lY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUNvbm5lY3Rpb24oYWRkcmVzcywgcmVsZWFzZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5fY3JlYXRlQ2hhbm5lbENvbm5lY3Rpb24oYWRkcmVzcyk7XG5cbiAgICAgIGNvbm5lY3Rpb24uX3JlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZWxlYXNlKGFkZHJlc3MsIGNvbm5lY3Rpb24pO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fb3BlbkNvbm5lY3Rpb25zW2Nvbm5lY3Rpb24uaWRdID0gY29ubmVjdGlvbjtcbiAgICAgIHJldHVybiBjb25uZWN0aW9uLmNvbm5lY3QodGhpcy5fdXNlckFnZW50LCB0aGlzLl9hdXRoVG9rZW4pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIC8vIGxldCdzIGRlc3Ryb3kgdGhpcyBjb25uZWN0aW9uXG4gICAgICAgIF90aGlzMi5fZGVzdHJveUNvbm5lY3Rpb24oY29ubmVjdGlvbik7IC8vIHByb3BhZ2F0ZSB0aGUgZXJyb3IgYmVjYXVzZSBjb25uZWN0aW9uIGZhaWxlZCB0byBjb25uZWN0IC8gaW5pdGlhbGl6ZVxuXG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBhIGNvbm5lY3Rpb24gaXMgdXNhYmxlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY29ubmVjdGlvbiBpcyBvcGVuXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3ZhbGlkYXRlQ29ubmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdmFsaWRhdGVDb25uZWN0aW9uKGNvbm4pIHtcbiAgICAgIGlmICghY29ubi5pc09wZW4oKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXhDb25uZWN0aW9uTGlmZXRpbWUgPSB0aGlzLl9jb25maWcubWF4Q29ubmVjdGlvbkxpZmV0aW1lO1xuICAgICAgdmFyIGxpZmV0aW1lID0gRGF0ZS5ub3coKSAtIGNvbm4uY3JlYXRpb25UaW1lc3RhbXA7XG4gICAgICByZXR1cm4gbGlmZXRpbWUgPD0gbWF4Q29ubmVjdGlvbkxpZmV0aW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIG9mIGEgY29ubmVjdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtDb25uZWN0aW9ufSB0aGUgY29ubmVjdGlvbiB0byBkaXNwb3NlLlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lDb25uZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95Q29ubmVjdGlvbihjb25uKSB7XG4gICAgICBkZWxldGUgdGhpcy5fb3BlbkNvbm5lY3Rpb25zW2Nvbm4uaWRdO1xuICAgICAgcmV0dXJuIGNvbm4uY2xvc2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jbG9zZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUG9vbC5jbG9zZSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoT2JqZWN0LnZhbHVlcyh0aGlzLl9vcGVuQ29ubmVjdGlvbnMpLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIF9jbG9zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvc2U7XG4gICAgfSgpXG4gIH1dLCBbe1xuICAgIGtleTogXCJfaW5zdGFsbElkbGVPYnNlcnZlck9uQ29ubmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5zdGFsbElkbGVPYnNlcnZlck9uQ29ubmVjdGlvbihjb25uLCBvYnNlcnZlcikge1xuICAgICAgY29ubi5fcXVldWVPYnNlcnZlcihvYnNlcnZlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVJZGxlT2JzZXJ2ZXJPbkNvbm5lY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUlkbGVPYnNlcnZlck9uQ29ubmVjdGlvbihjb25uKSB7XG4gICAgICBjb25uLl91cGRhdGVDdXJyZW50T2JzZXJ2ZXIoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBvb2xlZENvbm5lY3Rpb25Qcm92aWRlcjtcbn0oX2Nvbm5lY3Rpb25Qcm92aWRlcltcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFBvb2xlZENvbm5lY3Rpb25Qcm92aWRlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xuXG52YXIgX2RyaXZlciA9IHJlcXVpcmUoXCIuLi9kcml2ZXJcIik7XG5cbnZhciBfc2Vzc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3Nlc3Npb25cIikpO1xuXG52YXIgX3JvdXRpbmdUYWJsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm91dGluZy10YWJsZVwiKSk7XG5cbnZhciBfcmVkaXNjb3ZlcnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JlZGlzY292ZXJ5XCIpKTtcblxudmFyIF9yb3V0aW5nVXRpbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm91dGluZy11dGlsXCIpKTtcblxudmFyIF9ub2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKTtcblxudmFyIF9jb25uZWN0aW9uUHJvdmlkZXJTaW5nbGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tcHJvdmlkZXItc2luZ2xlXCIpKTtcblxudmFyIF9jb25uZWN0aW9uUHJvdmlkZXJQb29sZWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tcHJvdmlkZXItcG9vbGVkXCIpKTtcblxudmFyIF9jb25uZWN0aW9uRXJyb3JIYW5kbGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb25uZWN0aW9uLWVycm9yLWhhbmRsZXJcIikpO1xuXG52YXIgX2Nvbm5lY3Rpb25EZWxlZ2F0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29ubmVjdGlvbi1kZWxlZ2F0ZVwiKSk7XG5cbnZhciBfbGVhc3RDb25uZWN0ZWRMb2FkQmFsYW5jaW5nU3RyYXRlZ3kgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xlYXN0LWNvbm5lY3RlZC1sb2FkLWJhbGFuY2luZy1zdHJhdGVneVwiKSk7XG5cbnZhciBfYm9va21hcmsgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jvb2ttYXJrXCIpKTtcblxudmFyIF9jb25uZWN0aW9uQ2hhbm5lbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29ubmVjdGlvbi1jaGFubmVsXCIpKTtcblxudmFyIF9pbnRlZ2VyID0gcmVxdWlyZShcIi4uL2ludGVnZXJcIik7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgVU5BVVRIT1JJWkVEX0VSUk9SX0NPREUgPSAnTmVvLkNsaWVudEVycm9yLlNlY3VyaXR5LlVuYXV0aG9yaXplZCc7XG52YXIgREFUQUJBU0VfTk9UX0ZPVU5EX0VSUk9SX0NPREUgPSAnTmVvLkNsaWVudEVycm9yLkRhdGFiYXNlLkRhdGFiYXNlTm90Rm91bmQnO1xudmFyIFNZU1RFTV9EQl9OQU1FID0gJ3N5c3RlbSc7XG52YXIgREVGQVVMVF9EQl9OQU1FID0gJyc7XG52YXIgREVGQVVMVF9ST1VUSU5HX1RBQkxFX1BVUkdFX0RFTEFZID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKSgzMDAwMCk7XG5cbnZhciBSb3V0aW5nQ29ubmVjdGlvblByb3ZpZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUG9vbGVkQ29ubmVjdGlvblByb3YpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShSb3V0aW5nQ29ubmVjdGlvblByb3ZpZGVyLCBfUG9vbGVkQ29ubmVjdGlvblByb3YpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUm91dGluZ0Nvbm5lY3Rpb25Qcm92aWRlcik7XG5cbiAgZnVuY3Rpb24gUm91dGluZ0Nvbm5lY3Rpb25Qcm92aWRlcihfcmVmKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICAgICAgYWRkcmVzcyA9IF9yZWYuYWRkcmVzcyxcbiAgICAgICAgcm91dGluZ0NvbnRleHQgPSBfcmVmLnJvdXRpbmdDb250ZXh0LFxuICAgICAgICBob3N0TmFtZVJlc29sdmVyID0gX3JlZi5ob3N0TmFtZVJlc29sdmVyLFxuICAgICAgICBjb25maWcgPSBfcmVmLmNvbmZpZyxcbiAgICAgICAgbG9nID0gX3JlZi5sb2csXG4gICAgICAgIHVzZXJBZ2VudCA9IF9yZWYudXNlckFnZW50LFxuICAgICAgICBhdXRoVG9rZW4gPSBfcmVmLmF1dGhUb2tlbixcbiAgICAgICAgcm91dGluZ1RhYmxlUHVyZ2VEZWxheSA9IF9yZWYucm91dGluZ1RhYmxlUHVyZ2VEZWxheTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFJvdXRpbmdDb25uZWN0aW9uUHJvdmlkZXIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywge1xuICAgICAgaWQ6IGlkLFxuICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICBsb2c6IGxvZyxcbiAgICAgIHVzZXJBZ2VudDogdXNlckFnZW50LFxuICAgICAgYXV0aFRva2VuOiBhdXRoVG9rZW5cbiAgICB9LCBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgcmV0dXJuIF9jb25uZWN0aW9uQ2hhbm5lbFtcImRlZmF1bHRcIl0uY3JlYXRlKGFkZHJlc3MsIF90aGlzLl9jb25maWcsIF90aGlzLl9jcmVhdGVDb25uZWN0aW9uRXJyb3JIYW5kbGVyKCksIF90aGlzLl9sb2csIHJvdXRpbmdDb250ZXh0IHx8IHt9KTtcbiAgICB9KTtcbiAgICBfdGhpcy5fc2VlZFJvdXRlciA9IGFkZHJlc3M7XG4gICAgX3RoaXMuX3JvdXRpbmdUYWJsZXMgPSB7fTtcbiAgICBfdGhpcy5fcmVkaXNjb3ZlcnkgPSBuZXcgX3JlZGlzY292ZXJ5W1wiZGVmYXVsdFwiXShuZXcgX3JvdXRpbmdVdGlsW1wiZGVmYXVsdFwiXShyb3V0aW5nQ29udGV4dCwgYWRkcmVzcy50b1N0cmluZygpKSk7XG4gICAgX3RoaXMuX2xvYWRCYWxhbmNpbmdTdHJhdGVneSA9IG5ldyBfbGVhc3RDb25uZWN0ZWRMb2FkQmFsYW5jaW5nU3RyYXRlZ3lbXCJkZWZhdWx0XCJdKF90aGlzLl9jb25uZWN0aW9uUG9vbCk7XG4gICAgX3RoaXMuX2hvc3ROYW1lUmVzb2x2ZXIgPSBob3N0TmFtZVJlc29sdmVyO1xuICAgIF90aGlzLl9kbnNSZXNvbHZlciA9IG5ldyBfbm9kZS5Ib3N0TmFtZVJlc29sdmVyKCk7XG4gICAgX3RoaXMuX2xvZyA9IGxvZztcbiAgICBfdGhpcy5fdXNlU2VlZFJvdXRlciA9IHRydWU7XG4gICAgX3RoaXMuX3JvdXRpbmdUYWJsZVB1cmdlRGVsYXkgPSByb3V0aW5nVGFibGVQdXJnZURlbGF5ID8gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShyb3V0aW5nVGFibGVQdXJnZURlbGF5KSA6IERFRkFVTFRfUk9VVElOR19UQUJMRV9QVVJHRV9ERUxBWTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFJvdXRpbmdDb25uZWN0aW9uUHJvdmlkZXIsIFt7XG4gICAga2V5OiBcIl9jcmVhdGVDb25uZWN0aW9uRXJyb3JIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVDb25uZWN0aW9uRXJyb3JIYW5kbGVyKCkge1xuICAgICAgLy8gY29ubmVjdGlvbiBlcnJvcnMgbWVhbiBTRVJWSUNFX1VOQVZBSUxBQkxFIGZvciBkaXJlY3QgZHJpdmVyIGJ1dCBmb3Igcm91dGluZyBkcml2ZXIgdGhleSBzaG91bGQgb25seVxuICAgICAgLy8gcmVzdWx0IGluIFNFU1NJT05fRVhQSVJFRCBiZWNhdXNlIHRoZXJlIG1pZ2h0IHN0aWxsIGV4aXN0IG90aGVyIHNlcnZlcnMgY2FwYWJsZSBvZiBzZXJ2aW5nIHRoZSByZXF1ZXN0XG4gICAgICByZXR1cm4gbmV3IF9jb25uZWN0aW9uRXJyb3JIYW5kbGVyW1wiZGVmYXVsdFwiXShfZXJyb3IuU0VTU0lPTl9FWFBJUkVEKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZVVuYXZhaWxhYmlsaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVVbmF2YWlsYWJpbGl0eShlcnJvciwgYWRkcmVzcywgZGF0YWJhc2UpIHtcbiAgICAgIHRoaXMuX2xvZy53YXJuKFwiUm91dGluZyBkcml2ZXIgXCIuY29uY2F0KHRoaXMuX2lkLCBcIiB3aWxsIGZvcmdldCBcIikuY29uY2F0KGFkZHJlc3MsIFwiIGZvciBkYXRhYmFzZSAnXCIpLmNvbmNhdChkYXRhYmFzZSwgXCInIGJlY2F1c2Ugb2YgYW4gZXJyb3IgXCIpLmNvbmNhdChlcnJvci5jb2RlLCBcIiAnXCIpLmNvbmNhdChlcnJvci5tZXNzYWdlLCBcIidcIikpO1xuXG4gICAgICB0aGlzLmZvcmdldChhZGRyZXNzLCBkYXRhYmFzZSB8fCAnJyk7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVXcml0ZUZhaWx1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVdyaXRlRmFpbHVyZShlcnJvciwgYWRkcmVzcywgZGF0YWJhc2UpIHtcbiAgICAgIHRoaXMuX2xvZy53YXJuKFwiUm91dGluZyBkcml2ZXIgXCIuY29uY2F0KHRoaXMuX2lkLCBcIiB3aWxsIGZvcmdldCB3cml0ZXIgXCIpLmNvbmNhdChhZGRyZXNzLCBcIiBmb3IgZGF0YWJhc2UgJ1wiKS5jb25jYXQoZGF0YWJhc2UsIFwiJyBiZWNhdXNlIG9mIGFuIGVycm9yIFwiKS5jb25jYXQoZXJyb3IuY29kZSwgXCIgJ1wiKS5jb25jYXQoZXJyb3IubWVzc2FnZSwgXCInXCIpKTtcblxuICAgICAgdGhpcy5mb3JnZXRXcml0ZXIoYWRkcmVzcywgZGF0YWJhc2UgfHwgJycpO1xuICAgICAgcmV0dXJuICgwLCBfZXJyb3IubmV3RXJyb3IpKCdObyBsb25nZXIgcG9zc2libGUgdG8gd3JpdGUgdG8gc2VydmVyIGF0ICcgKyBhZGRyZXNzLCBfZXJyb3IuU0VTU0lPTl9FWFBJUkVEKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VlIHtAbGluayBDb25uZWN0aW9uUHJvdmlkZXJ9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgbWV0aG9kIGFuZFxuICAgICAqIGl0cyBhcmd1bWVudHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhY3F1aXJlQ29ubmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2FjcXVpcmVDb25uZWN0aW9uID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBfcmVmMixcbiAgICAgICAgICAgIGFjY2Vzc01vZGUsXG4gICAgICAgICAgICBkYXRhYmFzZSxcbiAgICAgICAgICAgIGJvb2ttYXJrLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhYmFzZVNwZWNpZmljRXJyb3JIYW5kbGVyLFxuICAgICAgICAgICAgcm91dGluZ1RhYmxlLFxuICAgICAgICAgICAgY29ubmVjdGlvbixcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkLFxuICAgICAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfcmVmMiA9IF9hcmdzLmxlbmd0aCA+IDAgJiYgX2FyZ3NbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzBdIDoge30sIGFjY2Vzc01vZGUgPSBfcmVmMi5hY2Nlc3NNb2RlLCBkYXRhYmFzZSA9IF9yZWYyLmRhdGFiYXNlLCBib29rbWFyayA9IF9yZWYyLmJvb2ttYXJrO1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlU3BlY2lmaWNFcnJvckhhbmRsZXIgPSBuZXcgX2Nvbm5lY3Rpb25FcnJvckhhbmRsZXJbXCJkZWZhdWx0XCJdKF9lcnJvci5TRVNTSU9OX0VYUElSRUQsIGZ1bmN0aW9uIChlcnJvciwgYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5faGFuZGxlVW5hdmFpbGFiaWxpdHkoZXJyb3IsIGFkZHJlc3MsIGRhdGFiYXNlKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IsIGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIuX2hhbmRsZVdyaXRlRmFpbHVyZShlcnJvciwgYWRkcmVzcywgZGF0YWJhc2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcmVzaFJvdXRpbmdUYWJsZSh7XG4gICAgICAgICAgICAgICAgICBhY2Nlc3NNb2RlOiBhY2Nlc3NNb2RlLFxuICAgICAgICAgICAgICAgICAgZGF0YWJhc2U6IGRhdGFiYXNlIHx8IERFRkFVTFRfREJfTkFNRSxcbiAgICAgICAgICAgICAgICAgIGJvb2ttYXJrOiBib29rbWFya1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByb3V0aW5nVGFibGUgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoYWNjZXNzTW9kZSA9PT0gX2RyaXZlci5SRUFEKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IHRoaXMuX2xvYWRCYWxhbmNpbmdTdHJhdGVneS5zZWxlY3RSZWFkZXIocm91dGluZ1RhYmxlLnJlYWRlcnMpO1xuICAgICAgICAgICAgICAgIG5hbWUgPSAncmVhZCc7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgaWYgKCEoYWNjZXNzTW9kZSA9PT0gX2RyaXZlci5XUklURSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLl9sb2FkQmFsYW5jaW5nU3RyYXRlZ3kuc2VsZWN0V3JpdGVyKHJvdXRpbmdUYWJsZS53cml0ZXJzKTtcbiAgICAgICAgICAgICAgICBuYW1lID0gJ3dyaXRlJztcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnSWxsZWdhbCBtb2RlICcgKyBhY2Nlc3NNb2RlKTtcblxuICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKShcIkZhaWxlZCB0byBvYnRhaW4gY29ubmVjdGlvbiB0b3dhcmRzIFwiLmNvbmNhdChuYW1lLCBcIiBzZXJ2ZXIuIEtub3duIHJvdXRpbmcgdGFibGUgaXM6IFwiKS5jb25jYXQocm91dGluZ1RhYmxlKSwgX2Vycm9yLlNFU1NJT05fRVhQSVJFRCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTg7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlQ29ubmVjdGlvblRvU2VydmVyKGFkZHJlc3MsIG5hbWUsIHJvdXRpbmdUYWJsZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBfY29ubmVjdGlvbkRlbGVnYXRlW1wiZGVmYXVsdFwiXShjb25uZWN0aW9uLCBkYXRhYmFzZVNwZWNpZmljRXJyb3JIYW5kbGVyKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjU7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDE4KTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZCA9IGRhdGFiYXNlU3BlY2lmaWNFcnJvckhhbmRsZXIuaGFuZGxlQW5kVHJhbnNmb3JtRXJyb3IoX2NvbnRleHQudDAsIGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIHRocm93IHRyYW5zZm9ybWVkO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcywgW1sxOCwgMjVdXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFjcXVpcmVDb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2FjcXVpcmVDb25uZWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY3F1aXJlQ29ubmVjdGlvbjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfaGFzUHJvdG9jb2xWZXJzaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfaGFzUHJvdG9jb2xWZXJzaW9uMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMih2ZXJzaW9uUHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBhZGRyZXNzZXMsIGxhc3RFcnJvciwgaSwgY29ubmVjdGlvbiwgcHJvdG9jb2w7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVNlZWRSb3V0ZXIodGhpcy5fc2VlZFJvdXRlcik7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGFkZHJlc3NlcyA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgYWRkcmVzc2VzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gX2Nvbm5lY3Rpb25DaGFubmVsW1wiZGVmYXVsdFwiXS5jcmVhdGUoYWRkcmVzc2VzW2ldLCB0aGlzLl9jb25maWcsIHRoaXMuX2NyZWF0ZUNvbm5lY3Rpb25FcnJvckhhbmRsZXIoKSwgdGhpcy5fbG9nKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDY7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLl9uZWdvdGlhdGVQcm90b2NvbCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBwcm90b2NvbCA9IGNvbm5lY3Rpb24ucHJvdG9jb2woKTtcblxuICAgICAgICAgICAgICAgIGlmICghcHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB2ZXJzaW9uUHJlZGljYXRlKHByb3RvY29sLnZlcnNpb24pKTtcblxuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGZhbHNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTU7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oNik7XG4gICAgICAgICAgICAgICAgbGFzdEVycm9yID0gX2NvbnRleHQyLnQwO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxODtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCgxOCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBsYXN0RXJyb3I7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMsIFtbNiwgMTUsIDE4LCAyMl1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2hhc1Byb3RvY29sVmVyc2lvbihfeCkge1xuICAgICAgICByZXR1cm4gX2hhc1Byb3RvY29sVmVyc2lvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9oYXNQcm90b2NvbFZlcnNpb247XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic3VwcG9ydHNNdWx0aURiXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc3VwcG9ydHNNdWx0aURiID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3RvY29sVmVyc2lvbihmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb24gPj0gX2NvbnN0YW50cy5CT0xUX1BST1RPQ09MX1Y0XzA7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0My5zZW50KTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc3VwcG9ydHNNdWx0aURiKCkge1xuICAgICAgICByZXR1cm4gX3N1cHBvcnRzTXVsdGlEYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3VwcG9ydHNNdWx0aURiO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInN1cHBvcnRzVHJhbnNhY3Rpb25Db25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zdXBwb3J0c1RyYW5zYWN0aW9uQ29uZmlnID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3RvY29sVmVyc2lvbihmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb24gPj0gX2NvbnN0YW50cy5CT0xUX1BST1RPQ09MX1YzO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDQuc2VudCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHN1cHBvcnRzVHJhbnNhY3Rpb25Db25maWcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwcG9ydHNUcmFuc2FjdGlvbkNvbmZpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3VwcG9ydHNUcmFuc2FjdGlvbkNvbmZpZztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJmb3JnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yZ2V0KGFkZHJlc3MsIGRhdGFiYXNlKSB7XG4gICAgICBpZiAoZGF0YWJhc2UgfHwgZGF0YWJhc2UgPT09ICcnKSB7XG4gICAgICAgIHRoaXMuX3JvdXRpbmdUYWJsZXNbZGF0YWJhc2VdLmZvcmdldChhZGRyZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5fcm91dGluZ1RhYmxlcykuZm9yRWFjaChmdW5jdGlvbiAocm91dGluZ1RhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIHJvdXRpbmdUYWJsZS5mb3JnZXQoYWRkcmVzcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBXZSdyZSBmaXJpbmcgYW5kIGZvcmdldHRpbmcgdGhpcyBvcGVyYXRpb24gZXhwbGljaXRseSBhbmQgbGlzdGVuaW5nIGZvciBhbnlcbiAgICAgIC8vIGVycm9ycyB0byBhdm9pZCB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25cblxuXG4gICAgICB0aGlzLl9jb25uZWN0aW9uUG9vbC5wdXJnZShhZGRyZXNzKVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHt9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yZ2V0V3JpdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcmdldFdyaXRlcihhZGRyZXNzLCBkYXRhYmFzZSkge1xuICAgICAgaWYgKGRhdGFiYXNlIHx8IGRhdGFiYXNlID09PSAnJykge1xuICAgICAgICB0aGlzLl9yb3V0aW5nVGFibGVzW2RhdGFiYXNlXS5mb3JnZXRXcml0ZXIoYWRkcmVzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMuX3JvdXRpbmdUYWJsZXMpLmZvckVhY2goZnVuY3Rpb24gKHJvdXRpbmdUYWJsZSkge1xuICAgICAgICAgIHJldHVybiByb3V0aW5nVGFibGUuZm9yZ2V0V3JpdGVyKGFkZHJlc3MpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FjcXVpcmVDb25uZWN0aW9uVG9TZXJ2ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FjcXVpcmVDb25uZWN0aW9uVG9TZXJ2ZXIoYWRkcmVzcywgc2VydmVyTmFtZSwgcm91dGluZ1RhYmxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblBvb2wuYWNxdWlyZShhZGRyZXNzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZyZXNoUm91dGluZ1RhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9mcmVzaFJvdXRpbmdUYWJsZSgpIHtcbiAgICAgIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgYWNjZXNzTW9kZSA9IF9yZWYzLmFjY2Vzc01vZGUsXG4gICAgICAgICAgZGF0YWJhc2UgPSBfcmVmMy5kYXRhYmFzZSxcbiAgICAgICAgICBib29rbWFyayA9IF9yZWYzLmJvb2ttYXJrO1xuXG4gICAgICB2YXIgY3VycmVudFJvdXRpbmdUYWJsZSA9IHRoaXMuX3JvdXRpbmdUYWJsZXNbZGF0YWJhc2VdIHx8IG5ldyBfcm91dGluZ1RhYmxlW1wiZGVmYXVsdFwiXSh7XG4gICAgICAgIGRhdGFiYXNlOiBkYXRhYmFzZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghY3VycmVudFJvdXRpbmdUYWJsZS5pc1N0YWxlRm9yKGFjY2Vzc01vZGUpKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50Um91dGluZ1RhYmxlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9sb2cuaW5mbyhcIlJvdXRpbmcgdGFibGUgaXMgc3RhbGUgZm9yIGRhdGFiYXNlOiBcXFwiXCIuY29uY2F0KGRhdGFiYXNlLCBcIlxcXCIgYW5kIGFjY2VzcyBtb2RlOiBcXFwiXCIpLmNvbmNhdChhY2Nlc3NNb2RlLCBcIlxcXCI6IFwiKS5jb25jYXQoY3VycmVudFJvdXRpbmdUYWJsZSkpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVmcmVzaFJvdXRpbmdUYWJsZShjdXJyZW50Um91dGluZ1RhYmxlLCBib29rbWFyayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZWZyZXNoUm91dGluZ1RhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZyZXNoUm91dGluZ1RhYmxlKGN1cnJlbnRSb3V0aW5nVGFibGUsIGJvb2ttYXJrKSB7XG4gICAgICB2YXIga25vd25Sb3V0ZXJzID0gY3VycmVudFJvdXRpbmdUYWJsZS5yb3V0ZXJzO1xuXG4gICAgICBpZiAodGhpcy5fdXNlU2VlZFJvdXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hSb3V0aW5nVGFibGVGcm9tU2VlZFJvdXRlckZhbGxiYWNrVG9Lbm93blJvdXRlcnMoa25vd25Sb3V0ZXJzLCBjdXJyZW50Um91dGluZ1RhYmxlLCBib29rbWFyayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9mZXRjaFJvdXRpbmdUYWJsZUZyb21Lbm93blJvdXRlcnNGYWxsYmFja1RvU2VlZFJvdXRlcihrbm93blJvdXRlcnMsIGN1cnJlbnRSb3V0aW5nVGFibGUsIGJvb2ttYXJrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZldGNoUm91dGluZ1RhYmxlRnJvbVNlZWRSb3V0ZXJGYWxsYmFja1RvS25vd25Sb3V0ZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZmV0Y2hSb3V0aW5nVGFibGVGcm9tU2VlZFJvdXRlckZhbGxiYWNrVG9Lbm93blJvdXRlcnMyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGtub3duUm91dGVycywgY3VycmVudFJvdXRpbmdUYWJsZSwgYm9va21hcmspIHtcbiAgICAgICAgdmFyIHNlZW5Sb3V0ZXJzLCBuZXdSb3V0aW5nVGFibGU7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIC8vIHdlIHN0YXJ0IHdpdGggc2VlZCByb3V0ZXIsIG5vIHJvdXRlcnMgd2VyZSBwcm9iZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgc2VlblJvdXRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoUm91dGluZ1RhYmxlVXNpbmdTZWVkUm91dGVyKHNlZW5Sb3V0ZXJzLCB0aGlzLl9zZWVkUm91dGVyLCBjdXJyZW50Um91dGluZ1RhYmxlLCBib29rbWFyayk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIG5ld1JvdXRpbmdUYWJsZSA9IF9jb250ZXh0NS5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFuZXdSb3V0aW5nVGFibGUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3VzZVNlZWRSb3V0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mZXRjaFJvdXRpbmdUYWJsZVVzaW5nS25vd25Sb3V0ZXJzKGtub3duUm91dGVycywgY3VycmVudFJvdXRpbmdUYWJsZSwgYm9va21hcmspO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgbmV3Um91dGluZ1RhYmxlID0gX2NvbnRleHQ1LnNlbnQ7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcHBseVJvdXRpbmdUYWJsZUlmUG9zc2libGUoY3VycmVudFJvdXRpbmdUYWJsZSwgbmV3Um91dGluZ1RhYmxlKTtcblxuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NS5zZW50KTtcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9mZXRjaFJvdXRpbmdUYWJsZUZyb21TZWVkUm91dGVyRmFsbGJhY2tUb0tub3duUm91dGVycyhfeDIsIF94MywgX3g0KSB7XG4gICAgICAgIHJldHVybiBfZmV0Y2hSb3V0aW5nVGFibGVGcm9tU2VlZFJvdXRlckZhbGxiYWNrVG9Lbm93blJvdXRlcnMyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZmV0Y2hSb3V0aW5nVGFibGVGcm9tU2VlZFJvdXRlckZhbGxiYWNrVG9Lbm93blJvdXRlcnM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZldGNoUm91dGluZ1RhYmxlRnJvbUtub3duUm91dGVyc0ZhbGxiYWNrVG9TZWVkUm91dGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZmV0Y2hSb3V0aW5nVGFibGVGcm9tS25vd25Sb3V0ZXJzRmFsbGJhY2tUb1NlZWRSb3V0ZXIyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KGtub3duUm91dGVycywgY3VycmVudFJvdXRpbmdUYWJsZSwgYm9va21hcmspIHtcbiAgICAgICAgdmFyIG5ld1JvdXRpbmdUYWJsZTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mZXRjaFJvdXRpbmdUYWJsZVVzaW5nS25vd25Sb3V0ZXJzKGtub3duUm91dGVycywgY3VycmVudFJvdXRpbmdUYWJsZSwgYm9va21hcmspO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBuZXdSb3V0aW5nVGFibGUgPSBfY29udGV4dDYuc2VudDtcblxuICAgICAgICAgICAgICAgIGlmIChuZXdSb3V0aW5nVGFibGUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hSb3V0aW5nVGFibGVVc2luZ1NlZWRSb3V0ZXIoa25vd25Sb3V0ZXJzLCB0aGlzLl9zZWVkUm91dGVyLCBjdXJyZW50Um91dGluZ1RhYmxlLCBib29rbWFyayk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIG5ld1JvdXRpbmdUYWJsZSA9IF9jb250ZXh0Ni5zZW50O1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Um91dGluZ1RhYmxlSWZQb3NzaWJsZShjdXJyZW50Um91dGluZ1RhYmxlLCBuZXdSb3V0aW5nVGFibGUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDYuc2VudCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTYsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfZmV0Y2hSb3V0aW5nVGFibGVGcm9tS25vd25Sb3V0ZXJzRmFsbGJhY2tUb1NlZWRSb3V0ZXIoX3g1LCBfeDYsIF94Nykge1xuICAgICAgICByZXR1cm4gX2ZldGNoUm91dGluZ1RhYmxlRnJvbUtub3duUm91dGVyc0ZhbGxiYWNrVG9TZWVkUm91dGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2ZldGNoUm91dGluZ1RhYmxlRnJvbUtub3duUm91dGVyc0ZhbGxiYWNrVG9TZWVkUm91dGVyO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9mZXRjaFJvdXRpbmdUYWJsZVVzaW5nS25vd25Sb3V0ZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZmV0Y2hSb3V0aW5nVGFibGVVc2luZ0tub3duUm91dGVyczIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoa25vd25Sb3V0ZXJzLCBjdXJyZW50Um91dGluZ1RhYmxlLCBib29rbWFyaykge1xuICAgICAgICB2YXIgbmV3Um91dGluZ1RhYmxlLCBsYXN0Um91dGVySW5kZXg7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hSb3V0aW5nVGFibGUoa25vd25Sb3V0ZXJzLCBjdXJyZW50Um91dGluZ1RhYmxlLCBib29rbWFyayk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG5ld1JvdXRpbmdUYWJsZSA9IF9jb250ZXh0Ny5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFuZXdSb3V0aW5nVGFibGUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIG5ld1JvdXRpbmdUYWJsZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIC8vIHJldHVybmVkIHJvdXRpbmcgdGFibGUgd2FzIHVuZGVmaW5lZCwgdGhpcyBtZWFucyBhIGNvbm5lY3Rpb24gZXJyb3IgaGFwcGVuZWQgYW5kIHRoZSBsYXN0IGtub3duXG4gICAgICAgICAgICAgICAgLy8gcm91dGVyIGRpZCBub3QgcmV0dXJuIGEgdmFsaWQgcm91dGluZyB0YWJsZSwgc28gd2UgbmVlZCB0byBmb3JnZXQgaXRcbiAgICAgICAgICAgICAgICBsYXN0Um91dGVySW5kZXggPSBrbm93blJvdXRlcnMubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgICAgIFJvdXRpbmdDb25uZWN0aW9uUHJvdmlkZXIuX2ZvcmdldFJvdXRlcihjdXJyZW50Um91dGluZ1RhYmxlLCBrbm93blJvdXRlcnMsIGxhc3RSb3V0ZXJJbmRleCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU3LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2ZldGNoUm91dGluZ1RhYmxlVXNpbmdLbm93blJvdXRlcnMoX3g4LCBfeDksIF94MTApIHtcbiAgICAgICAgcmV0dXJuIF9mZXRjaFJvdXRpbmdUYWJsZVVzaW5nS25vd25Sb3V0ZXJzMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2ZldGNoUm91dGluZ1RhYmxlVXNpbmdLbm93blJvdXRlcnM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZldGNoUm91dGluZ1RhYmxlVXNpbmdTZWVkUm91dGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZmV0Y2hSb3V0aW5nVGFibGVVc2luZ1NlZWRSb3V0ZXIyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KHNlZW5Sb3V0ZXJzLCBzZWVkUm91dGVyLCByb3V0aW5nVGFibGUsIGJvb2ttYXJrKSB7XG4gICAgICAgIHZhciByZXNvbHZlZEFkZHJlc3NlcywgbmV3QWRkcmVzc2VzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVTZWVkUm91dGVyKHNlZWRSb3V0ZXIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFkZHJlc3NlcyA9IF9jb250ZXh0OC5zZW50O1xuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgYWxsIGFkZHJlc3NlcyB0aGF0IHdlJ3ZlIGFscmVhZHkgdHJpZWRcbiAgICAgICAgICAgICAgICBuZXdBZGRyZXNzZXMgPSByZXNvbHZlZEFkZHJlc3Nlcy5maWx0ZXIoZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVuUm91dGVycy5pbmRleE9mKGFkZHJlc3MpIDwgMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoUm91dGluZ1RhYmxlKG5ld0FkZHJlc3Nlcywgcm91dGluZ1RhYmxlLCBib29rbWFyayk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0OC5zZW50KTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU4LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2ZldGNoUm91dGluZ1RhYmxlVXNpbmdTZWVkUm91dGVyKF94MTEsIF94MTIsIF94MTMsIF94MTQpIHtcbiAgICAgICAgcmV0dXJuIF9mZXRjaFJvdXRpbmdUYWJsZVVzaW5nU2VlZFJvdXRlcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9mZXRjaFJvdXRpbmdUYWJsZVVzaW5nU2VlZFJvdXRlcjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfcmVzb2x2ZVNlZWRSb3V0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZXNvbHZlU2VlZFJvdXRlcjIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkoc2VlZFJvdXRlcikge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB2YXIgcmVzb2x2ZWRBZGRyZXNzZXMsIGRuc1Jlc29sdmVkQWRkcmVzc2VzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hvc3ROYW1lUmVzb2x2ZXIucmVzb2x2ZShzZWVkUm91dGVyKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBZGRyZXNzZXMgPSBfY29udGV4dDkuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc29sdmVkQWRkcmVzc2VzLm1hcChmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fZG5zUmVzb2x2ZXIucmVzb2x2ZShhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGRuc1Jlc29sdmVkQWRkcmVzc2VzID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwgW10uY29uY2F0LmFwcGx5KFtdLCBkbnNSZXNvbHZlZEFkZHJlc3NlcykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTksIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfcmVzb2x2ZVNlZWRSb3V0ZXIoX3gxNSkge1xuICAgICAgICByZXR1cm4gX3Jlc29sdmVTZWVkUm91dGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3Jlc29sdmVTZWVkUm91dGVyO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9mZXRjaFJvdXRpbmdUYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmV0Y2hSb3V0aW5nVGFibGUocm91dGVyQWRkcmVzc2VzLCByb3V0aW5nVGFibGUsIGJvb2ttYXJrKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgcmV0dXJuIHJvdXRlckFkZHJlc3Nlcy5yZWR1Y2UoIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmNCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTAocmVmcmVzaGVkVGFibGVQcm9taXNlLCBjdXJyZW50Um91dGVyLCBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICB2YXIgbmV3Um91dGluZ1RhYmxlLCBwcmV2aW91c1JvdXRlckluZGV4LCBzZXNzaW9uO1xuICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XG4gICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVmcmVzaGVkVGFibGVQcm9taXNlO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgbmV3Um91dGluZ1RhYmxlID0gX2NvbnRleHQxMC5zZW50O1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIW5ld1JvdXRpbmdUYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuYWJydXB0KFwicmV0dXJuXCIsIG5ld1JvdXRpbmdUYWJsZSk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAvLyByZXR1cm5lZCByb3V0aW5nIHRhYmxlIHdhcyB1bmRlZmluZWQsIHRoaXMgbWVhbnMgYSBjb25uZWN0aW9uIGVycm9yIGhhcHBlbmVkIGFuZCB3ZSBuZWVkIHRvIGZvcmdldCB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIHJvdXRlciBhbmQgdHJ5IHRoZSBuZXh0IG9uZVxuICAgICAgICAgICAgICAgICAgcHJldmlvdXNSb3V0ZXJJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG5cbiAgICAgICAgICAgICAgICAgIFJvdXRpbmdDb25uZWN0aW9uUHJvdmlkZXIuX2ZvcmdldFJvdXRlcihyb3V0aW5nVGFibGUsIHJvdXRlckFkZHJlc3NlcywgcHJldmlvdXNSb3V0ZXJJbmRleCk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczQuX2NyZWF0ZVNlc3Npb25Gb3JSZWRpc2NvdmVyeShjdXJyZW50Um91dGVyLCBib29rbWFyayk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgc2Vzc2lvbiA9IF9jb250ZXh0MTAuc2VudDtcblxuICAgICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDI3O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5wcmV2ID0gMTM7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczQuX3JlZGlzY292ZXJ5Lmxvb2t1cFJvdXRpbmdUYWJsZU9uUm91dGVyKHNlc3Npb24sIHJvdXRpbmdUYWJsZS5kYXRhYmFzZSwgY3VycmVudFJvdXRlcik7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0MTAuc2VudCk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5wcmV2ID0gMTk7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDEwLnQwID0gX2NvbnRleHQxMFtcImNhdGNoXCJdKDEzKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCEoX2NvbnRleHQxMC50MCAmJiBfY29udGV4dDEwLnQwLmNvZGUgPT09IERBVEFCQVNFX05PVF9GT1VORF9FUlJPUl9DT0RFKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAyMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MTAudDA7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgICAgX3RoaXM0Ll9sb2cud2FybihcInVuYWJsZSB0byBmZXRjaCByb3V0aW5nIHRhYmxlIGJlY2F1c2Ugb2YgYW4gZXJyb3IgXCIuY29uY2F0KF9jb250ZXh0MTAudDApKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDI4O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBfY2FsbGVlMTAsIG51bGwsIFtbMTMsIDE5XV0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeDE2LCBfeDE3LCBfeDE4KSB7XG4gICAgICAgICAgcmV0dXJuIF9yZWY0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KCksIFByb21pc2UucmVzb2x2ZShudWxsKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVTZXNzaW9uRm9yUmVkaXNjb3ZlcnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jcmVhdGVTZXNzaW9uRm9yUmVkaXNjb3ZlcnkyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMShyb3V0ZXJBZGRyZXNzLCBib29rbWFyaykge1xuICAgICAgICB2YXIgY29ubmVjdGlvbiwgY29ubmVjdGlvblByb3ZpZGVyLCBwcm90b2NvbFZlcnNpb247XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTExJChfY29udGV4dDExKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDExLnByZXYgPSAwO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25Qb29sLmFjcXVpcmUocm91dGVyQWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPSBfY29udGV4dDExLnNlbnQ7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvblByb3ZpZGVyID0gbmV3IF9jb25uZWN0aW9uUHJvdmlkZXJTaW5nbGVbXCJkZWZhdWx0XCJdKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgIHByb3RvY29sVmVyc2lvbiA9IGNvbm5lY3Rpb24ucHJvdG9jb2woKS52ZXJzaW9uO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEocHJvdG9jb2xWZXJzaW9uIDwgNC4wKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmFicnVwdChcInJldHVyblwiLCBuZXcgX3Nlc3Npb25bXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgICAgICAgICAgIG1vZGU6IF9kcml2ZXIuV1JJVEUsXG4gICAgICAgICAgICAgICAgICBib29rbWFyazogX2Jvb2ttYXJrW1wiZGVmYXVsdFwiXS5lbXB0eSgpLFxuICAgICAgICAgICAgICAgICAgY29ubmVjdGlvblByb3ZpZGVyOiBjb25uZWN0aW9uUHJvdmlkZXJcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmFicnVwdChcInJldHVyblwiLCBuZXcgX3Nlc3Npb25bXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgICAgICAgICAgIG1vZGU6IF9kcml2ZXIuUkVBRCxcbiAgICAgICAgICAgICAgICAgIGRhdGFiYXNlOiBTWVNURU1fREJfTkFNRSxcbiAgICAgICAgICAgICAgICAgIGJvb2ttYXJrOiBib29rbWFyayxcbiAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Qcm92aWRlcjogY29ubmVjdGlvblByb3ZpZGVyXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS50MCA9IF9jb250ZXh0MTFbXCJjYXRjaFwiXSgwKTtcblxuICAgICAgICAgICAgICAgIGlmICghKF9jb250ZXh0MTEudDAgJiYgX2NvbnRleHQxMS50MC5jb2RlID09PSBVTkFVVEhPUklaRURfRVJST1JfQ09ERSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQxMS50MDtcblxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTExLCB0aGlzLCBbWzAsIDExXV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfY3JlYXRlU2Vzc2lvbkZvclJlZGlzY292ZXJ5KF94MTksIF94MjApIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVTZXNzaW9uRm9yUmVkaXNjb3ZlcnkyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfY3JlYXRlU2Vzc2lvbkZvclJlZGlzY292ZXJ5O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBseVJvdXRpbmdUYWJsZUlmUG9zc2libGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hcHBseVJvdXRpbmdUYWJsZUlmUG9zc2libGUyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMihjdXJyZW50Um91dGluZ1RhYmxlLCBuZXdSb3V0aW5nVGFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTIkKF9jb250ZXh0MTIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEyLnByZXYgPSBfY29udGV4dDEyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmIChuZXdSb3V0aW5nVGFibGUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKShcIkNvdWxkIG5vdCBwZXJmb3JtIGRpc2NvdmVyeS4gTm8gcm91dGluZyBzZXJ2ZXJzIGF2YWlsYWJsZS4gS25vd24gcm91dGluZyB0YWJsZTogXCIuY29uY2F0KGN1cnJlbnRSb3V0aW5nVGFibGUpLCBfZXJyb3IuU0VSVklDRV9VTkFWQUlMQUJMRSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGlmIChuZXdSb3V0aW5nVGFibGUud3JpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIC8vIHVzZSBzZWVkIHJvdXRlciBuZXh0IHRpbWUuIHRoaXMgaXMgaW1wb3J0YW50IHdoZW4gY2x1c3RlciBpcyBwYXJ0aXRpb25lZC4gaXQgdHJpZXMgdG8gbWFrZSBzdXJlIGRyaXZlclxuICAgICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgYWx3YXlzIGdldCByb3V0aW5nIHRhYmxlIHdpdGhvdXQgd3JpdGVycyBiZWNhdXNlIGl0IHRhbGtzIGV4Y2x1c2l2ZWx5IHRvIGEgbWlub3JpdHkgcGFydGl0aW9uXG4gICAgICAgICAgICAgICAgICB0aGlzLl91c2VTZWVkUm91dGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVSb3V0aW5nVGFibGUobmV3Um91dGluZ1RhYmxlKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuYWJydXB0KFwicmV0dXJuXCIsIG5ld1JvdXRpbmdUYWJsZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2FwcGx5Um91dGluZ1RhYmxlSWZQb3NzaWJsZShfeDIxLCBfeDIyKSB7XG4gICAgICAgIHJldHVybiBfYXBwbHlSb3V0aW5nVGFibGVJZlBvc3NpYmxlMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2FwcGx5Um91dGluZ1RhYmxlSWZQb3NzaWJsZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlUm91dGluZ1RhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdXBkYXRlUm91dGluZ1RhYmxlMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTMobmV3Um91dGluZ1RhYmxlKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEzJChfY29udGV4dDEzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMy5wcmV2ID0gX2NvbnRleHQxMy5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUG9vbC5rZWVwQWxsKG5ld1JvdXRpbmdUYWJsZS5hbGxTZXJ2ZXJzKCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IGV4cGlyZWQgdG8gcHVyZ2UgKGV4cGlyZWQgZm9yIGEgcHJlLWNvbmZpZ3VyZWQgYW1vdW50IG9mIHRpbWUpIHJvdXRpbmcgdGFibGUgZW50cmllc1xuICAgICAgICAgICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5fcm91dGluZ1RhYmxlcykuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pc0V4cGlyZWRGb3IoX3RoaXM1Ll9yb3V0aW5nVGFibGVQdXJnZURlbGF5KSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXM1Ll9yb3V0aW5nVGFibGVzW3ZhbHVlLmRhdGFiYXNlXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTsgLy8gbWFrZSB0aGlzIGRyaXZlciBpbnN0YW5jZSBhd2FyZSBvZiB0aGUgbmV3IHRhYmxlXG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yb3V0aW5nVGFibGVzW25ld1JvdXRpbmdUYWJsZS5kYXRhYmFzZV0gPSBuZXdSb3V0aW5nVGFibGU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuaW5mbyhcIlVwZGF0ZWQgcm91dGluZyB0YWJsZSBcIi5jb25jYXQobmV3Um91dGluZ1RhYmxlKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX3VwZGF0ZVJvdXRpbmdUYWJsZShfeDIzKSB7XG4gICAgICAgIHJldHVybiBfdXBkYXRlUm91dGluZ1RhYmxlMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3VwZGF0ZVJvdXRpbmdUYWJsZTtcbiAgICB9KClcbiAgfV0sIFt7XG4gICAga2V5OiBcIl9mb3JnZXRSb3V0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZvcmdldFJvdXRlcihyb3V0aW5nVGFibGUsIHJvdXRlcnNBcnJheSwgcm91dGVySW5kZXgpIHtcbiAgICAgIHZhciBhZGRyZXNzID0gcm91dGVyc0FycmF5W3JvdXRlckluZGV4XTtcblxuICAgICAgaWYgKHJvdXRpbmdUYWJsZSAmJiBhZGRyZXNzKSB7XG4gICAgICAgIHJvdXRpbmdUYWJsZS5mb3JnZXRSb3V0ZXIoYWRkcmVzcyk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSb3V0aW5nQ29ubmVjdGlvblByb3ZpZGVyO1xufShfY29ubmVjdGlvblByb3ZpZGVyUG9vbGVkW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUm91dGluZ0Nvbm5lY3Rpb25Qcm92aWRlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfY29ubmVjdGlvblByb3ZpZGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb25uZWN0aW9uLXByb3ZpZGVyXCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFNpbmdsZUNvbm5lY3Rpb25Qcm92aWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Nvbm5lY3Rpb25Qcm92aWRlcikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKFNpbmdsZUNvbm5lY3Rpb25Qcm92aWRlciwgX0Nvbm5lY3Rpb25Qcm92aWRlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihTaW5nbGVDb25uZWN0aW9uUHJvdmlkZXIpO1xuXG4gIGZ1bmN0aW9uIFNpbmdsZUNvbm5lY3Rpb25Qcm92aWRlcihjb25uZWN0aW9uKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBTaW5nbGVDb25uZWN0aW9uUHJvdmlkZXIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogU2VlIHtAbGluayBDb25uZWN0aW9uUHJvdmlkZXJ9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgbWV0aG9kIGFuZFxuICAgKiBpdHMgYXJndW1lbnRzLlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoU2luZ2xlQ29ubmVjdGlvblByb3ZpZGVyLCBbe1xuICAgIGtleTogXCJhY3F1aXJlQ29ubmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY3F1aXJlQ29ubmVjdGlvbigpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBhY2Nlc3NNb2RlID0gX3JlZi5hY2Nlc3NNb2RlLFxuICAgICAgICAgIGRhdGFiYXNlID0gX3JlZi5kYXRhYmFzZSxcbiAgICAgICAgICBib29rbWFya3MgPSBfcmVmLmJvb2ttYXJrcztcblxuICAgICAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLl9jb25uZWN0aW9uO1xuICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbm5lY3Rpb24pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2luZ2xlQ29ubmVjdGlvblByb3ZpZGVyO1xufShfY29ubmVjdGlvblByb3ZpZGVyW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU2luZ2xlQ29ubmVjdGlvblByb3ZpZGVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2Jvb2ttYXJrID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ib29rbWFya1wiKSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIENvbm5lY3Rpb25Qcm92aWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbm5lY3Rpb25Qcm92aWRlcigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIENvbm5lY3Rpb25Qcm92aWRlcik7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKENvbm5lY3Rpb25Qcm92aWRlciwgW3tcbiAgICBrZXk6IFwiYWNxdWlyZUNvbm5lY3Rpb25cIixcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGFjcXVpcmVzIGEgY29ubmVjdGlvbiBhZ2FpbnN0IHRoZSBzcGVjaWZpZWQgZGF0YWJhc2UuXG4gICAgICpcbiAgICAgKiBBY2Nlc3MgbW9kZSBhbmQgQm9va21hcmtzIG9ubHkgYXBwbGllcyB0byByb3V0aW5nIGRyaXZlci4gQWNjZXNzIG1vZGUgb25seVxuICAgICAqIGRpZmZlcmVudGlhdGVzIHRoZSB0YXJnZXQgc2VydmVyIGZvciB0aGUgY29ubmVjdGlvbiwgd2hlcmUgV1JJVEUgc2VsZWN0cyBhXG4gICAgICogV1JJVEVSIHNlcnZlciwgd2hlcmVhcyBSRUFEIHNlbGVjdHMgYSBSRUFEIHNlcnZlci4gQm9va21hcmtzLCB3aGVuIHNwZWNpZmllZCxcbiAgICAgKiBpcyBvbmx5IHBhc3NlZCB0byB0aGUgcm91dGluZyBkaXNjb3ZlcnkgcHJvY2VkdXJlLCBmb3IgdGhlIHN5c3RlbSBkYXRhYmFzZSB0b1xuICAgICAqIHN5bmNocm9uaXplIG9uIGNyZWF0aW9uIG9mIGRhdGFiYXNlcyBhbmQgaXMgbmV2ZXIgdXNlZCBpbiBkaXJlY3QgZHJpdmVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbSAtIG9iamVjdCBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0uYWNjZXNzTW9kZSAtIHRoZSBhY2Nlc3MgbW9kZSBmb3IgdGhlIHRvLWJlLWFjcXVpcmVkIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0uZGF0YWJhc2UgLSB0aGUgdGFyZ2V0IGRhdGFiYXNlIGZvciB0aGUgdG8tYmUtYWNxdWlyZWQgY29ubmVjdGlvblxuICAgICAqIEBwYXJhbSB7Qm9va21hcmt9IHBhcmFtLmJvb2ttYXJrcyAtIHRoZSBib29rbWFya3MgdG8gc2VuZCB0byByb3V0aW5nIGRpc2NvdmVyeVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBhY3F1aXJlQ29ubmVjdGlvbigpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBhY2Nlc3NNb2RlID0gX3JlZi5hY2Nlc3NNb2RlLFxuICAgICAgICAgIGRhdGFiYXNlID0gX3JlZi5kYXRhYmFzZSxcbiAgICAgICAgICBib29rbWFya3MgPSBfcmVmLmJvb2ttYXJrcztcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgdGhlIGJhY2tlbmQgZGF0YWJhc2Ugc3VwcG9ydHMgbXVsdGkgZGF0YWJhc2UgZnVuY3Rpb25hbGl0eVxuICAgICAqIGJ5IGNoZWNraW5nIHByb3RvY29sIGhhbmRzaGFrZSByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN1cHBvcnRzTXVsdGlEYlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdXBwb3J0c011bHRpRGIoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciB0aGUgYmFja2VuZCBkYXRhYmFzZSBzdXBwb3J0cyB0cmFuc2FjdGlvbiBjb25maWcgZnVuY3Rpb25hbGl0eVxuICAgICAqIGJ5IGNoZWNraW5nIHByb3RvY29sIGhhbmRzaGFrZSByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN1cHBvcnRzVHJhbnNhY3Rpb25Db25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VwcG9ydHNUcmFuc2FjdGlvbkNvbmZpZygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGlzIGNvbm5lY3Rpb24gcHJvdmlkZXIgYWxvbmcgd2l0aCBpdHMgaW50ZXJuYWxzIChjb25uZWN0aW9ucywgcG9vbHMsIGV0Yy4pXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbm5lY3Rpb25Qcm92aWRlcjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDb25uZWN0aW9uUHJvdmlkZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfc3RyZWFtT2JzZXJ2ZXJzID0gcmVxdWlyZShcIi4vc3RyZWFtLW9ic2VydmVyc1wiKTtcblxudmFyIF9ib2x0UHJvdG9jb2xWID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ib2x0LXByb3RvY29sLXYxXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQ29ubmVjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25FcnJvckhhbmRsZXJ9IGVycm9ySGFuZGxlciB0aGUgZXJyb3IgaGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gQ29ubmVjdGlvbihlcnJvckhhbmRsZXIpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIENvbm5lY3Rpb24pO1xuICAgIHRoaXMuX2Vycm9ySGFuZGxlciA9IGVycm9ySGFuZGxlcjtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQ29ubmVjdGlvbiwgW3tcbiAgICBrZXk6IFwiaXNPcGVuXCIsXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGlzIGNvbm5lY3Rpb24gaXMgaW4gYSB3b3JraW5nIGNvbmRpdGlvblxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBpc09wZW4oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9sdFByb3RvY29sfSB0aGUgdW5kZXJseWluZyBib2x0IHByb3RvY29sIGFzc2lnbmVkIHRvIHRoaXMgY29ubmVjdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJvdG9jb2xcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvdG9jb2woKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U2VydmVyQWRkcmVzc30gdGhlIHNlcnZlciBhZGRyZXNzIHRoaXMgY29ubmVjdGlvbiBpcyBvcGVuZWQgYWdhaW5zdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29ubmVjdFwiLFxuXG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgdGFyZ2V0IGFkZHJlc3MsIG5lZ290aWF0ZSBCb2x0IHByb3RvY29sIGFuZCBzZW5kIGluaXRpYWxpemF0aW9uIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJBZ2VudCB0aGUgdXNlciBhZ2VudCBmb3IgdGhpcyBkcml2ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF1dGhUb2tlbiB0aGUgb2JqZWN0IGNvbnRhaW5pbmcgYXV0aCBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbm5lY3Rpb24+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBpZiBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWwuIFJlamVjdGVkIHByb21pc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KHVzZXJBZ2VudCwgYXV0aFRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIG1lc3NhZ2UgdG8gdGhlIG5ldHdvcmsgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0ge1JlcXVlc3RNZXNzYWdlfSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSB7UmVzdWx0U3RyZWFtT2JzZXJ2ZXJ9IG9ic2VydmVyIHRoZSByZXNwb25zZSBvYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsdXNoIGB0cnVlYCBpZiBmbHVzaCBzaG91bGQgaGFwcGVuIGFmdGVyIHRoZSBtZXNzYWdlIGlzIHdyaXR0ZW4gdG8gdGhlIGJ1ZmZlci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlKG1lc3NhZ2UsIG9ic2VydmVyLCBmbHVzaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIFJFU0VULW1lc3NhZ2UgdG8gdGhlIGRhdGFiYXNlLiBNZXNzYWdlIGlzIGltbWVkaWF0ZWx5IGZsdXNoZWQgdG8gdGhlIG5ldHdvcmsuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gcHJvbWlzZSByZXNvbHZlZCB3aGVuIFNVQ0NFU1MtbWVzc2FnZSByZXNwb25zZSBhcnJpdmVzLCBvciBmYWlsZWQgd2hlbiBvdGhlciByZXNwb25zZSBtZXNzYWdlcyBhcnJpdmVzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRBbmRGbHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldEFuZEZsdXNoKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBjbG9zZSBvbiB0aGUgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gLSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLlxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVycm9yXG4gICAgICogQHBhcmFtIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyB7TmVvNGpFcnJvcnwqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQW5kVHJhbnNmb3JtRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQW5kVHJhbnNmb3JtRXJyb3IoZXJyb3IsIGFkZHJlc3MpIHtcbiAgICAgIGlmICh0aGlzLl9lcnJvckhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9ySGFuZGxlci5oYW5kbGVBbmRUcmFuc2Zvcm1FcnJvcihlcnJvciwgYWRkcmVzcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGFiYXNlSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkcmVzc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1NlcnZlclZlcnNpb259IHRoZSB2ZXJzaW9uIG9mIHRoZSBzZXJ2ZXIgdGhpcyBjb25uZWN0aW9uIGlzIGNvbm5lY3RlZCB0b1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmVyc2lvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJ2ZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb25uZWN0aW9uO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENvbm5lY3Rpb247IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfY29ubmVjdGlvbkhvbGRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29ubmVjdGlvbi1ob2xkZXJcIikpO1xuXG52YXIgX2RyaXZlciA9IHJlcXVpcmUoXCIuLi9kcml2ZXJcIik7XG5cbnZhciBfc3RyZWFtT2JzZXJ2ZXJzID0gcmVxdWlyZShcIi4vc3RyZWFtLW9ic2VydmVyc1wiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogVmVyaWZpZXMgY29ubmVjdGl2aXR5IHVzaW5nIHRoZSBnaXZlbiBjb25uZWN0aW9uIHByb3ZpZGVyLlxuICovXG52YXIgQ29ubmVjdGl2aXR5VmVyaWZpZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvblByb3ZpZGVyfSBjb25uZWN0aW9uUHJvdmlkZXIgdGhlIHByb3ZpZGVyIHRvIG9idGFpbiBjb25uZWN0aW9ucyBmcm9tLlxuICAgKi9cbiAgZnVuY3Rpb24gQ29ubmVjdGl2aXR5VmVyaWZpZXIoY29ubmVjdGlvblByb3ZpZGVyKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBDb25uZWN0aXZpdHlWZXJpZmllcik7XG4gICAgdGhpcy5fY29ubmVjdGlvblByb3ZpZGVyID0gY29ubmVjdGlvblByb3ZpZGVyO1xuICB9XG4gIC8qKlxuICAgKiBUcnkgdG8gb2J0YWluIGEgd29ya2luZyBjb25uZWN0aW9uIGZyb20gdGhlIGNvbm5lY3Rpb24gcHJvdmlkZXIuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IHByb21pc2UgcmVzb2x2ZWQgd2l0aCBzZXJ2ZXIgaW5mbyBvciByZWplY3RlZCB3aXRoIGVycm9yLlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQ29ubmVjdGl2aXR5VmVyaWZpZXIsIFt7XG4gICAga2V5OiBcInZlcmlmeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnkoKSB7XG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgX3JlZiRkYXRhYmFzZSA9IF9yZWYuZGF0YWJhc2UsXG4gICAgICAgICAgZGF0YWJhc2UgPSBfcmVmJGRhdGFiYXNlID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkZGF0YWJhc2U7XG5cbiAgICAgIHJldHVybiBhY3F1aXJlQW5kUmVsZWFzZUR1bW15Q29ubmVjdGlvbih0aGlzLl9jb25uZWN0aW9uUHJvdmlkZXIsIGRhdGFiYXNlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbm5lY3Rpdml0eVZlcmlmaWVyO1xufSgpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtDb25uZWN0aW9uUHJvdmlkZXJ9IGNvbm5lY3Rpb25Qcm92aWRlciB0aGUgcHJvdmlkZXIgdG8gb2J0YWluIGNvbm5lY3Rpb25zIGZyb20uXG4gKiBAcmV0dXJuIHtQcm9taXNlPG9iamVjdD59IHByb21pc2UgcmVzb2x2ZWQgd2l0aCBzZXJ2ZXIgaW5mbyBvciByZWplY3RlZCB3aXRoIGVycm9yLlxuICovXG5cblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDb25uZWN0aXZpdHlWZXJpZmllcjtcblxuZnVuY3Rpb24gYWNxdWlyZUFuZFJlbGVhc2VEdW1teUNvbm5lY3Rpb24oY29ubmVjdGlvblByb3ZpZGVyLCBkYXRhYmFzZSkge1xuICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IG5ldyBfY29ubmVjdGlvbkhvbGRlcltcImRlZmF1bHRcIl0oe1xuICAgIG1vZGU6IF9kcml2ZXIuUkVBRCxcbiAgICBkYXRhYmFzZTogZGF0YWJhc2UsXG4gICAgY29ubmVjdGlvblByb3ZpZGVyOiBjb25uZWN0aW9uUHJvdmlkZXJcbiAgfSk7XG4gIGNvbm5lY3Rpb25Ib2xkZXIuaW5pdGlhbGl6ZUNvbm5lY3Rpb24oKTtcbiAgcmV0dXJuIGNvbm5lY3Rpb25Ib2xkZXIuZ2V0Q29ubmVjdGlvbigpLnRoZW4oZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAvLyBhYmxlIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb25cbiAgICByZXR1cm4gY29ubmVjdGlvbkhvbGRlci5jbG9zZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uc2VydmVyO1xuICAgIH0pO1xuICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgIC8vIGZhaWxlZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uXG4gICAgcmV0dXJuIGNvbm5lY3Rpb25Ib2xkZXIuY2xvc2UoKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChpZ25vcmVkRXJyb3IpIHsvLyBpZ25vcmUgY29ubmVjdGlvbiByZWxlYXNlIGVycm9yXG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH0pO1xuICB9KTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQk9MVF9QUk9UT0NPTF9WNF8xID0gZXhwb3J0cy5CT0xUX1BST1RPQ09MX1Y0XzAgPSBleHBvcnRzLkJPTFRfUFJPVE9DT0xfVjMgPSBleHBvcnRzLkJPTFRfUFJPVE9DT0xfVjIgPSBleHBvcnRzLkJPTFRfUFJPVE9DT0xfVjEgPSBleHBvcnRzLkFDQ0VTU19NT0RFX1dSSVRFID0gZXhwb3J0cy5BQ0NFU1NfTU9ERV9SRUFEID0gdm9pZCAwO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBBQ0NFU1NfTU9ERV9SRUFEID0gJ1JFQUQnO1xuZXhwb3J0cy5BQ0NFU1NfTU9ERV9SRUFEID0gQUNDRVNTX01PREVfUkVBRDtcbnZhciBBQ0NFU1NfTU9ERV9XUklURSA9ICdXUklURSc7XG5leHBvcnRzLkFDQ0VTU19NT0RFX1dSSVRFID0gQUNDRVNTX01PREVfV1JJVEU7XG52YXIgQk9MVF9QUk9UT0NPTF9WMSA9IDE7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjEgPSBCT0xUX1BST1RPQ09MX1YxO1xudmFyIEJPTFRfUFJPVE9DT0xfVjIgPSAyO1xuZXhwb3J0cy5CT0xUX1BST1RPQ09MX1YyID0gQk9MVF9QUk9UT0NPTF9WMjtcbnZhciBCT0xUX1BST1RPQ09MX1YzID0gMztcbmV4cG9ydHMuQk9MVF9QUk9UT0NPTF9WMyA9IEJPTFRfUFJPVE9DT0xfVjM7XG52YXIgQk9MVF9QUk9UT0NPTF9WNF8wID0gNC4wO1xuZXhwb3J0cy5CT0xUX1BST1RPQ09MX1Y0XzAgPSBCT0xUX1BST1RPQ09MX1Y0XzA7XG52YXIgQk9MVF9QUk9UT0NPTF9WNF8xID0gNC4xO1xuZXhwb3J0cy5CT0xUX1BST1RPQ09MX1Y0XzEgPSBCT0xUX1BST1RPQ09MX1Y0XzE7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX3JvdW5kUm9iaW5BcnJheUluZGV4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yb3VuZC1yb2Jpbi1hcnJheS1pbmRleFwiKSk7XG5cbnZhciBfbG9hZEJhbGFuY2luZ1N0cmF0ZWd5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2luZy1zdHJhdGVneVwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yW1wiZGVmYXVsdFwiXSkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBMZWFzdENvbm5lY3RlZExvYWRCYWxhbmNpbmdTdHJhdGVneSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvYWRCYWxhbmNpbmdTdHJhdGVnKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoTGVhc3RDb25uZWN0ZWRMb2FkQmFsYW5jaW5nU3RyYXRlZ3ksIF9Mb2FkQmFsYW5jaW5nU3RyYXRlZyk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihMZWFzdENvbm5lY3RlZExvYWRCYWxhbmNpbmdTdHJhdGVneSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1Bvb2x9IGNvbm5lY3Rpb25Qb29sIHRoZSBjb25uZWN0aW9uIHBvb2wgb2YgdGhpcyBkcml2ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBMZWFzdENvbm5lY3RlZExvYWRCYWxhbmNpbmdTdHJhdGVneShjb25uZWN0aW9uUG9vbCkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgTGVhc3RDb25uZWN0ZWRMb2FkQmFsYW5jaW5nU3RyYXRlZ3kpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMuX3JlYWRlcnNJbmRleCA9IG5ldyBfcm91bmRSb2JpbkFycmF5SW5kZXhbXCJkZWZhdWx0XCJdKCk7XG4gICAgX3RoaXMuX3dyaXRlcnNJbmRleCA9IG5ldyBfcm91bmRSb2JpbkFycmF5SW5kZXhbXCJkZWZhdWx0XCJdKCk7XG4gICAgX3RoaXMuX2Nvbm5lY3Rpb25Qb29sID0gY29ubmVjdGlvblBvb2w7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoTGVhc3RDb25uZWN0ZWRMb2FkQmFsYW5jaW5nU3RyYXRlZ3ksIFt7XG4gICAga2V5OiBcInNlbGVjdFJlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RSZWFkZXIoa25vd25SZWFkZXJzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VsZWN0KGtub3duUmVhZGVycywgdGhpcy5fcmVhZGVyc0luZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdFdyaXRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RXcml0ZXIoa25vd25Xcml0ZXJzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VsZWN0KGtub3duV3JpdGVycywgdGhpcy5fd3JpdGVyc0luZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NlbGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VsZWN0KGFkZHJlc3Nlcywgcm91bmRSb2JpbkluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYWRkcmVzc2VzLmxlbmd0aDtcblxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gLy8gY2hvb3NlIHN0YXJ0IGluZGV4IGZvciBpdGVyYXRpb24gaW4gcm91bmQtcm9iaW4gZmFzaGlvblxuXG5cbiAgICAgIHZhciBzdGFydEluZGV4ID0gcm91bmRSb2JpbkluZGV4Lm5leHQobGVuZ3RoKTtcbiAgICAgIHZhciBpbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgICB2YXIgbGVhc3RDb25uZWN0ZWRBZGRyZXNzID0gbnVsbDtcbiAgICAgIHZhciBsZWFzdEFjdGl2ZUNvbm5lY3Rpb25zID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7IC8vIGl0ZXJhdGUgb3ZlciB0aGUgYXJyYXkgdG8gZmluZCBsZWFzdCBjb25uZWN0ZWQgYWRkcmVzc1xuXG4gICAgICBkbyB7XG4gICAgICAgIHZhciBhZGRyZXNzID0gYWRkcmVzc2VzW2luZGV4XTtcblxuICAgICAgICB2YXIgYWN0aXZlQ29ubmVjdGlvbnMgPSB0aGlzLl9jb25uZWN0aW9uUG9vbC5hY3RpdmVSZXNvdXJjZUNvdW50KGFkZHJlc3MpO1xuXG4gICAgICAgIGlmIChhY3RpdmVDb25uZWN0aW9ucyA8IGxlYXN0QWN0aXZlQ29ubmVjdGlvbnMpIHtcbiAgICAgICAgICBsZWFzdENvbm5lY3RlZEFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICAgIGxlYXN0QWN0aXZlQ29ubmVjdGlvbnMgPSBhY3RpdmVDb25uZWN0aW9ucztcbiAgICAgICAgfSAvLyBsb29wIG92ZXIgdG8gdGhlIHN0YXJ0IG9mIHRoZSBhcnJheSB3aGVuIGVuZCBpcyByZWFjaGVkXG5cblxuICAgICAgICBpZiAoaW5kZXggPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoaW5kZXggIT09IHN0YXJ0SW5kZXgpO1xuXG4gICAgICByZXR1cm4gbGVhc3RDb25uZWN0ZWRBZGRyZXNzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTGVhc3RDb25uZWN0ZWRMb2FkQmFsYW5jaW5nU3RyYXRlZ3k7XG59KF9sb2FkQmFsYW5jaW5nU3RyYXRlZ3lbXCJkZWZhdWx0XCJdKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBMZWFzdENvbm5lY3RlZExvYWRCYWxhbmNpbmdTdHJhdGVneTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQSBmYWNpbGl0eSB0byBzZWxlY3QgbW9zdCBhcHByb3ByaWF0ZSByZWFkZXIgb3Igd3JpdGVyIGFtb25nIHRoZSBnaXZlbiBhZGRyZXNzZXMgZm9yIHJlcXVlc3QgcHJvY2Vzc2luZy5cbiAqL1xudmFyIExvYWRCYWxhbmNpbmdTdHJhdGVneSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExvYWRCYWxhbmNpbmdTdHJhdGVneSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIExvYWRCYWxhbmNpbmdTdHJhdGVneSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKExvYWRCYWxhbmNpbmdTdHJhdGVneSwgW3tcbiAgICBrZXk6IFwic2VsZWN0UmVhZGVyXCIsXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgbmV4dCBtb3N0IGFwcHJvcHJpYXRlIHJlYWRlciBmcm9tIHRoZSBsaXN0IG9mIGdpdmVuIHJlYWRlcnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0ga25vd25SZWFkZXJzIGFuIGFycmF5IG9mIGN1cnJlbnRseSBrbm93biByZWFkZXJzIHRvIHNlbGVjdCBmcm9tLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gbW9zdCBhcHByb3ByaWF0ZSByZWFkZXIgb3IgYG51bGxgIGlmIGdpdmVuIGFycmF5IGlzIGVtcHR5LlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RSZWFkZXIoa25vd25SZWFkZXJzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fic3RyYWN0IGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBuZXh0IG1vc3QgYXBwcm9wcmlhdGUgd3JpdGVyIGZyb20gdGhlIGxpc3Qgb2YgZ2l2ZW4gd3JpdGVycy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBrbm93bldyaXRlcnMgYW4gYXJyYXkgb2YgY3VycmVudGx5IGtub3duIHdyaXRlcnMgdG8gc2VsZWN0IGZyb20uXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBtb3N0IGFwcHJvcHJpYXRlIHdyaXRlciBvciBgbnVsbGAgaWYgZ2l2ZW4gYXJyYXkgaXMgZW1wdHkuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RXcml0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0V3JpdGVyKGtub3duV3JpdGVycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBYnN0cmFjdCBmdW5jdGlvbicpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTG9hZEJhbGFuY2luZ1N0cmF0ZWd5O1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IExvYWRCYWxhbmNpbmdTdHJhdGVneTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG5cbnZhciBfbGV2ZWxzO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgRVJST1IgPSAnZXJyb3InO1xudmFyIFdBUk4gPSAnd2Fybic7XG52YXIgSU5GTyA9ICdpbmZvJztcbnZhciBERUJVRyA9ICdkZWJ1Zyc7XG52YXIgREVGQVVMVF9MRVZFTCA9IElORk87XG52YXIgbGV2ZWxzID0gKF9sZXZlbHMgPSB7fSwgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKShfbGV2ZWxzLCBFUlJPUiwgMCksICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkoX2xldmVscywgV0FSTiwgMSksICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkoX2xldmVscywgSU5GTywgMiksICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkoX2xldmVscywgREVCVUcsIDMpLCBfbGV2ZWxzKTtcbi8qKlxuICogTG9nZ2VyIHVzZWQgYnkgdGhlIGRyaXZlciB0byBub3RpZnkgYWJvdXQgdmFyaW91cyBpbnRlcm5hbCBldmVudHMuIFNpbmdsZSBsb2dnZXIgc2hvdWxkIGJlIHVzZWQgcGVyIGRyaXZlci5cbiAqL1xuXG52YXIgTG9nZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGV2ZWwgdGhlIGVuYWJsZWQgbG9nZ2luZyBsZXZlbC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihsZXZlbDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpfSBsb2dnZXJGdW5jdGlvbiB0aGUgZnVuY3Rpb24gdG8gd3JpdGUgdGhlIGxvZyBsZXZlbCBhbmQgbWVzc2FnZS5cbiAgICovXG4gIGZ1bmN0aW9uIExvZ2dlcihsZXZlbCwgbG9nZ2VyRnVuY3Rpb24pIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIExvZ2dlcik7XG4gICAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLl9sb2dnZXJGdW5jdGlvbiA9IGxvZ2dlckZ1bmN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgbG9nZ2VyIGJhc2VkIG9uIHRoZSBnaXZlbiBkcml2ZXIgY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRyaXZlckNvbmZpZyB0aGUgZHJpdmVyIGNvbmZpZ3VyYXRpb24gYXMgc3VwcGxpZWQgYnkgdGhlIHVzZXIuXG4gICAqIEByZXR1cm4ge0xvZ2dlcn0gYSBuZXcgbG9nZ2VyIGluc3RhbmNlIG9yIGEgbm8tb3AgbG9nZ2VyIHdoZW4gbm90IGNvbmZpZ3VyZWQuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShMb2dnZXIsIFt7XG4gICAga2V5OiBcImlzRXJyb3JFbmFibGVkXCIsXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBlcnJvciBsb2dnaW5nIGlzIGVuYWJsZWQsIGkuZS4gaXQgaXMgbm90IGEgbm8tb3AgaW1wbGVtZW50YXRpb24uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIHdoZW4gZW5hYmxlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRXJyb3JFbmFibGVkKCkge1xuICAgICAgcmV0dXJuIGlzTGV2ZWxFbmFibGVkKHRoaXMuX2xldmVsLCBFUlJPUik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBhbiBlcnJvciBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIGxvZy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0aGlzLmlzRXJyb3JFbmFibGVkKCkpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyRnVuY3Rpb24oRVJST1IsIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB3YXJuIGxvZ2dpbmcgaXMgZW5hYmxlZCwgaS5lLiBpdCBpcyBub3QgYSBuby1vcCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgd2hlbiBlbmFibGVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzV2FybkVuYWJsZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNXYXJuRW5hYmxlZCgpIHtcbiAgICAgIHJldHVybiBpc0xldmVsRW5hYmxlZCh0aGlzLl9sZXZlbCwgV0FSTik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBhbiB3YXJuaW5nIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gbG9nLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2FyblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3YXJuKG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0aGlzLmlzV2FybkVuYWJsZWQoKSkge1xuICAgICAgICB0aGlzLl9sb2dnZXJGdW5jdGlvbihXQVJOLCBtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgaW5mbyBsb2dnaW5nIGlzIGVuYWJsZWQsIGkuZS4gaXQgaXMgbm90IGEgbm8tb3AgaW1wbGVtZW50YXRpb24uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIHdoZW4gZW5hYmxlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0luZm9FbmFibGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzSW5mb0VuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gaXNMZXZlbEVuYWJsZWQodGhpcy5fbGV2ZWwsIElORk8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgYW4gaW5mbyBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIGxvZy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5mbyhtZXNzYWdlKSB7XG4gICAgICBpZiAodGhpcy5pc0luZm9FbmFibGVkKCkpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyRnVuY3Rpb24oSU5GTywgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGRlYnVnIGxvZ2dpbmcgaXMgZW5hYmxlZCwgaS5lLiBpdCBpcyBub3QgYSBuby1vcCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgd2hlbiBlbmFibGVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzRGVidWdFbmFibGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGVidWdFbmFibGVkKCkge1xuICAgICAgcmV0dXJuIGlzTGV2ZWxFbmFibGVkKHRoaXMuX2xldmVsLCBERUJVRyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBhIGRlYnVnIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gbG9nLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVidWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVidWcobWVzc2FnZSkge1xuICAgICAgaWYgKHRoaXMuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICB0aGlzLl9sb2dnZXJGdW5jdGlvbihERUJVRywgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShkcml2ZXJDb25maWcpIHtcbiAgICAgIGlmIChkcml2ZXJDb25maWcgJiYgZHJpdmVyQ29uZmlnLmxvZ2dpbmcpIHtcbiAgICAgICAgdmFyIGxvZ2dpbmdDb25maWcgPSBkcml2ZXJDb25maWcubG9nZ2luZztcbiAgICAgICAgdmFyIGxldmVsID0gZXh0cmFjdENvbmZpZ3VyZWRMZXZlbChsb2dnaW5nQ29uZmlnKTtcbiAgICAgICAgdmFyIGxvZ2dlckZ1bmN0aW9uID0gZXh0cmFjdENvbmZpZ3VyZWRMb2dnZXIobG9nZ2luZ0NvbmZpZyk7XG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyKGxldmVsLCBsb2dnZXJGdW5jdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm5vT3AoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbm8tb3AgbG9nZ2VyIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge0xvZ2dlcn0gdGhlIG5vLW9wIGxvZ2dlciBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5vT3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9PcCgpIHtcbiAgICAgIHJldHVybiBub09wTG9nZ2VyO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTG9nZ2VyO1xufSgpO1xuXG52YXIgTm9PcExvZ2dlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvZ2dlcikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKE5vT3BMb2dnZXIsIF9Mb2dnZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTm9PcExvZ2dlcik7XG5cbiAgZnVuY3Rpb24gTm9PcExvZ2dlcigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIE5vT3BMb2dnZXIpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoTm9PcExvZ2dlciwgW3tcbiAgICBrZXk6IFwiaXNFcnJvckVuYWJsZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFcnJvckVuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNXYXJuRW5hYmxlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1dhcm5FbmFibGVkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3YXJuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdhcm4obWVzc2FnZSkge31cbiAgfSwge1xuICAgIGtleTogXCJpc0luZm9FbmFibGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzSW5mb0VuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5mbyhtZXNzYWdlKSB7fVxuICB9LCB7XG4gICAga2V5OiBcImlzRGVidWdFbmFibGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGVidWdFbmFibGVkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWJ1Z1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWJ1ZyhtZXNzYWdlKSB7fVxuICB9XSk7XG4gIHJldHVybiBOb09wTG9nZ2VyO1xufShMb2dnZXIpO1xuXG52YXIgbm9PcExvZ2dlciA9IG5ldyBOb09wTG9nZ2VyKCk7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBsb2dnaW5nIGxldmVsIGlzIGVuYWJsZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlndXJlZExldmVsIHRoZSBjb25maWd1cmVkIGxldmVsLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldExldmVsIHRoZSBsZXZlbCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHZhbHVlIG9mIGB0cnVlYCB3aGVuIGVuYWJsZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzTGV2ZWxFbmFibGVkKGNvbmZpZ3VyZWRMZXZlbCwgdGFyZ2V0TGV2ZWwpIHtcbiAgcmV0dXJuIGxldmVsc1tjb25maWd1cmVkTGV2ZWxdID49IGxldmVsc1t0YXJnZXRMZXZlbF07XG59XG4vKipcbiAqIEV4dHJhY3QgdGhlIGNvbmZpZ3VyZWQgbG9nZ2luZyBsZXZlbCBmcm9tIHRoZSBkcml2ZXIncyBsb2dnaW5nIGNvbmZpZ3VyYXRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gbG9nZ2luZ0NvbmZpZyB0aGUgbG9nZ2luZyBjb25maWd1cmF0aW9uLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgY29uZmlndXJlZCBsb2cgbGV2ZWwgb3IgZGVmYXVsdCB3aGVuIG5vbmUgY29uZmlndXJlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dHJhY3RDb25maWd1cmVkTGV2ZWwobG9nZ2luZ0NvbmZpZykge1xuICBpZiAobG9nZ2luZ0NvbmZpZyAmJiBsb2dnaW5nQ29uZmlnLmxldmVsKSB7XG4gICAgdmFyIGNvbmZpZ3VyZWRMZXZlbCA9IGxvZ2dpbmdDb25maWcubGV2ZWw7XG4gICAgdmFyIHZhbHVlID0gbGV2ZWxzW2NvbmZpZ3VyZWRMZXZlbF07XG5cbiAgICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSB7XG4gICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKShcIklsbGVnYWwgbG9nZ2luZyBsZXZlbDogXCIuY29uY2F0KGNvbmZpZ3VyZWRMZXZlbCwgXCIuIFN1cHBvcnRlZCBsZXZlbHMgYXJlOiBcIikuY29uY2F0KE9iamVjdC5rZXlzKGxldmVscykpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlndXJlZExldmVsO1xuICB9XG5cbiAgcmV0dXJuIERFRkFVTFRfTEVWRUw7XG59XG4vKipcbiAqIEV4dHJhY3QgdGhlIGNvbmZpZ3VyZWQgbG9nZ2VyIGZ1bmN0aW9uIGZyb20gdGhlIGRyaXZlcidzIGxvZ2dpbmcgY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2dnaW5nQ29uZmlnIHRoZSBsb2dnaW5nIGNvbmZpZ3VyYXRpb24uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihsZXZlbDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpfSB0aGUgY29uZmlndXJlZCBsb2dnaW5nIGZ1bmN0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gZXh0cmFjdENvbmZpZ3VyZWRMb2dnZXIobG9nZ2luZ0NvbmZpZykge1xuICBpZiAobG9nZ2luZ0NvbmZpZyAmJiBsb2dnaW5nQ29uZmlnLmxvZ2dlcikge1xuICAgIHZhciBjb25maWd1cmVkTG9nZ2VyID0gbG9nZ2luZ0NvbmZpZy5sb2dnZXI7XG5cbiAgICBpZiAoY29uZmlndXJlZExvZ2dlciAmJiB0eXBlb2YgY29uZmlndXJlZExvZ2dlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyZWRMb2dnZXI7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoXCJJbGxlZ2FsIGxvZ2dlciBmdW5jdGlvbjogXCIuY29uY2F0KGxvZ2dpbmdDb25maWcubG9nZ2VyKSk7XG59XG5cbnZhciBfZGVmYXVsdCA9IExvZ2dlcjtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5TdHJ1Y3R1cmUgPSBleHBvcnRzLlVucGFja2VyID0gZXhwb3J0cy5QYWNrZXIgPSB2b2lkIDA7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9ub2RlID0gcmVxdWlyZShcIi4vbm9kZVwiKTtcblxudmFyIF9pbnRlZ2VyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4uL2ludGVnZXJcIikpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xuXG52YXIgX2dyYXBoVHlwZXMgPSByZXF1aXJlKFwiLi4vZ3JhcGgtdHlwZXNcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIFRJTllfU1RSSU5HID0gMHg4MDtcbnZhciBUSU5ZX0xJU1QgPSAweDkwO1xudmFyIFRJTllfTUFQID0gMHhhMDtcbnZhciBUSU5ZX1NUUlVDVCA9IDB4YjA7XG52YXIgTlVMTCA9IDB4YzA7XG52YXIgRkxPQVRfNjQgPSAweGMxO1xudmFyIEZBTFNFID0gMHhjMjtcbnZhciBUUlVFID0gMHhjMztcbnZhciBJTlRfOCA9IDB4Yzg7XG52YXIgSU5UXzE2ID0gMHhjOTtcbnZhciBJTlRfMzIgPSAweGNhO1xudmFyIElOVF82NCA9IDB4Y2I7XG52YXIgU1RSSU5HXzggPSAweGQwO1xudmFyIFNUUklOR18xNiA9IDB4ZDE7XG52YXIgU1RSSU5HXzMyID0gMHhkMjtcbnZhciBMSVNUXzggPSAweGQ0O1xudmFyIExJU1RfMTYgPSAweGQ1O1xudmFyIExJU1RfMzIgPSAweGQ2O1xudmFyIEJZVEVTXzggPSAweGNjO1xudmFyIEJZVEVTXzE2ID0gMHhjZDtcbnZhciBCWVRFU18zMiA9IDB4Y2U7XG52YXIgTUFQXzggPSAweGQ4O1xudmFyIE1BUF8xNiA9IDB4ZDk7XG52YXIgTUFQXzMyID0gMHhkYTtcbnZhciBTVFJVQ1RfOCA9IDB4ZGM7XG52YXIgU1RSVUNUXzE2ID0gMHhkZDtcbnZhciBOT0RFID0gMHg0ZTtcbnZhciBOT0RFX1NUUlVDVF9TSVpFID0gMztcbnZhciBSRUxBVElPTlNISVAgPSAweDUyO1xudmFyIFJFTEFUSU9OU0hJUF9TVFJVQ1RfU0laRSA9IDU7XG52YXIgVU5CT1VORF9SRUxBVElPTlNISVAgPSAweDcyO1xudmFyIFVOQk9VTkRfUkVMQVRJT05TSElQX1NUUlVDVF9TSVpFID0gMztcbnZhciBQQVRIID0gMHg1MDtcbnZhciBQQVRIX1NUUlVDVF9TSVpFID0gMztcbi8qKlxuICogQSBTdHJ1Y3R1cmUgaGF2ZSBhIHNpZ25hdHVyZSBhbmQgZmllbGRzLlxuICogQGFjY2VzcyBwcml2YXRlXG4gKi9cblxudmFyIFN0cnVjdHVyZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgbmV3IGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBTdHJ1Y3R1cmUoc2lnbmF0dXJlLCBmaWVsZHMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFN0cnVjdHVyZSk7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFN0cnVjdHVyZSwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgZmllbGRTdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBmaWVsZFN0ciArPSAnLCAnO1xuICAgICAgICB9XG5cbiAgICAgICAgZmllbGRTdHIgKz0gdGhpcy5maWVsZHNbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnU3RydWN0dXJlKCcgKyB0aGlzLnNpZ25hdHVyZSArICcsIFsnICsgZmllbGRTdHIgKyAnXSknO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3RydWN0dXJlO1xufSgpO1xuLyoqXG4gKiBDbGFzcyB0byBwYWNrXG4gKiBAYWNjZXNzIHByaXZhdGVcbiAqL1xuXG5cbmV4cG9ydHMuU3RydWN0dXJlID0gU3RydWN0dXJlO1xuXG52YXIgUGFja2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0NodW5rZXJ9IGNoYW5uZWwgdGhlIGNodW5rZXIgYmFja2VkIGJ5IGEgbmV0d29yayBjaGFubmVsLlxuICAgKi9cbiAgZnVuY3Rpb24gUGFja2VyKGNoYW5uZWwpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFBhY2tlcik7XG4gICAgdGhpcy5fY2ggPSBjaGFubmVsO1xuICAgIHRoaXMuX2J5dGVBcnJheXNTdXBwb3J0ZWQgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcGFja2FibGUgZnVuY3Rpb24gb3V0IG9mIHRoZSBwcm92aWRlZCB2YWx1ZVxuICAgKiBAcGFyYW0geCB0aGUgdmFsdWUgdG8gcGFja1xuICAgKiBAcmV0dXJucyBGdW5jdGlvblxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUGFja2VyLCBbe1xuICAgIGtleTogXCJwYWNrYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWNrYWJsZSh4KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoeCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fY2gud3JpdGVVSW50OChOVUxMKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoeCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fY2gud3JpdGVVSW50OChUUlVFKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoeCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX2NoLndyaXRlVUludDgoRkFMU0UpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMucGFja0Zsb2F0KHgpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMucGFja1N0cmluZyh4KTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF9pbnRlZ2VyLmlzSW50KSh4KSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5wYWNrSW50ZWdlcih4KTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIEludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5wYWNrQnl0ZXMoeCk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnBhY2tMaXN0SGVhZGVyKHgubGVuZ3RoKTtcblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB4Lmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgX3RoaXMucGFja2FibGUoeFtfaV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiB4W19pXSkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlzSXRlcmFibGUoeCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFja2FibGVJdGVyYWJsZSh4KTtcbiAgICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIF9ncmFwaFR5cGVzLk5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vblBhY2thYmxlVmFsdWUoXCJJdCBpcyBub3QgYWxsb3dlZCB0byBwYXNzIG5vZGVzIGluIHF1ZXJ5IHBhcmFtZXRlcnMsIGdpdmVuOiBcIi5jb25jYXQoeCkpO1xuICAgICAgfSBlbHNlIGlmICh4IGluc3RhbmNlb2YgX2dyYXBoVHlwZXMuUmVsYXRpb25zaGlwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub25QYWNrYWJsZVZhbHVlKFwiSXQgaXMgbm90IGFsbG93ZWQgdG8gcGFzcyByZWxhdGlvbnNoaXBzIGluIHF1ZXJ5IHBhcmFtZXRlcnMsIGdpdmVuOiBcIi5jb25jYXQoeCkpO1xuICAgICAgfSBlbHNlIGlmICh4IGluc3RhbmNlb2YgX2dyYXBoVHlwZXMuUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9uUGFja2FibGVWYWx1ZShcIkl0IGlzIG5vdCBhbGxvd2VkIHRvIHBhc3MgcGF0aHMgaW4gcXVlcnkgcGFyYW1ldGVycywgZ2l2ZW46IFwiLmNvbmNhdCh4KSk7XG4gICAgICB9IGVsc2UgaWYgKHggaW5zdGFuY2VvZiBTdHJ1Y3R1cmUpIHtcbiAgICAgICAgdmFyIHBhY2thYmxlRmllbGRzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4LmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBhY2thYmxlRmllbGRzW2ldID0gdGhpcy5wYWNrYWJsZSh4LmZpZWxkc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5wYWNrU3RydWN0KHguc2lnbmF0dXJlLCBwYWNrYWJsZUZpZWxkcyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCgwLCBfdHlwZW9mMltcImRlZmF1bHRcIl0pKHgpID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoeCk7XG4gICAgICAgICAgdmFyIGNvdW50ID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGtleXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgaWYgKHhba2V5c1tfaTJdXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMucGFja01hcEhlYWRlcihjb3VudCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBrZXlzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW19pM107XG5cbiAgICAgICAgICAgIGlmICh4W2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBfdGhpcy5wYWNrU3RyaW5nKGtleSk7XG5cbiAgICAgICAgICAgICAgX3RoaXMucGFja2FibGUoeFtrZXldKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub25QYWNrYWJsZVZhbHVlKFwiVW5hYmxlIHRvIHBhY2sgdGhlIGdpdmVuIHZhbHVlOiBcIi5jb25jYXQoeCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWNrYWJsZUl0ZXJhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhY2thYmxlSXRlcmFibGUoaXRlcmFibGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBhcnJheSA9IEFycmF5LmZyb20oaXRlcmFibGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYWNrYWJsZShhcnJheSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGhhbmRsZSBlcnJvcnMgZnJvbSBpdGVyYWJsZSB0byBhcnJheSBjb252ZXJzaW9uXG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKFwiQ2Fubm90IHBhY2sgZ2l2ZW4gaXRlcmFibGUsIFwiLmNvbmNhdChlLm1lc3NhZ2UsIFwiOiBcIikuY29uY2F0KGl0ZXJhYmxlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhY2tzIGEgc3RydWN0XG4gICAgICogQHBhcmFtIHNpZ25hdHVyZSB0aGUgc2lnbmF0dXJlIG9mIHRoZSBzdHJ1Y3RcbiAgICAgKiBAcGFyYW0gcGFja2FibGVGaWVsZHMgdGhlIGZpZWxkcyBvZiB0aGUgc3RydWN0LCBtYWtlIHN1cmUgeW91IGNhbGwgYHBhY2thYmxlIG9uIGFsbCBmaWVsZHNgXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYWNrU3RydWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhY2tTdHJ1Y3Qoc2lnbmF0dXJlLCBwYWNrYWJsZUZpZWxkcykge1xuICAgICAgcGFja2FibGVGaWVsZHMgPSBwYWNrYWJsZUZpZWxkcyB8fCBbXTtcbiAgICAgIHRoaXMucGFja1N0cnVjdEhlYWRlcihwYWNrYWJsZUZpZWxkcy5sZW5ndGgsIHNpZ25hdHVyZSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFja2FibGVGaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFja2FibGVGaWVsZHNbaV0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFja0ludGVnZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFja0ludGVnZXIoeCkge1xuICAgICAgdmFyIGhpZ2ggPSB4LmhpZ2g7XG4gICAgICB2YXIgbG93ID0geC5sb3c7XG5cbiAgICAgIGlmICh4LmdyZWF0ZXJUaGFuT3JFcXVhbCgtMHgxMCkgJiYgeC5sZXNzVGhhbigweDgwKSkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZUludDgobG93KTtcbiAgICAgIH0gZWxzZSBpZiAoeC5ncmVhdGVyVGhhbk9yRXF1YWwoLTB4ODApICYmIHgubGVzc1RoYW4oLTB4MTApKSB7XG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoSU5UXzgpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlSW50OChsb3cpO1xuICAgICAgfSBlbHNlIGlmICh4LmdyZWF0ZXJUaGFuT3JFcXVhbCgtMHg4MDAwKSAmJiB4Lmxlc3NUaGFuKDB4ODAwMCkpIHtcbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChJTlRfMTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlSW50MTYobG93KTtcbiAgICAgIH0gZWxzZSBpZiAoeC5ncmVhdGVyVGhhbk9yRXF1YWwoLTB4ODAwMDAwMDApICYmIHgubGVzc1RoYW4oMHg4MDAwMDAwMCkpIHtcbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChJTlRfMzIpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlSW50MzIobG93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoSU5UXzY0KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZUludDMyKGhpZ2gpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlSW50MzIobG93KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFja0Zsb2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhY2tGbG9hdCh4KSB7XG4gICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KEZMT0FUXzY0KTtcblxuICAgICAgdGhpcy5fY2gud3JpdGVGbG9hdDY0KHgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWNrU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhY2tTdHJpbmcoeCkge1xuICAgICAgdmFyIGJ5dGVzID0gX25vZGUudXRmOC5lbmNvZGUoeCk7XG5cbiAgICAgIHZhciBzaXplID0gYnl0ZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoc2l6ZSA8IDB4MTApIHtcbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChUSU5ZX1NUUklORyB8IHNpemUpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlQnl0ZXMoYnl0ZXMpO1xuICAgICAgfSBlbHNlIGlmIChzaXplIDwgMHgxMDApIHtcbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChTVFJJTkdfOCk7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChzaXplKTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZUJ5dGVzKGJ5dGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDB4MTAwMDApIHtcbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChTVFJJTkdfMTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoc2l6ZSAvIDI1NiA+PiAwKTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KHNpemUgJSAyNTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlQnl0ZXMoYnl0ZXMpO1xuICAgICAgfSBlbHNlIGlmIChzaXplIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChTVFJJTkdfMzIpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoKHNpemUgLyAxNjc3NzIxNiA+PiAwKSAlIDI1Nik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OCgoc2l6ZSAvIDY1NTM2ID4+IDApICUgMjU2KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KChzaXplIC8gMjU2ID4+IDApICUgMjU2KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KHNpemUgJSAyNTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlQnl0ZXMoYnl0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ1VURi04IHN0cmluZ3Mgb2Ygc2l6ZSAnICsgc2l6ZSArICcgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFja0xpc3RIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFja0xpc3RIZWFkZXIoc2l6ZSkge1xuICAgICAgaWYgKHNpemUgPCAweDEwKSB7XG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoVElOWV9MSVNUIHwgc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KExJU1RfOCk7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChzaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDB4MTAwMDApIHtcbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChMSVNUXzE2KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KChzaXplIC8gMjU2ID4+IDApICUgMjU2KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KHNpemUgJSAyNTYpO1xuICAgICAgfSBlbHNlIGlmIChzaXplIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChMSVNUXzMyKTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KChzaXplIC8gMTY3NzcyMTYgPj4gMCkgJSAyNTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoKHNpemUgLyA2NTUzNiA+PiAwKSAlIDI1Nik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OCgoc2l6ZSAvIDI1NiA+PiAwKSAlIDI1Nik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChzaXplICUgMjU2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdMaXN0cyBvZiBzaXplICcgKyBzaXplICsgJyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWNrQnl0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFja0J5dGVzKGFycmF5KSB7XG4gICAgICBpZiAodGhpcy5fYnl0ZUFycmF5c1N1cHBvcnRlZCkge1xuICAgICAgICB0aGlzLnBhY2tCeXRlc0hlYWRlcihhcnJheS5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9jaC53cml0ZUludDgoYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnQnl0ZSBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGRhdGFiYXNlIHRoaXMgZHJpdmVyIGlzIGNvbm5lY3RlZCB0bycpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWNrQnl0ZXNIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFja0J5dGVzSGVhZGVyKHNpemUpIHtcbiAgICAgIGlmIChzaXplIDwgMHgxMDApIHtcbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChCWVRFU184KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KHNpemUpO1xuICAgICAgfSBlbHNlIGlmIChzaXplIDwgMHgxMDAwMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KEJZVEVTXzE2KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KChzaXplIC8gMjU2ID4+IDApICUgMjU2KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KHNpemUgJSAyNTYpO1xuICAgICAgfSBlbHNlIGlmIChzaXplIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChCWVRFU18zMik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OCgoc2l6ZSAvIDE2Nzc3MjE2ID4+IDApICUgMjU2KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KChzaXplIC8gNjU1MzYgPj4gMCkgJSAyNTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoKHNpemUgLyAyNTYgPj4gMCkgJSAyNTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoc2l6ZSAlIDI1Nik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnQnl0ZSBhcnJheXMgb2Ygc2l6ZSAnICsgc2l6ZSArICcgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFja01hcEhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWNrTWFwSGVhZGVyKHNpemUpIHtcbiAgICAgIGlmIChzaXplIDwgMHgxMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KFRJTllfTUFQIHwgc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KE1BUF84KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KHNpemUpO1xuICAgICAgfSBlbHNlIGlmIChzaXplIDwgMHgxMDAwMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KE1BUF8xNik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChzaXplIC8gMjU2ID4+IDApO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoc2l6ZSAlIDI1Nik7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KE1BUF8zMik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OCgoc2l6ZSAvIDE2Nzc3MjE2ID4+IDApICUgMjU2KTtcblxuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KChzaXplIC8gNjU1MzYgPj4gMCkgJSAyNTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoKHNpemUgLyAyNTYgPj4gMCkgJSAyNTYpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoc2l6ZSAlIDI1Nik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnTWFwcyBvZiBzaXplICcgKyBzaXplICsgJyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWNrU3RydWN0SGVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhY2tTdHJ1Y3RIZWFkZXIoc2l6ZSwgc2lnbmF0dXJlKSB7XG4gICAgICBpZiAoc2l6ZSA8IDB4MTApIHtcbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChUSU5ZX1NUUlVDVCB8IHNpemUpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoc2lnbmF0dXJlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDB4MTAwKSB7XG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoU1RSVUNUXzgpO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoc2l6ZSk7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChzaWduYXR1cmUpO1xuICAgICAgfSBlbHNlIGlmIChzaXplIDwgMHgxMDAwMCkge1xuICAgICAgICB0aGlzLl9jaC53cml0ZVVJbnQ4KFNUUlVDVF8xNik7XG5cbiAgICAgICAgdGhpcy5fY2gud3JpdGVVSW50OChzaXplIC8gMjU2ID4+IDApO1xuXG4gICAgICAgIHRoaXMuX2NoLndyaXRlVUludDgoc2l6ZSAlIDI1Nik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnU3RydWN0dXJlcyBvZiBzaXplICcgKyBzaXplICsgJyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlQnl0ZUFycmF5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlQnl0ZUFycmF5cygpIHtcbiAgICAgIHRoaXMuX2J5dGVBcnJheXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX25vblBhY2thYmxlVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25vblBhY2thYmxlVmFsdWUobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikobWVzc2FnZSwgX2Vycm9yLlBST1RPQ09MX0VSUk9SKTtcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQYWNrZXI7XG59KCk7XG4vKipcbiAqIENsYXNzIHRvIHVucGFja1xuICogQGFjY2VzcyBwcml2YXRlXG4gKi9cblxuXG5leHBvcnRzLlBhY2tlciA9IFBhY2tlcjtcblxudmFyIFVucGFja2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVMb3NzbGVzc0ludGVnZXJzIGlmIHRoaXMgdW5wYWNrZXIgc2hvdWxkIGNvbnZlcnQgYWxsIHJlY2VpdmVkIGludGVnZXJzIHRvIG5hdGl2ZSBKUyBudW1iZXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gVW5wYWNrZXIoKSB7XG4gICAgdmFyIGRpc2FibGVMb3NzbGVzc0ludGVnZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFVucGFja2VyKTtcbiAgICB0aGlzLl9kaXNhYmxlTG9zc2xlc3NJbnRlZ2VycyA9IGRpc2FibGVMb3NzbGVzc0ludGVnZXJzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShVbnBhY2tlciwgW3tcbiAgICBrZXk6IFwidW5wYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucGFjayhidWZmZXIpIHtcbiAgICAgIHZhciBtYXJrZXIgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG4gICAgICB2YXIgbWFya2VySGlnaCA9IG1hcmtlciAmIDB4ZjA7XG4gICAgICB2YXIgbWFya2VyTG93ID0gbWFya2VyICYgMHgwZjtcblxuICAgICAgaWYgKG1hcmtlciA9PT0gTlVMTCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9ib29sZWFuID0gdGhpcy5fdW5wYWNrQm9vbGVhbihtYXJrZXIpO1xuXG4gICAgICBpZiAoX2Jvb2xlYW4gIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIF9ib29sZWFuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbnVtYmVyT3JJbnRlZ2VyID0gdGhpcy5fdW5wYWNrTnVtYmVyT3JJbnRlZ2VyKG1hcmtlciwgYnVmZmVyKTtcblxuICAgICAgaWYgKG51bWJlck9ySW50ZWdlciAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5fZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMgJiYgKDAsIF9pbnRlZ2VyLmlzSW50KShudW1iZXJPckludGVnZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bWJlck9ySW50ZWdlci50b051bWJlck9ySW5maW5pdHkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW1iZXJPckludGVnZXI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHJpbmcgPSB0aGlzLl91bnBhY2tTdHJpbmcobWFya2VyLCBtYXJrZXJIaWdoLCBtYXJrZXJMb3csIGJ1ZmZlcik7XG5cbiAgICAgIGlmIChzdHJpbmcgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cblxuICAgICAgdmFyIGxpc3QgPSB0aGlzLl91bnBhY2tMaXN0KG1hcmtlciwgbWFya2VySGlnaCwgbWFya2VyTG93LCBidWZmZXIpO1xuXG4gICAgICBpZiAobGlzdCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ5dGVBcnJheSA9IHRoaXMuX3VucGFja0J5dGVBcnJheShtYXJrZXIsIGJ1ZmZlcik7XG5cbiAgICAgIGlmIChieXRlQXJyYXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVBcnJheTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hcCA9IHRoaXMuX3VucGFja01hcChtYXJrZXIsIG1hcmtlckhpZ2gsIG1hcmtlckxvdywgYnVmZmVyKTtcblxuICAgICAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RydWN0ID0gdGhpcy5fdW5wYWNrU3RydWN0KG1hcmtlciwgbWFya2VySGlnaCwgbWFya2VyTG93LCBidWZmZXIpO1xuXG4gICAgICBpZiAoc3RydWN0ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdHJ1Y3Q7XG4gICAgICB9XG5cbiAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdVbmtub3duIHBhY2tlZCB2YWx1ZSB3aXRoIG1hcmtlciAnICsgbWFya2VyLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVucGFja0ludGVnZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5wYWNrSW50ZWdlcihidWZmZXIpIHtcbiAgICAgIHZhciBtYXJrZXIgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLl91bnBhY2tJbnRlZ2VyKG1hcmtlciwgYnVmZmVyKTtcblxuICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdVbmFibGUgdG8gdW5wYWNrIGludGVnZXIgdmFsdWUgd2l0aCBtYXJrZXIgJyArIG1hcmtlci50b1N0cmluZygxNikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdW5wYWNrQm9vbGVhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wYWNrQm9vbGVhbihtYXJrZXIpIHtcbiAgICAgIGlmIChtYXJrZXIgPT09IFRSVUUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlciA9PT0gRkFMU0UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bnBhY2tOdW1iZXJPckludGVnZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VucGFja051bWJlck9ySW50ZWdlcihtYXJrZXIsIGJ1ZmZlcikge1xuICAgICAgaWYgKG1hcmtlciA9PT0gRkxPQVRfNjQpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkRmxvYXQ2NCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucGFja0ludGVnZXIobWFya2VyLCBidWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdW5wYWNrSW50ZWdlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wYWNrSW50ZWdlcihtYXJrZXIsIGJ1ZmZlcikge1xuICAgICAgaWYgKG1hcmtlciA+PSAwICYmIG1hcmtlciA8IDEyOCkge1xuICAgICAgICByZXR1cm4gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShtYXJrZXIpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIgPj0gMjQwICYmIG1hcmtlciA8IDI1Nikge1xuICAgICAgICByZXR1cm4gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShtYXJrZXIgLSAyNTYpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIgPT09IElOVF84KSB7XG4gICAgICAgIHJldHVybiAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKGJ1ZmZlci5yZWFkSW50OCgpKTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyID09PSBJTlRfMTYpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfaW50ZWdlcltcImludFwiXSkoYnVmZmVyLnJlYWRJbnQxNigpKTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyID09PSBJTlRfMzIpIHtcbiAgICAgICAgdmFyIGIgPSBidWZmZXIucmVhZEludDMyKCk7XG4gICAgICAgIHJldHVybiAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKGIpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIgPT09IElOVF82NCkge1xuICAgICAgICB2YXIgaGlnaCA9IGJ1ZmZlci5yZWFkSW50MzIoKTtcbiAgICAgICAgdmFyIGxvdyA9IGJ1ZmZlci5yZWFkSW50MzIoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBfaW50ZWdlcltcImRlZmF1bHRcIl0obG93LCBoaWdoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdW5wYWNrU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnBhY2tTdHJpbmcobWFya2VyLCBtYXJrZXJIaWdoLCBtYXJrZXJMb3csIGJ1ZmZlcikge1xuICAgICAgaWYgKG1hcmtlckhpZ2ggPT09IFRJTllfU1RSSU5HKSB7XG4gICAgICAgIHJldHVybiBfbm9kZS51dGY4LmRlY29kZShidWZmZXIsIG1hcmtlckxvdyk7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlciA9PT0gU1RSSU5HXzgpIHtcbiAgICAgICAgcmV0dXJuIF9ub2RlLnV0ZjguZGVjb2RlKGJ1ZmZlciwgYnVmZmVyLnJlYWRVSW50OCgpKTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyID09PSBTVFJJTkdfMTYpIHtcbiAgICAgICAgcmV0dXJuIF9ub2RlLnV0ZjguZGVjb2RlKGJ1ZmZlciwgYnVmZmVyLnJlYWRVSW50MTYoKSk7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlciA9PT0gU1RSSU5HXzMyKSB7XG4gICAgICAgIHJldHVybiBfbm9kZS51dGY4LmRlY29kZShidWZmZXIsIGJ1ZmZlci5yZWFkVUludDMyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bnBhY2tMaXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnBhY2tMaXN0KG1hcmtlciwgbWFya2VySGlnaCwgbWFya2VyTG93LCBidWZmZXIpIHtcbiAgICAgIGlmIChtYXJrZXJIaWdoID09PSBUSU5ZX0xJU1QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucGFja0xpc3RXaXRoU2l6ZShtYXJrZXJMb3csIGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlciA9PT0gTElTVF84KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnBhY2tMaXN0V2l0aFNpemUoYnVmZmVyLnJlYWRVSW50OCgpLCBidWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIgPT09IExJU1RfMTYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucGFja0xpc3RXaXRoU2l6ZShidWZmZXIucmVhZFVJbnQxNigpLCBidWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIgPT09IExJU1RfMzIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucGFja0xpc3RXaXRoU2l6ZShidWZmZXIucmVhZFVJbnQzMigpLCBidWZmZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bnBhY2tMaXN0V2l0aFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VucGFja0xpc3RXaXRoU2l6ZShzaXplLCBidWZmZXIpIHtcbiAgICAgIHZhciB2YWx1ZSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICB2YWx1ZS5wdXNoKHRoaXMudW5wYWNrKGJ1ZmZlcikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bnBhY2tCeXRlQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VucGFja0J5dGVBcnJheShtYXJrZXIsIGJ1ZmZlcikge1xuICAgICAgaWYgKG1hcmtlciA9PT0gQllURVNfOCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5wYWNrQnl0ZUFycmF5V2l0aFNpemUoYnVmZmVyLnJlYWRVSW50OCgpLCBidWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIgPT09IEJZVEVTXzE2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnBhY2tCeXRlQXJyYXlXaXRoU2l6ZShidWZmZXIucmVhZFVJbnQxNigpLCBidWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIgPT09IEJZVEVTXzMyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnBhY2tCeXRlQXJyYXlXaXRoU2l6ZShidWZmZXIucmVhZFVJbnQzMigpLCBidWZmZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bnBhY2tCeXRlQXJyYXlXaXRoU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wYWNrQnl0ZUFycmF5V2l0aFNpemUoc2l6ZSwgYnVmZmVyKSB7XG4gICAgICB2YXIgdmFsdWUgPSBuZXcgSW50OEFycmF5KHNpemUpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICB2YWx1ZVtpXSA9IGJ1ZmZlci5yZWFkSW50OCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bnBhY2tNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VucGFja01hcChtYXJrZXIsIG1hcmtlckhpZ2gsIG1hcmtlckxvdywgYnVmZmVyKSB7XG4gICAgICBpZiAobWFya2VySGlnaCA9PT0gVElOWV9NQVApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucGFja01hcFdpdGhTaXplKG1hcmtlckxvdywgYnVmZmVyKTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyID09PSBNQVBfOCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5wYWNrTWFwV2l0aFNpemUoYnVmZmVyLnJlYWRVSW50OCgpLCBidWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIgPT09IE1BUF8xNikge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5wYWNrTWFwV2l0aFNpemUoYnVmZmVyLnJlYWRVSW50MTYoKSwgYnVmZmVyKTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyID09PSBNQVBfMzIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucGFja01hcFdpdGhTaXplKGJ1ZmZlci5yZWFkVUludDMyKCksIGJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VucGFja01hcFdpdGhTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnBhY2tNYXBXaXRoU2l6ZShzaXplLCBidWZmZXIpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy51bnBhY2soYnVmZmVyKTtcbiAgICAgICAgdmFsdWVba2V5XSA9IHRoaXMudW5wYWNrKGJ1ZmZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VucGFja1N0cnVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wYWNrU3RydWN0KG1hcmtlciwgbWFya2VySGlnaCwgbWFya2VyTG93LCBidWZmZXIpIHtcbiAgICAgIGlmIChtYXJrZXJIaWdoID09PSBUSU5ZX1NUUlVDVCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5wYWNrU3RydWN0V2l0aFNpemUobWFya2VyTG93LCBidWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIgPT09IFNUUlVDVF84KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnBhY2tTdHJ1Y3RXaXRoU2l6ZShidWZmZXIucmVhZFVJbnQ4KCksIGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlciA9PT0gU1RSVUNUXzE2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnBhY2tTdHJ1Y3RXaXRoU2l6ZShidWZmZXIucmVhZFVJbnQxNigpLCBidWZmZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bnBhY2tTdHJ1Y3RXaXRoU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wYWNrU3RydWN0V2l0aFNpemUoc3RydWN0U2l6ZSwgYnVmZmVyKSB7XG4gICAgICB2YXIgc2lnbmF0dXJlID0gYnVmZmVyLnJlYWRVSW50OCgpO1xuXG4gICAgICBpZiAoc2lnbmF0dXJlID09PSBOT0RFKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnBhY2tOb2RlKHN0cnVjdFNpemUsIGJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gUkVMQVRJT05TSElQKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnBhY2tSZWxhdGlvbnNoaXAoc3RydWN0U2l6ZSwgYnVmZmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoc2lnbmF0dXJlID09PSBVTkJPVU5EX1JFTEFUSU9OU0hJUCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5wYWNrVW5ib3VuZFJlbGF0aW9uc2hpcChzdHJ1Y3RTaXplLCBidWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09IFBBVEgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucGFja1BhdGgoc3RydWN0U2l6ZSwgYnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnBhY2tVbmtub3duU3RydWN0KHNpZ25hdHVyZSwgc3RydWN0U2l6ZSwgYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VucGFja05vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VucGFja05vZGUoc3RydWN0U2l6ZSwgYnVmZmVyKSB7XG4gICAgICB0aGlzLl92ZXJpZnlTdHJ1Y3RTaXplKCdOb2RlJywgTk9ERV9TVFJVQ1RfU0laRSwgc3RydWN0U2l6ZSk7XG5cbiAgICAgIHJldHVybiBuZXcgX2dyYXBoVHlwZXMuTm9kZSh0aGlzLnVucGFjayhidWZmZXIpLCAvLyBJZGVudGl0eVxuICAgICAgdGhpcy51bnBhY2soYnVmZmVyKSwgLy8gTGFiZWxzXG4gICAgICB0aGlzLnVucGFjayhidWZmZXIpIC8vIFByb3BlcnRpZXNcbiAgICAgICk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bnBhY2tSZWxhdGlvbnNoaXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VucGFja1JlbGF0aW9uc2hpcChzdHJ1Y3RTaXplLCBidWZmZXIpIHtcbiAgICAgIHRoaXMuX3ZlcmlmeVN0cnVjdFNpemUoJ1JlbGF0aW9uc2hpcCcsIFJFTEFUSU9OU0hJUF9TVFJVQ1RfU0laRSwgc3RydWN0U2l6ZSk7XG5cbiAgICAgIHJldHVybiBuZXcgX2dyYXBoVHlwZXMuUmVsYXRpb25zaGlwKHRoaXMudW5wYWNrKGJ1ZmZlciksIC8vIElkZW50aXR5XG4gICAgICB0aGlzLnVucGFjayhidWZmZXIpLCAvLyBTdGFydCBOb2RlIElkZW50aXR5XG4gICAgICB0aGlzLnVucGFjayhidWZmZXIpLCAvLyBFbmQgTm9kZSBJZGVudGl0eVxuICAgICAgdGhpcy51bnBhY2soYnVmZmVyKSwgLy8gVHlwZVxuICAgICAgdGhpcy51bnBhY2soYnVmZmVyKSAvLyBQcm9wZXJ0aWVzXG4gICAgICApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdW5wYWNrVW5ib3VuZFJlbGF0aW9uc2hpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wYWNrVW5ib3VuZFJlbGF0aW9uc2hpcChzdHJ1Y3RTaXplLCBidWZmZXIpIHtcbiAgICAgIHRoaXMuX3ZlcmlmeVN0cnVjdFNpemUoJ1VuYm91bmRSZWxhdGlvbnNoaXAnLCBVTkJPVU5EX1JFTEFUSU9OU0hJUF9TVFJVQ1RfU0laRSwgc3RydWN0U2l6ZSk7XG5cbiAgICAgIHJldHVybiBuZXcgX2dyYXBoVHlwZXMuVW5ib3VuZFJlbGF0aW9uc2hpcCh0aGlzLnVucGFjayhidWZmZXIpLCAvLyBJZGVudGl0eVxuICAgICAgdGhpcy51bnBhY2soYnVmZmVyKSwgLy8gVHlwZVxuICAgICAgdGhpcy51bnBhY2soYnVmZmVyKSAvLyBQcm9wZXJ0aWVzXG4gICAgICApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdW5wYWNrUGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wYWNrUGF0aChzdHJ1Y3RTaXplLCBidWZmZXIpIHtcbiAgICAgIHRoaXMuX3ZlcmlmeVN0cnVjdFNpemUoJ1BhdGgnLCBQQVRIX1NUUlVDVF9TSVpFLCBzdHJ1Y3RTaXplKTtcblxuICAgICAgdmFyIG5vZGVzID0gdGhpcy51bnBhY2soYnVmZmVyKTtcbiAgICAgIHZhciByZWxzID0gdGhpcy51bnBhY2soYnVmZmVyKTtcbiAgICAgIHZhciBzZXF1ZW5jZSA9IHRoaXMudW5wYWNrKGJ1ZmZlcik7XG4gICAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICAgIHZhciBwcmV2Tm9kZSA9IG5vZGVzWzBdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcXVlbmNlLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciBuZXh0Tm9kZSA9IG5vZGVzW3NlcXVlbmNlW2kgKyAxXV07XG4gICAgICAgIHZhciByZWxJbmRleCA9IHNlcXVlbmNlW2ldO1xuICAgICAgICB2YXIgcmVsID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChyZWxJbmRleCA+IDApIHtcbiAgICAgICAgICByZWwgPSByZWxzW3JlbEluZGV4IC0gMV07XG5cbiAgICAgICAgICBpZiAocmVsIGluc3RhbmNlb2YgX2dyYXBoVHlwZXMuVW5ib3VuZFJlbGF0aW9uc2hpcCkge1xuICAgICAgICAgICAgLy8gVG8gYXZvaWQgZHVwbGljYXRpb24sIHJlbGF0aW9uc2hpcHMgaW4gYSBwYXRoIGRvIG5vdCBjb250YWluXG4gICAgICAgICAgICAvLyBpbmZvcm1hdGlvbiBhYm91dCB0aGVpciBzdGFydCBhbmQgZW5kIG5vZGVzLCB0aGF0J3MgaW5zdGVhZFxuICAgICAgICAgICAgLy8gaW5mZXJyZWQgZnJvbSB0aGUgcGF0aCBzZXF1ZW5jZS4gVGhpcyBpcyB1cyBpbmZlcnJpbmcgKGFuZCxcbiAgICAgICAgICAgIC8vIGZvciBwZXJmb3JtYW5jZSByZWFzb25zIHJlbWVtYmVyaW5nKSB0aGUgc3RhcnQvZW5kIG9mIGEgcmVsLlxuICAgICAgICAgICAgcmVsc1tyZWxJbmRleCAtIDFdID0gcmVsID0gcmVsLmJpbmQocHJldk5vZGUuaWRlbnRpdHksIG5leHROb2RlLmlkZW50aXR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVsID0gcmVsc1stcmVsSW5kZXggLSAxXTtcblxuICAgICAgICAgIGlmIChyZWwgaW5zdGFuY2VvZiBfZ3JhcGhUeXBlcy5VbmJvdW5kUmVsYXRpb25zaGlwKSB7XG4gICAgICAgICAgICAvLyBTZWUgYWJvdmVcbiAgICAgICAgICAgIHJlbHNbLXJlbEluZGV4IC0gMV0gPSByZWwgPSByZWwuYmluZChuZXh0Tm9kZS5pZGVudGl0eSwgcHJldk5vZGUuaWRlbnRpdHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBEb25lIGh5ZHJhdGluZyBvbmUgcGF0aCBzZWdtZW50LlxuXG5cbiAgICAgICAgc2VnbWVudHMucHVzaChuZXcgX2dyYXBoVHlwZXMuUGF0aFNlZ21lbnQocHJldk5vZGUsIHJlbCwgbmV4dE5vZGUpKTtcbiAgICAgICAgcHJldk5vZGUgPSBuZXh0Tm9kZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBfZ3JhcGhUeXBlcy5QYXRoKG5vZGVzWzBdLCBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSwgc2VnbWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdW5wYWNrVW5rbm93blN0cnVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wYWNrVW5rbm93blN0cnVjdChzaWduYXR1cmUsIHN0cnVjdFNpemUsIGJ1ZmZlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBTdHJ1Y3R1cmUoc2lnbmF0dXJlLCBbXSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RydWN0U2l6ZTsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh0aGlzLnVucGFjayhidWZmZXIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3ZlcmlmeVN0cnVjdFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZlcmlmeVN0cnVjdFNpemUoc3RydWN0TmFtZSwgZXhwZWN0ZWRTaXplLCBhY3R1YWxTaXplKSB7XG4gICAgICBpZiAoZXhwZWN0ZWRTaXplICE9PSBhY3R1YWxTaXplKSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKFwiV3Jvbmcgc3RydWN0IHNpemUgZm9yIFwiLmNvbmNhdChzdHJ1Y3ROYW1lLCBcIiwgZXhwZWN0ZWQgXCIpLmNvbmNhdChleHBlY3RlZFNpemUsIFwiIGJ1dCB3YXMgXCIpLmNvbmNhdChhY3R1YWxTaXplKSwgX2Vycm9yLlBST1RPQ09MX0VSUk9SKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFVucGFja2VyO1xufSgpO1xuXG5leHBvcnRzLlVucGFja2VyID0gVW5wYWNrZXI7XG5cbmZ1bmN0aW9uIGlzSXRlcmFibGUob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2Ygb2JqW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5VbnBhY2tlciA9IGV4cG9ydHMuUGFja2VyID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2dldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgdjEgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9wYWNrc3RyZWFtLXYxXCIpKTtcblxudmFyIF9zcGF0aWFsVHlwZXMgPSByZXF1aXJlKFwiLi4vc3BhdGlhbC10eXBlc1wiKTtcblxudmFyIF90ZW1wb3JhbFR5cGVzID0gcmVxdWlyZShcIi4uL3RlbXBvcmFsLXR5cGVzXCIpO1xuXG52YXIgX2ludGVnZXIgPSByZXF1aXJlKFwiLi4vaW50ZWdlclwiKTtcblxudmFyIF90ZW1wb3JhbFV0aWwgPSByZXF1aXJlKFwiLi90ZW1wb3JhbC11dGlsXCIpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgUE9JTlRfMkQgPSAweDU4O1xudmFyIFBPSU5UXzJEX1NUUlVDVF9TSVpFID0gMztcbnZhciBQT0lOVF8zRCA9IDB4NTk7XG52YXIgUE9JTlRfM0RfU1RSVUNUX1NJWkUgPSA0O1xudmFyIERVUkFUSU9OID0gMHg0NTtcbnZhciBEVVJBVElPTl9TVFJVQ1RfU0laRSA9IDQ7XG52YXIgTE9DQUxfVElNRSA9IDB4NzQ7XG52YXIgTE9DQUxfVElNRV9TVFJVQ1RfU0laRSA9IDE7XG52YXIgVElNRSA9IDB4NTQ7XG52YXIgVElNRV9TVFJVQ1RfU0laRSA9IDI7XG52YXIgREFURSA9IDB4NDQ7XG52YXIgREFURV9TVFJVQ1RfU0laRSA9IDE7XG52YXIgTE9DQUxfREFURV9USU1FID0gMHg2NDtcbnZhciBMT0NBTF9EQVRFX1RJTUVfU1RSVUNUX1NJWkUgPSAyO1xudmFyIERBVEVfVElNRV9XSVRIX1pPTkVfT0ZGU0VUID0gMHg0NjtcbnZhciBEQVRFX1RJTUVfV0lUSF9aT05FX09GRlNFVF9TVFJVQ1RfU0laRSA9IDM7XG52YXIgREFURV9USU1FX1dJVEhfWk9ORV9JRCA9IDB4NjY7XG52YXIgREFURV9USU1FX1dJVEhfWk9ORV9JRF9TVFJVQ1RfU0laRSA9IDM7XG5cbnZhciBQYWNrZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF92MSRQYWNrZXIpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShQYWNrZXIsIF92MSRQYWNrZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUGFja2VyKTtcblxuICBmdW5jdGlvbiBQYWNrZXIoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBQYWNrZXIpO1xuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUGFja2VyLCBbe1xuICAgIGtleTogXCJkaXNhYmxlQnl0ZUFycmF5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlQnl0ZUFycmF5cygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQm9sdCBWMiBzaG91bGQgYWx3YXlzIHN1cHBvcnQgYnl0ZSBhcnJheXMnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFja2FibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFja2FibGUob2JqKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoKDAsIF9zcGF0aWFsVHlwZXMuaXNQb2ludCkob2JqKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwYWNrUG9pbnQob2JqLCBfdGhpcyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCgwLCBfdGVtcG9yYWxUeXBlcy5pc0R1cmF0aW9uKShvYmopKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhY2tEdXJhdGlvbihvYmosIF90aGlzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF90ZW1wb3JhbFR5cGVzLmlzTG9jYWxUaW1lKShvYmopKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhY2tMb2NhbFRpbWUob2JqLCBfdGhpcyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCgwLCBfdGVtcG9yYWxUeXBlcy5pc1RpbWUpKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcGFja1RpbWUob2JqLCBfdGhpcyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCgwLCBfdGVtcG9yYWxUeXBlcy5pc0RhdGUpKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcGFja0RhdGUob2JqLCBfdGhpcyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCgwLCBfdGVtcG9yYWxUeXBlcy5pc0xvY2FsRGF0ZVRpbWUpKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcGFja0xvY2FsRGF0ZVRpbWUob2JqLCBfdGhpcyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCgwLCBfdGVtcG9yYWxUeXBlcy5pc0RhdGVUaW1lKShvYmopKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhY2tEYXRlVGltZShvYmosIF90aGlzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoMCwgX2dldDJbXCJkZWZhdWx0XCJdKSgoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKFBhY2tlci5wcm90b3R5cGUpLCBcInBhY2thYmxlXCIsIHRoaXMpLmNhbGwodGhpcywgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBhY2tlcjtcbn0odjEuUGFja2VyKTtcblxuZXhwb3J0cy5QYWNrZXIgPSBQYWNrZXI7XG5cbnZhciBVbnBhY2tlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3YxJFVucGFja2VyKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoVW5wYWNrZXIsIF92MSRVbnBhY2tlcik7XG5cbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoVW5wYWNrZXIpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlTG9zc2xlc3NJbnRlZ2VycyBpZiB0aGlzIHVucGFja2VyIHNob3VsZCBjb252ZXJ0IGFsbCByZWNlaXZlZCBpbnRlZ2VycyB0byBuYXRpdmUgSlMgbnVtYmVycy5cbiAgICovXG4gIGZ1bmN0aW9uIFVucGFja2VyKCkge1xuICAgIHZhciBkaXNhYmxlTG9zc2xlc3NJbnRlZ2VycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBVbnBhY2tlcik7XG4gICAgcmV0dXJuIF9zdXBlcjIuY2FsbCh0aGlzLCBkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycyk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFVucGFja2VyLCBbe1xuICAgIGtleTogXCJfdW5wYWNrVW5rbm93blN0cnVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5wYWNrVW5rbm93blN0cnVjdChzaWduYXR1cmUsIHN0cnVjdFNpemUsIGJ1ZmZlcikge1xuICAgICAgaWYgKHNpZ25hdHVyZSA9PT0gUE9JTlRfMkQpIHtcbiAgICAgICAgcmV0dXJuIHVucGFja1BvaW50MkQodGhpcywgc3RydWN0U2l6ZSwgYnVmZmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoc2lnbmF0dXJlID09PSBQT0lOVF8zRCkge1xuICAgICAgICByZXR1cm4gdW5wYWNrUG9pbnQzRCh0aGlzLCBzdHJ1Y3RTaXplLCBidWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09IERVUkFUSU9OKSB7XG4gICAgICAgIHJldHVybiB1bnBhY2tEdXJhdGlvbih0aGlzLCBzdHJ1Y3RTaXplLCBidWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09IExPQ0FMX1RJTUUpIHtcbiAgICAgICAgcmV0dXJuIHVucGFja0xvY2FsVGltZSh0aGlzLCBzdHJ1Y3RTaXplLCBidWZmZXIsIHRoaXMuX2Rpc2FibGVMb3NzbGVzc0ludGVnZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAoc2lnbmF0dXJlID09PSBUSU1FKSB7XG4gICAgICAgIHJldHVybiB1bnBhY2tUaW1lKHRoaXMsIHN0cnVjdFNpemUsIGJ1ZmZlciwgdGhpcy5fZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xuICAgICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09IERBVEUpIHtcbiAgICAgICAgcmV0dXJuIHVucGFja0RhdGUodGhpcywgc3RydWN0U2l6ZSwgYnVmZmVyLCB0aGlzLl9kaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycyk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gTE9DQUxfREFURV9USU1FKSB7XG4gICAgICAgIHJldHVybiB1bnBhY2tMb2NhbERhdGVUaW1lKHRoaXMsIHN0cnVjdFNpemUsIGJ1ZmZlciwgdGhpcy5fZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xuICAgICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09IERBVEVfVElNRV9XSVRIX1pPTkVfT0ZGU0VUKSB7XG4gICAgICAgIHJldHVybiB1bnBhY2tEYXRlVGltZVdpdGhab25lT2Zmc2V0KHRoaXMsIHN0cnVjdFNpemUsIGJ1ZmZlciwgdGhpcy5fZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xuICAgICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09IERBVEVfVElNRV9XSVRIX1pPTkVfSUQpIHtcbiAgICAgICAgcmV0dXJuIHVucGFja0RhdGVUaW1lV2l0aFpvbmVJZCh0aGlzLCBzdHJ1Y3RTaXplLCBidWZmZXIsIHRoaXMuX2Rpc2FibGVMb3NzbGVzc0ludGVnZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoMCwgX2dldDJbXCJkZWZhdWx0XCJdKSgoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKFVucGFja2VyLnByb3RvdHlwZSksIFwiX3VucGFja1Vua25vd25TdHJ1Y3RcIiwgdGhpcykuY2FsbCh0aGlzLCBzaWduYXR1cmUsIHN0cnVjdFNpemUsIGJ1ZmZlciwgdGhpcy5fZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVW5wYWNrZXI7XG59KHYxLlVucGFja2VyKTtcbi8qKlxuICogUGFjayBnaXZlbiAyRCBvciAzRCBwb2ludC5cbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IHRoZSBwb2ludCB2YWx1ZSB0byBwYWNrLlxuICogQHBhcmFtIHtQYWNrZXJ9IHBhY2tlciB0aGUgcGFja2VyIHRvIHVzZS5cbiAqL1xuXG5cbmV4cG9ydHMuVW5wYWNrZXIgPSBVbnBhY2tlcjtcblxuZnVuY3Rpb24gcGFja1BvaW50KHBvaW50LCBwYWNrZXIpIHtcbiAgdmFyIGlzMkRQb2ludCA9IHBvaW50LnogPT09IG51bGwgfHwgcG9pbnQueiA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpczJEUG9pbnQpIHtcbiAgICBwYWNrUG9pbnQyRChwb2ludCwgcGFja2VyKTtcbiAgfSBlbHNlIHtcbiAgICBwYWNrUG9pbnQzRChwb2ludCwgcGFja2VyKTtcbiAgfVxufVxuLyoqXG4gKiBQYWNrIGdpdmVuIDJEIHBvaW50LlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnQgdGhlIHBvaW50IHZhbHVlIHRvIHBhY2suXG4gKiBAcGFyYW0ge1BhY2tlcn0gcGFja2VyIHRoZSBwYWNrZXIgdG8gdXNlLlxuICovXG5cblxuZnVuY3Rpb24gcGFja1BvaW50MkQocG9pbnQsIHBhY2tlcikge1xuICB2YXIgcGFja2FibGVTdHJ1Y3RGaWVsZHMgPSBbcGFja2VyLnBhY2thYmxlKCgwLCBfaW50ZWdlcltcImludFwiXSkocG9pbnQuc3JpZCkpLCBwYWNrZXIucGFja2FibGUocG9pbnQueCksIHBhY2tlci5wYWNrYWJsZShwb2ludC55KV07XG4gIHBhY2tlci5wYWNrU3RydWN0KFBPSU5UXzJELCBwYWNrYWJsZVN0cnVjdEZpZWxkcyk7XG59XG4vKipcbiAqIFBhY2sgZ2l2ZW4gM0QgcG9pbnQuXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludCB0aGUgcG9pbnQgdmFsdWUgdG8gcGFjay5cbiAqIEBwYXJhbSB7UGFja2VyfSBwYWNrZXIgdGhlIHBhY2tlciB0byB1c2UuXG4gKi9cblxuXG5mdW5jdGlvbiBwYWNrUG9pbnQzRChwb2ludCwgcGFja2VyKSB7XG4gIHZhciBwYWNrYWJsZVN0cnVjdEZpZWxkcyA9IFtwYWNrZXIucGFja2FibGUoKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShwb2ludC5zcmlkKSksIHBhY2tlci5wYWNrYWJsZShwb2ludC54KSwgcGFja2VyLnBhY2thYmxlKHBvaW50LnkpLCBwYWNrZXIucGFja2FibGUocG9pbnQueildO1xuICBwYWNrZXIucGFja1N0cnVjdChQT0lOVF8zRCwgcGFja2FibGVTdHJ1Y3RGaWVsZHMpO1xufVxuLyoqXG4gKiBVbnBhY2sgMkQgcG9pbnQgdmFsdWUgdXNpbmcgdGhlIGdpdmVuIHVucGFja2VyLlxuICogQHBhcmFtIHtVbnBhY2tlcn0gdW5wYWNrZXIgdGhlIHVucGFja2VyIHRvIHVzZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJ1Y3RTaXplIHRoZSByZXRyaWV2ZWQgc3RydWN0IHNpemUuXG4gKiBAcGFyYW0ge0Jhc2VCdWZmZXJ9IGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHVucGFjayBmcm9tLlxuICogQHJldHVybiB7UG9pbnR9IHRoZSB1bnBhY2tlZCAyRCBwb2ludCB2YWx1ZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHVucGFja1BvaW50MkQodW5wYWNrZXIsIHN0cnVjdFNpemUsIGJ1ZmZlcikge1xuICB1bnBhY2tlci5fdmVyaWZ5U3RydWN0U2l6ZSgnUG9pbnQyRCcsIFBPSU5UXzJEX1NUUlVDVF9TSVpFLCBzdHJ1Y3RTaXplKTtcblxuICByZXR1cm4gbmV3IF9zcGF0aWFsVHlwZXMuUG9pbnQodW5wYWNrZXIudW5wYWNrKGJ1ZmZlciksIC8vIHNyaWRcbiAgdW5wYWNrZXIudW5wYWNrKGJ1ZmZlciksIC8vIHhcbiAgdW5wYWNrZXIudW5wYWNrKGJ1ZmZlciksIC8vIHlcbiAgdW5kZWZpbmVkIC8vIHpcbiAgKTtcbn1cbi8qKlxuICogVW5wYWNrIDNEIHBvaW50IHZhbHVlIHVzaW5nIHRoZSBnaXZlbiB1bnBhY2tlci5cbiAqIEBwYXJhbSB7VW5wYWNrZXJ9IHVucGFja2VyIHRoZSB1bnBhY2tlciB0byB1c2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RydWN0U2l6ZSB0aGUgcmV0cmlldmVkIHN0cnVjdCBzaXplLlxuICogQHBhcmFtIHtCYXNlQnVmZmVyfSBidWZmZXIgdGhlIGJ1ZmZlciB0byB1bnBhY2sgZnJvbS5cbiAqIEByZXR1cm4ge1BvaW50fSB0aGUgdW5wYWNrZWQgM0QgcG9pbnQgdmFsdWUuXG4gKi9cblxuXG5mdW5jdGlvbiB1bnBhY2tQb2ludDNEKHVucGFja2VyLCBzdHJ1Y3RTaXplLCBidWZmZXIpIHtcbiAgdW5wYWNrZXIuX3ZlcmlmeVN0cnVjdFNpemUoJ1BvaW50M0QnLCBQT0lOVF8zRF9TVFJVQ1RfU0laRSwgc3RydWN0U2l6ZSk7XG5cbiAgcmV0dXJuIG5ldyBfc3BhdGlhbFR5cGVzLlBvaW50KHVucGFja2VyLnVucGFjayhidWZmZXIpLCAvLyBzcmlkXG4gIHVucGFja2VyLnVucGFjayhidWZmZXIpLCAvLyB4XG4gIHVucGFja2VyLnVucGFjayhidWZmZXIpLCAvLyB5XG4gIHVucGFja2VyLnVucGFjayhidWZmZXIpIC8vIHpcbiAgKTtcbn1cbi8qKlxuICogUGFjayBnaXZlbiBkdXJhdGlvbi5cbiAqIEBwYXJhbSB7RHVyYXRpb259IHZhbHVlIHRoZSBkdXJhdGlvbiB2YWx1ZSB0byBwYWNrLlxuICogQHBhcmFtIHtQYWNrZXJ9IHBhY2tlciB0aGUgcGFja2VyIHRvIHVzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhY2tEdXJhdGlvbih2YWx1ZSwgcGFja2VyKSB7XG4gIHZhciBtb250aHMgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHZhbHVlLm1vbnRocyk7XG4gIHZhciBkYXlzID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKSh2YWx1ZS5kYXlzKTtcbiAgdmFyIHNlY29uZHMgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHZhbHVlLnNlY29uZHMpO1xuICB2YXIgbmFub3NlY29uZHMgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHZhbHVlLm5hbm9zZWNvbmRzKTtcbiAgdmFyIHBhY2thYmxlU3RydWN0RmllbGRzID0gW3BhY2tlci5wYWNrYWJsZShtb250aHMpLCBwYWNrZXIucGFja2FibGUoZGF5cyksIHBhY2tlci5wYWNrYWJsZShzZWNvbmRzKSwgcGFja2VyLnBhY2thYmxlKG5hbm9zZWNvbmRzKV07XG4gIHBhY2tlci5wYWNrU3RydWN0KERVUkFUSU9OLCBwYWNrYWJsZVN0cnVjdEZpZWxkcyk7XG59XG4vKipcbiAqIFVucGFjayBkdXJhdGlvbiB2YWx1ZSB1c2luZyB0aGUgZ2l2ZW4gdW5wYWNrZXIuXG4gKiBAcGFyYW0ge1VucGFja2VyfSB1bnBhY2tlciB0aGUgdW5wYWNrZXIgdG8gdXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cnVjdFNpemUgdGhlIHJldHJpZXZlZCBzdHJ1Y3Qgc2l6ZS5cbiAqIEBwYXJhbSB7QmFzZUJ1ZmZlcn0gYnVmZmVyIHRoZSBidWZmZXIgdG8gdW5wYWNrIGZyb20uXG4gKiBAcmV0dXJuIHtEdXJhdGlvbn0gdGhlIHVucGFja2VkIGR1cmF0aW9uIHZhbHVlLlxuICovXG5cblxuZnVuY3Rpb24gdW5wYWNrRHVyYXRpb24odW5wYWNrZXIsIHN0cnVjdFNpemUsIGJ1ZmZlcikge1xuICB1bnBhY2tlci5fdmVyaWZ5U3RydWN0U2l6ZSgnRHVyYXRpb24nLCBEVVJBVElPTl9TVFJVQ1RfU0laRSwgc3RydWN0U2l6ZSk7XG5cbiAgdmFyIG1vbnRocyA9IHVucGFja2VyLnVucGFjayhidWZmZXIpO1xuICB2YXIgZGF5cyA9IHVucGFja2VyLnVucGFjayhidWZmZXIpO1xuICB2YXIgc2Vjb25kcyA9IHVucGFja2VyLnVucGFjayhidWZmZXIpO1xuICB2YXIgbmFub3NlY29uZHMgPSB1bnBhY2tlci51bnBhY2soYnVmZmVyKTtcbiAgcmV0dXJuIG5ldyBfdGVtcG9yYWxUeXBlcy5EdXJhdGlvbihtb250aHMsIGRheXMsIHNlY29uZHMsIG5hbm9zZWNvbmRzKTtcbn1cbi8qKlxuICogUGFjayBnaXZlbiBsb2NhbCB0aW1lLlxuICogQHBhcmFtIHtMb2NhbFRpbWV9IHZhbHVlIHRoZSBsb2NhbCB0aW1lIHZhbHVlIHRvIHBhY2suXG4gKiBAcGFyYW0ge1BhY2tlcn0gcGFja2VyIHRoZSBwYWNrZXIgdG8gdXNlLlxuICovXG5cblxuZnVuY3Rpb24gcGFja0xvY2FsVGltZSh2YWx1ZSwgcGFja2VyKSB7XG4gIHZhciBuYW5vT2ZEYXkgPSAoMCwgX3RlbXBvcmFsVXRpbC5sb2NhbFRpbWVUb05hbm9PZkRheSkodmFsdWUuaG91ciwgdmFsdWUubWludXRlLCB2YWx1ZS5zZWNvbmQsIHZhbHVlLm5hbm9zZWNvbmQpO1xuICB2YXIgcGFja2FibGVTdHJ1Y3RGaWVsZHMgPSBbcGFja2VyLnBhY2thYmxlKG5hbm9PZkRheSldO1xuICBwYWNrZXIucGFja1N0cnVjdChMT0NBTF9USU1FLCBwYWNrYWJsZVN0cnVjdEZpZWxkcyk7XG59XG4vKipcbiAqIFVucGFjayBsb2NhbCB0aW1lIHZhbHVlIHVzaW5nIHRoZSBnaXZlbiB1bnBhY2tlci5cbiAqIEBwYXJhbSB7VW5wYWNrZXJ9IHVucGFja2VyIHRoZSB1bnBhY2tlciB0byB1c2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RydWN0U2l6ZSB0aGUgcmV0cmlldmVkIHN0cnVjdCBzaXplLlxuICogQHBhcmFtIHtCYXNlQnVmZmVyfSBidWZmZXIgdGhlIGJ1ZmZlciB0byB1bnBhY2sgZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMgaWYgaW50ZWdlciBwcm9wZXJ0aWVzIGluIHRoZSByZXN1bHQgbG9jYWwgdGltZSBzaG91bGQgYmUgbmF0aXZlIEpTIG51bWJlcnMuXG4gKiBAcmV0dXJuIHtMb2NhbFRpbWV9IHRoZSB1bnBhY2tlZCBsb2NhbCB0aW1lIHZhbHVlLlxuICovXG5cblxuZnVuY3Rpb24gdW5wYWNrTG9jYWxUaW1lKHVucGFja2VyLCBzdHJ1Y3RTaXplLCBidWZmZXIsIGRpc2FibGVMb3NzbGVzc0ludGVnZXJzKSB7XG4gIHVucGFja2VyLl92ZXJpZnlTdHJ1Y3RTaXplKCdMb2NhbFRpbWUnLCBMT0NBTF9USU1FX1NUUlVDVF9TSVpFLCBzdHJ1Y3RTaXplKTtcblxuICB2YXIgbmFub09mRGF5ID0gdW5wYWNrZXIudW5wYWNrSW50ZWdlcihidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gKDAsIF90ZW1wb3JhbFV0aWwubmFub09mRGF5VG9Mb2NhbFRpbWUpKG5hbm9PZkRheSk7XG4gIHJldHVybiBjb252ZXJ0SW50ZWdlclByb3BzSWZOZWVkZWQocmVzdWx0LCBkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycyk7XG59XG4vKipcbiAqIFBhY2sgZ2l2ZW4gdGltZS5cbiAqIEBwYXJhbSB7VGltZX0gdmFsdWUgdGhlIHRpbWUgdmFsdWUgdG8gcGFjay5cbiAqIEBwYXJhbSB7UGFja2VyfSBwYWNrZXIgdGhlIHBhY2tlciB0byB1c2UuXG4gKi9cblxuXG5mdW5jdGlvbiBwYWNrVGltZSh2YWx1ZSwgcGFja2VyKSB7XG4gIHZhciBuYW5vT2ZEYXkgPSAoMCwgX3RlbXBvcmFsVXRpbC5sb2NhbFRpbWVUb05hbm9PZkRheSkodmFsdWUuaG91ciwgdmFsdWUubWludXRlLCB2YWx1ZS5zZWNvbmQsIHZhbHVlLm5hbm9zZWNvbmQpO1xuICB2YXIgb2Zmc2V0U2Vjb25kcyA9ICgwLCBfaW50ZWdlcltcImludFwiXSkodmFsdWUudGltZVpvbmVPZmZzZXRTZWNvbmRzKTtcbiAgdmFyIHBhY2thYmxlU3RydWN0RmllbGRzID0gW3BhY2tlci5wYWNrYWJsZShuYW5vT2ZEYXkpLCBwYWNrZXIucGFja2FibGUob2Zmc2V0U2Vjb25kcyldO1xuICBwYWNrZXIucGFja1N0cnVjdChUSU1FLCBwYWNrYWJsZVN0cnVjdEZpZWxkcyk7XG59XG4vKipcbiAqIFVucGFjayB0aW1lIHZhbHVlIHVzaW5nIHRoZSBnaXZlbiB1bnBhY2tlci5cbiAqIEBwYXJhbSB7VW5wYWNrZXJ9IHVucGFja2VyIHRoZSB1bnBhY2tlciB0byB1c2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RydWN0U2l6ZSB0aGUgcmV0cmlldmVkIHN0cnVjdCBzaXplLlxuICogQHBhcmFtIHtCYXNlQnVmZmVyfSBidWZmZXIgdGhlIGJ1ZmZlciB0byB1bnBhY2sgZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMgaWYgaW50ZWdlciBwcm9wZXJ0aWVzIGluIHRoZSByZXN1bHQgdGltZSBzaG91bGQgYmUgbmF0aXZlIEpTIG51bWJlcnMuXG4gKiBAcmV0dXJuIHtUaW1lfSB0aGUgdW5wYWNrZWQgdGltZSB2YWx1ZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHVucGFja1RpbWUodW5wYWNrZXIsIHN0cnVjdFNpemUsIGJ1ZmZlciwgZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpIHtcbiAgdW5wYWNrZXIuX3ZlcmlmeVN0cnVjdFNpemUoJ1RpbWUnLCBUSU1FX1NUUlVDVF9TSVpFLCBzdHJ1Y3RTaXplKTtcblxuICB2YXIgbmFub09mRGF5ID0gdW5wYWNrZXIudW5wYWNrSW50ZWdlcihidWZmZXIpO1xuICB2YXIgb2Zmc2V0U2Vjb25kcyA9IHVucGFja2VyLnVucGFja0ludGVnZXIoYnVmZmVyKTtcbiAgdmFyIGxvY2FsVGltZSA9ICgwLCBfdGVtcG9yYWxVdGlsLm5hbm9PZkRheVRvTG9jYWxUaW1lKShuYW5vT2ZEYXkpO1xuICB2YXIgcmVzdWx0ID0gbmV3IF90ZW1wb3JhbFR5cGVzLlRpbWUobG9jYWxUaW1lLmhvdXIsIGxvY2FsVGltZS5taW51dGUsIGxvY2FsVGltZS5zZWNvbmQsIGxvY2FsVGltZS5uYW5vc2Vjb25kLCBvZmZzZXRTZWNvbmRzKTtcbiAgcmV0dXJuIGNvbnZlcnRJbnRlZ2VyUHJvcHNJZk5lZWRlZChyZXN1bHQsIGRpc2FibGVMb3NzbGVzc0ludGVnZXJzKTtcbn1cbi8qKlxuICogUGFjayBnaXZlbiBuZW80aiBkYXRlLlxuICogQHBhcmFtIHtEYXRlfSB2YWx1ZSB0aGUgZGF0ZSB2YWx1ZSB0byBwYWNrLlxuICogQHBhcmFtIHtQYWNrZXJ9IHBhY2tlciB0aGUgcGFja2VyIHRvIHVzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhY2tEYXRlKHZhbHVlLCBwYWNrZXIpIHtcbiAgdmFyIGVwb2NoRGF5ID0gKDAsIF90ZW1wb3JhbFV0aWwuZGF0ZVRvRXBvY2hEYXkpKHZhbHVlLnllYXIsIHZhbHVlLm1vbnRoLCB2YWx1ZS5kYXkpO1xuICB2YXIgcGFja2FibGVTdHJ1Y3RGaWVsZHMgPSBbcGFja2VyLnBhY2thYmxlKGVwb2NoRGF5KV07XG4gIHBhY2tlci5wYWNrU3RydWN0KERBVEUsIHBhY2thYmxlU3RydWN0RmllbGRzKTtcbn1cbi8qKlxuICogVW5wYWNrIG5lbzRqIGRhdGUgdmFsdWUgdXNpbmcgdGhlIGdpdmVuIHVucGFja2VyLlxuICogQHBhcmFtIHtVbnBhY2tlcn0gdW5wYWNrZXIgdGhlIHVucGFja2VyIHRvIHVzZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJ1Y3RTaXplIHRoZSByZXRyaWV2ZWQgc3RydWN0IHNpemUuXG4gKiBAcGFyYW0ge0Jhc2VCdWZmZXJ9IGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHVucGFjayBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlTG9zc2xlc3NJbnRlZ2VycyBpZiBpbnRlZ2VyIHByb3BlcnRpZXMgaW4gdGhlIHJlc3VsdCBkYXRlIHNob3VsZCBiZSBuYXRpdmUgSlMgbnVtYmVycy5cbiAqIEByZXR1cm4ge0RhdGV9IHRoZSB1bnBhY2tlZCBuZW80aiBkYXRlIHZhbHVlLlxuICovXG5cblxuZnVuY3Rpb24gdW5wYWNrRGF0ZSh1bnBhY2tlciwgc3RydWN0U2l6ZSwgYnVmZmVyLCBkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycykge1xuICB1bnBhY2tlci5fdmVyaWZ5U3RydWN0U2l6ZSgnRGF0ZScsIERBVEVfU1RSVUNUX1NJWkUsIHN0cnVjdFNpemUpO1xuXG4gIHZhciBlcG9jaERheSA9IHVucGFja2VyLnVucGFja0ludGVnZXIoYnVmZmVyKTtcbiAgdmFyIHJlc3VsdCA9ICgwLCBfdGVtcG9yYWxVdGlsLmVwb2NoRGF5VG9EYXRlKShlcG9jaERheSk7XG4gIHJldHVybiBjb252ZXJ0SW50ZWdlclByb3BzSWZOZWVkZWQocmVzdWx0LCBkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycyk7XG59XG4vKipcbiAqIFBhY2sgZ2l2ZW4gbG9jYWwgZGF0ZSB0aW1lLlxuICogQHBhcmFtIHtMb2NhbERhdGVUaW1lfSB2YWx1ZSB0aGUgbG9jYWwgZGF0ZSB0aW1lIHZhbHVlIHRvIHBhY2suXG4gKiBAcGFyYW0ge1BhY2tlcn0gcGFja2VyIHRoZSBwYWNrZXIgdG8gdXNlLlxuICovXG5cblxuZnVuY3Rpb24gcGFja0xvY2FsRGF0ZVRpbWUodmFsdWUsIHBhY2tlcikge1xuICB2YXIgZXBvY2hTZWNvbmQgPSAoMCwgX3RlbXBvcmFsVXRpbC5sb2NhbERhdGVUaW1lVG9FcG9jaFNlY29uZCkodmFsdWUueWVhciwgdmFsdWUubW9udGgsIHZhbHVlLmRheSwgdmFsdWUuaG91ciwgdmFsdWUubWludXRlLCB2YWx1ZS5zZWNvbmQsIHZhbHVlLm5hbm9zZWNvbmQpO1xuICB2YXIgbmFubyA9ICgwLCBfaW50ZWdlcltcImludFwiXSkodmFsdWUubmFub3NlY29uZCk7XG4gIHZhciBwYWNrYWJsZVN0cnVjdEZpZWxkcyA9IFtwYWNrZXIucGFja2FibGUoZXBvY2hTZWNvbmQpLCBwYWNrZXIucGFja2FibGUobmFubyldO1xuICBwYWNrZXIucGFja1N0cnVjdChMT0NBTF9EQVRFX1RJTUUsIHBhY2thYmxlU3RydWN0RmllbGRzKTtcbn1cbi8qKlxuICogVW5wYWNrIGxvY2FsIGRhdGUgdGltZSB2YWx1ZSB1c2luZyB0aGUgZ2l2ZW4gdW5wYWNrZXIuXG4gKiBAcGFyYW0ge1VucGFja2VyfSB1bnBhY2tlciB0aGUgdW5wYWNrZXIgdG8gdXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cnVjdFNpemUgdGhlIHJldHJpZXZlZCBzdHJ1Y3Qgc2l6ZS5cbiAqIEBwYXJhbSB7QmFzZUJ1ZmZlcn0gYnVmZmVyIHRoZSBidWZmZXIgdG8gdW5wYWNrIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVMb3NzbGVzc0ludGVnZXJzIGlmIGludGVnZXIgcHJvcGVydGllcyBpbiB0aGUgcmVzdWx0IGxvY2FsIGRhdGUtdGltZSBzaG91bGQgYmUgbmF0aXZlIEpTIG51bWJlcnMuXG4gKiBAcmV0dXJuIHtMb2NhbERhdGVUaW1lfSB0aGUgdW5wYWNrZWQgbG9jYWwgZGF0ZSB0aW1lIHZhbHVlLlxuICovXG5cblxuZnVuY3Rpb24gdW5wYWNrTG9jYWxEYXRlVGltZSh1bnBhY2tlciwgc3RydWN0U2l6ZSwgYnVmZmVyLCBkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycykge1xuICB1bnBhY2tlci5fdmVyaWZ5U3RydWN0U2l6ZSgnTG9jYWxEYXRlVGltZScsIExPQ0FMX0RBVEVfVElNRV9TVFJVQ1RfU0laRSwgc3RydWN0U2l6ZSk7XG5cbiAgdmFyIGVwb2NoU2Vjb25kID0gdW5wYWNrZXIudW5wYWNrSW50ZWdlcihidWZmZXIpO1xuICB2YXIgbmFubyA9IHVucGFja2VyLnVucGFja0ludGVnZXIoYnVmZmVyKTtcbiAgdmFyIHJlc3VsdCA9ICgwLCBfdGVtcG9yYWxVdGlsLmVwb2NoU2Vjb25kQW5kTmFub1RvTG9jYWxEYXRlVGltZSkoZXBvY2hTZWNvbmQsIG5hbm8pO1xuICByZXR1cm4gY29udmVydEludGVnZXJQcm9wc0lmTmVlZGVkKHJlc3VsdCwgZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xufVxuLyoqXG4gKiBQYWNrIGdpdmVuIGRhdGUgdGltZS5cbiAqIEBwYXJhbSB7RGF0ZVRpbWV9IHZhbHVlIHRoZSBkYXRlIHRpbWUgdmFsdWUgdG8gcGFjay5cbiAqIEBwYXJhbSB7UGFja2VyfSBwYWNrZXIgdGhlIHBhY2tlciB0byB1c2UuXG4gKi9cblxuXG5mdW5jdGlvbiBwYWNrRGF0ZVRpbWUodmFsdWUsIHBhY2tlcikge1xuICBpZiAodmFsdWUudGltZVpvbmVJZCkge1xuICAgIHBhY2tEYXRlVGltZVdpdGhab25lSWQodmFsdWUsIHBhY2tlcik7XG4gIH0gZWxzZSB7XG4gICAgcGFja0RhdGVUaW1lV2l0aFpvbmVPZmZzZXQodmFsdWUsIHBhY2tlcik7XG4gIH1cbn1cbi8qKlxuICogUGFjayBnaXZlbiBkYXRlIHRpbWUgd2l0aCB6b25lIG9mZnNldC5cbiAqIEBwYXJhbSB7RGF0ZVRpbWV9IHZhbHVlIHRoZSBkYXRlIHRpbWUgdmFsdWUgdG8gcGFjay5cbiAqIEBwYXJhbSB7UGFja2VyfSBwYWNrZXIgdGhlIHBhY2tlciB0byB1c2UuXG4gKi9cblxuXG5mdW5jdGlvbiBwYWNrRGF0ZVRpbWVXaXRoWm9uZU9mZnNldCh2YWx1ZSwgcGFja2VyKSB7XG4gIHZhciBlcG9jaFNlY29uZCA9ICgwLCBfdGVtcG9yYWxVdGlsLmxvY2FsRGF0ZVRpbWVUb0Vwb2NoU2Vjb25kKSh2YWx1ZS55ZWFyLCB2YWx1ZS5tb250aCwgdmFsdWUuZGF5LCB2YWx1ZS5ob3VyLCB2YWx1ZS5taW51dGUsIHZhbHVlLnNlY29uZCwgdmFsdWUubmFub3NlY29uZCk7XG4gIHZhciBuYW5vID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKSh2YWx1ZS5uYW5vc2Vjb25kKTtcbiAgdmFyIHRpbWVab25lT2Zmc2V0U2Vjb25kcyA9ICgwLCBfaW50ZWdlcltcImludFwiXSkodmFsdWUudGltZVpvbmVPZmZzZXRTZWNvbmRzKTtcbiAgdmFyIHBhY2thYmxlU3RydWN0RmllbGRzID0gW3BhY2tlci5wYWNrYWJsZShlcG9jaFNlY29uZCksIHBhY2tlci5wYWNrYWJsZShuYW5vKSwgcGFja2VyLnBhY2thYmxlKHRpbWVab25lT2Zmc2V0U2Vjb25kcyldO1xuICBwYWNrZXIucGFja1N0cnVjdChEQVRFX1RJTUVfV0lUSF9aT05FX09GRlNFVCwgcGFja2FibGVTdHJ1Y3RGaWVsZHMpO1xufVxuLyoqXG4gKiBVbnBhY2sgZGF0ZSB0aW1lIHdpdGggem9uZSBvZmZzZXQgdmFsdWUgdXNpbmcgdGhlIGdpdmVuIHVucGFja2VyLlxuICogQHBhcmFtIHtVbnBhY2tlcn0gdW5wYWNrZXIgdGhlIHVucGFja2VyIHRvIHVzZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJ1Y3RTaXplIHRoZSByZXRyaWV2ZWQgc3RydWN0IHNpemUuXG4gKiBAcGFyYW0ge0Jhc2VCdWZmZXJ9IGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHVucGFjayBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlTG9zc2xlc3NJbnRlZ2VycyBpZiBpbnRlZ2VyIHByb3BlcnRpZXMgaW4gdGhlIHJlc3VsdCBkYXRlLXRpbWUgc2hvdWxkIGJlIG5hdGl2ZSBKUyBudW1iZXJzLlxuICogQHJldHVybiB7RGF0ZVRpbWV9IHRoZSB1bnBhY2tlZCBkYXRlIHRpbWUgd2l0aCB6b25lIG9mZnNldCB2YWx1ZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHVucGFja0RhdGVUaW1lV2l0aFpvbmVPZmZzZXQodW5wYWNrZXIsIHN0cnVjdFNpemUsIGJ1ZmZlciwgZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpIHtcbiAgdW5wYWNrZXIuX3ZlcmlmeVN0cnVjdFNpemUoJ0RhdGVUaW1lV2l0aFpvbmVPZmZzZXQnLCBEQVRFX1RJTUVfV0lUSF9aT05FX09GRlNFVF9TVFJVQ1RfU0laRSwgc3RydWN0U2l6ZSk7XG5cbiAgdmFyIGVwb2NoU2Vjb25kID0gdW5wYWNrZXIudW5wYWNrSW50ZWdlcihidWZmZXIpO1xuICB2YXIgbmFubyA9IHVucGFja2VyLnVucGFja0ludGVnZXIoYnVmZmVyKTtcbiAgdmFyIHRpbWVab25lT2Zmc2V0U2Vjb25kcyA9IHVucGFja2VyLnVucGFja0ludGVnZXIoYnVmZmVyKTtcbiAgdmFyIGxvY2FsRGF0ZVRpbWUgPSAoMCwgX3RlbXBvcmFsVXRpbC5lcG9jaFNlY29uZEFuZE5hbm9Ub0xvY2FsRGF0ZVRpbWUpKGVwb2NoU2Vjb25kLCBuYW5vKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBfdGVtcG9yYWxUeXBlcy5EYXRlVGltZShsb2NhbERhdGVUaW1lLnllYXIsIGxvY2FsRGF0ZVRpbWUubW9udGgsIGxvY2FsRGF0ZVRpbWUuZGF5LCBsb2NhbERhdGVUaW1lLmhvdXIsIGxvY2FsRGF0ZVRpbWUubWludXRlLCBsb2NhbERhdGVUaW1lLnNlY29uZCwgbG9jYWxEYXRlVGltZS5uYW5vc2Vjb25kLCB0aW1lWm9uZU9mZnNldFNlY29uZHMsIG51bGwpO1xuICByZXR1cm4gY29udmVydEludGVnZXJQcm9wc0lmTmVlZGVkKHJlc3VsdCwgZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpO1xufVxuLyoqXG4gKiBQYWNrIGdpdmVuIGRhdGUgdGltZSB3aXRoIHpvbmUgaWQuXG4gKiBAcGFyYW0ge0RhdGVUaW1lfSB2YWx1ZSB0aGUgZGF0ZSB0aW1lIHZhbHVlIHRvIHBhY2suXG4gKiBAcGFyYW0ge1BhY2tlcn0gcGFja2VyIHRoZSBwYWNrZXIgdG8gdXNlLlxuICovXG5cblxuZnVuY3Rpb24gcGFja0RhdGVUaW1lV2l0aFpvbmVJZCh2YWx1ZSwgcGFja2VyKSB7XG4gIHZhciBlcG9jaFNlY29uZCA9ICgwLCBfdGVtcG9yYWxVdGlsLmxvY2FsRGF0ZVRpbWVUb0Vwb2NoU2Vjb25kKSh2YWx1ZS55ZWFyLCB2YWx1ZS5tb250aCwgdmFsdWUuZGF5LCB2YWx1ZS5ob3VyLCB2YWx1ZS5taW51dGUsIHZhbHVlLnNlY29uZCwgdmFsdWUubmFub3NlY29uZCk7XG4gIHZhciBuYW5vID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKSh2YWx1ZS5uYW5vc2Vjb25kKTtcbiAgdmFyIHRpbWVab25lSWQgPSB2YWx1ZS50aW1lWm9uZUlkO1xuICB2YXIgcGFja2FibGVTdHJ1Y3RGaWVsZHMgPSBbcGFja2VyLnBhY2thYmxlKGVwb2NoU2Vjb25kKSwgcGFja2VyLnBhY2thYmxlKG5hbm8pLCBwYWNrZXIucGFja2FibGUodGltZVpvbmVJZCldO1xuICBwYWNrZXIucGFja1N0cnVjdChEQVRFX1RJTUVfV0lUSF9aT05FX0lELCBwYWNrYWJsZVN0cnVjdEZpZWxkcyk7XG59XG4vKipcbiAqIFVucGFjayBkYXRlIHRpbWUgd2l0aCB6b25lIGlkIHZhbHVlIHVzaW5nIHRoZSBnaXZlbiB1bnBhY2tlci5cbiAqIEBwYXJhbSB7VW5wYWNrZXJ9IHVucGFja2VyIHRoZSB1bnBhY2tlciB0byB1c2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RydWN0U2l6ZSB0aGUgcmV0cmlldmVkIHN0cnVjdCBzaXplLlxuICogQHBhcmFtIHtCYXNlQnVmZmVyfSBidWZmZXIgdGhlIGJ1ZmZlciB0byB1bnBhY2sgZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMgaWYgaW50ZWdlciBwcm9wZXJ0aWVzIGluIHRoZSByZXN1bHQgZGF0ZS10aW1lIHNob3VsZCBiZSBuYXRpdmUgSlMgbnVtYmVycy5cbiAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgdW5wYWNrZWQgZGF0ZSB0aW1lIHdpdGggem9uZSBpZCB2YWx1ZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHVucGFja0RhdGVUaW1lV2l0aFpvbmVJZCh1bnBhY2tlciwgc3RydWN0U2l6ZSwgYnVmZmVyLCBkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycykge1xuICB1bnBhY2tlci5fdmVyaWZ5U3RydWN0U2l6ZSgnRGF0ZVRpbWVXaXRoWm9uZUlkJywgREFURV9USU1FX1dJVEhfWk9ORV9JRF9TVFJVQ1RfU0laRSwgc3RydWN0U2l6ZSk7XG5cbiAgdmFyIGVwb2NoU2Vjb25kID0gdW5wYWNrZXIudW5wYWNrSW50ZWdlcihidWZmZXIpO1xuICB2YXIgbmFubyA9IHVucGFja2VyLnVucGFja0ludGVnZXIoYnVmZmVyKTtcbiAgdmFyIHRpbWVab25lSWQgPSB1bnBhY2tlci51bnBhY2soYnVmZmVyKTtcbiAgdmFyIGxvY2FsRGF0ZVRpbWUgPSAoMCwgX3RlbXBvcmFsVXRpbC5lcG9jaFNlY29uZEFuZE5hbm9Ub0xvY2FsRGF0ZVRpbWUpKGVwb2NoU2Vjb25kLCBuYW5vKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBfdGVtcG9yYWxUeXBlcy5EYXRlVGltZShsb2NhbERhdGVUaW1lLnllYXIsIGxvY2FsRGF0ZVRpbWUubW9udGgsIGxvY2FsRGF0ZVRpbWUuZGF5LCBsb2NhbERhdGVUaW1lLmhvdXIsIGxvY2FsRGF0ZVRpbWUubWludXRlLCBsb2NhbERhdGVUaW1lLnNlY29uZCwgbG9jYWxEYXRlVGltZS5uYW5vc2Vjb25kLCBudWxsLCB0aW1lWm9uZUlkKTtcbiAgcmV0dXJuIGNvbnZlcnRJbnRlZ2VyUHJvcHNJZk5lZWRlZChyZXN1bHQsIGRpc2FibGVMb3NzbGVzc0ludGVnZXJzKTtcbn1cblxuZnVuY3Rpb24gY29udmVydEludGVnZXJQcm9wc0lmTmVlZGVkKG9iaiwgZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnMpIHtcbiAgaWYgKCFkaXNhYmxlTG9zc2xlc3NJbnRlZ2Vycykge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgY2xvbmUgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcblxuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgICAgIGNsb25lW3Byb3BdID0gKDAsIF9pbnRlZ2VyLmlzSW50KSh2YWx1ZSkgPyB2YWx1ZS50b051bWJlck9ySW5maW5pdHkoKSA6IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5mcmVlemUoY2xvbmUpO1xuICByZXR1cm4gY2xvbmU7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ERUZBVUxUX0FDUVVJU0lUSU9OX1RJTUVPVVQgPSBleHBvcnRzLkRFRkFVTFRfTUFYX1NJWkUgPSBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgREVGQVVMVF9NQVhfU0laRSA9IDEwMDtcbmV4cG9ydHMuREVGQVVMVF9NQVhfU0laRSA9IERFRkFVTFRfTUFYX1NJWkU7XG52YXIgREVGQVVMVF9BQ1FVSVNJVElPTl9USU1FT1VUID0gNjAgKiAxMDAwOyAvLyA2MCBzZWNvbmRzXG5cbmV4cG9ydHMuREVGQVVMVF9BQ1FVSVNJVElPTl9USU1FT1VUID0gREVGQVVMVF9BQ1FVSVNJVElPTl9USU1FT1VUO1xuXG52YXIgUG9vbENvbmZpZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBvb2xDb25maWcobWF4U2l6ZSwgYWNxdWlzaXRpb25UaW1lb3V0KSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBQb29sQ29uZmlnKTtcbiAgICB0aGlzLm1heFNpemUgPSB2YWx1ZU9yRGVmYXVsdChtYXhTaXplLCBERUZBVUxUX01BWF9TSVpFKTtcbiAgICB0aGlzLmFjcXVpc2l0aW9uVGltZW91dCA9IHZhbHVlT3JEZWZhdWx0KGFjcXVpc2l0aW9uVGltZW91dCwgREVGQVVMVF9BQ1FVSVNJVElPTl9USU1FT1VUKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUG9vbENvbmZpZywgbnVsbCwgW3tcbiAgICBrZXk6IFwiZGVmYXVsdENvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0Q29uZmlnKCkge1xuICAgICAgcmV0dXJuIG5ldyBQb29sQ29uZmlnKERFRkFVTFRfTUFYX1NJWkUsIERFRkFVTFRfQUNRVUlTSVRJT05fVElNRU9VVCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21Ecml2ZXJDb25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbURyaXZlckNvbmZpZyhjb25maWcpIHtcbiAgICAgIHZhciBtYXhTaXplQ29uZmlndXJlZCA9IGlzQ29uZmlndXJlZChjb25maWcubWF4Q29ubmVjdGlvblBvb2xTaXplKTtcbiAgICAgIHZhciBtYXhTaXplID0gbWF4U2l6ZUNvbmZpZ3VyZWQgPyBjb25maWcubWF4Q29ubmVjdGlvblBvb2xTaXplIDogREVGQVVMVF9NQVhfU0laRTtcbiAgICAgIHZhciBhY3F1aXNpdGlvblRpbWVvdXRDb25maWd1cmVkID0gaXNDb25maWd1cmVkKGNvbmZpZy5jb25uZWN0aW9uQWNxdWlzaXRpb25UaW1lb3V0KTtcbiAgICAgIHZhciBhY3F1aXNpdGlvblRpbWVvdXQgPSBhY3F1aXNpdGlvblRpbWVvdXRDb25maWd1cmVkID8gY29uZmlnLmNvbm5lY3Rpb25BY3F1aXNpdGlvblRpbWVvdXQgOiBERUZBVUxUX0FDUVVJU0lUSU9OX1RJTUVPVVQ7XG4gICAgICByZXR1cm4gbmV3IFBvb2xDb25maWcobWF4U2l6ZSwgYWNxdWlzaXRpb25UaW1lb3V0KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBvb2xDb25maWc7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUG9vbENvbmZpZztcblxuZnVuY3Rpb24gdmFsdWVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IDAgfHwgdmFsdWUgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gaXNDb25maWd1cmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gMCB8fCB2YWx1ZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcG9vbENvbmZpZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcG9vbC1jb25maWdcIikpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xuXG52YXIgX2xvZ2dlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbG9nZ2VyXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgUG9vbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGFkZHJlc3M6IFNlcnZlckFkZHJlc3MsIGZ1bmN0aW9uKGFkZHJlc3M6IFNlcnZlckFkZHJlc3MsIHJlc291cmNlOiBvYmplY3QpOiBQcm9taXNlPG9iamVjdD4pOiBQcm9taXNlPG9iamVjdD59IGNyZWF0ZVxuICAgKiAgICAgICAgICAgICAgICBhbiBhbGxvY2F0aW9uIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIHByb21pc2Ugd2l0aCBhIG5ldyByZXNvdXJjZS4gSXQncyBnaXZlbiBhbiBhZGRyZXNzIGZvciB3aGljaCB0b1xuICAgKiAgICAgICAgICAgICAgICBhbGxvY2F0ZSB0aGUgY29ubmVjdGlvbiBhbmQgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIHRoZSByZXNvdXJjZSB0byB0aGUgcG9vbCBpZiBpbnZva2VkLCB3aGljaCBpc1xuICAgKiAgICAgICAgICAgICAgICBtZWFudCB0byBiZSBjYWxsZWQgb24gLmRpc3Bvc2Ugb3IgLmNsb3NlIG9yIHdoYXRldmVyIG1lY2hhbmlzbSB0aGUgcmVzb3VyY2UgdXNlcyB0byBmaW5hbGl6ZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihyZXNvdXJjZTogb2JqZWN0KTogUHJvbWlzZTx2b2lkPn0gZGVzdHJveVxuICAgKiAgICAgICAgICAgICAgICBjYWxsZWQgd2l0aCB0aGUgcmVzb3VyY2Ugd2hlbiBpdCBpcyBldmljdGVkIGZyb20gdGhpcyBwb29sXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24ocmVzb3VyY2U6IG9iamVjdCk6IGJvb2xlYW59IHZhbGlkYXRlXG4gICAqICAgICAgICAgICAgICAgIGNhbGxlZCBhdCB2YXJpb3VzIHRpbWVzIChsaWtlIHdoZW4gYW4gaW5zdGFuY2UgaXMgYWNxdWlyZWQgYW5kIHdoZW4gaXQgaXMgcmV0dXJuZWQuXG4gICAqICAgICAgICAgICAgICAgIElmIHRoaXMgcmV0dXJucyBmYWxzZSwgdGhlIHJlc291cmNlIHdpbGwgYmUgZXZpY3RlZFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHJlc291cmNlOiBvYmplY3QsIG9ic2VydmVyOiB7IG9uRXJyb3IgfSk6IHZvaWR9IGluc3RhbGxJZGxlT2JzZXJ2ZXJcbiAgICogICAgICAgICAgICAgICAgY2FsbGVkIHdoZW4gdGhlIHJlc291cmNlIGlzIHJlbGVhc2VkIGJhY2sgdG8gcG9vbFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHJlc291cmNlOiBvYmplY3QpOiB2b2lkfSByZW1vdmVJZGxlT2JzZXJ2ZXJcbiAgICogICAgICAgICAgICAgICAgY2FsbGVkIHdoZW4gdGhlIHJlc291cmNlIGlzIGFjcXVpcmVkIGZyb20gdGhlIHBvb2xcbiAgICogQHBhcmFtIHtQb29sQ29uZmlnfSBjb25maWcgY29uZmlndXJhdGlvbiBmb3IgdGhlIG5ldyBkcml2ZXIuXG4gICAqIEBwYXJhbSB7TG9nZ2VyfSBsb2cgdGhlIGRyaXZlciBsb2dnZXIuXG4gICAqL1xuICBmdW5jdGlvbiBQb29sKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgX3JlZiRjcmVhdGUgPSBfcmVmLmNyZWF0ZSxcbiAgICAgICAgY3JlYXRlID0gX3JlZiRjcmVhdGUgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChhZGRyZXNzLCByZWxlYXNlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSA6IF9yZWYkY3JlYXRlLFxuICAgICAgICBfcmVmJGRlc3Ryb3kgPSBfcmVmLmRlc3Ryb3ksXG4gICAgICAgIGRlc3Ryb3kgPSBfcmVmJGRlc3Ryb3kgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChjb25uKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSA6IF9yZWYkZGVzdHJveSxcbiAgICAgICAgX3JlZiR2YWxpZGF0ZSA9IF9yZWYudmFsaWRhdGUsXG4gICAgICAgIHZhbGlkYXRlID0gX3JlZiR2YWxpZGF0ZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGNvbm4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gOiBfcmVmJHZhbGlkYXRlLFxuICAgICAgICBfcmVmJGluc3RhbGxJZGxlT2JzZXIgPSBfcmVmLmluc3RhbGxJZGxlT2JzZXJ2ZXIsXG4gICAgICAgIGluc3RhbGxJZGxlT2JzZXJ2ZXIgPSBfcmVmJGluc3RhbGxJZGxlT2JzZXIgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChjb25uLCBvYnNlcnZlcikge30gOiBfcmVmJGluc3RhbGxJZGxlT2JzZXIsXG4gICAgICAgIF9yZWYkcmVtb3ZlSWRsZU9ic2VydiA9IF9yZWYucmVtb3ZlSWRsZU9ic2VydmVyLFxuICAgICAgICByZW1vdmVJZGxlT2JzZXJ2ZXIgPSBfcmVmJHJlbW92ZUlkbGVPYnNlcnYgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChjb25uKSB7fSA6IF9yZWYkcmVtb3ZlSWRsZU9ic2VydixcbiAgICAgICAgX3JlZiRjb25maWcgPSBfcmVmLmNvbmZpZyxcbiAgICAgICAgY29uZmlnID0gX3JlZiRjb25maWcgPT09IHZvaWQgMCA/IF9wb29sQ29uZmlnW1wiZGVmYXVsdFwiXS5kZWZhdWx0Q29uZmlnKCkgOiBfcmVmJGNvbmZpZyxcbiAgICAgICAgX3JlZiRsb2cgPSBfcmVmLmxvZyxcbiAgICAgICAgbG9nID0gX3JlZiRsb2cgPT09IHZvaWQgMCA/IF9sb2dnZXJbXCJkZWZhdWx0XCJdLm5vT3AoKSA6IF9yZWYkbG9nO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBQb29sKTtcbiAgICB0aGlzLl9jcmVhdGUgPSBjcmVhdGU7XG4gICAgdGhpcy5fZGVzdHJveSA9IGRlc3Ryb3k7XG4gICAgdGhpcy5fdmFsaWRhdGUgPSB2YWxpZGF0ZTtcbiAgICB0aGlzLl9pbnN0YWxsSWRsZU9ic2VydmVyID0gaW5zdGFsbElkbGVPYnNlcnZlcjtcbiAgICB0aGlzLl9yZW1vdmVJZGxlT2JzZXJ2ZXIgPSByZW1vdmVJZGxlT2JzZXJ2ZXI7XG4gICAgdGhpcy5fbWF4U2l6ZSA9IGNvbmZpZy5tYXhTaXplO1xuICAgIHRoaXMuX2FjcXVpc2l0aW9uVGltZW91dCA9IGNvbmZpZy5hY3F1aXNpdGlvblRpbWVvdXQ7XG4gICAgdGhpcy5fcG9vbHMgPSB7fTtcbiAgICB0aGlzLl9wZW5kaW5nQ3JlYXRlcyA9IHt9O1xuICAgIHRoaXMuX2FjcXVpcmVSZXF1ZXN0cyA9IHt9O1xuICAgIHRoaXMuX2FjdGl2ZVJlc291cmNlQ291bnRzID0ge307XG4gICAgdGhpcy5fcmVsZWFzZSA9IHRoaXMuX3JlbGVhc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9sb2cgPSBsb2c7XG4gICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFjcXVpcmUgYW5kIGlkbGUgcmVzb3VyY2UgZm9tIHRoZSBwb29sIG9yIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAqIEBwYXJhbSB7U2VydmVyQWRkcmVzc30gYWRkcmVzcyB0aGUgYWRkcmVzcyBmb3Igd2hpY2ggd2UncmUgYWNxdWlyaW5nLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHJlc291cmNlIHRoYXQgaXMgcmVhZHkgdG8gdXNlLlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUG9vbCwgW3tcbiAgICBrZXk6IFwiYWNxdWlyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY3F1aXJlKGFkZHJlc3MpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlKGFkZHJlc3MpLnRoZW4oZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgICAgIHZhciBrZXkgPSBhZGRyZXNzLmFzS2V5KCk7XG5cbiAgICAgICAgaWYgKHJlc291cmNlKSB7XG4gICAgICAgICAgcmVzb3VyY2VBY3F1aXJlZChrZXksIF90aGlzLl9hY3RpdmVSZXNvdXJjZUNvdW50cyk7XG5cbiAgICAgICAgICBpZiAoX3RoaXMuX2xvZy5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKFwiXCIuY29uY2F0KHJlc291cmNlLCBcIiBhY3F1aXJlZCBmcm9tIHRoZSBwb29sIFwiKS5jb25jYXQoa2V5KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc291cmNlO1xuICAgICAgICB9IC8vIFdlJ3JlIG91dCBvZiByZXNvdXJjZXMgYW5kIHdpbGwgdHJ5IHRvIGFjcXVpcmUgbGF0ZXIgb24gd2hlbiBhbiBleGlzdGluZyByZXNvdXJjZSBpcyByZWxlYXNlZC5cblxuXG4gICAgICAgIHZhciBhbGxSZXF1ZXN0cyA9IF90aGlzLl9hY3F1aXJlUmVxdWVzdHM7XG4gICAgICAgIHZhciByZXF1ZXN0cyA9IGFsbFJlcXVlc3RzW2tleV07XG5cbiAgICAgICAgaWYgKCFyZXF1ZXN0cykge1xuICAgICAgICAgIGFsbFJlcXVlc3RzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlcXVlc3Q7XG4gICAgICAgICAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gYWNxdWlzaXRpb24gdGltZW91dCBmaXJlZFxuICAgICAgICAgICAgLy8gcmVtb3ZlIHJlcXVlc3QgZnJvbSB0aGUgcXVldWUgb2YgcGVuZGluZyByZXF1ZXN0cywgaWYgaXQncyBzdGlsbCB0aGVyZVxuICAgICAgICAgICAgLy8gcmVxdWVzdCBtaWdodCd2ZSBiZWVuIHRha2VuIG91dCBieSB0aGUgcmVsZWFzZSBvcGVyYXRpb25cbiAgICAgICAgICAgIHZhciBwZW5kaW5nUmVxdWVzdHMgPSBhbGxSZXF1ZXN0c1trZXldO1xuXG4gICAgICAgICAgICBpZiAocGVuZGluZ1JlcXVlc3RzKSB7XG4gICAgICAgICAgICAgIGFsbFJlcXVlc3RzW2tleV0gPSBwZW5kaW5nUmVxdWVzdHMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0gIT09IHJlcXVlc3Q7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5pc0NvbXBsZXRlZCgpKSB7Ly8gcmVxdWVzdCBhbHJlYWR5IHJlc29sdmVkL3JlamVjdGVkIGJ5IHRoZSByZWxlYXNlIG9wZXJhdGlvbjsgbm90aGluZyB0byBkb1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmVxdWVzdCBpcyBzdGlsbCBwZW5kaW5nIGFuZCBuZWVkcyB0byBiZSBmYWlsZWRcbiAgICAgICAgICAgICAgdmFyIGFjdGl2ZUNvdW50ID0gX3RoaXMuYWN0aXZlUmVzb3VyY2VDb3VudChhZGRyZXNzKTtcblxuICAgICAgICAgICAgICB2YXIgaWRsZUNvdW50ID0gX3RoaXMuaGFzKGFkZHJlc3MpID8gX3RoaXMuX3Bvb2xzW2tleV0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgcmVxdWVzdC5yZWplY3QoKDAsIF9lcnJvci5uZXdFcnJvcikoXCJDb25uZWN0aW9uIGFjcXVpc2l0aW9uIHRpbWVkIG91dCBpbiBcIi5jb25jYXQoX3RoaXMuX2FjcXVpc2l0aW9uVGltZW91dCwgXCIgbXMuIFBvb3Mgc3RhdHVzOiBBY3RpdmUgY29ubiBjb3VudCA9IFwiKS5jb25jYXQoYWN0aXZlQ291bnQsIFwiLCBJZGxlIGNvbm4gY291bnQgPSBcIikuY29uY2F0KGlkbGVDb3VudCwgXCIuXCIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgX3RoaXMuX2FjcXVpc2l0aW9uVGltZW91dCk7XG4gICAgICAgICAgcmVxdWVzdCA9IG5ldyBQZW5kaW5nUmVxdWVzdChrZXksIHJlc29sdmUsIHJlamVjdCwgdGltZW91dElkLCBfdGhpcy5fbG9nKTtcbiAgICAgICAgICBhbGxSZXF1ZXN0c1trZXldLnB1c2gocmVxdWVzdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYWxsIGlkbGUgcmVzb3VyY2VzIGZvciB0aGUgZ2l2ZW4gYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0ge1NlcnZlckFkZHJlc3N9IGFkZHJlc3MgdGhlIGFkZHJlc3Mgb2YgdGhlIHNlcnZlciB0byBwdXJnZSBpdHMgcG9vbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgcmVzb3VyY2VzIGFyZSBwdXJnZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1cmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1cmdlKGFkZHJlc3MpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXJnZUtleShhZGRyZXNzLmFzS2V5KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGFsbCBpZGxlIHJlc291cmNlcyBpbiB0aGlzIHBvb2wuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIHJlc291cmNlcyBhcmUgcHVyZ2VkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHRoaXMuX3Bvb2xzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLl9wdXJnZUtleShrZXkpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBLZWVwIHRoZSBpZGxlIHJlc291cmNlcyBmb3IgdGhlIHByb3ZpZGVkIGFkZHJlc3NlcyBhbmQgcHVyZ2UgdGhlIHJlc3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIG90aGVyIHJlc291cmNlcyBhcmUgcHVyZ2VkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJrZWVwQWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtlZXBBbGwoYWRkcmVzc2VzKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGtleXNUb0tlZXAgPSBhZGRyZXNzZXMubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBhLmFzS2V5KCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBrZXlzUHJlc2VudCA9IE9iamVjdC5rZXlzKHRoaXMuX3Bvb2xzKTtcbiAgICAgIHZhciBrZXlzVG9QdXJnZSA9IGtleXNQcmVzZW50LmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4ga2V5c1RvS2VlcC5pbmRleE9mKGspID09PSAtMTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGtleXNUb1B1cmdlLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBfdGhpczMuX3B1cmdlS2V5KGtleSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgcG9vbCBjb250YWlucyByZXNvdXJjZXMgZm9yIHRoZSBnaXZlbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7U2VydmVyQWRkcmVzc30gYWRkcmVzcyB0aGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCB3aGVuIHBvb2wgY29udGFpbnMgZW50cmllcyBmb3IgdGhlIGdpdmVuIGtleSwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoYWRkcmVzcykge1xuICAgICAgcmV0dXJuIGFkZHJlc3MuYXNLZXkoKSBpbiB0aGlzLl9wb29scztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGNvdW50IG9mIGFjdGl2ZSAoY2hlY2tlZCBvdXQgb2YgdGhlIHBvb2wpIHJlc291cmNlcyBmb3IgdGhlIGdpdmVuIGtleS5cbiAgICAgKiBAcGFyYW0ge1NlcnZlckFkZHJlc3N9IGFkZHJlc3MgdGhlIGFkZHJlc3Mgb2YgdGhlIHNlcnZlciB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGNvdW50IG9mIHJlc291cmNlcyBhY3F1aXJlZCBieSBjbGllbnRzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWN0aXZlUmVzb3VyY2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY3RpdmVSZXNvdXJjZUNvdW50KGFkZHJlc3MpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVSZXNvdXJjZUNvdW50c1thZGRyZXNzLmFzS2V5KCldIHx8IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hY3F1aXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYWNxdWlyZTIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhZGRyZXNzKSB7XG4gICAgICAgIHZhciBrZXksIHBvb2wsIF9yZXNvdXJjZSwgbnVtQ29ubmVjdGlvbnMsIHJlc291cmNlO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ1Bvb2wgaXMgY2xvc2VkLCBpdCBpcyBubyBtb3JlIGFibGUgdG8gc2VydmUgcmVxdWVzdHMuJyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGtleSA9IGFkZHJlc3MuYXNLZXkoKTtcbiAgICAgICAgICAgICAgICBwb29sID0gdGhpcy5fcG9vbHNba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmICghcG9vbCkge1xuICAgICAgICAgICAgICAgICAgcG9vbCA9IFtdO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcG9vbHNba2V5XSA9IHBvb2w7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nQ3JlYXRlc1trZXldID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGlmICghcG9vbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9yZXNvdXJjZSA9IHBvb2wucG9wKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKF9yZXNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZW1vdmVJZGxlT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUlkbGVPYnNlcnZlcihfcmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgIH0gLy8gaWRsZSByZXNvdXJjZSBpcyB2YWxpZCBhbmQgY2FuIGJlIGFjcXVpcmVkXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgUHJvbWlzZS5yZXNvbHZlKF9yZXNvdXJjZSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXN0cm95KF9yZXNvdXJjZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX21heFNpemUgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSW5jbHVkZSBwZW5kaW5nIGNyZWF0ZXMgd2hlbiBjaGVja2luZyBwb29sIHNpemUgc2luY2UgdGhlc2UgcHJvYmFibHkgd2lsbCBhZGRcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgbnVtYmVyIHdoZW4gZnVsZmlsbGVkLlxuICAgICAgICAgICAgICAgIG51bUNvbm5lY3Rpb25zID0gdGhpcy5hY3RpdmVSZXNvdXJjZUNvdW50KGFkZHJlc3MpICsgdGhpcy5fcGVuZGluZ0NyZWF0ZXNba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmICghKG51bUNvbm5lY3Rpb25zID49IHRoaXMuX21heFNpemUpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgZXhpc3Qgbm8gaWRsZSB2YWxpZCByZXNvdXJjZXMsIGNyZWF0ZSBhIG5ldyBvbmUgZm9yIGFjcXVpc2l0aW9uXG4gICAgICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBob3cgbWFueSBwZW5kaW5nIGNyZWF0ZXMgdGhlcmUgYXJlIHRvIGF2b2lkIG1ha2luZyB0b28gbWFueSBjb25uZWN0aW9ucy5cbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nQ3JlYXRlc1trZXldID0gdGhpcy5fcGVuZGluZ0NyZWF0ZXNba2V5XSArIDE7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDIxO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlKGFkZHJlc3MsIHRoaXMuX3JlbGVhc2UpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI1O1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDcmVhdGVzW2tleV0gPSB0aGlzLl9wZW5kaW5nQ3JlYXRlc1trZXldIC0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDI1KTtcblxuICAgICAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzb3VyY2UpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcywgW1syMSwsIDI1LCAyOF1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2FjcXVpcmUoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9hY3F1aXJlMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2FjcXVpcmU7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbGVhc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWxlYXNlMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMihhZGRyZXNzLCByZXNvdXJjZSkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICB2YXIga2V5LCBwb29sO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBrZXkgPSBhZGRyZXNzLmFzS2V5KCk7XG4gICAgICAgICAgICAgICAgcG9vbCA9IHRoaXMuX3Bvb2xzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXBvb2wpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdmFsaWRhdGUocmVzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbG9nLmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIlwiLmNvbmNhdChyZXNvdXJjZSwgXCIgZGVzdHJveWVkIGFuZCBjYW4ndCBiZSByZWxlYXNlZCB0byB0aGUgcG9vbCBcIikuY29uY2F0KGtleSwgXCIgYmVjYXVzZSBpdCBpcyBub3QgZnVuY3Rpb25hbFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXN0cm95KHJlc291cmNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luc3RhbGxJZGxlT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbGxJZGxlT2JzZXJ2ZXIocmVzb3VyY2UsIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzNC5fbG9nLmRlYnVnKFwiSWRsZSBjb25uZWN0aW9uIFwiLmNvbmNhdChyZXNvdXJjZSwgXCIgZGVzdHJveWVkIGJlY2F1c2Ugb2YgZXJyb3I6IFwiKS5jb25jYXQoZXJyb3IpKTtcblxuICAgICAgICAgICAgICAgICAgICAgIHZhciBwb29sID0gX3RoaXM0Ll9wb29sc1trZXldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzNC5fcG9vbHNba2V5XSA9IHBvb2wuZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByICE9PSByZXNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH0gLy8gbGV0J3Mgbm90IGNhcmUgYWJvdXQgYmFja2dyb3VuZCBjbGVhbi11cHMgZHVlIHRvIGVycm9ycyBidXQganVzdCB0cmlnZ2VyIHRoZSBkZXN0cm95XG4gICAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VzcyBmb3IgdGhlIHJlc291cmNlLCB3ZSBlc3BlY2lhbGx5IGNhdGNoIGFueSBlcnJvcnMgYW5kIGlnbm9yZSB0aGVtIHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgICAgICAgLy8gdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uIHdhcm5pbmdzXG5cblxuICAgICAgICAgICAgICAgICAgICAgIF90aGlzNC5fZGVzdHJveShyZXNvdXJjZSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvb2wucHVzaChyZXNvdXJjZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbG9nLmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIlwiLmNvbmNhdChyZXNvdXJjZSwgXCIgcmVsZWFzZWQgdG8gdGhlIHBvb2wgXCIpLmNvbmNhdChrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgLy8ga2V5IGhhcyBiZWVuIHB1cmdlZCwgZG9uJ3QgcHV0IGl0IGJhY2ssIGp1c3QgZGVzdHJveSB0aGUgcmVzb3VyY2VcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbG9nLmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIlwiLmNvbmNhdChyZXNvdXJjZSwgXCIgZGVzdHJveWVkIGFuZCBjYW4ndCBiZSByZWxlYXNlZCB0byB0aGUgcG9vbCBcIikuY29uY2F0KGtleSwgXCIgYmVjYXVzZSBwb29sIGhhcyBiZWVuIHB1cmdlZFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVzdHJveShyZXNvdXJjZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICByZXNvdXJjZVJlbGVhc2VkKGtleSwgdGhpcy5fYWN0aXZlUmVzb3VyY2VDb3VudHMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1BlbmRpbmdBY3F1aXJlUmVxdWVzdHMoYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfcmVsZWFzZShfeDIsIF94Mykge1xuICAgICAgICByZXR1cm4gX3JlbGVhc2UyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVsZWFzZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfcHVyZ2VLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9wdXJnZUtleTIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoa2V5KSB7XG4gICAgICAgIHZhciBwb29sLCByZXNvdXJjZTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcG9vbCA9IHRoaXMuX3Bvb2xzW2tleV0gfHwgW107XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGlmICghcG9vbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc291cmNlID0gcG9vbC5wb3AoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZW1vdmVJZGxlT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUlkbGVPYnNlcnZlcihyZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXN0cm95KHJlc291cmNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcG9vbHNba2V5XTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX3B1cmdlS2V5KF94NCkge1xuICAgICAgICByZXR1cm4gX3B1cmdlS2V5Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3B1cmdlS2V5O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9wcm9jZXNzUGVuZGluZ0FjcXVpcmVSZXF1ZXN0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJvY2Vzc1BlbmRpbmdBY3F1aXJlUmVxdWVzdHMoYWRkcmVzcykge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBrZXkgPSBhZGRyZXNzLmFzS2V5KCk7XG4gICAgICB2YXIgcmVxdWVzdHMgPSB0aGlzLl9hY3F1aXJlUmVxdWVzdHNba2V5XTtcblxuICAgICAgaWYgKHJlcXVlc3RzKSB7XG4gICAgICAgIHZhciBwZW5kaW5nUmVxdWVzdCA9IHJlcXVlc3RzLnNoaWZ0KCk7IC8vIHBvcCBhIHBlbmRpbmcgYWNxdWlyZSByZXF1ZXN0XG5cbiAgICAgICAgaWYgKHBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICAgICAgdGhpcy5fYWNxdWlyZShhZGRyZXNzKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgLy8gZmFpbGVkIHRvIGFjcXVpcmUvY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24gdG8gcmVzb2x2ZSB0aGUgcGVuZGluZyBhY3F1aXJlIHJlcXVlc3RcbiAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSB0aGUgZXJyb3IgYnkgZmFpbGluZyB0aGUgcGVuZGluZyByZXF1ZXN0XG4gICAgICAgICAgICBwZW5kaW5nUmVxdWVzdC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgICAgICAgICAvLyBtYW5hZ2VkIHRvIGFjcXVpcmUgYSB2YWxpZCByZXNvdXJjZSBmcm9tIHRoZSBwb29sXG4gICAgICAgICAgICAgIGlmIChwZW5kaW5nUmVxdWVzdC5pc0NvbXBsZXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBoYXMgYmVlbiBjb21wbGV0ZWQsIG1vc3QgbGlrZWx5IGZhaWxlZCBieSBhIHRpbWVvdXRcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIGFjcXVpcmVkIHJlc291cmNlIGJhY2sgdG8gdGhlIHBvb2xcbiAgICAgICAgICAgICAgICBfdGhpczUuX3JlbGVhc2UoYWRkcmVzcywgcmVzb3VyY2UpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgaXMgc3RpbGwgcGVuZGluZyBhbmQgY2FuIGJlIHJlc29sdmVkIHdpdGggdGhlIG5ld2x5IGFjcXVpcmVkIHJlc291cmNlXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VBY3F1aXJlZChrZXksIF90aGlzNS5fYWN0aXZlUmVzb3VyY2VDb3VudHMpOyAvLyBpbmNyZW1lbnQgdGhlIGFjdGl2ZSBjb3VudGVyXG5cbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVxdWVzdC5yZXNvbHZlKHJlc291cmNlKTsgLy8gcmVzb2x2ZSB0aGUgcGVuZGluZyByZXF1ZXN0IHdpdGggdGhlIGFjcXVpcmVkIHJlc291cmNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fYWNxdWlyZVJlcXVlc3RzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBvb2w7XG59KCk7XG4vKipcbiAqIEluY3JlbWVudCBhY3RpdmUgKGNoZWNrZWQgb3V0IG9mIHRoZSBwb29sKSByZXNvdXJjZSBjb3VudGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0aGUgcmVzb3VyY2UgZ3JvdXAgaWRlbnRpZmllciAoc2VydmVyIGFkZHJlc3MgZm9yIGNvbm5lY3Rpb25zKS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGFjdGl2ZVJlc291cmNlQ291bnRzIHRoZSBvYmplY3QgaG9sZGluZyBhY3RpdmUgY291bnRzIHBlciBrZXkuXG4gKi9cblxuXG5mdW5jdGlvbiByZXNvdXJjZUFjcXVpcmVkKGtleSwgYWN0aXZlUmVzb3VyY2VDb3VudHMpIHtcbiAgdmFyIGN1cnJlbnRDb3VudCA9IGFjdGl2ZVJlc291cmNlQ291bnRzW2tleV0gfHwgMDtcbiAgYWN0aXZlUmVzb3VyY2VDb3VudHNba2V5XSA9IGN1cnJlbnRDb3VudCArIDE7XG59XG4vKipcbiAqIERlY3JlbWVudCBhY3RpdmUgKGNoZWNrZWQgb3V0IG9mIHRoZSBwb29sKSByZXNvdXJjZSBjb3VudGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0aGUgcmVzb3VyY2UgZ3JvdXAgaWRlbnRpZmllciAoc2VydmVyIGFkZHJlc3MgZm9yIGNvbm5lY3Rpb25zKS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGFjdGl2ZVJlc291cmNlQ291bnRzIHRoZSBvYmplY3QgaG9sZGluZyBhY3RpdmUgY291bnRzIHBlciBrZXkuXG4gKi9cblxuXG5mdW5jdGlvbiByZXNvdXJjZVJlbGVhc2VkKGtleSwgYWN0aXZlUmVzb3VyY2VDb3VudHMpIHtcbiAgdmFyIGN1cnJlbnRDb3VudCA9IGFjdGl2ZVJlc291cmNlQ291bnRzW2tleV0gfHwgMDtcbiAgdmFyIG5leHRDb3VudCA9IGN1cnJlbnRDb3VudCAtIDE7XG5cbiAgaWYgKG5leHRDb3VudCA+IDApIHtcbiAgICBhY3RpdmVSZXNvdXJjZUNvdW50c1trZXldID0gbmV4dENvdW50O1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBhY3RpdmVSZXNvdXJjZUNvdW50c1trZXldO1xuICB9XG59XG5cbnZhciBQZW5kaW5nUmVxdWVzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBlbmRpbmdSZXF1ZXN0KGtleSwgcmVzb2x2ZSwgcmVqZWN0LCB0aW1lb3V0SWQsIGxvZykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUGVuZGluZ1JlcXVlc3QpO1xuICAgIHRoaXMuX2tleSA9IGtleTtcbiAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgdGhpcy5fdGltZW91dElkID0gdGltZW91dElkO1xuICAgIHRoaXMuX2xvZyA9IGxvZztcbiAgICB0aGlzLl9jb21wbGV0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUGVuZGluZ1JlcXVlc3QsIFt7XG4gICAga2V5OiBcImlzQ29tcGxldGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQ29tcGxldGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbXBsZXRlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKHJlc291cmNlKSB7XG4gICAgICBpZiAodGhpcy5fY29tcGxldGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0SWQpO1xuXG4gICAgICBpZiAodGhpcy5fbG9nLmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiXCIuY29uY2F0KHJlc291cmNlLCBcIiBhY3F1aXJlZCBmcm9tIHRoZSBwb29sIFwiKS5jb25jYXQodGhpcy5fa2V5KSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Jlc29sdmUocmVzb3VyY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVqZWN0KGVycm9yKSB7XG4gICAgICBpZiAodGhpcy5fY29tcGxldGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0SWQpO1xuXG4gICAgICB0aGlzLl9yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUGVuZGluZ1JlcXVlc3Q7XG59KCk7XG5cbnZhciBfZGVmYXVsdCA9IFBvb2w7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX25vZGUgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xuXG52YXIgX2JvbHRQcm90b2NvbFYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2JvbHQtcHJvdG9jb2wtdjFcIikpO1xuXG52YXIgX2JvbHRQcm90b2NvbFYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ib2x0LXByb3RvY29sLXYyXCIpKTtcblxudmFyIF9ib2x0UHJvdG9jb2xWMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYm9sdC1wcm90b2NvbC12M1wiKSk7XG5cbnZhciBfYm9sdFByb3RvY29sVjR4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ib2x0LXByb3RvY29sLXY0eDBcIikpO1xuXG52YXIgX2JvbHRQcm90b2NvbFY0eDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2JvbHQtcHJvdG9jb2wtdjR4MVwiKSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEJPTFRfTUFHSUNfUFJFQU1CTEUgPSAweDYwNjBiMDE3O1xuXG52YXIgUHJvdG9jb2xIYW5kc2hha2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb24gdGhlIGNvbm5lY3Rpb24gb3duaW5nIHRoaXMgcHJvdG9jb2wuXG4gICAqIEBwYXJhbSB7Q2hhbm5lbH0gY2hhbm5lbCB0aGUgbmV0d29yayBjaGFubmVsLlxuICAgKiBAcGFyYW0ge0NodW5rZXJ9IGNodW5rZXIgdGhlIG1lc3NhZ2UgY2h1bmtlci5cbiAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlTG9zc2xlc3NJbnRlZ2VycyBmbGFnIHRvIHVzZSBuYXRpdmUgSlMgbnVtYmVycy5cbiAgICogQHBhcmFtIHtMb2dnZXJ9IGxvZyB0aGUgbG9nZ2VyLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvdG9jb2xIYW5kc2hha2VyKGNvbm5lY3Rpb24sIGNoYW5uZWwsIGNodW5rZXIsIGRpc2FibGVMb3NzbGVzc0ludGVnZXJzLCBsb2cpIHtcbiAgICB2YXIgc2VydmVyc2lkZVJvdXRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IG51bGw7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBQcm90b2NvbEhhbmRzaGFrZXIpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIHRoaXMuX2NoYW5uZWwgPSBjaGFubmVsO1xuICAgIHRoaXMuX2NodW5rZXIgPSBjaHVua2VyO1xuICAgIHRoaXMuX2Rpc2FibGVMb3NzbGVzc0ludGVnZXJzID0gZGlzYWJsZUxvc3NsZXNzSW50ZWdlcnM7XG4gICAgdGhpcy5fbG9nID0gbG9nO1xuICAgIHRoaXMuX3NlcnZlcnNpZGVSb3V0aW5nID0gc2VydmVyc2lkZVJvdXRpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgQm9sdCBoYW5kc2hha2UgaW50byB0aGUgdW5kZXJseWluZyBuZXR3b3JrIGNoYW5uZWwuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShQcm90b2NvbEhhbmRzaGFrZXIsIFt7XG4gICAga2V5OiBcIndyaXRlSGFuZHNoYWtlUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZUhhbmRzaGFrZVJlcXVlc3QoKSB7XG4gICAgICB0aGlzLl9jaGFubmVsLndyaXRlKG5ld0hhbmRzaGFrZUJ1ZmZlcigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZ2l2ZW4gaGFuZHNoYWtlIHJlc3BvbnNlIGFuZCBjcmVhdGUgdGhlIG5lZ290aWF0ZWQgYm9sdCBwcm90b2NvbC5cbiAgICAgKiBAcGFyYW0ge0Jhc2VCdWZmZXJ9IGJ1ZmZlciBieXRlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBoYW5kc2hha2UgcmVzcG9uc2UuXG4gICAgICogQHJldHVybiB7Qm9sdFByb3RvY29sfSBib2x0IHByb3RvY29sIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHZlcnNpb24gc3VnZ2VzdGVkIGJ5IHRoZSBkYXRhYmFzZS5cbiAgICAgKiBAdGhyb3dzIHtOZW80akVycm9yfSB3aGVuIGJvbHQgcHJvdG9jb2wgY2FuJ3QgYmUgaW5zdGFudGlhdGVkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlTmVnb3RpYXRlZFByb3RvY29sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU5lZ290aWF0ZWRQcm90b2NvbChidWZmZXIpIHtcbiAgICAgIHZhciBoID0gW2J1ZmZlci5yZWFkVUludDgoKSwgYnVmZmVyLnJlYWRVSW50OCgpLCBidWZmZXIucmVhZFVJbnQ4KCksIGJ1ZmZlci5yZWFkVUludDgoKV07XG5cbiAgICAgIGlmIChoWzBdID09PSAweDQ4ICYmIGhbMV0gPT09IDB4NTQgJiYgaFsyXSA9PT0gMHg1NCAmJiBoWzNdID09PSAweDUwKSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdTZXJ2ZXIgcmVzcG9uZGVkIEhUVFAuIE1ha2Ugc3VyZSB5b3UgYXJlIG5vdCB0cnlpbmcgdG8gY29ubmVjdCB0byB0aGUgaHR0cCBlbmRwb2ludCAnICsgJyhIVFRQIGRlZmF1bHRzIHRvIHBvcnQgNzQ3NCB3aGVyZWFzIEJPTFQgZGVmYXVsdHMgdG8gcG9ydCA3Njg3KScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmVnb3RpYXRlZFZlcnNpb24gPSBOdW1iZXIoaFszXSArICcuJyArIGhbMl0pO1xuXG4gICAgICBpZiAodGhpcy5fbG9nLmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiXCIuY29uY2F0KHRoaXMuX2Nvbm5lY3Rpb24sIFwiIG5lZ290aWF0ZWQgcHJvdG9jb2wgdmVyc2lvbiBcIikuY29uY2F0KG5lZ290aWF0ZWRWZXJzaW9uKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVQcm90b2NvbFdpdGhWZXJzaW9uKG5lZ290aWF0ZWRWZXJzaW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Qm9sdFByb3RvY29sfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlUHJvdG9jb2xXaXRoVmVyc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlUHJvdG9jb2xXaXRoVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBuZXcgX2JvbHRQcm90b2NvbFZbXCJkZWZhdWx0XCJdKHRoaXMuX2Nvbm5lY3Rpb24sIHRoaXMuX2NodW5rZXIsIHRoaXMuX2Rpc2FibGVMb3NzbGVzc0ludGVnZXJzKTtcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBfYm9sdFByb3RvY29sVjJbXCJkZWZhdWx0XCJdKHRoaXMuX2Nvbm5lY3Rpb24sIHRoaXMuX2NodW5rZXIsIHRoaXMuX2Rpc2FibGVMb3NzbGVzc0ludGVnZXJzKTtcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIG5ldyBfYm9sdFByb3RvY29sVjNbXCJkZWZhdWx0XCJdKHRoaXMuX2Nvbm5lY3Rpb24sIHRoaXMuX2NodW5rZXIsIHRoaXMuX2Rpc2FibGVMb3NzbGVzc0ludGVnZXJzKTtcblxuICAgICAgICBjYXNlIDQuMDpcbiAgICAgICAgICByZXR1cm4gbmV3IF9ib2x0UHJvdG9jb2xWNHhbXCJkZWZhdWx0XCJdKHRoaXMuX2Nvbm5lY3Rpb24sIHRoaXMuX2NodW5rZXIsIHRoaXMuX2Rpc2FibGVMb3NzbGVzc0ludGVnZXJzKTtcblxuICAgICAgICBjYXNlIDQuMTpcbiAgICAgICAgICByZXR1cm4gbmV3IF9ib2x0UHJvdG9jb2xWNHgyW1wiZGVmYXVsdFwiXSh0aGlzLl9jb25uZWN0aW9uLCB0aGlzLl9jaHVua2VyLCB0aGlzLl9kaXNhYmxlTG9zc2xlc3NJbnRlZ2VycywgdGhpcy5fc2VydmVyc2lkZVJvdXRpbmcpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ1Vua25vd24gQm9sdCBwcm90b2NvbCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQcm90b2NvbEhhbmRzaGFrZXI7XG59KCk7XG4vKipcbiAqIEByZXR1cm4ge0Jhc2VCdWZmZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQcm90b2NvbEhhbmRzaGFrZXI7XG5cbmZ1bmN0aW9uIG5ld0hhbmRzaGFrZUJ1ZmZlcigpIHtcbiAgdmFyIGhhbmRzaGFrZUJ1ZmZlciA9ICgwLCBfbm9kZS5hbGxvYykoNSAqIDQpOyAvLyBtYWdpYyBwcmVhbWJsZVxuXG4gIGhhbmRzaGFrZUJ1ZmZlci53cml0ZUludDMyKEJPTFRfTUFHSUNfUFJFQU1CTEUpOyAvLyBwcm9wb3NlZCB2ZXJzaW9uc1xuXG4gIGhhbmRzaGFrZUJ1ZmZlci53cml0ZUludDMyKDEgPDwgOCB8IDQpO1xuICBoYW5kc2hha2VCdWZmZXIud3JpdGVJbnQzMig0KTtcbiAgaGFuZHNoYWtlQnVmZmVyLndyaXRlSW50MzIoMyk7XG4gIGhhbmRzaGFrZUJ1ZmZlci53cml0ZUludDMyKDIpOyAvLyByZXNldCB0aGUgcmVhZGVyIHBvc2l0aW9uXG5cbiAgaGFuZHNoYWtlQnVmZmVyLnJlc2V0KCk7XG4gIHJldHVybiBoYW5kc2hha2VCdWZmZXI7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3JvdXRpbmdUYWJsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm91dGluZy10YWJsZVwiKSk7XG5cbnZhciBfcm91dGluZ1V0aWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JvdXRpbmctdXRpbFwiKSk7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIFJlZGlzY292ZXJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1JvdXRpbmdVdGlsfSByb3V0aW5nVXRpbCB0aGUgdXRpbCB0byB1c2UuXG4gICAqL1xuICBmdW5jdGlvbiBSZWRpc2NvdmVyeShyb3V0aW5nVXRpbCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUmVkaXNjb3ZlcnkpO1xuICAgIHRoaXMuX3JvdXRpbmdVdGlsID0gcm91dGluZ1V0aWw7XG4gIH1cbiAgLyoqXG4gICAqIFRyeSB0byBmZXRjaCBuZXcgcm91dGluZyB0YWJsZSBmcm9tIHRoZSBnaXZlbiByb3V0ZXIuXG4gICAqIEBwYXJhbSB7U2Vzc2lvbn0gc2Vzc2lvbiB0aGUgc2Vzc2lvbiB0byB1c2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZSB0aGUgZGF0YWJhc2UgZm9yIHdoaWNoIHRvIGxvb2t1cCByb3V0aW5nIHRhYmxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm91dGVyQWRkcmVzcyB0aGUgVVJMIG9mIHRoZSByb3V0ZXIuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8Um91dGluZ1RhYmxlPn0gcHJvbWlzZSByZXNvbHZlZCB3aXRoIG5ldyByb3V0aW5nIHRhYmxlIG9yIG51bGwgd2hlbiBjb25uZWN0aW9uIGVycm9yIGhhcHBlbmVkLlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUmVkaXNjb3ZlcnksIFt7XG4gICAga2V5OiBcImxvb2t1cFJvdXRpbmdUYWJsZU9uUm91dGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbG9va3VwUm91dGluZ1RhYmxlT25Sb3V0ZXIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShzZXNzaW9uLCBkYXRhYmFzZSwgcm91dGVyQWRkcmVzcykge1xuICAgICAgICB2YXIgcmVjb3JkcywgcmVjb3JkLCBleHBpcmF0aW9uVGltZSwgX3RoaXMkX3JvdXRpbmdVdGlsJHBhLCByb3V0ZXJzLCByZWFkZXJzLCB3cml0ZXJzO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JvdXRpbmdVdGlsLmNhbGxSb3V0aW5nUHJvY2VkdXJlKHNlc3Npb24sIGRhdGFiYXNlLCByb3V0ZXJBZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVjb3JkcyA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShyZWNvcmRzID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBpZiAoIShyZWNvcmRzLmxlbmd0aCAhPT0gMSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ0lsbGVnYWwgcmVzcG9uc2UgZnJvbSByb3V0ZXIgXCInICsgcm91dGVyQWRkcmVzcyArICdcIi4gJyArICdSZWNlaXZlZCAnICsgcmVjb3Jkcy5sZW5ndGggKyAnIHJlY29yZHMgYnV0IGV4cGVjdGVkIG9ubHkgb25lLlxcbicgKyBKU09OLnN0cmluZ2lmeShyZWNvcmRzKSwgX2Vycm9yLlBST1RPQ09MX0VSUk9SKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgcmVjb3JkID0gcmVjb3Jkc1swXTtcbiAgICAgICAgICAgICAgICBleHBpcmF0aW9uVGltZSA9IHRoaXMuX3JvdXRpbmdVdGlsLnBhcnNlVHRsKHJlY29yZCwgcm91dGVyQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgX3RoaXMkX3JvdXRpbmdVdGlsJHBhID0gdGhpcy5fcm91dGluZ1V0aWwucGFyc2VTZXJ2ZXJzKHJlY29yZCwgcm91dGVyQWRkcmVzcyksIHJvdXRlcnMgPSBfdGhpcyRfcm91dGluZ1V0aWwkcGEucm91dGVycywgcmVhZGVycyA9IF90aGlzJF9yb3V0aW5nVXRpbCRwYS5yZWFkZXJzLCB3cml0ZXJzID0gX3RoaXMkX3JvdXRpbmdVdGlsJHBhLndyaXRlcnM7XG5cbiAgICAgICAgICAgICAgICBSZWRpc2NvdmVyeS5fYXNzZXJ0Tm9uRW1wdHkocm91dGVycywgJ3JvdXRlcnMnLCByb3V0ZXJBZGRyZXNzKTtcblxuICAgICAgICAgICAgICAgIFJlZGlzY292ZXJ5Ll9hc3NlcnROb25FbXB0eShyZWFkZXJzLCAncmVhZGVycycsIHJvdXRlckFkZHJlc3MpOyAvLyBjYXNlIHdpdGggbm8gd3JpdGVycyBpcyBwcm9jZXNzZWQgaGlnaGVyIGluIHRoZSBwcm9taXNlIGNoYWluIGJlY2F1c2Ugb25seSBSb3V0aW5nRHJpdmVyIGtub3dzXG4gICAgICAgICAgICAgICAgLy8gaG93IHRvIGRlYWwgd2l0aCBzdWNoIHRhYmxlIGFuZCBob3cgdG8gdHJlYXQgcm91dGVyIHRoYXQgcmV0dXJuZWQgc3VjaCB0YWJsZVxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBfcm91dGluZ1RhYmxlW1wiZGVmYXVsdFwiXSh7XG4gICAgICAgICAgICAgICAgICBkYXRhYmFzZTogZGF0YWJhc2UsXG4gICAgICAgICAgICAgICAgICByb3V0ZXJzOiByb3V0ZXJzLFxuICAgICAgICAgICAgICAgICAgcmVhZGVyczogcmVhZGVycyxcbiAgICAgICAgICAgICAgICAgIHdyaXRlcnM6IHdyaXRlcnMsXG4gICAgICAgICAgICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWVcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbG9va3VwUm91dGluZ1RhYmxlT25Sb3V0ZXIoX3gsIF94MiwgX3gzKSB7XG4gICAgICAgIHJldHVybiBfbG9va3VwUm91dGluZ1RhYmxlT25Sb3V0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvb2t1cFJvdXRpbmdUYWJsZU9uUm91dGVyO1xuICAgIH0oKVxuICB9XSwgW3tcbiAgICBrZXk6IFwiX2Fzc2VydE5vbkVtcHR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hc3NlcnROb25FbXB0eShzZXJ2ZXJBZGRyZXNzZXNBcnJheSwgc2VydmVyc05hbWUsIHJvdXRlckFkZHJlc3MpIHtcbiAgICAgIGlmIChzZXJ2ZXJBZGRyZXNzZXNBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ1JlY2VpdmVkIG5vICcgKyBzZXJ2ZXJzTmFtZSArICcgZnJvbSByb3V0ZXIgJyArIHJvdXRlckFkZHJlc3MsIF9lcnJvci5QUk9UT0NPTF9FUlJPUik7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSZWRpc2NvdmVyeTtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSZWRpc2NvdmVyeTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4cG9ydHMuQUxMID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcblxudmFyIF9pbnRlZ2VyID0gcmVxdWlyZShcIi4uL2ludGVnZXJcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLy8gU2lnbmF0dXJlIGJ5dGVzIGZvciBlYWNoIHJlcXVlc3QgbWVzc2FnZSB0eXBlXG52YXIgSU5JVCA9IDB4MDE7IC8vIDAwMDAgMDAwMSAvLyBJTklUIDx1c2VyX2FnZW50PiA8YXV0aGVudGljYXRpb25fdG9rZW4+XG5cbnZhciBBQ0tfRkFJTFVSRSA9IDB4MGU7IC8vIDAwMDAgMTExMCAvLyBBQ0tfRkFJTFVSRSAtIHVudXNlZFxuXG52YXIgUkVTRVQgPSAweDBmOyAvLyAwMDAwIDExMTEgLy8gUkVTRVRcblxudmFyIFJVTiA9IDB4MTA7IC8vIDAwMDEgMDAwMCAvLyBSVU4gPHF1ZXJ5PiA8cGFyYW1ldGVycz5cblxudmFyIERJU0NBUkRfQUxMID0gMHgyZjsgLy8gMDAxMCAxMTExIC8vIERJU0NBUkRfQUxMIC0gdW51c2VkXG5cbnZhciBQVUxMX0FMTCA9IDB4M2Y7IC8vIDAwMTEgMTExMSAvLyBQVUxMX0FMTFxuXG52YXIgSEVMTE8gPSAweDAxOyAvLyAwMDAwIDAwMDEgLy8gSEVMTE8gPG1ldGFkYXRhPlxuXG52YXIgR09PREJZRSA9IDB4MDI7IC8vIDAwMDAgMDAxMCAvLyBHT09EQllFXG5cbnZhciBCRUdJTiA9IDB4MTE7IC8vIDAwMDEgMDAwMSAvLyBCRUdJTiA8bWV0YWRhdGE+XG5cbnZhciBDT01NSVQgPSAweDEyOyAvLyAwMDAxIDAwMTAgLy8gQ09NTUlUXG5cbnZhciBST0xMQkFDSyA9IDB4MTM7IC8vIDAwMDEgMDAxMSAvLyBST0xMQkFDS1xuXG52YXIgRElTQ0FSRCA9IDB4MmY7IC8vIDAwMTAgMTExMSAvLyBESVNDQVJEXG5cbnZhciBQVUxMID0gMHgzZjsgLy8gMDAxMSAxMTExIC8vIFBVTExcblxudmFyIFJFQURfTU9ERSA9ICdyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxudmFyIE5PX1NUQVRFTUVOVF9JRCA9IC0xO1xudmFyIEFMTCA9IC0xO1xuZXhwb3J0cy5BTEwgPSBBTEw7XG5cbnZhciBSZXF1ZXN0TWVzc2FnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlcXVlc3RNZXNzYWdlKHNpZ25hdHVyZSwgZmllbGRzLCB0b1N0cmluZykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUmVxdWVzdE1lc3NhZ2UpO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgIHRoaXMudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IElOSVQgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsaWVudE5hbWUgdGhlIGNsaWVudCBuYW1lLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXV0aFRva2VuIHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlbi5cbiAgICogQHJldHVybiB7UmVxdWVzdE1lc3NhZ2V9IG5ldyBJTklUIG1lc3NhZ2UuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShSZXF1ZXN0TWVzc2FnZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KGNsaWVudE5hbWUsIGF1dGhUb2tlbikge1xuICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0TWVzc2FnZShJTklULCBbY2xpZW50TmFtZSwgYXV0aFRva2VuXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJJTklUIFwiLmNvbmNhdChjbGllbnROYW1lLCBcIiB7Li4ufVwiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgUlVOIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IHRoZSBjeXBoZXIgcXVlcnkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgdGhlIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gICAgICogQHJldHVybiB7UmVxdWVzdE1lc3NhZ2V9IG5ldyBSVU4gbWVzc2FnZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJ1blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW4ocXVlcnksIHBhcmFtZXRlcnMpIHtcbiAgICAgIHJldHVybiBuZXcgUmVxdWVzdE1lc3NhZ2UoUlVOLCBbcXVlcnksIHBhcmFtZXRlcnNdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlJVTiBcIi5jb25jYXQocXVlcnksIFwiIFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkocGFyYW1ldGVycykpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIFBVTExfQUxMIG1lc3NhZ2UuXG4gICAgICogQHJldHVybiB7UmVxdWVzdE1lc3NhZ2V9IHRoZSBQVUxMX0FMTCBtZXNzYWdlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHVsbEFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdWxsQWxsKCkge1xuICAgICAgcmV0dXJuIFBVTExfQUxMX01FU1NBR0U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIFJFU0VUIG1lc3NhZ2UuXG4gICAgICogQHJldHVybiB7UmVxdWVzdE1lc3NhZ2V9IHRoZSBSRVNFVCBtZXNzYWdlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICByZXR1cm4gUkVTRVRfTUVTU0FHRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEhFTExPIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJBZ2VudCB0aGUgdXNlciBhZ2VudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXV0aFRva2VuIHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uYWwgc2VydmVyIHNpZGUgcm91dGluZywgc2V0IHRvIHJvdXRpbmcgY29udGV4dCB0byB0dXJuIG9uIHNlcnZlciBzaWRlIHJvdXRpbmcgKD4gNC4xKVxuICAgICAqIEByZXR1cm4ge1JlcXVlc3RNZXNzYWdlfSBuZXcgSEVMTE8gbWVzc2FnZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhlbGxvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhlbGxvKHVzZXJBZ2VudCwgYXV0aFRva2VuKSB7XG4gICAgICB2YXIgcm91dGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgIHZhciBtZXRhZGF0YSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB1c2VyX2FnZW50OiB1c2VyQWdlbnRcbiAgICAgIH0sIGF1dGhUb2tlbik7XG5cbiAgICAgIGlmIChyb3V0aW5nICE9IG51bGwpIHtcbiAgICAgICAgbWV0YWRhdGEucm91dGluZyA9IHJvdXRpbmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUmVxdWVzdE1lc3NhZ2UoSEVMTE8sIFttZXRhZGF0YV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiSEVMTE8ge3VzZXJfYWdlbnQ6ICdcIi5jb25jYXQodXNlckFnZW50LCBcIicsIC4uLn1cIik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEJFR0lOIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtCb29rbWFya30gYm9va21hcmsgdGhlIGJvb2ttYXJrLlxuICAgICAqIEBwYXJhbSB7VHhDb25maWd9IHR4Q29uZmlnIHRoZSBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZSB0aGUgZGF0YWJhc2UgbmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSB0aGUgYWNjZXNzIG1vZGUuXG4gICAgICogQHJldHVybiB7UmVxdWVzdE1lc3NhZ2V9IG5ldyBCRUdJTiBtZXNzYWdlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYmVnaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVnaW4oKSB7XG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgYm9va21hcmsgPSBfcmVmLmJvb2ttYXJrLFxuICAgICAgICAgIHR4Q29uZmlnID0gX3JlZi50eENvbmZpZyxcbiAgICAgICAgICBkYXRhYmFzZSA9IF9yZWYuZGF0YWJhc2UsXG4gICAgICAgICAgbW9kZSA9IF9yZWYubW9kZTtcblxuICAgICAgdmFyIG1ldGFkYXRhID0gYnVpbGRUeE1ldGFkYXRhKGJvb2ttYXJrLCB0eENvbmZpZywgZGF0YWJhc2UsIG1vZGUpO1xuICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0TWVzc2FnZShCRUdJTiwgW21ldGFkYXRhXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJCRUdJTiBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBDT01NSVQgbWVzc2FnZS5cbiAgICAgKiBAcmV0dXJuIHtSZXF1ZXN0TWVzc2FnZX0gdGhlIENPTU1JVCBtZXNzYWdlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbW1pdCgpIHtcbiAgICAgIHJldHVybiBDT01NSVRfTUVTU0FHRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgUk9MTEJBQ0sgbWVzc2FnZS5cbiAgICAgKiBAcmV0dXJuIHtSZXF1ZXN0TWVzc2FnZX0gdGhlIFJPTExCQUNLIG1lc3NhZ2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyb2xsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb2xsYmFjaygpIHtcbiAgICAgIHJldHVybiBST0xMQkFDS19NRVNTQUdFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgUlVOIG1lc3NhZ2Ugd2l0aCBhZGRpdGlvbmFsIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSB0aGUgY3lwaGVyIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIHRoZSBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Qm9va21hcmt9IGJvb2ttYXJrIHRoZSBib29rbWFyay5cbiAgICAgKiBAcGFyYW0ge1R4Q29uZmlnfSB0eENvbmZpZyB0aGUgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YWJhc2UgdGhlIGRhdGFiYXNlIG5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgdGhlIGFjY2VzcyBtb2RlLlxuICAgICAqIEByZXR1cm4ge1JlcXVlc3RNZXNzYWdlfSBuZXcgUlVOIG1lc3NhZ2Ugd2l0aCBhZGRpdGlvbmFsIG1ldGFkYXRhLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicnVuV2l0aE1ldGFkYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bldpdGhNZXRhZGF0YShxdWVyeSwgcGFyYW1ldGVycykge1xuICAgICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgICAgICBib29rbWFyayA9IF9yZWYyLmJvb2ttYXJrLFxuICAgICAgICAgIHR4Q29uZmlnID0gX3JlZjIudHhDb25maWcsXG4gICAgICAgICAgZGF0YWJhc2UgPSBfcmVmMi5kYXRhYmFzZSxcbiAgICAgICAgICBtb2RlID0gX3JlZjIubW9kZTtcblxuICAgICAgdmFyIG1ldGFkYXRhID0gYnVpbGRUeE1ldGFkYXRhKGJvb2ttYXJrLCB0eENvbmZpZywgZGF0YWJhc2UsIG1vZGUpO1xuICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0TWVzc2FnZShSVU4sIFtxdWVyeSwgcGFyYW1ldGVycywgbWV0YWRhdGFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlJVTiBcIi5jb25jYXQocXVlcnksIFwiIFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkocGFyYW1ldGVycyksIFwiIFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBHT09EQllFIG1lc3NhZ2UuXG4gICAgICogQHJldHVybiB7UmVxdWVzdE1lc3NhZ2V9IHRoZSBHT09EQllFIG1lc3NhZ2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnb29kYnllXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdvb2RieWUoKSB7XG4gICAgICByZXR1cm4gR09PREJZRV9NRVNTQUdFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgUFVMTCBtZXNzYWdlIHdpdGggYWRkaXRpb25hbCBtZXRhZGF0YS5cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBzdG10SWRcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBuXG4gICAgICogQHJldHVybiB7UmVxdWVzdE1lc3NhZ2V9IHRoZSBQVUxMIG1lc3NhZ2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1bGwoKSB7XG4gICAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIF9yZWYzJHN0bXRJZCA9IF9yZWYzLnN0bXRJZCxcbiAgICAgICAgICBzdG10SWQgPSBfcmVmMyRzdG10SWQgPT09IHZvaWQgMCA/IE5PX1NUQVRFTUVOVF9JRCA6IF9yZWYzJHN0bXRJZCxcbiAgICAgICAgICBfcmVmMyRuID0gX3JlZjMubixcbiAgICAgICAgICBuID0gX3JlZjMkbiA9PT0gdm9pZCAwID8gQUxMIDogX3JlZjMkbjtcblxuICAgICAgdmFyIG1ldGFkYXRhID0gYnVpbGRTdHJlYW1NZXRhZGF0YShzdG10SWQgfHwgTk9fU1RBVEVNRU5UX0lELCBuIHx8IEFMTCk7XG4gICAgICByZXR1cm4gbmV3IFJlcXVlc3RNZXNzYWdlKFBVTEwsIFttZXRhZGF0YV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiUFVMTCBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgRElTQ0FSRCBtZXNzYWdlIHdpdGggYWRkaXRpb25hbCBtZXRhZGF0YS5cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBzdG10SWRcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBuXG4gICAgICogQHJldHVybiB7UmVxdWVzdE1lc3NhZ2V9IHRoZSBQVUxMIG1lc3NhZ2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNjYXJkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2NhcmQoKSB7XG4gICAgICB2YXIgX3JlZjQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIF9yZWY0JHN0bXRJZCA9IF9yZWY0LnN0bXRJZCxcbiAgICAgICAgICBzdG10SWQgPSBfcmVmNCRzdG10SWQgPT09IHZvaWQgMCA/IE5PX1NUQVRFTUVOVF9JRCA6IF9yZWY0JHN0bXRJZCxcbiAgICAgICAgICBfcmVmNCRuID0gX3JlZjQubixcbiAgICAgICAgICBuID0gX3JlZjQkbiA9PT0gdm9pZCAwID8gQUxMIDogX3JlZjQkbjtcblxuICAgICAgdmFyIG1ldGFkYXRhID0gYnVpbGRTdHJlYW1NZXRhZGF0YShzdG10SWQgfHwgTk9fU1RBVEVNRU5UX0lELCBuIHx8IEFMTCk7XG4gICAgICByZXR1cm4gbmV3IFJlcXVlc3RNZXNzYWdlKERJU0NBUkQsIFttZXRhZGF0YV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiRElTQ0FSRCBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUmVxdWVzdE1lc3NhZ2U7XG59KCk7XG4vKipcbiAqIENyZWF0ZSBhbiBvYmplY3QgdGhhdCByZXByZXNlbnQgdHJhbnNhY3Rpb24gbWV0YWRhdGEuXG4gKiBAcGFyYW0ge0Jvb2ttYXJrfSBib29rbWFyayB0aGUgYm9va21hcmsuXG4gKiBAcGFyYW0ge1R4Q29uZmlnfSB0eENvbmZpZyB0aGUgY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhYmFzZSB0aGUgZGF0YWJhc2UgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIHRoZSBhY2Nlc3MgbW9kZS5cbiAqIEByZXR1cm4ge09iamVjdH0gYSBtZXRhZGF0YSBvYmplY3QuXG4gKi9cblxuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJlcXVlc3RNZXNzYWdlO1xuXG5mdW5jdGlvbiBidWlsZFR4TWV0YWRhdGEoYm9va21hcmssIHR4Q29uZmlnLCBkYXRhYmFzZSwgbW9kZSkge1xuICB2YXIgbWV0YWRhdGEgPSB7fTtcblxuICBpZiAoIWJvb2ttYXJrLmlzRW1wdHkoKSkge1xuICAgIG1ldGFkYXRhLmJvb2ttYXJrcyA9IGJvb2ttYXJrLnZhbHVlcygpO1xuICB9XG5cbiAgaWYgKHR4Q29uZmlnLnRpbWVvdXQpIHtcbiAgICBtZXRhZGF0YS50eF90aW1lb3V0ID0gdHhDb25maWcudGltZW91dDtcbiAgfVxuXG4gIGlmICh0eENvbmZpZy5tZXRhZGF0YSkge1xuICAgIG1ldGFkYXRhLnR4X21ldGFkYXRhID0gdHhDb25maWcubWV0YWRhdGE7XG4gIH1cblxuICBpZiAoZGF0YWJhc2UpIHtcbiAgICBtZXRhZGF0YS5kYiA9ICgwLCBfdXRpbC5hc3NlcnRTdHJpbmcpKGRhdGFiYXNlLCAnZGF0YWJhc2UnKTtcbiAgfVxuXG4gIGlmIChtb2RlID09PSBfY29uc3RhbnRzLkFDQ0VTU19NT0RFX1JFQUQpIHtcbiAgICBtZXRhZGF0YS5tb2RlID0gUkVBRF9NT0RFO1xuICB9XG5cbiAgcmV0dXJuIG1ldGFkYXRhO1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBzdHJlYW1pbmcgbWV0YWRhdGEuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBzdG10SWQgVGhlIHF1ZXJ5IGlkIHRvIHN0cmVhbSBpdHMgcmVzdWx0cy5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IG4gVGhlIG51bWJlciBvZiByZWNvcmRzIHRvIHN0cmVhbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IGEgbWV0YWRhdGEgb2JqZWN0LlxuICovXG5cblxuZnVuY3Rpb24gYnVpbGRTdHJlYW1NZXRhZGF0YShzdG10SWQsIG4pIHtcbiAgdmFyIG1ldGFkYXRhID0ge1xuICAgIG46ICgwLCBfaW50ZWdlcltcImludFwiXSkobilcbiAgfTtcblxuICBpZiAoc3RtdElkICE9PSBOT19TVEFURU1FTlRfSUQpIHtcbiAgICBtZXRhZGF0YS5xaWQgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHN0bXRJZCk7XG4gIH1cblxuICByZXR1cm4gbWV0YWRhdGE7XG59IC8vIGNvbnN0YW50cyBmb3IgbWVzc2FnZXMgdGhhdCBuZXZlciBjaGFuZ2VcblxuXG52YXIgUFVMTF9BTExfTUVTU0FHRSA9IG5ldyBSZXF1ZXN0TWVzc2FnZShQVUxMX0FMTCwgW10sIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdQVUxMX0FMTCc7XG59KTtcbnZhciBSRVNFVF9NRVNTQUdFID0gbmV3IFJlcXVlc3RNZXNzYWdlKFJFU0VULCBbXSwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ1JFU0VUJztcbn0pO1xudmFyIENPTU1JVF9NRVNTQUdFID0gbmV3IFJlcXVlc3RNZXNzYWdlKENPTU1JVCwgW10sIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdDT01NSVQnO1xufSk7XG52YXIgUk9MTEJBQ0tfTUVTU0FHRSA9IG5ldyBSZXF1ZXN0TWVzc2FnZShST0xMQkFDSywgW10sIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdST0xMQkFDSyc7XG59KTtcbnZhciBHT09EQllFX01FU1NBR0UgPSBuZXcgUmVxdWVzdE1lc3NhZ2UoR09PREJZRSwgW10sIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdHT09EQllFJztcbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBCYXNlSG9zdE5hbWVSZXNvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VIb3N0TmFtZVJlc29sdmVyKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgQmFzZUhvc3ROYW1lUmVzb2x2ZXIpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShCYXNlSG9zdE5hbWVSZXNvbHZlciwgW3tcbiAgICBrZXk6IFwicmVzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBYnN0cmFjdCBmdW5jdGlvbicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVzb2x2ZVRvSXRzZWxmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNvbHZlVG9JdHNlbGYoYWRkcmVzcykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbYWRkcmVzc10pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQmFzZUhvc3ROYW1lUmVzb2x2ZXI7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQmFzZUhvc3ROYW1lUmVzb2x2ZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfc2VydmVyQWRkcmVzcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3NlcnZlci1hZGRyZXNzXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiByZXNvbHZlVG9TZWxmKGFkZHJlc3MpIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbYWRkcmVzc10pO1xufVxuXG52YXIgQ29uZmlndXJlZEN1c3RvbVJlc29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29uZmlndXJlZEN1c3RvbVJlc29sdmVyKHJlc29sdmVyRnVuY3Rpb24pIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIENvbmZpZ3VyZWRDdXN0b21SZXNvbHZlcik7XG4gICAgdGhpcy5fcmVzb2x2ZXJGdW5jdGlvbiA9IHJlc29sdmVyRnVuY3Rpb24gfHwgcmVzb2x2ZVRvU2VsZjtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQ29uZmlndXJlZEN1c3RvbVJlc29sdmVyLCBbe1xuICAgIGtleTogXCJyZXNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmUoc2VlZFJvdXRlcikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKF90aGlzLl9yZXNvbHZlckZ1bmN0aW9uKHNlZWRSb3V0ZXIuYXNIb3N0UG9ydCgpKSk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzb2x2ZWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29uZmlndXJlZCByZXNvbHZlciBmdW5jdGlvbiBzaG91bGQgZWl0aGVyIHJldHVybiBhbiBhcnJheSBvZiBhZGRyZXNzZXMgb3IgYSBQcm9taXNlIHJlc29sdmVkIHdpdGggYW4gYXJyYXkgb2YgYWRkcmVzc2VzLicgKyBcIkVhY2ggYWRkcmVzcyBpcyAnPGhvc3Q+Ojxwb3J0PicuIEdvdDogXCIuY29uY2F0KHJlc29sdmVkKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzb2x2ZWQubWFwKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgcmV0dXJuIF9zZXJ2ZXJBZGRyZXNzW1wiZGVmYXVsdFwiXS5mcm9tVXJsKHIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29uZmlndXJlZEN1c3RvbVJlc29sdmVyO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENvbmZpZ3VyZWRDdXN0b21SZXNvbHZlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuLi9lcnJvclwiKTtcblxudmFyIF9yeGpzID0gcmVxdWlyZShcInJ4anNcIik7XG5cbnZhciBfb3BlcmF0b3JzID0gcmVxdWlyZShcInJ4anMvb3BlcmF0b3JzXCIpO1xuXG52YXIgX2xvZ2dlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbG9nZ2VyXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgREVGQVVMVF9NQVhfUkVUUllfVElNRV9NUyA9IDMwICogMTAwMDsgLy8gMzAgc2Vjb25kc1xuXG52YXIgREVGQVVMVF9JTklUSUFMX1JFVFJZX0RFTEFZX01TID0gMTAwMDsgLy8gMSBzZWNvbmRzXG5cbnZhciBERUZBVUxUX1JFVFJZX0RFTEFZX01VTFRJUExJRVIgPSAyLjA7XG52YXIgREVGQVVMVF9SRVRSWV9ERUxBWV9KSVRURVJfRkFDVE9SID0gMC4yO1xuXG52YXIgUnhSZXRyeUxvZ2ljID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gICAqIEBwYXJhbSB7TG9nZ2VyfSBhcmdzLmxvZ2dlclxuICAgKi9cbiAgZnVuY3Rpb24gUnhSZXRyeUxvZ2ljKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgX3JlZiRtYXhSZXRyeVRpbWVvdXQgPSBfcmVmLm1heFJldHJ5VGltZW91dCxcbiAgICAgICAgbWF4UmV0cnlUaW1lb3V0ID0gX3JlZiRtYXhSZXRyeVRpbWVvdXQgPT09IHZvaWQgMCA/IERFRkFVTFRfTUFYX1JFVFJZX1RJTUVfTVMgOiBfcmVmJG1heFJldHJ5VGltZW91dCxcbiAgICAgICAgX3JlZiRpbml0aWFsRGVsYXkgPSBfcmVmLmluaXRpYWxEZWxheSxcbiAgICAgICAgaW5pdGlhbERlbGF5ID0gX3JlZiRpbml0aWFsRGVsYXkgPT09IHZvaWQgMCA/IERFRkFVTFRfSU5JVElBTF9SRVRSWV9ERUxBWV9NUyA6IF9yZWYkaW5pdGlhbERlbGF5LFxuICAgICAgICBfcmVmJGRlbGF5TXVsdGlwbGllciA9IF9yZWYuZGVsYXlNdWx0aXBsaWVyLFxuICAgICAgICBkZWxheU11bHRpcGxpZXIgPSBfcmVmJGRlbGF5TXVsdGlwbGllciA9PT0gdm9pZCAwID8gREVGQVVMVF9SRVRSWV9ERUxBWV9NVUxUSVBMSUVSIDogX3JlZiRkZWxheU11bHRpcGxpZXIsXG4gICAgICAgIF9yZWYkZGVsYXlKaXR0ZXIgPSBfcmVmLmRlbGF5Sml0dGVyLFxuICAgICAgICBkZWxheUppdHRlciA9IF9yZWYkZGVsYXlKaXR0ZXIgPT09IHZvaWQgMCA/IERFRkFVTFRfUkVUUllfREVMQVlfSklUVEVSX0ZBQ1RPUiA6IF9yZWYkZGVsYXlKaXR0ZXIsXG4gICAgICAgIF9yZWYkbG9nZ2VyID0gX3JlZi5sb2dnZXIsXG4gICAgICAgIGxvZ2dlciA9IF9yZWYkbG9nZ2VyID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRsb2dnZXI7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFJ4UmV0cnlMb2dpYyk7XG4gICAgdGhpcy5fbWF4UmV0cnlUaW1lb3V0ID0gdmFsdWVPckRlZmF1bHQobWF4UmV0cnlUaW1lb3V0LCBERUZBVUxUX01BWF9SRVRSWV9USU1FX01TKTtcbiAgICB0aGlzLl9pbml0aWFsRGVsYXkgPSB2YWx1ZU9yRGVmYXVsdChpbml0aWFsRGVsYXksIERFRkFVTFRfSU5JVElBTF9SRVRSWV9ERUxBWV9NUyk7XG4gICAgdGhpcy5fZGVsYXlNdWx0aXBsaWVyID0gdmFsdWVPckRlZmF1bHQoZGVsYXlNdWx0aXBsaWVyLCBERUZBVUxUX1JFVFJZX0RFTEFZX01VTFRJUExJRVIpO1xuICAgIHRoaXMuX2RlbGF5Sml0dGVyID0gdmFsdWVPckRlZmF1bHQoZGVsYXlKaXR0ZXIsIERFRkFVTFRfUkVUUllfREVMQVlfSklUVEVSX0ZBQ1RPUik7XG4gICAgdGhpcy5fbG9nZ2VyID0gbG9nZ2VyO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09ic2VydmFibGU8QW55Pn0gd29ya1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUnhSZXRyeUxvZ2ljLCBbe1xuICAgIGtleTogXCJyZXRyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXRyeSh3b3JrKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gd29yay5waXBlKCgwLCBfb3BlcmF0b3JzLnJldHJ5V2hlbikoZnVuY3Rpb24gKGZhaWxlZFdvcmspIHtcbiAgICAgICAgdmFyIGhhbmRsZWRFeGNlcHRpb25zID0gW107XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgcmV0cnlDb3VudCA9IDE7XG4gICAgICAgIHZhciBkZWxheUR1cmF0aW9uID0gX3RoaXMuX2luaXRpYWxEZWxheTtcbiAgICAgICAgcmV0dXJuIGZhaWxlZFdvcmsucGlwZSgoMCwgX29wZXJhdG9ycy5mbGF0TWFwKShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaWYgKCFSeFJldHJ5TG9naWMuX2NhblJldHJ5T24oZXJyKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcnhqcy50aHJvd0Vycm9yKShlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhbmRsZWRFeGNlcHRpb25zLnB1c2goZXJyKTtcblxuICAgICAgICAgIGlmIChyZXRyeUNvdW50ID49IDIgJiYgRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA+PSBfdGhpcy5fbWF4UmV0cnlUaW1lb3V0KSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSAoMCwgX2Vycm9yLm5ld0Vycm9yKShcIkZhaWxlZCBhZnRlciByZXRyaWVkIGZvciBcIi5jb25jYXQocmV0cnlDb3VudCwgXCIgdGltZXMgaW4gXCIpLmNvbmNhdChfdGhpcy5fbWF4UmV0cnlUaW1lb3V0LCBcIiBtcy4gTWFrZSBzdXJlIHRoYXQgeW91ciBkYXRhYmFzZSBpcyBvbmxpbmUgYW5kIHJldHJ5IGFnYWluLlwiKSwgX2Vycm9yLlNFUlZJQ0VfVU5BVkFJTEFCTEUpO1xuICAgICAgICAgICAgZXJyb3Iuc2VlbkVycm9ycyA9IGhhbmRsZWRFeGNlcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcnhqcy50aHJvd0Vycm9yKShlcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5leHREZWxheUR1cmF0aW9uID0gX3RoaXMuX2NvbXB1dGVOZXh0RGVsYXkoZGVsYXlEdXJhdGlvbik7XG5cbiAgICAgICAgICBkZWxheUR1cmF0aW9uID0gZGVsYXlEdXJhdGlvbiAqIF90aGlzLl9kZWxheU11bHRpcGxpZXI7XG4gICAgICAgICAgcmV0cnlDb3VudCsrO1xuXG4gICAgICAgICAgaWYgKF90aGlzLl9sb2dnZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9sb2dnZXIud2FybihcIlRyYW5zYWN0aW9uIGZhaWxlZCBhbmQgd2lsbCBiZSByZXRyaWVkIGluIFwiLmNvbmNhdChuZXh0RGVsYXlEdXJhdGlvbikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAoMCwgX3J4anMub2YpKDEpLnBpcGUoKDAsIF9vcGVyYXRvcnMuZGVsYXkpKG5leHREZWxheUR1cmF0aW9uKSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbXB1dGVOZXh0RGVsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXB1dGVOZXh0RGVsYXkoZGVsYXkpIHtcbiAgICAgIHZhciBqaXR0ZXIgPSBkZWxheSAqIHRoaXMuX2RlbGF5Sml0dGVyO1xuICAgICAgcmV0dXJuIGRlbGF5IC0gaml0dGVyICsgMiAqIGppdHRlciAqIE1hdGgucmFuZG9tKCk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiX2NhblJldHJ5T25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhblJldHJ5T24oZXJyb3IpIHtcbiAgICAgIHJldHVybiBlcnJvciAmJiBlcnJvci5jb2RlICYmIChlcnJvci5jb2RlID09PSBfZXJyb3IuU0VSVklDRV9VTkFWQUlMQUJMRSB8fCBlcnJvci5jb2RlID09PSBfZXJyb3IuU0VTU0lPTl9FWFBJUkVEIHx8IHRoaXMuX2lzVHJhbnNpZW50RXJyb3IoZXJyb3IpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzVHJhbnNpZW50RXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzVHJhbnNpZW50RXJyb3IoZXJyb3IpIHtcbiAgICAgIC8vIFJldHJpZXMgc2hvdWxkIG5vdCBoYXBwZW4gd2hlbiB0cmFuc2FjdGlvbiB3YXMgZXhwbGljaXRseSB0ZXJtaW5hdGVkIGJ5IHRoZSB1c2VyLlxuICAgICAgLy8gVGVybWluYXRpb24gb2YgdHJhbnNhY3Rpb24gbWlnaHQgcmVzdWx0IGluIHR3byBkaWZmZXJlbnQgZXJyb3IgY29kZXMgZGVwZW5kaW5nIG9uIHdoZXJlIGl0IHdhc1xuICAgICAgLy8gdGVybWluYXRlZC4gVGhlc2UgYXJlIHJlYWxseSBjbGllbnQgZXJyb3JzIGJ1dCBjbGFzc2lmaWNhdGlvbiBvbiB0aGUgc2VydmVyIGlzIG5vdCBlbnRpcmVseSBjb3JyZWN0IGFuZFxuICAgICAgLy8gdGhleSBhcmUgY2xhc3NpZmllZCBhcyB0cmFuc2llbnQuXG4gICAgICB2YXIgY29kZSA9IGVycm9yLmNvZGU7XG5cbiAgICAgIGlmIChjb2RlLmluZGV4T2YoJ1RyYW5zaWVudEVycm9yJykgPj0gMCkge1xuICAgICAgICBpZiAoY29kZSA9PT0gJ05lby5UcmFuc2llbnRFcnJvci5UcmFuc2FjdGlvbi5UZXJtaW5hdGVkJyB8fCBjb2RlID09PSAnTmVvLlRyYW5zaWVudEVycm9yLlRyYW5zYWN0aW9uLkxvY2tDbGllbnRTdG9wcGVkJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSeFJldHJ5TG9naWM7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUnhSZXRyeUxvZ2ljO1xuXG5mdW5jdGlvbiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0VmFsdWU7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIFJvdW5kUm9iaW5BcnJheUluZGV4ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2luaXRpYWxPZmZzZXQ9MF0gdGhlIGluaXRpYWwgb2Zmc2V0IGZvciByb3VuZCByb2Jpbi5cbiAgICovXG4gIGZ1bmN0aW9uIFJvdW5kUm9iaW5BcnJheUluZGV4KGluaXRpYWxPZmZzZXQpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFJvdW5kUm9iaW5BcnJheUluZGV4KTtcbiAgICB0aGlzLl9vZmZzZXQgPSBpbml0aWFsT2Zmc2V0IHx8IDA7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBuZXh0IGluZGV4IGZvciBhbiBhcnJheSB3aXRoIGdpdmVuIGxlbmd0aC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFycmF5TGVuZ3RoIHRoZSBhcnJheSBsZW5ndGguXG4gICAqIEByZXR1cm4ge251bWJlcn0gaW5kZXggaW4gdGhlIGFycmF5LlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUm91bmRSb2JpbkFycmF5SW5kZXgsIFt7XG4gICAga2V5OiBcIm5leHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dChhcnJheUxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5TGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHRPZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB0aGlzLl9vZmZzZXQgKz0gMTtcblxuICAgICAgaWYgKHRoaXMuX29mZnNldCA9PT0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHRPZmZzZXQgJSBhcnJheUxlbmd0aDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJvdW5kUm9iaW5BcnJheUluZGV4O1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJvdW5kUm9iaW5BcnJheUluZGV4OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX3RvQ29uc3VtYWJsZUFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXlcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2ludGVnZXIgPSByZXF1aXJlKFwiLi4vaW50ZWdlclwiKTtcblxudmFyIF9kcml2ZXIgPSByZXF1aXJlKFwiLi4vZHJpdmVyXCIpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBNSU5fUk9VVEVSUyA9IDE7XG5cbnZhciBSb3V0aW5nVGFibGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSb3V0aW5nVGFibGUoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBkYXRhYmFzZSA9IF9yZWYuZGF0YWJhc2UsXG4gICAgICAgIHJvdXRlcnMgPSBfcmVmLnJvdXRlcnMsXG4gICAgICAgIHJlYWRlcnMgPSBfcmVmLnJlYWRlcnMsXG4gICAgICAgIHdyaXRlcnMgPSBfcmVmLndyaXRlcnMsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gX3JlZi5leHBpcmF0aW9uVGltZTtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUm91dGluZ1RhYmxlKTtcbiAgICB0aGlzLmRhdGFiYXNlID0gZGF0YWJhc2U7XG4gICAgdGhpcy5kYXRhYmFzZU5hbWUgPSBkYXRhYmFzZSB8fCAnZGVmYXVsdCBkYXRhYmFzZSc7XG4gICAgdGhpcy5yb3V0ZXJzID0gcm91dGVycyB8fCBbXTtcbiAgICB0aGlzLnJlYWRlcnMgPSByZWFkZXJzIHx8IFtdO1xuICAgIHRoaXMud3JpdGVycyA9IHdyaXRlcnMgfHwgW107XG4gICAgdGhpcy5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lIHx8ICgwLCBfaW50ZWdlcltcImludFwiXSkoMCk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFJvdXRpbmdUYWJsZSwgW3tcbiAgICBrZXk6IFwiZm9yZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcmdldChhZGRyZXNzKSB7XG4gICAgICAvLyBEb24ndCByZW1vdmUgaXQgZnJvbSB0aGUgc2V0IG9mIHJvdXRlcnMsIHNpbmNlIHRoYXQgbWlnaHQgbWVhbiB3ZSBsb3NlIG91ciBhYmlsaXR5IHRvIHJlLWRpc2NvdmVyLFxuICAgICAgLy8ganVzdCByZW1vdmUgaXQgZnJvbSB0aGUgc2V0IG9mIHJlYWRlcnMgYW5kIHdyaXRlcnMsIHNvIHRoYXQgd2UgZG9uJ3QgdXNlIGl0IGZvciBhY3R1YWwgd29yayB3aXRob3V0XG4gICAgICAvLyBwZXJmb3JtaW5nIGRpc2NvdmVyeSBmaXJzdC5cbiAgICAgIHRoaXMucmVhZGVycyA9IHJlbW92ZUZyb21BcnJheSh0aGlzLnJlYWRlcnMsIGFkZHJlc3MpO1xuICAgICAgdGhpcy53cml0ZXJzID0gcmVtb3ZlRnJvbUFycmF5KHRoaXMud3JpdGVycywgYWRkcmVzcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcmdldFJvdXRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JnZXRSb3V0ZXIoYWRkcmVzcykge1xuICAgICAgdGhpcy5yb3V0ZXJzID0gcmVtb3ZlRnJvbUFycmF5KHRoaXMucm91dGVycywgYWRkcmVzcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcmdldFdyaXRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JnZXRXcml0ZXIoYWRkcmVzcykge1xuICAgICAgdGhpcy53cml0ZXJzID0gcmVtb3ZlRnJvbUFycmF5KHRoaXMud3JpdGVycywgYWRkcmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgcm91dGluZyB0YWJsZSBpcyBmcmVzaCB0byBwZXJmb3JtIHRoZSByZXF1aXJlZCBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc01vZGUgdGhlIHR5cGUgb2Ygb3BlcmF0aW9uLiBBbGxvd2VkIHZhbHVlcyBhcmUge0BsaW5rIFJFQUR9IGFuZCB7QGxpbmsgV1JJVEV9LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCB3aGVuIHRoaXMgdGFibGUgY29udGFpbnMgc2VydmVycyB0byBzZXJ2ZSB0aGUgcmVxdWlyZWQgb3BlcmF0aW9uLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzU3RhbGVGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTdGFsZUZvcihhY2Nlc3NNb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5leHBpcmF0aW9uVGltZS5sZXNzVGhhbihEYXRlLm5vdygpKSB8fCB0aGlzLnJvdXRlcnMubGVuZ3RoIDwgTUlOX1JPVVRFUlMgfHwgYWNjZXNzTW9kZSA9PT0gX2RyaXZlci5SRUFEICYmIHRoaXMucmVhZGVycy5sZW5ndGggPT09IDAgfHwgYWNjZXNzTW9kZSA9PT0gX2RyaXZlci5XUklURSAmJiB0aGlzLndyaXRlcnMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIHJvdXRpbmcgdGFibGUgaXMgZXhwaXJlZCBmb3Igc3BlY2lmaWVkIGFtb3VudCBvZiBkdXJhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBkdXJhdGlvbiBhbW91bnQgb2YgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHRvIGNoZWNrIGZvciBleHBpcmF0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0V4cGlyZWRGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFeHBpcmVkRm9yKGR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5leHBpcmF0aW9uVGltZS5hZGQoZHVyYXRpb24pLmxlc3NUaGFuKERhdGUubm93KCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbGxTZXJ2ZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFsbFNlcnZlcnMoKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyW1wiZGVmYXVsdFwiXSkodGhpcy5yb3V0ZXJzKSwgKDAsIF90b0NvbnN1bWFibGVBcnJheTJbXCJkZWZhdWx0XCJdKSh0aGlzLnJlYWRlcnMpLCAoMCwgX3RvQ29uc3VtYWJsZUFycmF5MltcImRlZmF1bHRcIl0pKHRoaXMud3JpdGVycykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnUm91dGluZ1RhYmxlWycgKyBcImRhdGFiYXNlPVwiLmNvbmNhdCh0aGlzLmRhdGFiYXNlTmFtZSwgXCIsIFwiKSArIFwiZXhwaXJhdGlvblRpbWU9XCIuY29uY2F0KHRoaXMuZXhwaXJhdGlvblRpbWUsIFwiLCBcIikgKyBcImN1cnJlbnRUaW1lPVwiLmNvbmNhdChEYXRlLm5vdygpLCBcIiwgXCIpICsgXCJyb3V0ZXJzPVtcIi5jb25jYXQodGhpcy5yb3V0ZXJzLCBcIl0sIFwiKSArIFwicmVhZGVycz1bXCIuY29uY2F0KHRoaXMucmVhZGVycywgXCJdLCBcIikgKyBcIndyaXRlcnM9W1wiLmNvbmNhdCh0aGlzLndyaXRlcnMsIFwiXV1cIik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSb3V0aW5nVGFibGU7XG59KCk7XG4vKipcbiAqIFJlbW92ZSBhbGwgb2NjdXJyZW5jZXMgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIGFycmF5LlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgdGhlIGFycmF5IHRvIGZpbHRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEByZXR1cm4ge0FycmF5fSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cblxuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJvdXRpbmdUYWJsZTtcblxuZnVuY3Rpb24gcmVtb3ZlRnJvbUFycmF5KGFycmF5LCBlbGVtZW50KSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS5hc0tleSgpICE9PSBlbGVtZW50LmFzS2V5KCk7XG4gIH0pO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkXCIpO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuLi9lcnJvclwiKTtcblxudmFyIF9pbnRlZ2VyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4uL2ludGVnZXJcIikpO1xuXG52YXIgX3NlcnZlclZlcnNpb24gPSByZXF1aXJlKFwiLi9zZXJ2ZXItdmVyc2lvblwiKTtcblxudmFyIF9ib29rbWFyayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYm9va21hcmtcIikpO1xuXG52YXIgX3Nlc3Npb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9zZXNzaW9uXCIpKTtcblxudmFyIF90eENvbmZpZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdHgtY29uZmlnXCIpKTtcblxudmFyIF9zZXJ2ZXJBZGRyZXNzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zZXJ2ZXItYWRkcmVzc1wiKSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIENPTlRFWFQgPSAnY29udGV4dCc7XG52YXIgQ0FMTF9HRVRfUk9VVElOR19UQUJMRSA9IFwiQ0FMTCBkYm1zLmNsdXN0ZXIucm91dGluZy5nZXRSb3V0aW5nVGFibGUoJFwiLmNvbmNhdChDT05URVhULCBcIilcIik7XG52YXIgREFUQUJBU0UgPSAnZGF0YWJhc2UnO1xudmFyIENBTExfR0VUX1JPVVRJTkdfVEFCTEVfTVVMVElfREIgPSBcIkNBTEwgZGJtcy5yb3V0aW5nLmdldFJvdXRpbmdUYWJsZSgkXCIuY29uY2F0KENPTlRFWFQsIFwiLCAkXCIpLmNvbmNhdChEQVRBQkFTRSwgXCIpXCIpO1xudmFyIFBST0NFRFVSRV9OT1RfRk9VTkRfQ09ERSA9ICdOZW8uQ2xpZW50RXJyb3IuUHJvY2VkdXJlLlByb2NlZHVyZU5vdEZvdW5kJztcbnZhciBEQVRBQkFTRV9OT1RfRk9VTkRfQ09ERSA9ICdOZW8uQ2xpZW50RXJyb3IuRGF0YWJhc2UuRGF0YWJhc2VOb3RGb3VuZCc7XG5cbnZhciBSb3V0aW5nVXRpbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJvdXRpbmdVdGlsKHJvdXRpbmdDb250ZXh0LCBpbml0aWFsQWRkcmVzcykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUm91dGluZ1V0aWwpO1xuICAgIHRoaXMuX3JvdXRpbmdDb250ZXh0ID0gcm91dGluZ0NvbnRleHQ7IC8vIFRoZSBhZGRyZXNzIHRoYXQgdGhlIGRyaXZlciBpcyBjb25uZWN0aW5nIHRvLCB1c2VkIGJ5IHJvdXRpbmcgYXMgYSBmYWxsYmFjayB3aGVuIHJvdXRpbmdcbiAgICAvLyBhbmQgY2x1c3RlcmluZyBpc24ndCBjb25maWd1cmVkLlxuXG4gICAgdGhpcy5faW5pdGlhbEFkZHJlc3MgPSBpbml0aWFsQWRkcmVzcztcbiAgfVxuICAvKipcbiAgICogSW52b2tlIHJvdXRpbmcgcHJvY2VkdXJlIHVzaW5nIHRoZSBnaXZlbiBzZXNzaW9uLlxuICAgKiBAcGFyYW0ge1Nlc3Npb259IHNlc3Npb24gdGhlIHNlc3Npb24gdG8gdXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm91dGVyQWRkcmVzcyB0aGUgVVJMIG9mIHRoZSByb3V0ZXIuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UmVjb3JkW10+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggcmVjb3JkcyByZXR1cm5lZCBieSB0aGUgcHJvY2VkdXJlIGNhbGwgb3IgbnVsbCBpZlxuICAgKiBjb25uZWN0aW9uIGVycm9yIGhhcHBlbmVkLlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUm91dGluZ1V0aWwsIFt7XG4gICAga2V5OiBcImNhbGxSb3V0aW5nUHJvY2VkdXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY2FsbFJvdXRpbmdQcm9jZWR1cmUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShzZXNzaW9uLCBkYXRhYmFzZSwgcm91dGVyQWRkcmVzcykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsQXZhaWxhYmxlUm91dGluZ1Byb2NlZHVyZShzZXNzaW9uLCBkYXRhYmFzZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb24uY2xvc2UoKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXN1bHQucmVjb3Jkcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA5O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcblxuICAgICAgICAgICAgICAgIGlmICghKF9jb250ZXh0LnQwLmNvZGUgPT09IERBVEFCQVNFX05PVF9GT1VORF9DT0RFKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQudDA7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICBpZiAoIShfY29udGV4dC50MC5jb2RlID09PSBQUk9DRURVUkVfTk9UX0ZPVU5EX0NPREUpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKShcIlNlcnZlciBhdCBcIi5jb25jYXQocm91dGVyQWRkcmVzcy5hc0hvc3RQb3J0KCksIFwiIGNhbid0IHBlcmZvcm0gcm91dGluZy4gTWFrZSBzdXJlIHlvdSBhcmUgY29ubmVjdGluZyB0byBhIGNhdXNhbCBjbHVzdGVyXCIpLCBfZXJyb3IuU0VSVklDRV9VTkFWQUlMQUJMRSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcywgW1swLCA5XV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjYWxsUm91dGluZ1Byb2NlZHVyZShfeCwgX3gyLCBfeDMpIHtcbiAgICAgICAgcmV0dXJuIF9jYWxsUm91dGluZ1Byb2NlZHVyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbFJvdXRpbmdQcm9jZWR1cmU7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VUdGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VUdGwocmVjb3JkLCByb3V0ZXJBZGRyZXNzKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbm93ID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShEYXRlLm5vdygpKTtcbiAgICAgICAgdmFyIGV4cGlyZXMgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHJlY29yZC5nZXQoJ3R0bCcpKS5tdWx0aXBseSgxMDAwKS5hZGQobm93KTsgLy8gaWYgdGhlIHNlcnZlciB1c2VzIGEgcmVhbGx5IGJpZyBleHBpcmUgdGltZSBsaWtlIExvbmcuTUFYX1ZBTFVFIHRoaXMgbWF5IGhhdmUgb3ZlcmZsb3dlZFxuXG4gICAgICAgIGlmIChleHBpcmVzLmxlc3NUaGFuKG5vdykpIHtcbiAgICAgICAgICByZXR1cm4gX2ludGVnZXJbXCJkZWZhdWx0XCJdLk1BWF9WQUxVRTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHBpcmVzO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoXCJVbmFibGUgdG8gcGFyc2UgVFRMIGVudHJ5IGZyb20gcm91dGVyIFwiLmNvbmNhdChyb3V0ZXJBZGRyZXNzLCBcIiBmcm9tIHJlY29yZDpcXG5cIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KHJlY29yZCksIFwiXFxuRXJyb3IgbWVzc2FnZTogXCIpLmNvbmNhdChlcnJvci5tZXNzYWdlKSwgX2Vycm9yLlBST1RPQ09MX0VSUk9SKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VTZXJ2ZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlU2VydmVycyhyZWNvcmQsIHJvdXRlckFkZHJlc3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzZXJ2ZXJzID0gcmVjb3JkLmdldCgnc2VydmVycycpO1xuICAgICAgICB2YXIgcm91dGVycyA9IFtdO1xuICAgICAgICB2YXIgcmVhZGVycyA9IFtdO1xuICAgICAgICB2YXIgd3JpdGVycyA9IFtdO1xuICAgICAgICBzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgICAgIHZhciByb2xlID0gc2VydmVyLnJvbGU7XG4gICAgICAgICAgdmFyIGFkZHJlc3NlcyA9IHNlcnZlci5hZGRyZXNzZXM7XG5cbiAgICAgICAgICBpZiAocm9sZSA9PT0gJ1JPVVRFJykge1xuICAgICAgICAgICAgcm91dGVycyA9IHBhcnNlQXJyYXkoYWRkcmVzc2VzKS5tYXAoZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9zZXJ2ZXJBZGRyZXNzW1wiZGVmYXVsdFwiXS5mcm9tVXJsKGFkZHJlc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyb2xlID09PSAnV1JJVEUnKSB7XG4gICAgICAgICAgICB3cml0ZXJzID0gcGFyc2VBcnJheShhZGRyZXNzZXMpLm1hcChmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICByZXR1cm4gX3NlcnZlckFkZHJlc3NbXCJkZWZhdWx0XCJdLmZyb21VcmwoYWRkcmVzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJvbGUgPT09ICdSRUFEJykge1xuICAgICAgICAgICAgcmVhZGVycyA9IHBhcnNlQXJyYXkoYWRkcmVzc2VzKS5tYXAoZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9zZXJ2ZXJBZGRyZXNzW1wiZGVmYXVsdFwiXS5mcm9tVXJsKGFkZHJlc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdVbmtub3duIHNlcnZlciByb2xlIFwiJyArIHJvbGUgKyAnXCInLCBfZXJyb3IuUFJPVE9DT0xfRVJST1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm91dGVyczogcm91dGVycyxcbiAgICAgICAgICByZWFkZXJzOiByZWFkZXJzLFxuICAgICAgICAgIHdyaXRlcnM6IHdyaXRlcnNcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKFwiVW5hYmxlIHRvIHBhcnNlIHNlcnZlcnMgZW50cnkgZnJvbSByb3V0ZXIgXCIuY29uY2F0KHJvdXRlckFkZHJlc3MsIFwiIGZyb20gcmVjb3JkOlxcblwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkocmVjb3JkKSwgXCJcXG5FcnJvciBtZXNzYWdlOiBcIikuY29uY2F0KGVycm9yLm1lc3NhZ2UpLCBfZXJyb3IuUFJPVE9DT0xfRVJST1IpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FsbEF2YWlsYWJsZVJvdXRpbmdQcm9jZWR1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGxBdmFpbGFibGVSb3V0aW5nUHJvY2VkdXJlKHNlc3Npb24sIGRhdGFiYXNlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gc2Vzc2lvbi5fcnVuKG51bGwsIG51bGwsIGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgIHZhciBxdWVyeTtcbiAgICAgICAgdmFyIHBhcmFtcztcbiAgICAgICAgdmFyIHByb3RvY29sVmVyc2lvbiA9IGNvbm5lY3Rpb24ucHJvdG9jb2woKS52ZXJzaW9uO1xuXG4gICAgICAgIGlmIChwcm90b2NvbFZlcnNpb24gPj0gNC4wKSB7XG4gICAgICAgICAgcXVlcnkgPSBDQUxMX0dFVF9ST1VUSU5HX1RBQkxFX01VTFRJX0RCO1xuICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGNvbnRleHQ6IF90aGlzLl9yb3V0aW5nQ29udGV4dCB8fCB7fSxcbiAgICAgICAgICAgIGRhdGFiYXNlOiBkYXRhYmFzZSB8fCBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBwYXJhbXMuY29udGV4dC5hZGRyZXNzID0gX3RoaXMuX2luaXRpYWxBZGRyZXNzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHF1ZXJ5ID0gQ0FMTF9HRVRfUk9VVElOR19UQUJMRTtcbiAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICBjb250ZXh0OiBfdGhpcy5fcm91dGluZ0NvbnRleHRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24ucHJvdG9jb2woKS5ydW4ocXVlcnksIHBhcmFtcywge1xuICAgICAgICAgIGJvb2ttYXJrOiBzZXNzaW9uLl9sYXN0Qm9va21hcmssXG4gICAgICAgICAgdHhDb25maWc6IF90eENvbmZpZ1tcImRlZmF1bHRcIl0uZW1wdHkoKSxcbiAgICAgICAgICBtb2RlOiBzZXNzaW9uLl9tb2RlLFxuICAgICAgICAgIGRhdGFiYXNlOiBzZXNzaW9uLl9kYXRhYmFzZSxcbiAgICAgICAgICBhZnRlckNvbXBsZXRlOiBzZXNzaW9uLl9vbkNvbXBsZXRlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSb3V0aW5nVXRpbDtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSb3V0aW5nVXRpbDtcblxuZnVuY3Rpb24gcGFyc2VBcnJheShhZGRyZXNzZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFkZHJlc3NlcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheSBleHBlY3RlZCBidXQgZ290OiAnICsgYWRkcmVzc2VzKTtcbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKGFkZHJlc3Nlcyk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBfdXJsVXRpbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXJsLXV0aWxcIikpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBTZXJ2ZXJBZGRyZXNzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2VydmVyQWRkcmVzcyhob3N0LCByZXNvbHZlZCwgcG9ydCwgaG9zdFBvcnQpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFNlcnZlckFkZHJlc3MpO1xuICAgIHRoaXMuX2hvc3QgPSAoMCwgX3V0aWwuYXNzZXJ0U3RyaW5nKShob3N0LCAnaG9zdCcpO1xuICAgIHRoaXMuX3Jlc29sdmVkID0gcmVzb2x2ZWQgPyAoMCwgX3V0aWwuYXNzZXJ0U3RyaW5nKShyZXNvbHZlZCwgJ3Jlc29sdmVkJykgOiBudWxsO1xuICAgIHRoaXMuX3BvcnQgPSAoMCwgX3V0aWwuYXNzZXJ0TnVtYmVyKShwb3J0LCAncG9ydCcpO1xuICAgIHRoaXMuX2hvc3RQb3J0ID0gaG9zdFBvcnQ7XG4gICAgdGhpcy5fc3RyaW5nVmFsdWUgPSByZXNvbHZlZCA/IFwiXCIuY29uY2F0KGhvc3RQb3J0LCBcIihcIikuY29uY2F0KHJlc29sdmVkLCBcIilcIikgOiBcIlwiLmNvbmNhdChob3N0UG9ydCk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFNlcnZlckFkZHJlc3MsIFt7XG4gICAga2V5OiBcImhvc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaG9zdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ob3N0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNvbHZlZEhvc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZWRIb3N0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkID8gdGhpcy5fcmVzb2x2ZWQgOiB0aGlzLl9ob3N0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvcnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcG9ydDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZVdpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZVdpdGgocmVzb2x2ZWQpIHtcbiAgICAgIHJldHVybiBuZXcgU2VydmVyQWRkcmVzcyh0aGlzLl9ob3N0LCByZXNvbHZlZCwgdGhpcy5fcG9ydCwgdGhpcy5faG9zdFBvcnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhc0hvc3RQb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzSG9zdFBvcnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faG9zdFBvcnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFzS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzS2V5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hvc3RQb3J0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHJpbmdWYWx1ZTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tVXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21VcmwodXJsKSB7XG4gICAgICB2YXIgdXJsUGFyc2VkID0gX3VybFV0aWxbXCJkZWZhdWx0XCJdLnBhcnNlRGF0YWJhc2VVcmwodXJsKTtcblxuICAgICAgcmV0dXJuIG5ldyBTZXJ2ZXJBZGRyZXNzKHVybFBhcnNlZC5ob3N0LCBudWxsLCB1cmxQYXJzZWQucG9ydCwgdXJsUGFyc2VkLmhvc3RBbmRQb3J0KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNlcnZlckFkZHJlc3M7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU2VydmVyQWRkcmVzczsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlZFUlNJT05fSU5fREVWID0gZXhwb3J0cy5WRVJTSU9OXzRfMF8wID0gZXhwb3J0cy5WRVJTSU9OXzNfNV8wID0gZXhwb3J0cy5WRVJTSU9OXzNfNF8wID0gZXhwb3J0cy5WRVJTSU9OXzNfMl8wID0gZXhwb3J0cy5TZXJ2ZXJWZXJzaW9uID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBTRVJWRVJfVkVSU0lPTl9SRUdFWCA9IG5ldyBSZWdFeHAoJ14oTmVvNGovKT8oXFxcXGQrKVxcXFwuKFxcXFxkKykoPzpcXFxcLik/KFxcXFxkKikoXFxcXC58LXxcXFxcKyk/KFswLTlBLVphLXotLl0qKT8kJyk7XG52YXIgTkVPNEpfSU5fREVWX1ZFUlNJT05fU1RSSU5HID0gJ05lbzRqL2Rldic7XG5cbnZhciBTZXJ2ZXJWZXJzaW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWFqb3IgdGhlIG1ham9yIHZlcnNpb24gbnVtYmVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWlub3IgdGhlIG1pbm9yIHZlcnNpb24gbnVtYmVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGF0Y2ggdGhlIHBhdGNoIHZlcnNpb24gbnVtYmVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGhlIG9yaWdpbmFsIHZlcnNpb24gc3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiBTZXJ2ZXJWZXJzaW9uKG1ham9yLCBtaW5vciwgcGF0Y2gsIG9yaWdpbmFsVmVyc2lvblN0cmluZykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgU2VydmVyVmVyc2lvbik7XG4gICAgdGhpcy5tYWpvciA9IG1ham9yO1xuICAgIHRoaXMubWlub3IgPSBtaW5vcjtcbiAgICB0aGlzLnBhdGNoID0gcGF0Y2g7XG4gICAgdGhpcy5fb3JpZ2luYWxWZXJzaW9uU3RyaW5nID0gb3JpZ2luYWxWZXJzaW9uU3RyaW5nO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBzZXJ2ZXIgdmVyc2lvbiB1c2luZyB0aGUgZ2l2ZW4gZHJpdmVyLlxuICAgKiBAcGFyYW0ge0RyaXZlcn0gZHJpdmVyIHRoZSBkcml2ZXIgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFNlcnZlclZlcnNpb24+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggYSB7QGxpbmsgU2VydmVyVmVyc2lvbn0gb2JqZWN0IG9yIHJlamVjdGVkIHdpdGggZXJyb3IuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShTZXJ2ZXJWZXJzaW9uLCBbe1xuICAgIGtleTogXCJjb21wYXJlVG9cIixcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdGhpcyB2ZXJzaW9uIHRvIHRoZSBnaXZlbiBvbmUuXG4gICAgICogQHBhcmFtIHtTZXJ2ZXJWZXJzaW9ufSBvdGhlciB0aGUgdmVyc2lvbiB0byBjb21wYXJlIHdpdGguXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB2YWx1ZSAwIGlmIHRoaXMgdmVyc2lvbiBpcyB0aGUgc2FtZSBhcyB0aGUgZ2l2ZW4gb25lLCB2YWx1ZSBsZXNzIHRoZW4gMCB3aGVuIHRoaXMgdmVyc2lvblxuICAgICAqIHdhcyByZWxlYXNlZCBlYXJsaWVyIHRoYW4gdGhlIGdpdmVuIG9uZSBhbmQgdmFsdWUgZ3JlYXRlciB0aGVuIDAgd2hlbiB0aGlzIHZlcnNpb24gd2FzIHJlbGVhc2VkIGFmdGVyXG4gICAgICogdGhhbiB0aGUgZ2l2ZW4gb25lLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlSW50cyh0aGlzLm1ham9yLCBvdGhlci5tYWpvcik7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gY29tcGFyZUludHModGhpcy5taW5vciwgb3RoZXIubWlub3IpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBjb21wYXJlSW50cyh0aGlzLnBhdGNoLCBvdGhlci5wYXRjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5fb3JpZ2luYWxWZXJzaW9uU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbFZlcnNpb25TdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLm1ham9yLCBcIi5cIikuY29uY2F0KHRoaXMubWlub3IsIFwiLlwiKS5jb25jYXQodGhpcy5wYXRjaCk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbURyaXZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRHJpdmVyKGRyaXZlcikge1xuICAgICAgdmFyIHNlc3Npb24gPSBkcml2ZXIuc2Vzc2lvbigpO1xuICAgICAgcmV0dXJuIHNlc3Npb24ucnVuKCdSRVRVUk4gMScpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gc2Vzc2lvbi5jbG9zZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBTZXJ2ZXJWZXJzaW9uLmZyb21TdHJpbmcocmVzdWx0LnN1bW1hcnkuc2VydmVyLnZlcnNpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBnaXZlbiBzdHJpbmcgdG8gYSB7QGxpbmsgU2VydmVyVmVyc2lvbn0gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uU3RyIHRoZSBzdHJpbmcgdG8gcGFyc2UuXG4gICAgICogQHJldHVybiB7U2VydmVyVmVyc2lvbn0gdmVyc2lvbiBmb3IgdGhlIGdpdmVuIHN0cmluZy5cbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIGdpdmVuIHN0cmluZyBjYW4ndCBiZSBwYXJzZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmcm9tU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TdHJpbmcodmVyc2lvblN0cikge1xuICAgICAgaWYgKCF2ZXJzaW9uU3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VydmVyVmVyc2lvbigzLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgKDAsIF91dGlsLmFzc2VydFN0cmluZykodmVyc2lvblN0ciwgJ05lbzRqIHZlcnNpb24gc3RyaW5nJyk7XG5cbiAgICAgIGlmICh2ZXJzaW9uU3RyLnRvTG93ZXJDYXNlKCkgPT09IE5FTzRKX0lOX0RFVl9WRVJTSU9OX1NUUklORy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OX0lOX0RFVjtcbiAgICAgIH1cblxuICAgICAgdmFyIHZlcnNpb24gPSB2ZXJzaW9uU3RyLm1hdGNoKFNFUlZFUl9WRVJTSU9OX1JFR0VYKTtcblxuICAgICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucGFyc2FibGUgTmVvNGogdmVyc2lvbjogXCIuY29uY2F0KHZlcnNpb25TdHIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1ham9yID0gcGFyc2VJbnRTdHJpY3QodmVyc2lvblsyXSk7XG4gICAgICB2YXIgbWlub3IgPSBwYXJzZUludFN0cmljdCh2ZXJzaW9uWzNdKTtcbiAgICAgIHZhciBwYXRjaCA9IHBhcnNlSW50U3RyaWN0KHZlcnNpb25bNF0gfHwgMCk7XG4gICAgICByZXR1cm4gbmV3IFNlcnZlclZlcnNpb24obWFqb3IsIG1pbm9yLCBwYXRjaCwgdmVyc2lvblN0cik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTZXJ2ZXJWZXJzaW9uO1xufSgpO1xuXG5leHBvcnRzLlNlcnZlclZlcnNpb24gPSBTZXJ2ZXJWZXJzaW9uO1xuXG5mdW5jdGlvbiBwYXJzZUludFN0cmljdChzdHIsIG5hbWUpIHtcbiAgdmFyIHZhbHVlID0gcGFyc2VJbnQoc3RyLCAxMCk7XG5cbiAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVucGFyc2FibGUgbnVtYmVyIFwiLmNvbmNhdChuYW1lLCBcIjogJ1wiKS5jb25jYXQoc3RyLCBcIidcIikpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlSW50cyh4LCB5KSB7XG4gIHJldHVybiB4IDwgeSA/IC0xIDogeCA9PT0geSA/IDAgOiAxO1xufVxuXG52YXIgVkVSU0lPTl8zXzJfMCA9IFNlcnZlclZlcnNpb24uZnJvbVN0cmluZygnTmVvNGovMy4yLjAnKTtcbmV4cG9ydHMuVkVSU0lPTl8zXzJfMCA9IFZFUlNJT05fM18yXzA7XG52YXIgVkVSU0lPTl8zXzRfMCA9IFNlcnZlclZlcnNpb24uZnJvbVN0cmluZygnTmVvNGovMy40LjAnKTtcbmV4cG9ydHMuVkVSU0lPTl8zXzRfMCA9IFZFUlNJT05fM180XzA7XG52YXIgVkVSU0lPTl8zXzVfMCA9IFNlcnZlclZlcnNpb24uZnJvbVN0cmluZygnTmVvNGovMy41LjAnKTtcbmV4cG9ydHMuVkVSU0lPTl8zXzVfMCA9IFZFUlNJT05fM181XzA7XG52YXIgVkVSU0lPTl80XzBfMCA9IFNlcnZlclZlcnNpb24uZnJvbVN0cmluZygnTmVvNGovNC4wLjAnKTtcbmV4cG9ydHMuVkVSU0lPTl80XzBfMCA9IFZFUlNJT05fNF8wXzA7XG52YXIgbWF4VmVyID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG52YXIgVkVSU0lPTl9JTl9ERVYgPSBuZXcgU2VydmVyVmVyc2lvbihtYXhWZXIsIG1heFZlciwgbWF4VmVyLCBORU80Sl9JTl9ERVZfVkVSU0lPTl9TVFJJTkcpO1xuZXhwb3J0cy5WRVJTSU9OX0lOX0RFViA9IFZFUlNJT05fSU5fREVWOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ29tcGxldGVkT2JzZXJ2ZXIgPSBleHBvcnRzLkZhaWxlZE9ic2VydmVyID0gZXhwb3J0cy5SZXNldE9ic2VydmVyID0gZXhwb3J0cy5Mb2dpbk9ic2VydmVyID0gZXhwb3J0cy5SZXN1bHRTdHJlYW1PYnNlcnZlciA9IGV4cG9ydHMuU3RyZWFtT2JzZXJ2ZXIgPSB2b2lkIDA7XG5cbnZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpKTtcblxudmFyIF9nZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9yZWNvcmQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9yZWNvcmRcIikpO1xuXG52YXIgX2Nvbm5lY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb25cIikpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xuXG52YXIgX2ludGVnZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9pbnRlZ2VyXCIpKTtcblxudmFyIF9yZXF1ZXN0TWVzc2FnZSA9IHJlcXVpcmUoXCIuL3JlcXVlc3QtbWVzc2FnZVwiKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFN0cmVhbU9ic2VydmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RyZWFtT2JzZXJ2ZXIoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBTdHJlYW1PYnNlcnZlcik7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFN0cmVhbU9ic2VydmVyLCBbe1xuICAgIGtleTogXCJvbk5leHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25OZXh0KHJhd1JlY29yZCkge31cbiAgfSwge1xuICAgIGtleTogXCJvbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwib25Db21wbGV0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Db21wbGV0ZWQobWV0YSkge31cbiAgfV0pO1xuICByZXR1cm4gU3RyZWFtT2JzZXJ2ZXI7XG59KCk7XG4vKipcbiAqIEhhbmRsZXMgYSBSVU4vUFVMTF9BTEwsIG9yIFJVTi9ESVNDQVJEX0FMTCByZXF1ZXN0cywgbWFwcyB0aGUgcmVzcG9uc2VzXG4gKiBpbiBhIHdheSB0aGF0IGEgdXNlci1wcm92aWRlZCBvYnNlcnZlciBjYW4gc2VlIHRoZXNlIGFzIGEgY2xlYW4gU3RyZWFtXG4gKiBvZiByZWNvcmRzLlxuICogVGhpcyBjbGFzcyB3aWxsIHF1ZXVlIHVwIGluY29taW5nIG1lc3NhZ2VzIHVudGlsIGEgdXNlci1wcm92aWRlZCBvYnNlcnZlclxuICogZm9yIHRoZSBpbmNvbWluZyBzdHJlYW0gaXMgcmVnaXN0ZXJlZC4gVGh1cywgd2Uga2VlcCBmaWVsZHMgYXJvdW5kXG4gKiBmb3IgdHJhY2tpbmcgaGVhZC9yZWNvcmRzL3RhaWwuIFRoZXNlIGFyZSBvbmx5IHVzZWQgaWYgdGhlcmUgaXMgbm9cbiAqIG9ic2VydmVyIHJlZ2lzdGVyZWQuXG4gKiBAYWNjZXNzIHByaXZhdGVcbiAqL1xuXG5cbmV4cG9ydHMuU3RyZWFtT2JzZXJ2ZXIgPSBTdHJlYW1PYnNlcnZlcjtcblxudmFyIFJlc3VsdFN0cmVhbU9ic2VydmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3RyZWFtT2JzZXJ2ZXIpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShSZXN1bHRTdHJlYW1PYnNlcnZlciwgX1N0cmVhbU9ic2VydmVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJlc3VsdFN0cmVhbU9ic2VydmVyKTtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gcGFyYW0uY29ubmVjdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtLnJlYWN0aXZlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY29ubmVjdGlvbjogQ29ubmVjdGlvbiwgc3RtdElkOiBudW1iZXJ8SW50ZWdlciwgbjogbnVtYmVyfEludGVnZXIsIG9ic2VydmVyOiBTdHJlYW1PYnNlcnZlcil9IHBhcmFtLm1vcmVGdW5jdGlvbiAtXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oY29ubmVjdGlvbjogQ29ubmVjdGlvbiwgc3RtdElkOiBudW1iZXJ8SW50ZWdlciwgb2JzZXJ2ZXI6IFN0cmVhbU9ic2VydmVyKX0gcGFyYW0uZGlzY2FyZEZ1bmN0aW9uIC1cbiAgICogQHBhcmFtIHtudW1iZXJ8SW50ZWdlcn0gcGFyYW0uZmV0Y2hTaXplIC1cbiAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IEVycm9yKTogUHJvbWlzZXx2b2lkfSBwYXJhbS5iZWZvcmVFcnJvciAtXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBFcnJvcik6IFByb21pc2V8dm9pZH0gcGFyYW0uYWZ0ZXJFcnJvciAtXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oa2V5czogc3RyaW5nW10pOiBQcm9taXNlfHZvaWR9IHBhcmFtLmJlZm9yZUtleXMgLVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGtleXM6IHN0cmluZ1tdKTogUHJvbWlzZXx2b2lkfSBwYXJhbS5hZnRlcktleXMgLVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG1ldGFkYXRhOiBPYmplY3QpOiBQcm9taXNlfHZvaWR9IHBhcmFtLmJlZm9yZUNvbXBsZXRlIC1cbiAgICogQHBhcmFtIHtmdW5jdGlvbihtZXRhZGF0YTogT2JqZWN0KTogUHJvbWlzZXx2b2lkfSBwYXJhbS5hZnRlckNvbXBsZXRlIC1cbiAgICovXG4gIGZ1bmN0aW9uIFJlc3VsdFN0cmVhbU9ic2VydmVyKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgY29ubmVjdGlvbiA9IF9yZWYuY29ubmVjdGlvbixcbiAgICAgICAgX3JlZiRyZWFjdGl2ZSA9IF9yZWYucmVhY3RpdmUsXG4gICAgICAgIHJlYWN0aXZlID0gX3JlZiRyZWFjdGl2ZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJHJlYWN0aXZlLFxuICAgICAgICBtb3JlRnVuY3Rpb24gPSBfcmVmLm1vcmVGdW5jdGlvbixcbiAgICAgICAgZGlzY2FyZEZ1bmN0aW9uID0gX3JlZi5kaXNjYXJkRnVuY3Rpb24sXG4gICAgICAgIF9yZWYkZmV0Y2hTaXplID0gX3JlZi5mZXRjaFNpemUsXG4gICAgICAgIGZldGNoU2l6ZSA9IF9yZWYkZmV0Y2hTaXplID09PSB2b2lkIDAgPyBfcmVxdWVzdE1lc3NhZ2UuQUxMIDogX3JlZiRmZXRjaFNpemUsXG4gICAgICAgIGJlZm9yZUVycm9yID0gX3JlZi5iZWZvcmVFcnJvcixcbiAgICAgICAgYWZ0ZXJFcnJvciA9IF9yZWYuYWZ0ZXJFcnJvcixcbiAgICAgICAgYmVmb3JlS2V5cyA9IF9yZWYuYmVmb3JlS2V5cyxcbiAgICAgICAgYWZ0ZXJLZXlzID0gX3JlZi5hZnRlcktleXMsXG4gICAgICAgIGJlZm9yZUNvbXBsZXRlID0gX3JlZi5iZWZvcmVDb21wbGV0ZSxcbiAgICAgICAgYWZ0ZXJDb21wbGV0ZSA9IF9yZWYuYWZ0ZXJDb21wbGV0ZTtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUmVzdWx0U3RyZWFtT2JzZXJ2ZXIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIF90aGlzLl9maWVsZEtleXMgPSBudWxsO1xuICAgIF90aGlzLl9maWVsZExvb2t1cCA9IG51bGw7XG4gICAgX3RoaXMuX2hlYWQgPSBudWxsO1xuICAgIF90aGlzLl9xdWV1ZWRSZWNvcmRzID0gW107XG4gICAgX3RoaXMuX3RhaWwgPSBudWxsO1xuICAgIF90aGlzLl9lcnJvciA9IG51bGw7XG4gICAgX3RoaXMuX29ic2VydmVycyA9IFtdO1xuICAgIF90aGlzLl9tZXRhID0ge307XG4gICAgX3RoaXMuX2JlZm9yZUVycm9yID0gYmVmb3JlRXJyb3I7XG4gICAgX3RoaXMuX2FmdGVyRXJyb3IgPSBhZnRlckVycm9yO1xuICAgIF90aGlzLl9iZWZvcmVLZXlzID0gYmVmb3JlS2V5cztcbiAgICBfdGhpcy5fYWZ0ZXJLZXlzID0gYWZ0ZXJLZXlzO1xuICAgIF90aGlzLl9iZWZvcmVDb21wbGV0ZSA9IGJlZm9yZUNvbXBsZXRlO1xuICAgIF90aGlzLl9hZnRlckNvbXBsZXRlID0gYWZ0ZXJDb21wbGV0ZTtcbiAgICBfdGhpcy5fcXVlcnlJZCA9IG51bGw7XG4gICAgX3RoaXMuX21vcmVGdW5jdGlvbiA9IG1vcmVGdW5jdGlvbjtcbiAgICBfdGhpcy5fZGlzY2FyZEZ1bmN0aW9uID0gZGlzY2FyZEZ1bmN0aW9uO1xuICAgIF90aGlzLl9kaXNjYXJkID0gZmFsc2U7XG4gICAgX3RoaXMuX2ZldGNoU2l6ZSA9IGZldGNoU2l6ZTtcblxuICAgIF90aGlzLl9zZXRTdGF0ZShyZWFjdGl2ZSA/IF9zdGF0ZXMuUkVBRFkgOiBfc3RhdGVzLlJFQURZX1NUUkVBTUlORyk7XG5cbiAgICBfdGhpcy5fc2V0dXBBdW9QdWxsKGZldGNoU2l6ZSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdpbGwgYmUgY2FsbGVkIG9uIGV2ZXJ5IHJlY29yZCB0aGF0IGNvbWVzIGluIGFuZCB0cmFuc2Zvcm0gYSByYXcgcmVjb3JkXG4gICAqIHRvIGEgT2JqZWN0LiBJZiB1c2VyLXByb3ZpZGVkIG9ic2VydmVyIGlzIHByZXNlbnQsIHBhc3MgdHJhbnNmb3JtZWQgcmVjb3JkXG4gICAqIHRvIGl0J3Mgb25OZXh0IG1ldGhvZCwgb3RoZXJ3aXNlLCBwdXNoIHRvIHJlY29yZCBxdWUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJhd1JlY29yZCAtIEFuIGFycmF5IHdpdGggdGhlIHJhdyByZWNvcmRcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFJlc3VsdFN0cmVhbU9ic2VydmVyLCBbe1xuICAgIGtleTogXCJvbk5leHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25OZXh0KHJhd1JlY29yZCkge1xuICAgICAgdmFyIHJlY29yZCA9IG5ldyBfcmVjb3JkW1wiZGVmYXVsdFwiXSh0aGlzLl9maWVsZEtleXMsIHJhd1JlY29yZCwgdGhpcy5fZmllbGRMb29rdXApO1xuXG4gICAgICBpZiAodGhpcy5fb2JzZXJ2ZXJzLnNvbWUoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIG8ub25OZXh0O1xuICAgICAgfSkpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICBpZiAoby5vbk5leHQpIHtcbiAgICAgICAgICAgIG8ub25OZXh0KHJlY29yZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZFJlY29yZHMucHVzaChyZWNvcmQpO1xuXG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZWRSZWNvcmRzLmxlbmd0aCA+IHRoaXMuX2hpZ2hSZWNvcmRXYXRlcm1hcmspIHtcbiAgICAgICAgICB0aGlzLl9hdXRvUHVsbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uQ29tcGxldGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ29tcGxldGVkKG1ldGEpIHtcbiAgICAgIHRoaXMuX3N0YXRlLm9uU3VjY2Vzcyh0aGlzLCBtZXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBiZSBjYWxsZWQgb24gZXJyb3JzLlxuICAgICAqIElmIHVzZXItcHJvdmlkZWQgb2JzZXJ2ZXIgaXMgcHJlc2VudCwgcGFzcyB0aGUgZXJyb3JcbiAgICAgKiB0byBpdCdzIG9uRXJyb3IgbWV0aG9kLCBvdGhlcndpc2Ugc2V0IGluc3RhbmNlIHZhcmlhYmxlIF9lcnJvci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXJyb3IgLSBBbiBlcnJvciBvYmplY3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgdGhpcy5fc3RhdGUub25FcnJvcih0aGlzLCBlcnJvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbCBwZW5kaW5nIHJlY29yZCBzdHJlYW1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhbmNlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICB0aGlzLl9kaXNjYXJkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RyZWFtIG9ic2VydmVyIGRlZmF1bHRzIHRvIGhhbmRsaW5nIHJlc3BvbnNlcyBmb3IgdHdvIG1lc3NhZ2VzOiBSVU4gKyBQVUxMX0FMTCBvciBSVU4gKyBESVNDQVJEX0FMTC5cbiAgICAgKiBSZXNwb25zZSBmb3IgUlVOIGluaXRpYWxpemVzIHF1ZXJ5IGtleXMuIFJlc3BvbnNlIGZvciBQVUxMX0FMTCAvIERJU0NBUkRfQUxMIGV4cG9zZXMgdGhlIHJlc3VsdCBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBIb3dldmVyLCBzb21lIG9wZXJhdGlvbnMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgc2luZ2xlIG1lc3NhZ2Ugd2hpY2ggcmVjZWl2ZXMgZnVsbCBtZXRhZGF0YSBpbiBhIHNpbmdsZSByZXNwb25zZS5cbiAgICAgKiBGb3IgZXhhbXBsZSwgb3BlcmF0aW9ucyB0byBiZWdpbiwgY29tbWl0IGFuZCByb2xsYmFjayBhbiBleHBsaWNpdCB0cmFuc2FjdGlvbiB1c2UgdHdvIG1lc3NhZ2VzIGluIEJvbHQgVjEgYnV0IGEgc2luZ2xlIG1lc3NhZ2UgaW4gQm9sdCBWMy5cbiAgICAgKiBNZXNzYWdlcyBhcmUgYFJVTiBcIkJFR0lOXCIge31gICsgYFBVTExfQUxMYCBpbiBCb2x0IFYxIGFuZCBgQkVHSU5gIGluIEJvbHQgVjMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHByZXBhcmVzIHRoZSBvYnNlcnZlciB0byBvbmx5IGhhbmRsZSBhIHNpbmdsZSByZXNwb25zZSBtZXNzYWdlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGFyZVRvSGFuZGxlU2luZ2xlUmVzcG9uc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyZVRvSGFuZGxlU2luZ2xlUmVzcG9uc2UoKSB7XG4gICAgICB0aGlzLl9oZWFkID0gW107XG4gICAgICB0aGlzLl9maWVsZEtleXMgPSBbXTtcblxuICAgICAgdGhpcy5fc2V0U3RhdGUoX3N0YXRlcy5TVFJFQU1JTkcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrIHRoaXMgb2JzZXJ2ZXIgYXMgaWYgaXQgaGFzIGNvbXBsZXRlZCB3aXRoIG5vIG1ldGFkYXRhLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWFya0NvbXBsZXRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrQ29tcGxldGVkKCkge1xuICAgICAgdGhpcy5faGVhZCA9IFtdO1xuICAgICAgdGhpcy5fZmllbGRLZXlzID0gW107XG4gICAgICB0aGlzLl90YWlsID0ge307XG5cbiAgICAgIHRoaXMuX3NldFN0YXRlKF9zdGF0ZXMuU1VDQ0VFREVEKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIGV2ZW50cyB3aXRoIHByb3ZpZGVkIG9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciAtIE9ic2VydmVyIG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oa2V5czogU3RyaW5nW10pfSBvYnNlcnZlci5vbktleXMgLSBIYW5kbGUgc3RyZWFtIGhlYWRlciwgZmllbGQga2V5cy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHJlY29yZDogT2JqZWN0KX0gb2JzZXJ2ZXIub25OZXh0IC0gSGFuZGxlIHJlY29yZHMsIG9uZSBieSBvbmUuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihtZXRhZGF0YTogT2JqZWN0KX0gb2JzZXJ2ZXIub25Db21wbGV0ZWQgLSBIYW5kbGUgc3RyZWFtIHRhaWwsIHRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycm9yOiBPYmplY3QpfSBvYnNlcnZlci5vbkVycm9yIC0gSGFuZGxlIGVycm9ycywgc2hvdWxkIGFsd2F5cyBiZSBwcm92aWRlZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN1YnNjcmliZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICBvYnNlcnZlci5vbkVycm9yKHRoaXMuX2Vycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faGVhZCAmJiBvYnNlcnZlci5vbktleXMpIHtcbiAgICAgICAgb2JzZXJ2ZXIub25LZXlzKHRoaXMuX2hlYWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcXVldWVkUmVjb3Jkcy5sZW5ndGggPiAwICYmIG9ic2VydmVyLm9uTmV4dCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlZFJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYnNlcnZlci5vbk5leHQodGhpcy5fcXVldWVkUmVjb3Jkc1tpXSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fcXVldWVkUmVjb3Jkcy5sZW5ndGggLSBpIC0gMSA8PSB0aGlzLl9sb3dSZWNvcmRXYXRlcm1hcmspIHtcbiAgICAgICAgICAgIHRoaXMuX2F1dG9QdWxsID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBfc3RhdGVzLlJFQURZKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVN0cmVhbWluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fdGFpbCAmJiBvYnNlcnZlci5vbkNvbXBsZXRlZCkge1xuICAgICAgICBvYnNlcnZlci5vbkNvbXBsZXRlZCh0aGlzLl90YWlsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuXG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IF9zdGF0ZXMuUkVBRFkpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlU3RyZWFtaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVIYXNNb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVIYXNNb3JlKG1ldGEpIHtcbiAgICAgIC8vIFdlJ3ZlIGNvbnN1bWVkIGN1cnJlbnQgYmF0Y2ggYW5kIHNlcnZlciBub3RpZmllZCB1cyB0aGF0IHRoZXJlJ3JlIG1vcmVcbiAgICAgIC8vIHJlY29yZHMgdG8gc3RyZWFtLiBMZXQncyBpbnZva2UgbW9yZSBvciBkaXNjYXJkIGZ1bmN0aW9uIGJhc2VkIG9uIHdoZXRoZXJcbiAgICAgIC8vIHRoZSB1c2VyIHdhbnRzIHRvIGRpc2NhcmQgc3RyZWFtaW5nIG9yIG5vdFxuICAgICAgdGhpcy5fc2V0U3RhdGUoX3N0YXRlcy5SRUFEWSk7IC8vIHdlJ3ZlIGRvbmUgc3RyZWFtaW5nXG5cblxuICAgICAgdGhpcy5faGFuZGxlU3RyZWFtaW5nKCk7XG5cbiAgICAgIGRlbGV0ZSBtZXRhLmhhc19tb3JlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlUHVsbFN1Y2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVB1bGxTdWNjZXNzKG1ldGEpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9zZXRTdGF0ZShfc3RhdGVzLlNVQ0NFRURFRCk7XG5cbiAgICAgIHZhciBjb21wbGV0aW9uTWV0YWRhdGEgPSBPYmplY3QuYXNzaWduKHRoaXMuX2Nvbm5lY3Rpb24gPyB7XG4gICAgICAgIHNlcnZlcjogdGhpcy5fY29ubmVjdGlvbi5zZXJ2ZXJcbiAgICAgIH0gOiB7fSwgdGhpcy5fbWV0YSwgbWV0YSk7XG4gICAgICB2YXIgYmVmb3JlSGFuZGxlclJlc3VsdCA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLl9iZWZvcmVDb21wbGV0ZSkge1xuICAgICAgICBiZWZvcmVIYW5kbGVyUmVzdWx0ID0gdGhpcy5fYmVmb3JlQ29tcGxldGUoY29tcGxldGlvbk1ldGFkYXRhKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRpbnVhdGlvbiA9IGZ1bmN0aW9uIGNvbnRpbnVhdGlvbigpIHtcbiAgICAgICAgLy8gRW5kIG9mIHN0cmVhbVxuICAgICAgICBfdGhpczIuX3RhaWwgPSBjb21wbGV0aW9uTWV0YWRhdGE7XG5cbiAgICAgICAgaWYgKF90aGlzMi5fb2JzZXJ2ZXJzLnNvbWUoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICByZXR1cm4gby5vbkNvbXBsZXRlZDtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBfdGhpczIuX29ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICBpZiAoby5vbkNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICBvLm9uQ29tcGxldGVkKGNvbXBsZXRpb25NZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMyLl9hZnRlckNvbXBsZXRlKSB7XG4gICAgICAgICAgX3RoaXMyLl9hZnRlckNvbXBsZXRlKGNvbXBsZXRpb25NZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChiZWZvcmVIYW5kbGVyUmVzdWx0KSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShiZWZvcmVIYW5kbGVyUmVzdWx0KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGludWF0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVSdW5TdWNjZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVSdW5TdWNjZXNzKG1ldGEsIGFmdGVyU3VjY2Vzcykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9maWVsZEtleXMgPT09IG51bGwpIHtcbiAgICAgICAgLy8gU3RyZWFtIGhlYWRlciwgYnVpbGQgYSBuYW1lLT5pbmRleCBmaWVsZCBsb29rdXAgdGFibGVcbiAgICAgICAgLy8gdG8gYmUgdXNlZCBieSByZWNvcmRzLiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiB0byBtYWtlIGl0XG4gICAgICAgIC8vIGZhc3RlciB0byBsb29rIHVwIGZpZWxkcyBpbiBhIHJlY29yZCBieSBuYW1lLCByYXRoZXIgdGhhbiBieSBpbmRleC5cbiAgICAgICAgLy8gU2luY2UgdGhlIHJlY29yZHMgd2UgZ2V0IGJhY2sgdmlhIEJvbHQgYXJlIGp1c3QgYXJyYXlzIG9mIHZhbHVlcy5cbiAgICAgICAgdGhpcy5fZmllbGRLZXlzID0gW107XG4gICAgICAgIHRoaXMuX2ZpZWxkTG9va3VwID0ge307XG5cbiAgICAgICAgaWYgKG1ldGEuZmllbGRzICYmIG1ldGEuZmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLl9maWVsZEtleXMgPSBtZXRhLmZpZWxkcztcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YS5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkTG9va3VwW21ldGEuZmllbGRzW2ldXSA9IGk7XG4gICAgICAgICAgfSAvLyByZW1vdmUgZmllbGRzIGtleSBmcm9tIG1ldGFkYXRhIG9iamVjdFxuXG5cbiAgICAgICAgICBkZWxldGUgbWV0YS5maWVsZHM7XG4gICAgICAgIH0gLy8gRXh0cmFjdCBzZXJ2ZXIgZ2VuZXJhdGVkIHF1ZXJ5IGlkIGZvciB1c2UgaW4gcmVxdWVzdE1vcmUgYW5kIGRpc2NhcmRcbiAgICAgICAgLy8gZnVuY3Rpb25zXG5cblxuICAgICAgICBpZiAobWV0YS5xaWQpIHtcbiAgICAgICAgICB0aGlzLl9xdWVyeUlkID0gbWV0YS5xaWQ7IC8vIHJlbW92ZSBxaWQgZnJvbSBtZXRhZGF0YSBvYmplY3RcblxuICAgICAgICAgIGRlbGV0ZSBtZXRhLnFpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0b3JlTWV0YWRhdGFGb3JDb21wbGV0aW9uKG1ldGEpO1xuXG4gICAgICAgIHZhciBiZWZvcmVIYW5kbGVyUmVzdWx0ID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5fYmVmb3JlS2V5cykge1xuICAgICAgICAgIGJlZm9yZUhhbmRsZXJSZXN1bHQgPSB0aGlzLl9iZWZvcmVLZXlzKHRoaXMuX2ZpZWxkS2V5cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGludWF0aW9uID0gZnVuY3Rpb24gY29udGludWF0aW9uKCkge1xuICAgICAgICAgIF90aGlzMy5faGVhZCA9IF90aGlzMy5fZmllbGRLZXlzO1xuXG4gICAgICAgICAgaWYgKF90aGlzMy5fb2JzZXJ2ZXJzLnNvbWUoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHJldHVybiBvLm9uS2V5cztcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgX3RoaXMzLl9vYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICBpZiAoby5vbktleXMpIHtcbiAgICAgICAgICAgICAgICBvLm9uS2V5cyhfdGhpczMuX2ZpZWxkS2V5cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdGhpczMuX2FmdGVyS2V5cykge1xuICAgICAgICAgICAgX3RoaXMzLl9hZnRlcktleXMoX3RoaXMzLl9maWVsZEtleXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFmdGVyU3VjY2VzcygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChiZWZvcmVIYW5kbGVyUmVzdWx0KSB7XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGJlZm9yZUhhbmRsZXJSZXN1bHQpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRpbnVhdGlvbigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9zZXRTdGF0ZShfc3RhdGVzLkZBSUxFRCk7XG5cbiAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICB2YXIgYmVmb3JlSGFuZGxlclJlc3VsdCA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLl9iZWZvcmVFcnJvcikge1xuICAgICAgICBiZWZvcmVIYW5kbGVyUmVzdWx0ID0gdGhpcy5fYmVmb3JlRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGludWF0aW9uID0gZnVuY3Rpb24gY29udGludWF0aW9uKCkge1xuICAgICAgICBpZiAoX3RoaXM0Ll9vYnNlcnZlcnMuc29tZShmdW5jdGlvbiAobykge1xuICAgICAgICAgIHJldHVybiBvLm9uRXJyb3I7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgX3RoaXM0Ll9vYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgaWYgKG8ub25FcnJvcikge1xuICAgICAgICAgICAgICBvLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzNC5fYWZ0ZXJFcnJvcikge1xuICAgICAgICAgIF90aGlzNC5fYWZ0ZXJFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChiZWZvcmVIYW5kbGVyUmVzdWx0KSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShiZWZvcmVIYW5kbGVyUmVzdWx0KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGludWF0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVTdHJlYW1pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVN0cmVhbWluZygpIHtcbiAgICAgIGlmICh0aGlzLl9oZWFkICYmIHRoaXMuX29ic2VydmVycy5zb21lKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvLm9uTmV4dCB8fCBvLm9uQ29tcGxldGVkO1xuICAgICAgfSkpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc2NhcmQpIHtcbiAgICAgICAgICB0aGlzLl9kaXNjYXJkRnVuY3Rpb24odGhpcy5fY29ubmVjdGlvbiwgdGhpcy5fcXVlcnlJZCwgdGhpcyk7XG5cbiAgICAgICAgICB0aGlzLl9zZXRTdGF0ZShfc3RhdGVzLlNUUkVBTUlORyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYXV0b1B1bGwpIHtcbiAgICAgICAgICB0aGlzLl9tb3JlRnVuY3Rpb24odGhpcy5fY29ubmVjdGlvbiwgdGhpcy5fcXVlcnlJZCwgdGhpcy5fZmV0Y2hTaXplLCB0aGlzKTtcblxuICAgICAgICAgIHRoaXMuX3NldFN0YXRlKF9zdGF0ZXMuU1RSRUFNSU5HKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc3RvcmVNZXRhZGF0YUZvckNvbXBsZXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0b3JlTWV0YWRhdGFGb3JDb21wbGV0aW9uKG1ldGEpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobWV0YSk7XG4gICAgICB2YXIgaW5kZXggPSBrZXlzLmxlbmd0aDtcbiAgICAgIHZhciBrZXkgPSAnJztcblxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHRoaXMuX21ldGFba2V5XSA9IG1ldGFba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwQXVvUHVsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBBdW9QdWxsKGZldGNoU2l6ZSkge1xuICAgICAgdGhpcy5fYXV0b1B1bGwgPSB0cnVlO1xuXG4gICAgICBpZiAoZmV0Y2hTaXplID09PSBfcmVxdWVzdE1lc3NhZ2UuQUxMKSB7XG4gICAgICAgIHRoaXMuX2xvd1JlY29yZFdhdGVybWFyayA9IE51bWJlci5NQVhfVkFMVUU7IC8vIHdlIHNoYWxsIGFsd2F5cyBsb3dlciB0aGFuIHRoaXMgbnVtYmVyIHRvIGVuYWJsZSBhdXRvIHB1bGxcblxuICAgICAgICB0aGlzLl9oaWdoUmVjb3JkV2F0ZXJtYXJrID0gTnVtYmVyLk1BWF9WQUxVRTsgLy8gd2Ugc2hhbGwgbmV2ZXIgcmVhY2ggdGhpcyBudW1iZXIgdG8gZGlzYWJsZSBhdXRvIHB1bGxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2xvd1JlY29yZFdhdGVybWFyayA9IDAuMyAqIGZldGNoU2l6ZTtcbiAgICAgICAgdGhpcy5faGlnaFJlY29yZFdhdGVybWFyayA9IDAuNyAqIGZldGNoU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlc3VsdFN0cmVhbU9ic2VydmVyO1xufShTdHJlYW1PYnNlcnZlcik7XG5cbmV4cG9ydHMuUmVzdWx0U3RyZWFtT2JzZXJ2ZXIgPSBSZXN1bHRTdHJlYW1PYnNlcnZlcjtcblxudmFyIExvZ2luT2JzZXJ2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdHJlYW1PYnNlcnZlcjIpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShMb2dpbk9ic2VydmVyLCBfU3RyZWFtT2JzZXJ2ZXIyKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihMb2dpbk9ic2VydmVyKTtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIC1cbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBwYXJhbS5jb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBFcnJvcil9IHBhcmFtLmJlZm9yZUVycm9yXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBFcnJvcil9IHBhcmFtLmFmdGVyRXJyb3JcbiAgICogQHBhcmFtIHtmdW5jdGlvbihtZXRhZGF0YSl9IHBhcmFtLmJlZm9yZUNvbXBsZXRlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obWV0YWRhdGEpfSBwYXJhbS5hZnRlckNvbXBsZXRlXG4gICAqL1xuICBmdW5jdGlvbiBMb2dpbk9ic2VydmVyKCkge1xuICAgIHZhciBfdGhpczU7XG5cbiAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBjb25uZWN0aW9uID0gX3JlZjIuY29ubmVjdGlvbixcbiAgICAgICAgYmVmb3JlRXJyb3IgPSBfcmVmMi5iZWZvcmVFcnJvcixcbiAgICAgICAgYWZ0ZXJFcnJvciA9IF9yZWYyLmFmdGVyRXJyb3IsXG4gICAgICAgIGJlZm9yZUNvbXBsZXRlID0gX3JlZjIuYmVmb3JlQ29tcGxldGUsXG4gICAgICAgIGFmdGVyQ29tcGxldGUgPSBfcmVmMi5hZnRlckNvbXBsZXRlO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBMb2dpbk9ic2VydmVyKTtcbiAgICBfdGhpczUgPSBfc3VwZXIyLmNhbGwodGhpcyk7XG4gICAgX3RoaXM1Ll9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICBfdGhpczUuX2JlZm9yZUVycm9yID0gYmVmb3JlRXJyb3I7XG4gICAgX3RoaXM1Ll9hZnRlckVycm9yID0gYWZ0ZXJFcnJvcjtcbiAgICBfdGhpczUuX2JlZm9yZUNvbXBsZXRlID0gYmVmb3JlQ29tcGxldGU7XG4gICAgX3RoaXM1Ll9hZnRlckNvbXBsZXRlID0gYWZ0ZXJDb21wbGV0ZTtcbiAgICByZXR1cm4gX3RoaXM1O1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShMb2dpbk9ic2VydmVyLCBbe1xuICAgIGtleTogXCJvbk5leHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25OZXh0KHJlY29yZCkge1xuICAgICAgdGhpcy5vbkVycm9yKCgwLCBfZXJyb3IubmV3RXJyb3IpKCdSZWNlaXZlZCBSRUNPUkQgd2hlbiBpbml0aWFsaXppbmcgJyArIEpTT04uc3RyaW5naWZ5KHJlY29yZCkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICBpZiAodGhpcy5fYmVmb3JlRXJyb3IpIHtcbiAgICAgICAgdGhpcy5fYmVmb3JlRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLl91cGRhdGVDdXJyZW50T2JzZXJ2ZXIoKTsgLy8gbWFrZSBzdXJlIHRoaXMgZXhhY3Qgb2JzZXJ2ZXIgd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluXG5cblxuICAgICAgdGhpcy5fY29ubmVjdGlvbi5faGFuZGxlRmF0YWxFcnJvcihlcnJvcik7IC8vIGluaXRpYWxpemF0aW9uIGVycm9ycyBhcmUgZmF0YWxcblxuXG4gICAgICBpZiAodGhpcy5fYWZ0ZXJFcnJvcikge1xuICAgICAgICB0aGlzLl9hZnRlckVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25Db21wbGV0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Db21wbGV0ZWQobWV0YWRhdGEpIHtcbiAgICAgIGlmICh0aGlzLl9iZWZvcmVDb21wbGV0ZSkge1xuICAgICAgICB0aGlzLl9iZWZvcmVDb21wbGV0ZShtZXRhZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAvLyByZWFkIHNlcnZlciB2ZXJzaW9uIGZyb20gdGhlIHJlc3BvbnNlIG1ldGFkYXRhLCBpZiBpdCBpcyBhdmFpbGFibGVcbiAgICAgICAgdmFyIHNlcnZlclZlcnNpb24gPSBtZXRhZGF0YS5zZXJ2ZXI7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jb25uZWN0aW9uLnZlcnNpb24pIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uLnZlcnNpb24gPSBzZXJ2ZXJWZXJzaW9uO1xuICAgICAgICB9IC8vIHJlYWQgZGF0YWJhc2UgY29ubmVjdGlvbiBpZCBmcm9tIHRoZSByZXNwb25zZSBtZXRhZGF0YSwgaWYgaXQgaXMgYXZhaWxhYmxlXG5cblxuICAgICAgICB2YXIgZGJDb25uZWN0aW9uSWQgPSBtZXRhZGF0YS5jb25uZWN0aW9uX2lkO1xuXG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbi5kYXRhYmFzZUlkKSB7XG4gICAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5kYXRhYmFzZUlkID0gZGJDb25uZWN0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2FmdGVyQ29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5fYWZ0ZXJDb21wbGV0ZShtZXRhZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMb2dpbk9ic2VydmVyO1xufShTdHJlYW1PYnNlcnZlcik7XG5cbmV4cG9ydHMuTG9naW5PYnNlcnZlciA9IExvZ2luT2JzZXJ2ZXI7XG5cbnZhciBSZXNldE9ic2VydmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3RyZWFtT2JzZXJ2ZXIzKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoUmVzZXRPYnNlcnZlciwgX1N0cmVhbU9ic2VydmVyMyk7XG5cbiAgdmFyIF9zdXBlcjMgPSBfY3JlYXRlU3VwZXIoUmVzZXRPYnNlcnZlcik7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSAtXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gcGFyYW0uY29ubmVjdGlvblxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycjogRXJyb3IpfSBwYXJhbS5vbkVycm9yXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obWV0YWRhdGEpfSBwYXJhbS5vbkNvbXBsZXRlXG4gICAqL1xuICBmdW5jdGlvbiBSZXNldE9ic2VydmVyKCkge1xuICAgIHZhciBfdGhpczY7XG5cbiAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBjb25uZWN0aW9uID0gX3JlZjMuY29ubmVjdGlvbixcbiAgICAgICAgb25FcnJvciA9IF9yZWYzLm9uRXJyb3IsXG4gICAgICAgIG9uQ29tcGxldGUgPSBfcmVmMy5vbkNvbXBsZXRlO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBSZXNldE9ic2VydmVyKTtcbiAgICBfdGhpczYgPSBfc3VwZXIzLmNhbGwodGhpcyk7XG4gICAgX3RoaXM2Ll9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICBfdGhpczYuX29uRXJyb3IgPSBvbkVycm9yO1xuICAgIF90aGlzNi5fb25Db21wbGV0ZSA9IG9uQ29tcGxldGU7XG4gICAgcmV0dXJuIF90aGlzNjtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUmVzZXRPYnNlcnZlciwgW3tcbiAgICBrZXk6IFwib25OZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTmV4dChyZWNvcmQpIHtcbiAgICAgIHRoaXMub25FcnJvcigoMCwgX2Vycm9yLm5ld0Vycm9yKSgnUmVjZWl2ZWQgUkVDT1JEIHdoZW4gcmVzZXR0aW5nOiByZWNlaXZlZCByZWNvcmQgaXM6ICcgKyBKU09OLnN0cmluZ2lmeShyZWNvcmQpLCBfZXJyb3IuUFJPVE9DT0xfRVJST1IpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gX2Vycm9yLlBST1RPQ09MX0VSUk9SKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uX2hhbmRsZVByb3RvY29sRXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9vbkVycm9yKSB7XG4gICAgICAgIHRoaXMuX29uRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbkNvbXBsZXRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNvbXBsZXRlZChtZXRhZGF0YSkge1xuICAgICAgaWYgKHRoaXMuX29uQ29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5fb25Db21wbGV0ZShtZXRhZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSZXNldE9ic2VydmVyO1xufShTdHJlYW1PYnNlcnZlcik7XG5cbmV4cG9ydHMuUmVzZXRPYnNlcnZlciA9IFJlc2V0T2JzZXJ2ZXI7XG5cbnZhciBGYWlsZWRPYnNlcnZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Jlc3VsdFN0cmVhbU9ic2VydmVyKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoRmFpbGVkT2JzZXJ2ZXIsIF9SZXN1bHRTdHJlYW1PYnNlcnZlcik7XG5cbiAgdmFyIF9zdXBlcjQgPSBfY3JlYXRlU3VwZXIoRmFpbGVkT2JzZXJ2ZXIpO1xuXG4gIGZ1bmN0aW9uIEZhaWxlZE9ic2VydmVyKF9yZWY0KSB7XG4gICAgdmFyIF90aGlzNztcblxuICAgIHZhciBlcnJvciA9IF9yZWY0LmVycm9yLFxuICAgICAgICBvbkVycm9yID0gX3JlZjQub25FcnJvcjtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIEZhaWxlZE9ic2VydmVyKTtcbiAgICBfdGhpczcgPSBfc3VwZXI0LmNhbGwodGhpcywge1xuICAgICAgYmVmb3JlRXJyb3I6IG9uRXJyb3JcbiAgICB9KTtcblxuICAgIF90aGlzNy5vbkVycm9yKGVycm9yKTtcblxuICAgIHJldHVybiBfdGhpczc7XG4gIH1cblxuICByZXR1cm4gRmFpbGVkT2JzZXJ2ZXI7XG59KFJlc3VsdFN0cmVhbU9ic2VydmVyKTtcblxuZXhwb3J0cy5GYWlsZWRPYnNlcnZlciA9IEZhaWxlZE9ic2VydmVyO1xuXG52YXIgQ29tcGxldGVkT2JzZXJ2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZXN1bHRTdHJlYW1PYnNlcnZlcjIpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShDb21wbGV0ZWRPYnNlcnZlciwgX1Jlc3VsdFN0cmVhbU9ic2VydmVyMik7XG5cbiAgdmFyIF9zdXBlcjUgPSBfY3JlYXRlU3VwZXIoQ29tcGxldGVkT2JzZXJ2ZXIpO1xuXG4gIGZ1bmN0aW9uIENvbXBsZXRlZE9ic2VydmVyKCkge1xuICAgIHZhciBfdGhpc1N1cGVyLCBfdGhpczg7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIENvbXBsZXRlZE9ic2VydmVyKTtcbiAgICBfdGhpczggPSBfc3VwZXI1LmNhbGwodGhpcyk7XG4gICAgKDAsIF9nZXQyW1wiZGVmYXVsdFwiXSkoKF90aGlzU3VwZXIgPSAoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDJbXCJkZWZhdWx0XCJdKShfdGhpczgpLCAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKENvbXBsZXRlZE9ic2VydmVyLnByb3RvdHlwZSkpLCBcIm1hcmtDb21wbGV0ZWRcIiwgX3RoaXNTdXBlcikuY2FsbChfdGhpc1N1cGVyKTtcbiAgICByZXR1cm4gX3RoaXM4O1xuICB9XG5cbiAgcmV0dXJuIENvbXBsZXRlZE9ic2VydmVyO1xufShSZXN1bHRTdHJlYW1PYnNlcnZlcik7XG5cbmV4cG9ydHMuQ29tcGxldGVkT2JzZXJ2ZXIgPSBDb21wbGV0ZWRPYnNlcnZlcjtcbnZhciBfc3RhdGVzID0ge1xuICBSRUFEWV9TVFJFQU1JTkc6IHtcbiAgICAvLyBhc3luYyBzdGFydCBzdGF0ZVxuICAgIG9uU3VjY2VzczogZnVuY3Rpb24gb25TdWNjZXNzKHN0cmVhbU9ic2VydmVyLCBtZXRhKSB7XG4gICAgICBzdHJlYW1PYnNlcnZlci5faGFuZGxlUnVuU3VjY2VzcyhtZXRhLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0cmVhbU9ic2VydmVyLl9zZXRTdGF0ZShfc3RhdGVzLlNUUkVBTUlORyk7XG4gICAgICB9IC8vIGFmdGVyIHJ1biBzdWNjZWVkZWQsIGFzeW5jIGRpcmVjdGx5IG1vdmUgdG8gc3RyZWFtaW5nXG4gICAgICAvLyBzdGF0ZVxuICAgICAgKTtcbiAgICB9LFxuICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3Ioc3RyZWFtT2JzZXJ2ZXIsIGVycm9yKSB7XG4gICAgICBzdHJlYW1PYnNlcnZlci5faGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIH0sXG4gICAgbmFtZTogZnVuY3Rpb24gbmFtZSgpIHtcbiAgICAgIHJldHVybiAnUkVBRFlfU1RSRUFNSU5HJztcbiAgICB9XG4gIH0sXG4gIFJFQURZOiB7XG4gICAgLy8gcmVhY3RpdmUgc3RhcnQgc3RhdGVcbiAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2VzcyhzdHJlYW1PYnNlcnZlciwgbWV0YSkge1xuICAgICAgc3RyZWFtT2JzZXJ2ZXIuX2hhbmRsZVJ1blN1Y2Nlc3MobWV0YSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtT2JzZXJ2ZXIuX2hhbmRsZVN0cmVhbWluZygpO1xuICAgICAgfSAvLyBhZnRlciBydW4gc3VjY2VlZGVkIHJlY2VpdmVkLCByZWFjdGl2ZSBzaGFsbCBzdGFydCBwdWxsaW5nXG4gICAgICApO1xuICAgIH0sXG4gICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihzdHJlYW1PYnNlcnZlciwgZXJyb3IpIHtcbiAgICAgIHN0cmVhbU9ic2VydmVyLl9oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgfSxcbiAgICBuYW1lOiBmdW5jdGlvbiBuYW1lKCkge1xuICAgICAgcmV0dXJuICdSRUFEWSc7XG4gICAgfVxuICB9LFxuICBTVFJFQU1JTkc6IHtcbiAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2VzcyhzdHJlYW1PYnNlcnZlciwgbWV0YSkge1xuICAgICAgaWYgKG1ldGEuaGFzX21vcmUpIHtcbiAgICAgICAgc3RyZWFtT2JzZXJ2ZXIuX2hhbmRsZUhhc01vcmUobWV0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW1PYnNlcnZlci5faGFuZGxlUHVsbFN1Y2Nlc3MobWV0YSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKHN0cmVhbU9ic2VydmVyLCBlcnJvcikge1xuICAgICAgc3RyZWFtT2JzZXJ2ZXIuX2hhbmRsZUVycm9yKGVycm9yKTtcbiAgICB9LFxuICAgIG5hbWU6IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgICByZXR1cm4gJ1NUUkVBTUlORyc7XG4gICAgfVxuICB9LFxuICBGQUlMRUQ6IHtcbiAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7Ly8gbW9yZSBlcnJvcnMgYXJlIGlnbm9yZWRcbiAgICB9LFxuICAgIG5hbWU6IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgICByZXR1cm4gJ0ZBSUxFRCc7XG4gICAgfVxuICB9LFxuICBTVUNDRUVERUQ6IHtcbiAgICBuYW1lOiBmdW5jdGlvbiBuYW1lKCkge1xuICAgICAgcmV0dXJuICdTVUNDRUVERUQnO1xuICAgIH1cbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm5vcm1hbGl6ZVNlY29uZHNGb3JEdXJhdGlvbiA9IG5vcm1hbGl6ZVNlY29uZHNGb3JEdXJhdGlvbjtcbmV4cG9ydHMubm9ybWFsaXplTmFub3NlY29uZHNGb3JEdXJhdGlvbiA9IG5vcm1hbGl6ZU5hbm9zZWNvbmRzRm9yRHVyYXRpb247XG5leHBvcnRzLmxvY2FsVGltZVRvTmFub09mRGF5ID0gbG9jYWxUaW1lVG9OYW5vT2ZEYXk7XG5leHBvcnRzLm5hbm9PZkRheVRvTG9jYWxUaW1lID0gbmFub09mRGF5VG9Mb2NhbFRpbWU7XG5leHBvcnRzLmxvY2FsRGF0ZVRpbWVUb0Vwb2NoU2Vjb25kID0gbG9jYWxEYXRlVGltZVRvRXBvY2hTZWNvbmQ7XG5leHBvcnRzLmVwb2NoU2Vjb25kQW5kTmFub1RvTG9jYWxEYXRlVGltZSA9IGVwb2NoU2Vjb25kQW5kTmFub1RvTG9jYWxEYXRlVGltZTtcbmV4cG9ydHMuZGF0ZVRvRXBvY2hEYXkgPSBkYXRlVG9FcG9jaERheTtcbmV4cG9ydHMuZXBvY2hEYXlUb0RhdGUgPSBlcG9jaERheVRvRGF0ZTtcbmV4cG9ydHMuZHVyYXRpb25Ub0lzb1N0cmluZyA9IGR1cmF0aW9uVG9Jc29TdHJpbmc7XG5leHBvcnRzLnRpbWVUb0lzb1N0cmluZyA9IHRpbWVUb0lzb1N0cmluZztcbmV4cG9ydHMudGltZVpvbmVPZmZzZXRUb0lzb1N0cmluZyA9IHRpbWVab25lT2Zmc2V0VG9Jc29TdHJpbmc7XG5leHBvcnRzLmRhdGVUb0lzb1N0cmluZyA9IGRhdGVUb0lzb1N0cmluZztcbmV4cG9ydHMudG90YWxOYW5vc2Vjb25kcyA9IHRvdGFsTmFub3NlY29uZHM7XG5leHBvcnRzLnRpbWVab25lT2Zmc2V0SW5TZWNvbmRzID0gdGltZVpvbmVPZmZzZXRJblNlY29uZHM7XG5leHBvcnRzLmFzc2VydFZhbGlkWWVhciA9IGFzc2VydFZhbGlkWWVhcjtcbmV4cG9ydHMuYXNzZXJ0VmFsaWRNb250aCA9IGFzc2VydFZhbGlkTW9udGg7XG5leHBvcnRzLmFzc2VydFZhbGlkRGF5ID0gYXNzZXJ0VmFsaWREYXk7XG5leHBvcnRzLmFzc2VydFZhbGlkSG91ciA9IGFzc2VydFZhbGlkSG91cjtcbmV4cG9ydHMuYXNzZXJ0VmFsaWRNaW51dGUgPSBhc3NlcnRWYWxpZE1pbnV0ZTtcbmV4cG9ydHMuYXNzZXJ0VmFsaWRTZWNvbmQgPSBhc3NlcnRWYWxpZFNlY29uZDtcbmV4cG9ydHMuYXNzZXJ0VmFsaWROYW5vc2Vjb25kID0gYXNzZXJ0VmFsaWROYW5vc2Vjb25kO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2ludGVnZXIgPSByZXF1aXJlKFwiLi4vaW50ZWdlclwiKTtcblxudmFyIF90ZW1wb3JhbFR5cGVzID0gcmVxdWlyZShcIi4uL3RlbXBvcmFsLXR5cGVzXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLypcbiAgQ29kZSBpbiB0aGlzIHV0aWwgc2hvdWxkIGJlIGNvbXBhdGlibGUgd2l0aCBjb2RlIGluIHRoZSBkYXRhYmFzZSB0aGF0IHVzZXMgSlNSLTMxMCBqYXZhLnRpbWUgQVBJcy5cblxuICBJdCBpcyBiYXNlZCBvbiBhIGxpYnJhcnkgY2FsbGVkIFRocmVlVGVuIChodHRwczovL2dpdGh1Yi5jb20vVGhyZWVUZW4vdGhyZWV0ZW5icCkgd2hpY2ggd2FzIGRlcml2ZWRcbiAgZnJvbSBKU1ItMzEwIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBwcmV2aW91c2x5IGhvc3RlZCBvbiBHaXRIdWIuIENvZGUgdXNlcyBgSW50ZWdlcmAgdHlwZSBldmVyeXdoZXJlXG4gIHRvIGNvcnJlY3RseSBoYW5kbGUgbGFyZ2UgaW50ZWdlciB2YWx1ZXMgdGhhdCBhcmUgZ3JlYXRlciB0aGFuIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG5cbiAgUGxlYXNlIGNvbnN1bHQgZWl0aGVyIFRocmVlVGVuIG9yIGpzLWpvZGEgKGh0dHBzOi8vZ2l0aHViLmNvbS9qcy1qb2RhL2pzLWpvZGEpIHdoZW4gd29ya2luZyB3aXRoIHRoZVxuICBjb252ZXJzaW9uIGZ1bmN0aW9ucy5cbiAqL1xudmFyIFZhbHVlUmFuZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWYWx1ZVJhbmdlKG1pbiwgbWF4KSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBWYWx1ZVJhbmdlKTtcbiAgICB0aGlzLl9taW5OdW1iZXIgPSBtaW47XG4gICAgdGhpcy5fbWF4TnVtYmVyID0gbWF4O1xuICAgIHRoaXMuX21pbkludGVnZXIgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKG1pbik7XG4gICAgdGhpcy5fbWF4SW50ZWdlciA9ICgwLCBfaW50ZWdlcltcImludFwiXSkobWF4KTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoVmFsdWVSYW5nZSwgW3tcbiAgICBrZXk6IFwiY29udGFpbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnModmFsdWUpIHtcbiAgICAgIGlmICgoMCwgX2ludGVnZXIuaXNJbnQpKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuZ3JlYXRlclRoYW5PckVxdWFsKHRoaXMuX21pbkludGVnZXIpICYmIHZhbHVlLmxlc3NUaGFuT3JFcXVhbCh0aGlzLl9tYXhJbnRlZ2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSB0aGlzLl9taW5OdW1iZXIgJiYgdmFsdWUgPD0gdGhpcy5fbWF4TnVtYmVyO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIltcIi5jb25jYXQodGhpcy5fbWluTnVtYmVyLCBcIiwgXCIpLmNvbmNhdCh0aGlzLl9tYXhOdW1iZXIsIFwiXVwiKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFZhbHVlUmFuZ2U7XG59KCk7XG5cbnZhciBZRUFSX1JBTkdFID0gbmV3IFZhbHVlUmFuZ2UoLTk5OTk5OTk5OSwgOTk5OTk5OTk5KTtcbnZhciBNT05USF9PRl9ZRUFSX1JBTkdFID0gbmV3IFZhbHVlUmFuZ2UoMSwgMTIpO1xudmFyIERBWV9PRl9NT05USF9SQU5HRSA9IG5ldyBWYWx1ZVJhbmdlKDEsIDMxKTtcbnZhciBIT1VSX09GX0RBWV9SQU5HRSA9IG5ldyBWYWx1ZVJhbmdlKDAsIDIzKTtcbnZhciBNSU5VVEVfT0ZfSE9VUl9SQU5HRSA9IG5ldyBWYWx1ZVJhbmdlKDAsIDU5KTtcbnZhciBTRUNPTkRfT0ZfTUlOVVRFX1JBTkdFID0gbmV3IFZhbHVlUmFuZ2UoMCwgNTkpO1xudmFyIE5BTk9TRUNPTkRfT0ZfU0VDT05EX1JBTkdFID0gbmV3IFZhbHVlUmFuZ2UoMCwgOTk5OTk5OTk5KTtcbnZhciBNSU5VVEVTX1BFUl9IT1VSID0gNjA7XG52YXIgU0VDT05EU19QRVJfTUlOVVRFID0gNjA7XG52YXIgU0VDT05EU19QRVJfSE9VUiA9IFNFQ09ORFNfUEVSX01JTlVURSAqIE1JTlVURVNfUEVSX0hPVVI7XG52YXIgTkFOT1NfUEVSX1NFQ09ORCA9IDEwMDAwMDAwMDA7XG52YXIgTkFOT1NfUEVSX01JTExJU0VDT05EID0gMTAwMDAwMDtcbnZhciBOQU5PU19QRVJfTUlOVVRFID0gTkFOT1NfUEVSX1NFQ09ORCAqIFNFQ09ORFNfUEVSX01JTlVURTtcbnZhciBOQU5PU19QRVJfSE9VUiA9IE5BTk9TX1BFUl9NSU5VVEUgKiBNSU5VVEVTX1BFUl9IT1VSO1xudmFyIERBWVNfMDAwMF9UT18xOTcwID0gNzE5NTI4O1xudmFyIERBWVNfUEVSXzQwMF9ZRUFSX0NZQ0xFID0gMTQ2MDk3O1xudmFyIFNFQ09ORFNfUEVSX0RBWSA9IDg2NDAwO1xuXG5mdW5jdGlvbiBub3JtYWxpemVTZWNvbmRzRm9yRHVyYXRpb24oc2Vjb25kcywgbmFub3NlY29uZHMpIHtcbiAgcmV0dXJuICgwLCBfaW50ZWdlcltcImludFwiXSkoc2Vjb25kcykuYWRkKGZsb29yRGl2KG5hbm9zZWNvbmRzLCBOQU5PU19QRVJfU0VDT05EKSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbm9zZWNvbmRzRm9yRHVyYXRpb24obmFub3NlY29uZHMpIHtcbiAgcmV0dXJuIGZsb29yTW9kKG5hbm9zZWNvbmRzLCBOQU5PU19QRVJfU0VDT05EKTtcbn1cbi8qKlxuICogQ29udmVydHMgZ2l2ZW4gbG9jYWwgdGltZSBpbnRvIGEgc2luZ2xlIGludGVnZXIgcmVwcmVzZW50aW5nIHRoaXMgc2FtZSB0aW1lIGluIG5hbm9zZWNvbmRzIG9mIHRoZSBkYXkuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gaG91ciB0aGUgaG91ciBvZiB0aGUgbG9jYWwgdGltZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG1pbnV0ZSB0aGUgbWludXRlIG9mIHRoZSBsb2NhbCB0aW1lIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gc2Vjb25kIHRoZSBzZWNvbmQgb2YgdGhlIGxvY2FsIHRpbWUgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBuYW5vc2Vjb25kIHRoZSBuYW5vc2Vjb25kIG9mIHRoZSBsb2NhbCB0aW1lIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfSBuYW5vc2Vjb25kcyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGxvY2FsIHRpbWUuXG4gKi9cblxuXG5mdW5jdGlvbiBsb2NhbFRpbWVUb05hbm9PZkRheShob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub3NlY29uZCkge1xuICBob3VyID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShob3VyKTtcbiAgbWludXRlID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShtaW51dGUpO1xuICBzZWNvbmQgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHNlY29uZCk7XG4gIG5hbm9zZWNvbmQgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKG5hbm9zZWNvbmQpO1xuICB2YXIgdG90YWxOYW5vcyA9IGhvdXIubXVsdGlwbHkoTkFOT1NfUEVSX0hPVVIpO1xuICB0b3RhbE5hbm9zID0gdG90YWxOYW5vcy5hZGQobWludXRlLm11bHRpcGx5KE5BTk9TX1BFUl9NSU5VVEUpKTtcbiAgdG90YWxOYW5vcyA9IHRvdGFsTmFub3MuYWRkKHNlY29uZC5tdWx0aXBseShOQU5PU19QRVJfU0VDT05EKSk7XG4gIHJldHVybiB0b3RhbE5hbm9zLmFkZChuYW5vc2Vjb25kKTtcbn1cbi8qKlxuICogQ29udmVydHMgbmFub3NlY29uZHMgb2YgdGhlIGRheSBpbnRvIGxvY2FsIHRpbWUuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gbmFub09mRGF5IHRoZSBuYW5vc2Vjb25kcyBvZiB0aGUgZGF5IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJuIHtMb2NhbFRpbWV9IHRoZSBsb2NhbCB0aW1lIHJlcHJlc2VudGluZyBnaXZlbiBuYW5vc2Vjb25kcyBvZiB0aGUgZGF5LlxuICovXG5cblxuZnVuY3Rpb24gbmFub09mRGF5VG9Mb2NhbFRpbWUobmFub09mRGF5KSB7XG4gIG5hbm9PZkRheSA9ICgwLCBfaW50ZWdlcltcImludFwiXSkobmFub09mRGF5KTtcbiAgdmFyIGhvdXIgPSBuYW5vT2ZEYXkuZGl2KE5BTk9TX1BFUl9IT1VSKTtcbiAgbmFub09mRGF5ID0gbmFub09mRGF5LnN1YnRyYWN0KGhvdXIubXVsdGlwbHkoTkFOT1NfUEVSX0hPVVIpKTtcbiAgdmFyIG1pbnV0ZSA9IG5hbm9PZkRheS5kaXYoTkFOT1NfUEVSX01JTlVURSk7XG4gIG5hbm9PZkRheSA9IG5hbm9PZkRheS5zdWJ0cmFjdChtaW51dGUubXVsdGlwbHkoTkFOT1NfUEVSX01JTlVURSkpO1xuICB2YXIgc2Vjb25kID0gbmFub09mRGF5LmRpdihOQU5PU19QRVJfU0VDT05EKTtcbiAgdmFyIG5hbm9zZWNvbmQgPSBuYW5vT2ZEYXkuc3VidHJhY3Qoc2Vjb25kLm11bHRpcGx5KE5BTk9TX1BFUl9TRUNPTkQpKTtcbiAgcmV0dXJuIG5ldyBfdGVtcG9yYWxUeXBlcy5Mb2NhbFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9zZWNvbmQpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBnaXZlbiBsb2NhbCBkYXRlIHRpbWUgaW50byBhIHNpbmdsZSBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGlzIHNhbWUgdGltZSBpbiBlcG9jaCBzZWNvbmRzIFVUQy5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSB5ZWFyIHRoZSB5ZWFyIG9mIHRoZSBsb2NhbCBkYXRlLXRpbWUgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBtb250aCB0aGUgbW9udGggb2YgdGhlIGxvY2FsIGRhdGUtdGltZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IGRheSB0aGUgZGF5IG9mIHRoZSBsb2NhbCBkYXRlLXRpbWUgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBob3VyIHRoZSBob3VyIG9mIHRoZSBsb2NhbCBkYXRlLXRpbWUgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBtaW51dGUgdGhlIG1pbnV0ZSBvZiB0aGUgbG9jYWwgZGF0ZS10aW1lIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gc2Vjb25kIHRoZSBzZWNvbmQgb2YgdGhlIGxvY2FsIGRhdGUtdGltZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG5hbm9zZWNvbmQgdGhlIG5hbm9zZWNvbmQgb2YgdGhlIGxvY2FsIGRhdGUtdGltZSB0byBjb252ZXJ0LlxuICogQHJldHVybiB7SW50ZWdlcn0gZXBvY2ggc2Vjb25kIGluIFVUQyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGxvY2FsIGRhdGUgdGltZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGxvY2FsRGF0ZVRpbWVUb0Vwb2NoU2Vjb25kKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vc2Vjb25kKSB7XG4gIHZhciBlcG9jaERheSA9IGRhdGVUb0Vwb2NoRGF5KHllYXIsIG1vbnRoLCBkYXkpO1xuICB2YXIgbG9jYWxUaW1lU2Vjb25kcyA9IGxvY2FsVGltZVRvU2Vjb25kT2ZEYXkoaG91ciwgbWludXRlLCBzZWNvbmQpO1xuICByZXR1cm4gZXBvY2hEYXkubXVsdGlwbHkoU0VDT05EU19QRVJfREFZKS5hZGQobG9jYWxUaW1lU2Vjb25kcyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGdpdmVuIGVwb2NoIHNlY29uZCBhbmQgbmFub3NlY29uZCBhZGp1c3RtZW50IGludG8gYSBsb2NhbCBkYXRlIHRpbWUgb2JqZWN0LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IGVwb2NoU2Vjb25kIHRoZSBlcG9jaCBzZWNvbmQgdG8gdXNlLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG5hbm8gdGhlIG5hbm9zZWNvbmQgdG8gdXNlLlxuICogQHJldHVybiB7TG9jYWxEYXRlVGltZX0gdGhlIGxvY2FsIGRhdGUgdGltZSByZXByZXNlbnRpbmcgZ2l2ZW4gZXBvY2ggc2Vjb25kIGFuZCBuYW5vLlxuICovXG5cblxuZnVuY3Rpb24gZXBvY2hTZWNvbmRBbmROYW5vVG9Mb2NhbERhdGVUaW1lKGVwb2NoU2Vjb25kLCBuYW5vKSB7XG4gIHZhciBlcG9jaERheSA9IGZsb29yRGl2KGVwb2NoU2Vjb25kLCBTRUNPTkRTX1BFUl9EQVkpO1xuICB2YXIgc2Vjb25kc09mRGF5ID0gZmxvb3JNb2QoZXBvY2hTZWNvbmQsIFNFQ09ORFNfUEVSX0RBWSk7XG4gIHZhciBuYW5vT2ZEYXkgPSBzZWNvbmRzT2ZEYXkubXVsdGlwbHkoTkFOT1NfUEVSX1NFQ09ORCkuYWRkKG5hbm8pO1xuICB2YXIgbG9jYWxEYXRlID0gZXBvY2hEYXlUb0RhdGUoZXBvY2hEYXkpO1xuICB2YXIgbG9jYWxUaW1lID0gbmFub09mRGF5VG9Mb2NhbFRpbWUobmFub09mRGF5KTtcbiAgcmV0dXJuIG5ldyBfdGVtcG9yYWxUeXBlcy5Mb2NhbERhdGVUaW1lKGxvY2FsRGF0ZS55ZWFyLCBsb2NhbERhdGUubW9udGgsIGxvY2FsRGF0ZS5kYXksIGxvY2FsVGltZS5ob3VyLCBsb2NhbFRpbWUubWludXRlLCBsb2NhbFRpbWUuc2Vjb25kLCBsb2NhbFRpbWUubmFub3NlY29uZCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGdpdmVuIGxvY2FsIGRhdGUgaW50byBhIHNpbmdsZSBpbnRlZ2VyIHJlcHJlc2VudGluZyBpdCdzIGVwb2NoIGRheS5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSB5ZWFyIHRoZSB5ZWFyIG9mIHRoZSBsb2NhbCBkYXRlIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gbW9udGggdGhlIG1vbnRoIG9mIHRoZSBsb2NhbCBkYXRlIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gZGF5IHRoZSBkYXkgb2YgdGhlIGxvY2FsIGRhdGUgdG8gY29udmVydC5cbiAqIEByZXR1cm4ge0ludGVnZXJ9IGVwb2NoIGRheSByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGRhdGUuXG4gKi9cblxuXG5mdW5jdGlvbiBkYXRlVG9FcG9jaERheSh5ZWFyLCBtb250aCwgZGF5KSB7XG4gIHllYXIgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHllYXIpO1xuICBtb250aCA9ICgwLCBfaW50ZWdlcltcImludFwiXSkobW9udGgpO1xuICBkYXkgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKGRheSk7XG4gIHZhciBlcG9jaERheSA9IHllYXIubXVsdGlwbHkoMzY1KTtcblxuICBpZiAoeWVhci5ncmVhdGVyVGhhbk9yRXF1YWwoMCkpIHtcbiAgICBlcG9jaERheSA9IGVwb2NoRGF5LmFkZCh5ZWFyLmFkZCgzKS5kaXYoNCkuc3VidHJhY3QoeWVhci5hZGQoOTkpLmRpdigxMDApKS5hZGQoeWVhci5hZGQoMzk5KS5kaXYoNDAwKSkpO1xuICB9IGVsc2Uge1xuICAgIGVwb2NoRGF5ID0gZXBvY2hEYXkuc3VidHJhY3QoeWVhci5kaXYoLTQpLnN1YnRyYWN0KHllYXIuZGl2KC0xMDApKS5hZGQoeWVhci5kaXYoLTQwMCkpKTtcbiAgfVxuXG4gIGVwb2NoRGF5ID0gZXBvY2hEYXkuYWRkKG1vbnRoLm11bHRpcGx5KDM2Nykuc3VidHJhY3QoMzYyKS5kaXYoMTIpKTtcbiAgZXBvY2hEYXkgPSBlcG9jaERheS5hZGQoZGF5LnN1YnRyYWN0KDEpKTtcblxuICBpZiAobW9udGguZ3JlYXRlclRoYW4oMikpIHtcbiAgICBlcG9jaERheSA9IGVwb2NoRGF5LnN1YnRyYWN0KDEpO1xuXG4gICAgaWYgKCFpc0xlYXBZZWFyKHllYXIpKSB7XG4gICAgICBlcG9jaERheSA9IGVwb2NoRGF5LnN1YnRyYWN0KDEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlcG9jaERheS5zdWJ0cmFjdChEQVlTXzAwMDBfVE9fMTk3MCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGdpdmVuIGVwb2NoIGRheSB0byBhIGxvY2FsIGRhdGUuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gZXBvY2hEYXkgdGhlIGVwb2NoIGRheSB0byBjb252ZXJ0LlxuICogQHJldHVybiB7RGF0ZX0gdGhlIGRhdGUgcmVwcmVzZW50aW5nIHRoZSBlcG9jaCBkYXkgaW4geWVhcnMsIG1vbnRocyBhbmQgZGF5cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGVwb2NoRGF5VG9EYXRlKGVwb2NoRGF5KSB7XG4gIGVwb2NoRGF5ID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShlcG9jaERheSk7XG4gIHZhciB6ZXJvRGF5ID0gZXBvY2hEYXkuYWRkKERBWVNfMDAwMF9UT18xOTcwKS5zdWJ0cmFjdCg2MCk7XG4gIHZhciBhZGp1c3QgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKDApO1xuXG4gIGlmICh6ZXJvRGF5Lmxlc3NUaGFuKDApKSB7XG4gICAgdmFyIGFkanVzdEN5Y2xlcyA9IHplcm9EYXkuYWRkKDEpLmRpdihEQVlTX1BFUl80MDBfWUVBUl9DWUNMRSkuc3VidHJhY3QoMSk7XG4gICAgYWRqdXN0ID0gYWRqdXN0Q3ljbGVzLm11bHRpcGx5KDQwMCk7XG4gICAgemVyb0RheSA9IHplcm9EYXkuYWRkKGFkanVzdEN5Y2xlcy5tdWx0aXBseSgtREFZU19QRVJfNDAwX1lFQVJfQ1lDTEUpKTtcbiAgfVxuXG4gIHZhciB5ZWFyID0gemVyb0RheS5tdWx0aXBseSg0MDApLmFkZCg1OTEpLmRpdihEQVlTX1BFUl80MDBfWUVBUl9DWUNMRSk7XG4gIHZhciBkYXlPZlllYXJFc3QgPSB6ZXJvRGF5LnN1YnRyYWN0KHllYXIubXVsdGlwbHkoMzY1KS5hZGQoeWVhci5kaXYoNCkpLnN1YnRyYWN0KHllYXIuZGl2KDEwMCkpLmFkZCh5ZWFyLmRpdig0MDApKSk7XG5cbiAgaWYgKGRheU9mWWVhckVzdC5sZXNzVGhhbigwKSkge1xuICAgIHllYXIgPSB5ZWFyLnN1YnRyYWN0KDEpO1xuICAgIGRheU9mWWVhckVzdCA9IHplcm9EYXkuc3VidHJhY3QoeWVhci5tdWx0aXBseSgzNjUpLmFkZCh5ZWFyLmRpdig0KSkuc3VidHJhY3QoeWVhci5kaXYoMTAwKSkuYWRkKHllYXIuZGl2KDQwMCkpKTtcbiAgfVxuXG4gIHllYXIgPSB5ZWFyLmFkZChhZGp1c3QpO1xuICB2YXIgbWFyY2hEYXlPZlllYXIgPSBkYXlPZlllYXJFc3Q7XG4gIHZhciBtYXJjaE1vbnRoID0gbWFyY2hEYXlPZlllYXIubXVsdGlwbHkoNSkuYWRkKDIpLmRpdigxNTMpO1xuICB2YXIgbW9udGggPSBtYXJjaE1vbnRoLmFkZCgyKS5tb2R1bG8oMTIpLmFkZCgxKTtcbiAgdmFyIGRheSA9IG1hcmNoRGF5T2ZZZWFyLnN1YnRyYWN0KG1hcmNoTW9udGgubXVsdGlwbHkoMzA2KS5hZGQoNSkuZGl2KDEwKSkuYWRkKDEpO1xuICB5ZWFyID0geWVhci5hZGQobWFyY2hNb250aC5kaXYoMTApKTtcbiAgcmV0dXJuIG5ldyBfdGVtcG9yYWxUeXBlcy5EYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xufVxuLyoqXG4gKiBGb3JtYXQgZ2l2ZW4gZHVyYXRpb24gdG8gYW4gSVNPIDg2MDEgc3RyaW5nLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG1vbnRocyB0aGUgbnVtYmVyIG9mIG1vbnRocy5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBkYXlzIHRoZSBudW1iZXIgb2YgZGF5cy5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBzZWNvbmRzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcy5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBuYW5vc2Vjb25kcyB0aGUgbnVtYmVyIG9mIG5hbm9zZWNvbmRzLlxuICogQHJldHVybiB7c3RyaW5nfSBJU08gc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBnaXZlbiBkdXJhdGlvbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGR1cmF0aW9uVG9Jc29TdHJpbmcobW9udGhzLCBkYXlzLCBzZWNvbmRzLCBuYW5vc2Vjb25kcykge1xuICB2YXIgbW9udGhzU3RyaW5nID0gZm9ybWF0TnVtYmVyKG1vbnRocyk7XG4gIHZhciBkYXlzU3RyaW5nID0gZm9ybWF0TnVtYmVyKGRheXMpO1xuICB2YXIgc2Vjb25kc0FuZE5hbm9zZWNvbmRzU3RyaW5nID0gZm9ybWF0U2Vjb25kc0FuZE5hbm9zZWNvbmRzRm9yRHVyYXRpb24oc2Vjb25kcywgbmFub3NlY29uZHMpO1xuICByZXR1cm4gXCJQXCIuY29uY2F0KG1vbnRoc1N0cmluZywgXCJNXCIpLmNvbmNhdChkYXlzU3RyaW5nLCBcIkRUXCIpLmNvbmNhdChzZWNvbmRzQW5kTmFub3NlY29uZHNTdHJpbmcsIFwiU1wiKTtcbn1cbi8qKlxuICogRm9ybWF0cyBnaXZlbiB0aW1lIHRvIGFuIElTTyA4NjAxIHN0cmluZy5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBob3VyIHRoZSBob3VyIHZhbHVlLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG1pbnV0ZSB0aGUgbWludXRlIHZhbHVlLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IHNlY29uZCB0aGUgc2Vjb25kIHZhbHVlLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG5hbm9zZWNvbmQgdGhlIG5hbm9zZWNvbmQgdmFsdWUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElTTyBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGdpdmVuIHRpbWUuXG4gKi9cblxuXG5mdW5jdGlvbiB0aW1lVG9Jc29TdHJpbmcoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9zZWNvbmQpIHtcbiAgdmFyIGhvdXJTdHJpbmcgPSBmb3JtYXROdW1iZXIoaG91ciwgMik7XG4gIHZhciBtaW51dGVTdHJpbmcgPSBmb3JtYXROdW1iZXIobWludXRlLCAyKTtcbiAgdmFyIHNlY29uZFN0cmluZyA9IGZvcm1hdE51bWJlcihzZWNvbmQsIDIpO1xuICB2YXIgbmFub3NlY29uZFN0cmluZyA9IGZvcm1hdE5hbm9zZWNvbmQobmFub3NlY29uZCk7XG4gIHJldHVybiBcIlwiLmNvbmNhdChob3VyU3RyaW5nLCBcIjpcIikuY29uY2F0KG1pbnV0ZVN0cmluZywgXCI6XCIpLmNvbmNhdChzZWNvbmRTdHJpbmcpLmNvbmNhdChuYW5vc2Vjb25kU3RyaW5nKTtcbn1cbi8qKlxuICogRm9ybWF0cyBnaXZlbiB0aW1lIHpvbmUgb2Zmc2V0IGluIHNlY29uZHMgdG8gc3RyaW5nIHJlcHJlc2VudGF0aW9uIGxpa2UgJ8KxSEg6TU0nLCAnwrFISDpNTTpTUycgb3IgJ1onIGZvciBVVEMuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gb2Zmc2V0U2Vjb25kcyB0aGUgb2Zmc2V0IGluIHNlY29uZHMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElTTyBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGdpdmVuIG9mZnNldC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHRpbWVab25lT2Zmc2V0VG9Jc29TdHJpbmcob2Zmc2V0U2Vjb25kcykge1xuICBvZmZzZXRTZWNvbmRzID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShvZmZzZXRTZWNvbmRzKTtcblxuICBpZiAob2Zmc2V0U2Vjb25kcy5lcXVhbHMoMCkpIHtcbiAgICByZXR1cm4gJ1onO1xuICB9XG5cbiAgdmFyIGlzTmVnYXRpdmUgPSBvZmZzZXRTZWNvbmRzLmlzTmVnYXRpdmUoKTtcblxuICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgIG9mZnNldFNlY29uZHMgPSBvZmZzZXRTZWNvbmRzLm11bHRpcGx5KC0xKTtcbiAgfVxuXG4gIHZhciBzaWduUHJlZml4ID0gaXNOZWdhdGl2ZSA/ICctJyA6ICcrJztcbiAgdmFyIGhvdXJzID0gZm9ybWF0TnVtYmVyKG9mZnNldFNlY29uZHMuZGl2KFNFQ09ORFNfUEVSX0hPVVIpLCAyKTtcbiAgdmFyIG1pbnV0ZXMgPSBmb3JtYXROdW1iZXIob2Zmc2V0U2Vjb25kcy5kaXYoU0VDT05EU19QRVJfTUlOVVRFKS5tb2R1bG8oTUlOVVRFU19QRVJfSE9VUiksIDIpO1xuICB2YXIgc2Vjb25kc1ZhbHVlID0gb2Zmc2V0U2Vjb25kcy5tb2R1bG8oU0VDT05EU19QRVJfTUlOVVRFKTtcbiAgdmFyIHNlY29uZHMgPSBzZWNvbmRzVmFsdWUuZXF1YWxzKDApID8gbnVsbCA6IGZvcm1hdE51bWJlcihzZWNvbmRzVmFsdWUsIDIpO1xuICByZXR1cm4gc2Vjb25kcyA/IFwiXCIuY29uY2F0KHNpZ25QcmVmaXgpLmNvbmNhdChob3VycywgXCI6XCIpLmNvbmNhdChtaW51dGVzLCBcIjpcIikuY29uY2F0KHNlY29uZHMpIDogXCJcIi5jb25jYXQoc2lnblByZWZpeCkuY29uY2F0KGhvdXJzLCBcIjpcIikuY29uY2F0KG1pbnV0ZXMpO1xufVxuLyoqXG4gKiBGb3JtYXRzIGdpdmVuIGRhdGUgdG8gYW4gSVNPIDg2MDEgc3RyaW5nLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IHllYXIgdGhlIGRhdGUgeWVhci5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBtb250aCB0aGUgZGF0ZSBtb250aC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBkYXkgdGhlIGRhdGUgZGF5LlxuICogQHJldHVybiB7c3RyaW5nfSBJU08gc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBnaXZlbiBkYXRlLlxuICovXG5cblxuZnVuY3Rpb24gZGF0ZVRvSXNvU3RyaW5nKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgeWVhciA9ICgwLCBfaW50ZWdlcltcImludFwiXSkoeWVhcik7XG4gIHZhciBpc05lZ2F0aXZlID0geWVhci5pc05lZ2F0aXZlKCk7XG5cbiAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICB5ZWFyID0geWVhci5tdWx0aXBseSgtMSk7XG4gIH1cblxuICB2YXIgeWVhclN0cmluZyA9IGZvcm1hdE51bWJlcih5ZWFyLCA0KTtcblxuICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgIHllYXJTdHJpbmcgPSAnLScgKyB5ZWFyU3RyaW5nO1xuICB9XG5cbiAgdmFyIG1vbnRoU3RyaW5nID0gZm9ybWF0TnVtYmVyKG1vbnRoLCAyKTtcbiAgdmFyIGRheVN0cmluZyA9IGZvcm1hdE51bWJlcihkYXksIDIpO1xuICByZXR1cm4gXCJcIi5jb25jYXQoeWVhclN0cmluZywgXCItXCIpLmNvbmNhdChtb250aFN0cmluZywgXCItXCIpLmNvbmNhdChkYXlTdHJpbmcpO1xufVxuLyoqXG4gKiBHZXQgdGhlIHRvdGFsIG51bWJlciBvZiBuYW5vc2Vjb25kcyBmcm9tIHRoZSBtaWxsaXNlY29uZHMgb2YgdGhlIGdpdmVuIHN0YW5kYXJkIEphdmFTY3JpcHQgZGF0ZSBhbmQgb3B0aW9uYWwgbmFub3NlY29uZCBwYXJ0LlxuICogQHBhcmFtIHtnbG9iYWwuRGF0ZX0gc3RhbmRhcmREYXRlIHRoZSBzdGFuZGFyZCBKYXZhU2NyaXB0IGRhdGUuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHVuZGVmaW5lZH0gbmFub3NlY29uZHMgdGhlIG9wdGlvbmFsIG51bWJlciBvZiBuYW5vc2Vjb25kcy5cbiAqIEByZXR1cm4ge0ludGVnZXJ8bnVtYmVyfSB0aGUgdG90YWwgYW1vdW50IG9mIG5hbm9zZWNvbmRzLlxuICovXG5cblxuZnVuY3Rpb24gdG90YWxOYW5vc2Vjb25kcyhzdGFuZGFyZERhdGUsIG5hbm9zZWNvbmRzKSB7XG4gIG5hbm9zZWNvbmRzID0gbmFub3NlY29uZHMgfHwgMDtcbiAgdmFyIG5hbm9zRnJvbU1pbGxpcyA9IHN0YW5kYXJkRGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAqIE5BTk9TX1BFUl9NSUxMSVNFQ09ORDtcbiAgcmV0dXJuICgwLCBfaW50ZWdlci5pc0ludCkobmFub3NlY29uZHMpID8gbmFub3NlY29uZHMuYWRkKG5hbm9zRnJvbU1pbGxpcykgOiBuYW5vc2Vjb25kcyArIG5hbm9zRnJvbU1pbGxpcztcbn1cbi8qKlxuICogR2V0IHRoZSB0aW1lIHpvbmUgb2Zmc2V0IGluIHNlY29uZHMgZnJvbSB0aGUgZ2l2ZW4gc3RhbmRhcmQgSmF2YVNjcmlwdCBkYXRlLlxuICpcbiAqIDxiPkltcGxlbWVudGF0aW9uIG5vdGU6PC9iPlxuICogVGltZSB6b25lIG9mZnNldCByZXR1cm5lZCBieSB0aGUgc3RhbmRhcmQgSmF2YVNjcmlwdCBkYXRlIGlzIHRoZSBkaWZmZXJlbmNlLCBpbiBtaW51dGVzLCBmcm9tIGxvY2FsIHRpbWUgdG8gVVRDLlxuICogU28gcG9zaXRpdmUgdmFsdWUgbWVhbnMgb2Zmc2V0IGlzIGJlaGluZCBVVEMgYW5kIG5lZ2F0aXZlIHZhbHVlIG1lYW5zIGl0IGlzIGFoZWFkLlxuICogRm9yIE5lbzRqIHRlbXBvcmFsIHR5cGVzLCBsaWtlIGBUaW1lYCBvciBgRGF0ZVRpbWVgIG9mZnNldCBpcyBpbiBzZWNvbmRzIGFuZCByZXByZXNlbnRzIGRpZmZlcmVuY2UgZnJvbSBVVEMgdG8gbG9jYWwgdGltZS5cbiAqIFRoaXMgaXMgZGlmZmVyZW50IGZyb20gc3RhbmRhcmQgSmF2YVNjcmlwdCBkYXRlcyBhbmQgdGhhdCdzIHdoeSBpbXBsZW1lbnRhdGlvbiBuZWdhdGVzIHRoZSByZXR1cm5lZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge2dsb2JhbC5EYXRlfSBzdGFuZGFyZERhdGUgdGhlIHN0YW5kYXJkIEphdmFTY3JpcHQgZGF0ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIHRpbWUgem9uZSBvZmZzZXQgaW4gc2Vjb25kcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHRpbWVab25lT2Zmc2V0SW5TZWNvbmRzKHN0YW5kYXJkRGF0ZSkge1xuICB2YXIgb2Zmc2V0SW5NaW51dGVzID0gc3RhbmRhcmREYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cbiAgaWYgKG9mZnNldEluTWludXRlcyA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIC0xICogb2Zmc2V0SW5NaW51dGVzICogU0VDT05EU19QRVJfTUlOVVRFO1xufVxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgeWVhciB2YWx1ZSBpcyB2YWxpZC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IHllYXIgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybiB7SW50ZWdlcnxudW1iZXJ9IHRoZSB2YWx1ZSBvZiB0aGUgeWVhciBpZiBpdCBpcyB2YWxpZC4gRXhjZXB0aW9uIGlzIHRocm93biBvdGhlcndpc2UuXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFllYXIoeWVhcikge1xuICByZXR1cm4gYXNzZXJ0VmFsaWRUZW1wb3JhbFZhbHVlKHllYXIsIFlFQVJfUkFOR0UsICdZZWFyJyk7XG59XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBtb250aCB2YWx1ZSBpcyB2YWxpZC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IG1vbnRoIHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge0ludGVnZXJ8bnVtYmVyfSB0aGUgdmFsdWUgb2YgdGhlIG1vbnRoIGlmIGl0IGlzIHZhbGlkLiBFeGNlcHRpb24gaXMgdGhyb3duIG90aGVyd2lzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkTW9udGgobW9udGgpIHtcbiAgcmV0dXJuIGFzc2VydFZhbGlkVGVtcG9yYWxWYWx1ZShtb250aCwgTU9OVEhfT0ZfWUVBUl9SQU5HRSwgJ01vbnRoJyk7XG59XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBkYXkgdmFsdWUgaXMgdmFsaWQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBkYXkgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybiB7SW50ZWdlcnxudW1iZXJ9IHRoZSB2YWx1ZSBvZiB0aGUgZGF5IGlmIGl0IGlzIHZhbGlkLiBFeGNlcHRpb24gaXMgdGhyb3duIG90aGVyd2lzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkRGF5KGRheSkge1xuICByZXR1cm4gYXNzZXJ0VmFsaWRUZW1wb3JhbFZhbHVlKGRheSwgREFZX09GX01PTlRIX1JBTkdFLCAnRGF5Jyk7XG59XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBob3VyIHZhbHVlIGlzIHZhbGlkLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gaG91ciB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfG51bWJlcn0gdGhlIHZhbHVlIG9mIHRoZSBob3VyIGlmIGl0IGlzIHZhbGlkLiBFeGNlcHRpb24gaXMgdGhyb3duIG90aGVyd2lzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkSG91cihob3VyKSB7XG4gIHJldHVybiBhc3NlcnRWYWxpZFRlbXBvcmFsVmFsdWUoaG91ciwgSE9VUl9PRl9EQVlfUkFOR0UsICdIb3VyJyk7XG59XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBtaW51dGUgdmFsdWUgaXMgdmFsaWQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBtaW51dGUgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybiB7SW50ZWdlcnxudW1iZXJ9IHRoZSB2YWx1ZSBvZiB0aGUgbWludXRlIGlmIGl0IGlzIHZhbGlkLiBFeGNlcHRpb24gaXMgdGhyb3duIG90aGVyd2lzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkTWludXRlKG1pbnV0ZSkge1xuICByZXR1cm4gYXNzZXJ0VmFsaWRUZW1wb3JhbFZhbHVlKG1pbnV0ZSwgTUlOVVRFX09GX0hPVVJfUkFOR0UsICdNaW51dGUnKTtcbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHNlY29uZCB2YWx1ZSBpcyB2YWxpZC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IHNlY29uZCB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfG51bWJlcn0gdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgaWYgaXQgaXMgdmFsaWQuIEV4Y2VwdGlvbiBpcyB0aHJvd24gb3RoZXJ3aXNlLlxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRTZWNvbmQoc2Vjb25kKSB7XG4gIHJldHVybiBhc3NlcnRWYWxpZFRlbXBvcmFsVmFsdWUoc2Vjb25kLCBTRUNPTkRfT0ZfTUlOVVRFX1JBTkdFLCAnU2Vjb25kJyk7XG59XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBuYW5vc2Vjb25kIHZhbHVlIGlzIHZhbGlkLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gbmFub3NlY29uZCB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfG51bWJlcn0gdGhlIHZhbHVlIG9mIHRoZSBuYW5vc2Vjb25kIGlmIGl0IGlzIHZhbGlkLiBFeGNlcHRpb24gaXMgdGhyb3duIG90aGVyd2lzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkTmFub3NlY29uZChuYW5vc2Vjb25kKSB7XG4gIHJldHVybiBhc3NlcnRWYWxpZFRlbXBvcmFsVmFsdWUobmFub3NlY29uZCwgTkFOT1NFQ09ORF9PRl9TRUNPTkRfUkFOR0UsICdOYW5vc2Vjb25kJyk7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBvZiBleHBlY3RlZCB0eXBlIGFuZCBpcyBpbiB0aGUgZXhwZWN0ZWQgcmFuZ2UuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSB2YWx1ZSB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge1ZhbHVlUmFuZ2V9IHJhbmdlIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSB2YWx1ZS5cbiAqIEByZXR1cm4ge0ludGVnZXJ8bnVtYmVyfSB0aGUgdmFsdWUgaWYgdmFsaWQuIEV4Y2VwdGlvbiBpcyB0aHJvd24gb3RoZXJ3aXNlLlxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRUZW1wb3JhbFZhbHVlKHZhbHVlLCByYW5nZSwgbmFtZSkge1xuICAoMCwgX3V0aWwuYXNzZXJ0TnVtYmVyT3JJbnRlZ2VyKSh2YWx1ZSwgbmFtZSk7XG5cbiAgaWYgKCFyYW5nZS5jb250YWlucyh2YWx1ZSkpIHtcbiAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKShcIlwiLmNvbmNhdChuYW1lLCBcIiBpcyBleHBlY3RlZCB0byBiZSBpbiByYW5nZSBcIikuY29uY2F0KHJhbmdlLCBcIiBidXQgd2FzOiBcIikuY29uY2F0KHZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIENvbnZlcnRzIGdpdmVuIGxvY2FsIHRpbWUgaW50byBhIHNpbmdsZSBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGlzIHNhbWUgdGltZSBpbiBzZWNvbmRzIG9mIHRoZSBkYXkuIE5hbm9zZWNvbmRzIGFyZSBza2lwcGVkLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IGhvdXIgdGhlIGhvdXIgb2YgdGhlIGxvY2FsIHRpbWUuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gbWludXRlIHRoZSBtaW51dGUgb2YgdGhlIGxvY2FsIHRpbWUuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gc2Vjb25kIHRoZSBzZWNvbmQgb2YgdGhlIGxvY2FsIHRpbWUuXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfSBzZWNvbmRzIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gbG9jYWwgdGltZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGxvY2FsVGltZVRvU2Vjb25kT2ZEYXkoaG91ciwgbWludXRlLCBzZWNvbmQpIHtcbiAgaG91ciA9ICgwLCBfaW50ZWdlcltcImludFwiXSkoaG91cik7XG4gIG1pbnV0ZSA9ICgwLCBfaW50ZWdlcltcImludFwiXSkobWludXRlKTtcbiAgc2Vjb25kID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShzZWNvbmQpO1xuICB2YXIgdG90YWxTZWNvbmRzID0gaG91ci5tdWx0aXBseShTRUNPTkRTX1BFUl9IT1VSKTtcbiAgdG90YWxTZWNvbmRzID0gdG90YWxTZWNvbmRzLmFkZChtaW51dGUubXVsdGlwbHkoU0VDT05EU19QRVJfTUlOVVRFKSk7XG4gIHJldHVybiB0b3RhbFNlY29uZHMuYWRkKHNlY29uZCk7XG59XG4vKipcbiAqIENoZWNrIGlmIGdpdmVuIHllYXIgaXMgYSBsZWFwIHllYXIuIFVzZXMgYWxnb3JpdGhtIGRlc2NyaWJlZCBoZXJlIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZWFwX3llYXIjQWxnb3JpdGhtfS5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSB5ZWFyIHRoZSB5ZWFyIHRvIGNoZWNrLiBXaWxsIGJlIGNvbnZlcnRlZCB0byB7QGxpbmsgSW50ZWdlcn0gZm9yIGFsbCBjYWxjdWxhdGlvbnMuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgZ2l2ZW4geWVhciBpcyBhIGxlYXAgeWVhciwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cblxuXG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgeWVhciA9ICgwLCBfaW50ZWdlcltcImludFwiXSkoeWVhcik7XG5cbiAgaWYgKCF5ZWFyLm1vZHVsbyg0KS5lcXVhbHMoMCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoIXllYXIubW9kdWxvKDEwMCkuZXF1YWxzKDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoIXllYXIubW9kdWxvKDQwMCkuZXF1YWxzKDApKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSB4IHRoZSBkaXZpZGVudC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSB5IHRoZSBkaXZpc29yLlxuICogQHJldHVybiB7SW50ZWdlcn0gdGhlIHJlc3VsdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZsb29yRGl2KHgsIHkpIHtcbiAgeCA9ICgwLCBfaW50ZWdlcltcImludFwiXSkoeCk7XG4gIHkgPSAoMCwgX2ludGVnZXJbXCJpbnRcIl0pKHkpO1xuICB2YXIgcmVzdWx0ID0geC5kaXYoeSk7XG5cbiAgaWYgKHguaXNQb3NpdGl2ZSgpICE9PSB5LmlzUG9zaXRpdmUoKSAmJiByZXN1bHQubXVsdGlwbHkoeSkubm90RXF1YWxzKHgpKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnN1YnRyYWN0KDEpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IHggdGhlIGRpdmlkZW50LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IHkgdGhlIGRpdmlzb3IuXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfSB0aGUgcmVzdWx0LlxuICovXG5cblxuZnVuY3Rpb24gZmxvb3JNb2QoeCwgeSkge1xuICB4ID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKSh4KTtcbiAgeSA9ICgwLCBfaW50ZWdlcltcImludFwiXSkoeSk7XG4gIHJldHVybiB4LnN1YnRyYWN0KGZsb29yRGl2KHgsIHkpLm11bHRpcGx5KHkpKTtcbn1cbi8qKlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IHNlY29uZHMgdGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBuYW5vc2Vjb25kcyB0aGUgbnVtYmVyIG9mIG5hbm9zZWNvbmRzIHRvIGZvcm1hdC5cbiAqIEByZXR1cm4ge3N0cmluZ30gZm9ybWF0dGVkIHZhbHVlLlxuICovXG5cblxuZnVuY3Rpb24gZm9ybWF0U2Vjb25kc0FuZE5hbm9zZWNvbmRzRm9yRHVyYXRpb24oc2Vjb25kcywgbmFub3NlY29uZHMpIHtcbiAgc2Vjb25kcyA9ICgwLCBfaW50ZWdlcltcImludFwiXSkoc2Vjb25kcyk7XG4gIG5hbm9zZWNvbmRzID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShuYW5vc2Vjb25kcyk7XG4gIHZhciBzZWNvbmRzU3RyaW5nO1xuICB2YXIgbmFub3NlY29uZHNTdHJpbmc7XG4gIHZhciBzZWNvbmRzTmVnYXRpdmUgPSBzZWNvbmRzLmlzTmVnYXRpdmUoKTtcbiAgdmFyIG5hbm9zZWNvbmRzR3JlYXRlclRoYW5aZXJvID0gbmFub3NlY29uZHMuZ3JlYXRlclRoYW4oMCk7XG5cbiAgaWYgKHNlY29uZHNOZWdhdGl2ZSAmJiBuYW5vc2Vjb25kc0dyZWF0ZXJUaGFuWmVybykge1xuICAgIGlmIChzZWNvbmRzLmVxdWFscygtMSkpIHtcbiAgICAgIHNlY29uZHNTdHJpbmcgPSAnLTAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWNvbmRzU3RyaW5nID0gc2Vjb25kcy5hZGQoMSkudG9TdHJpbmcoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2Vjb25kc1N0cmluZyA9IHNlY29uZHMudG9TdHJpbmcoKTtcbiAgfVxuXG4gIGlmIChuYW5vc2Vjb25kc0dyZWF0ZXJUaGFuWmVybykge1xuICAgIGlmIChzZWNvbmRzTmVnYXRpdmUpIHtcbiAgICAgIG5hbm9zZWNvbmRzU3RyaW5nID0gZm9ybWF0TmFub3NlY29uZChuYW5vc2Vjb25kcy5uZWdhdGUoKS5hZGQoMiAqIE5BTk9TX1BFUl9TRUNPTkQpLm1vZHVsbyhOQU5PU19QRVJfU0VDT05EKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbm9zZWNvbmRzU3RyaW5nID0gZm9ybWF0TmFub3NlY29uZChuYW5vc2Vjb25kcy5hZGQoTkFOT1NfUEVSX1NFQ09ORCkubW9kdWxvKE5BTk9TX1BFUl9TRUNPTkQpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFub3NlY29uZHNTdHJpbmcgPyBzZWNvbmRzU3RyaW5nICsgbmFub3NlY29uZHNTdHJpbmcgOiBzZWNvbmRzU3RyaW5nO1xufVxuLyoqXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gdmFsdWUgdGhlIG51bWJlciBvZiBuYW5vc2Vjb25kcyB0byBmb3JtYXQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGZvcm1hdHRlZCBhbmQgcG9zc2libHkgbGVmdC1wYWRkZWQgbmFub3NlY29uZHMgcGFydCBhcyBzdHJpbmcuXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXROYW5vc2Vjb25kKHZhbHVlKSB7XG4gIHZhbHVlID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKSh2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZS5lcXVhbHMoMCkgPyAnJyA6ICcuJyArIGZvcm1hdE51bWJlcih2YWx1ZSwgOSk7XG59XG4vKipcbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBudW0gdGhlIG51bWJlciB0byBmb3JtYXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0cmluZ0xlbmd0aD11bmRlZmluZWRdIHRoZSBzdHJpbmcgbGVuZ3RoIHRvIGxlZnQtcGFkIHRvLlxuICogQHJldHVybiB7c3RyaW5nfSBmb3JtYXR0ZWQgYW5kIHBvc3NpYmx5IGxlZnQtcGFkZGVkIG51bWJlciBhcyBzdHJpbmcuXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtKSB7XG4gIHZhciBzdHJpbmdMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgbnVtID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShudW0pO1xuICB2YXIgaXNOZWdhdGl2ZSA9IG51bS5pc05lZ2F0aXZlKCk7XG5cbiAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICBudW0gPSBudW0ubmVnYXRlKCk7XG4gIH1cblxuICB2YXIgbnVtU3RyaW5nID0gbnVtLnRvU3RyaW5nKCk7XG5cbiAgaWYgKHN0cmluZ0xlbmd0aCkge1xuICAgIC8vIGxlZnQgcGFkIHRoZSBzdHJpbmcgd2l0aCB6ZXJvZXNcbiAgICB3aGlsZSAobnVtU3RyaW5nLmxlbmd0aCA8IHN0cmluZ0xlbmd0aCkge1xuICAgICAgbnVtU3RyaW5nID0gJzAnICsgbnVtU3RyaW5nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc05lZ2F0aXZlID8gJy0nICsgbnVtU3RyaW5nIDogbnVtU3RyaW5nO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBERUZBVUxUX01BWF9SRVRSWV9USU1FX01TID0gMzAgKiAxMDAwOyAvLyAzMCBzZWNvbmRzXG5cbnZhciBERUZBVUxUX0lOSVRJQUxfUkVUUllfREVMQVlfTVMgPSAxMDAwOyAvLyAxIHNlY29uZHNcblxudmFyIERFRkFVTFRfUkVUUllfREVMQVlfTVVMVElQTElFUiA9IDIuMDtcbnZhciBERUZBVUxUX1JFVFJZX0RFTEFZX0pJVFRFUl9GQUNUT1IgPSAwLjI7XG5cbnZhciBUcmFuc2FjdGlvbkV4ZWN1dG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJhbnNhY3Rpb25FeGVjdXRvcihtYXhSZXRyeVRpbWVNcywgaW5pdGlhbFJldHJ5RGVsYXlNcywgbXVsdGlwbGllciwgaml0dGVyRmFjdG9yKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBUcmFuc2FjdGlvbkV4ZWN1dG9yKTtcbiAgICB0aGlzLl9tYXhSZXRyeVRpbWVNcyA9IF92YWx1ZU9yRGVmYXVsdChtYXhSZXRyeVRpbWVNcywgREVGQVVMVF9NQVhfUkVUUllfVElNRV9NUyk7XG4gICAgdGhpcy5faW5pdGlhbFJldHJ5RGVsYXlNcyA9IF92YWx1ZU9yRGVmYXVsdChpbml0aWFsUmV0cnlEZWxheU1zLCBERUZBVUxUX0lOSVRJQUxfUkVUUllfREVMQVlfTVMpO1xuICAgIHRoaXMuX211bHRpcGxpZXIgPSBfdmFsdWVPckRlZmF1bHQobXVsdGlwbGllciwgREVGQVVMVF9SRVRSWV9ERUxBWV9NVUxUSVBMSUVSKTtcbiAgICB0aGlzLl9qaXR0ZXJGYWN0b3IgPSBfdmFsdWVPckRlZmF1bHQoaml0dGVyRmFjdG9yLCBERUZBVUxUX1JFVFJZX0RFTEFZX0pJVFRFUl9GQUNUT1IpO1xuICAgIHRoaXMuX2luRmxpZ2h0VGltZW91dElkcyA9IFtdO1xuXG4gICAgdGhpcy5fdmVyaWZ5QWZ0ZXJDb25zdHJ1Y3Rpb24oKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoVHJhbnNhY3Rpb25FeGVjdXRvciwgW3tcbiAgICBrZXk6IFwiZXhlY3V0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGVjdXRlKHRyYW5zYWN0aW9uQ3JlYXRvciwgdHJhbnNhY3Rpb25Xb3JrKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfdGhpcy5fZXhlY3V0ZVRyYW5zYWN0aW9uSW5zaWRlUHJvbWlzZSh0cmFuc2FjdGlvbkNyZWF0b3IsIHRyYW5zYWN0aW9uV29yaywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHZhciByZXRyeVN0YXJ0VGltZU1zID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIHJldHJ5RGVsYXlNcyA9IF90aGlzLl9pbml0aWFsUmV0cnlEZWxheU1zO1xuICAgICAgICByZXR1cm4gX3RoaXMuX3JldHJ5VHJhbnNhY3Rpb25Qcm9taXNlKHRyYW5zYWN0aW9uQ3JlYXRvciwgdHJhbnNhY3Rpb25Xb3JrLCBlcnJvciwgcmV0cnlTdGFydFRpbWVNcywgcmV0cnlEZWxheU1zKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIC8vIGNhbmNlbCBhbGwgZXhpc3RpbmcgdGltZW91dHMgdG8gcHJldmVudCBmdXJ0aGVyIHJldHJpZXNcbiAgICAgIHRoaXMuX2luRmxpZ2h0VGltZW91dElkcy5mb3JFYWNoKGZ1bmN0aW9uICh0aW1lb3V0SWQpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2luRmxpZ2h0VGltZW91dElkcyA9IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmV0cnlUcmFuc2FjdGlvblByb21pc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JldHJ5VHJhbnNhY3Rpb25Qcm9taXNlKHRyYW5zYWN0aW9uQ3JlYXRvciwgdHJhbnNhY3Rpb25Xb3JrLCBlcnJvciwgcmV0cnlTdGFydFRpbWUsIHJldHJ5RGVsYXlNcykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBlbGFwc2VkVGltZU1zID0gRGF0ZS5ub3coKSAtIHJldHJ5U3RhcnRUaW1lO1xuXG4gICAgICBpZiAoZWxhcHNlZFRpbWVNcyA+IHRoaXMuX21heFJldHJ5VGltZU1zIHx8ICFUcmFuc2FjdGlvbkV4ZWN1dG9yLl9jYW5SZXRyeU9uKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgbmV4dFJldHJ5VGltZSA9IF90aGlzMi5fY29tcHV0ZURlbGF5V2l0aEppdHRlcihyZXRyeURlbGF5TXMpO1xuXG4gICAgICAgIHZhciB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBmaWx0ZXIgb3V0IHRoaXMgdGltZW91dElkIHdoZW4gdGltZSBoYXMgY29tZSBhbmQgZnVuY3Rpb24gaXMgYmVpbmcgZXhlY3V0ZWRcbiAgICAgICAgICBfdGhpczIuX2luRmxpZ2h0VGltZW91dElkcyA9IF90aGlzMi5faW5GbGlnaHRUaW1lb3V0SWRzLmZpbHRlcihmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZCAhPT0gdGltZW91dElkO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgX3RoaXMyLl9leGVjdXRlVHJhbnNhY3Rpb25JbnNpZGVQcm9taXNlKHRyYW5zYWN0aW9uQ3JlYXRvciwgdHJhbnNhY3Rpb25Xb3JrLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9LCBuZXh0UmV0cnlUaW1lKTsgLy8gYWRkIG5ld2x5IGNyZWF0ZWQgdGltZW91dElkIHRvIHRoZSBsaXN0IG9mIGFsbCBpbi1mbGlnaHQgdGltZW91dHNcblxuICAgICAgICBfdGhpczIuX2luRmxpZ2h0VGltZW91dElkcy5wdXNoKHRpbWVvdXRJZCk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB2YXIgbmV4dFJldHJ5RGVsYXlNcyA9IHJldHJ5RGVsYXlNcyAqIF90aGlzMi5fbXVsdGlwbGllcjtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5fcmV0cnlUcmFuc2FjdGlvblByb21pc2UodHJhbnNhY3Rpb25DcmVhdG9yLCB0cmFuc2FjdGlvbldvcmssIGVycm9yLCByZXRyeVN0YXJ0VGltZSwgbmV4dFJldHJ5RGVsYXlNcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2V4ZWN1dGVUcmFuc2FjdGlvbkluc2lkZVByb21pc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V4ZWN1dGVUcmFuc2FjdGlvbkluc2lkZVByb21pc2UodHJhbnNhY3Rpb25DcmVhdG9yLCB0cmFuc2FjdGlvbldvcmssIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB0eDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdHggPSB0cmFuc2FjdGlvbkNyZWF0b3IoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIGZhaWxlZCB0byBjcmVhdGUgYSB0cmFuc2FjdGlvblxuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHRQcm9taXNlID0gdGhpcy5fc2FmZUV4ZWN1dGVUcmFuc2FjdGlvbldvcmsodHgsIHRyYW5zYWN0aW9uV29yayk7XG5cbiAgICAgIHJlc3VsdFByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBfdGhpczMuX2hhbmRsZVRyYW5zYWN0aW9uV29ya1N1Y2Nlc3MocmVzdWx0LCB0eCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMuX2hhbmRsZVRyYW5zYWN0aW9uV29ya0ZhaWx1cmUoZXJyb3IsIHR4LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zYWZlRXhlY3V0ZVRyYW5zYWN0aW9uV29ya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2FmZUV4ZWN1dGVUcmFuc2FjdGlvbldvcmsodHgsIHRyYW5zYWN0aW9uV29yaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zYWN0aW9uV29yayh0eCk7IC8vIHVzZXIgZGVmaW5lZCBjYWxsYmFjayBpcyBzdXBwb3NlZCB0byByZXR1cm4gYSBwcm9taXNlLCBidXQgaXQgbWlnaHQgbm90OyBzbyB0byBwcm90ZWN0IGFnYWluc3QgYW5cbiAgICAgICAgLy8gaW5jb3JyZWN0IEFQSSB1c2FnZSB3ZSB3cmFwIHRoZSByZXR1cm5lZCB2YWx1ZSB3aXRoIGEgcmVzb2x2ZWQgcHJvbWlzZTsgdGhpcyBpcyBlZmZlY3RpdmVseSBhXG4gICAgICAgIC8vIHZhbGlkYXRpb24gc3RlcCB3aXRob3V0IHR5cGUgY2hlY2tzXG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZVRyYW5zYWN0aW9uV29ya1N1Y2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVRyYW5zYWN0aW9uV29ya1N1Y2Nlc3MocmVzdWx0LCB0eCwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAodHguaXNPcGVuKCkpIHtcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gd29yayByZXR1cm5lZCByZXNvbHZlZCBwcm9taXNlIGFuZCB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gY29tbWl0dGVkL3JvbGxlZCBiYWNrXG4gICAgICAgIC8vIHRyeSB0byBjb21taXQgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgIHR4LmNvbW1pdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIHRyYW5zYWN0aW9uIHdhcyBjb21taXR0ZWQsIHJldHVybiByZXN1bHQgdG8gdGhlIHVzZXJcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgLy8gdHJhbnNhY3Rpb24gZmFpbGVkIHRvIGNvbW1pdCwgcHJvcGFnYXRlIHRoZSBmYWlsdXJlXG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0cmFuc2FjdGlvbiB3b3JrIHJldHVybmVkIHJlc29sdmVkIHByb21pc2UgYW5kIHRyYW5zYWN0aW9uIGlzIGFscmVhZHkgY29tbWl0dGVkL3JvbGxlZCBiYWNrXG4gICAgICAgIC8vIHJldHVybiB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IGdpdmVuIHRyYW5zYWN0aW9uIHdvcmtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlVHJhbnNhY3Rpb25Xb3JrRmFpbHVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVHJhbnNhY3Rpb25Xb3JrRmFpbHVyZShlcnJvciwgdHgsIHJlamVjdCkge1xuICAgICAgaWYgKHR4LmlzT3BlbigpKSB7XG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIHdvcmsgZmFpbGVkIGFuZCB0aGUgdHJhbnNhY3Rpb24gaXMgc3RpbGwgb3Blbiwgcm9sbCBpdCBiYWNrIGFuZCBwcm9wYWdhdGUgdGhlIGZhaWx1cmVcbiAgICAgICAgdHgucm9sbGJhY2soKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChpZ25vcmUpIHsvLyBpZ25vcmUgdGhlIHJvbGxiYWNrIGVycm9yXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTsgLy8gcHJvcGFnYXRlIHRoZSBvcmlnaW5hbCBlcnJvciB3ZSBnb3QgZnJvbSB0aGUgdHJhbnNhY3Rpb24gd29ya1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gaXMgYWxyZWFkeSByb2xsZWQgYmFjaywgcHJvcGFnYXRlIHRoZSBlcnJvclxuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY29tcHV0ZURlbGF5V2l0aEppdHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcHV0ZURlbGF5V2l0aEppdHRlcihkZWxheU1zKSB7XG4gICAgICB2YXIgaml0dGVyID0gZGVsYXlNcyAqIHRoaXMuX2ppdHRlckZhY3RvcjtcbiAgICAgIHZhciBtaW4gPSBkZWxheU1zIC0gaml0dGVyO1xuICAgICAgdmFyIG1heCA9IGRlbGF5TXMgKyBqaXR0ZXI7XG4gICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdmVyaWZ5QWZ0ZXJDb25zdHJ1Y3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZlcmlmeUFmdGVyQ29uc3RydWN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX21heFJldHJ5VGltZU1zIDwgMCkge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnTWF4IHJldHJ5IHRpbWUgc2hvdWxkIGJlID49IDA6ICcgKyB0aGlzLl9tYXhSZXRyeVRpbWVNcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pbml0aWFsUmV0cnlEZWxheU1zIDwgMCkge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnSW5pdGlhbCByZXRyeSBkZWxheSBzaG91bGQgPj0gMDogJyArIHRoaXMuX2luaXRpYWxSZXRyeURlbGF5TXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fbXVsdGlwbGllciA8IDEuMCkge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnTXVsdGlwbGllciBzaG91bGQgYmUgPj0gMS4wOiAnICsgdGhpcy5fbXVsdGlwbGllcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9qaXR0ZXJGYWN0b3IgPCAwIHx8IHRoaXMuX2ppdHRlckZhY3RvciA+IDEpIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ0ppdHRlciBmYWN0b3Igc2hvdWxkIGJlIGluIFswLjAsIDEuMF06ICcgKyB0aGlzLl9qaXR0ZXJGYWN0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIl9jYW5SZXRyeU9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYW5SZXRyeU9uKGVycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3IgJiYgZXJyb3IgaW5zdGFuY2VvZiBfZXJyb3IuTmVvNGpFcnJvciAmJiBlcnJvci5jb2RlICYmIChlcnJvci5jb2RlID09PSBfZXJyb3IuU0VSVklDRV9VTkFWQUlMQUJMRSB8fCBlcnJvci5jb2RlID09PSBfZXJyb3IuU0VTU0lPTl9FWFBJUkVEIHx8IHRoaXMuX2lzVHJhbnNpZW50RXJyb3IoZXJyb3IpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzVHJhbnNpZW50RXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzVHJhbnNpZW50RXJyb3IoZXJyb3IpIHtcbiAgICAgIC8vIFJldHJpZXMgc2hvdWxkIG5vdCBoYXBwZW4gd2hlbiB0cmFuc2FjdGlvbiB3YXMgZXhwbGljaXRseSB0ZXJtaW5hdGVkIGJ5IHRoZSB1c2VyLlxuICAgICAgLy8gVGVybWluYXRpb24gb2YgdHJhbnNhY3Rpb24gbWlnaHQgcmVzdWx0IGluIHR3byBkaWZmZXJlbnQgZXJyb3IgY29kZXMgZGVwZW5kaW5nIG9uIHdoZXJlIGl0IHdhc1xuICAgICAgLy8gdGVybWluYXRlZC4gVGhlc2UgYXJlIHJlYWxseSBjbGllbnQgZXJyb3JzIGJ1dCBjbGFzc2lmaWNhdGlvbiBvbiB0aGUgc2VydmVyIGlzIG5vdCBlbnRpcmVseSBjb3JyZWN0IGFuZFxuICAgICAgLy8gdGhleSBhcmUgY2xhc3NpZmllZCBhcyB0cmFuc2llbnQuXG4gICAgICB2YXIgY29kZSA9IGVycm9yLmNvZGU7XG5cbiAgICAgIGlmIChjb2RlLmluZGV4T2YoJ1RyYW5zaWVudEVycm9yJykgPj0gMCkge1xuICAgICAgICBpZiAoY29kZSA9PT0gJ05lby5UcmFuc2llbnRFcnJvci5UcmFuc2FjdGlvbi5UZXJtaW5hdGVkJyB8fCBjb2RlID09PSAnTmVvLlRyYW5zaWVudEVycm9yLlRyYW5zYWN0aW9uLkxvY2tDbGllbnRTdG9wcGVkJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUcmFuc2FjdGlvbkV4ZWN1dG9yO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFRyYW5zYWN0aW9uRXhlY3V0b3I7XG5cbmZ1bmN0aW9uIF92YWx1ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0VmFsdWU7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciB1dGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdXRpbFwiKSk7XG5cbnZhciBfaW50ZWdlciA9IHJlcXVpcmUoXCIuLi9pbnRlZ2VyXCIpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBJbnRlcm5hbCBob2xkZXIgb2YgdGhlIHRyYW5zYWN0aW9uIGNvbmZpZ3VyYXRpb24uXG4gKiBJdCBwZXJmb3JtcyBpbnB1dCB2YWxpZGF0aW9uIGFuZCB2YWx1ZSBjb252ZXJzaW9uIGZvciBmdXJ0aGVyIHNlcmlhbGl6YXRpb24gYnkgdGhlIEJvbHQgcHJvdG9jb2wgbGF5ZXIuXG4gKiBVc2VycyBvZiB0aGUgZHJpdmVyIHByb3ZpZGUgdHJhbnNhY3Rpb24gY29uZmlndXJhdGlvbiBhcyByZWd1bGFyIG9iamVjdHMgYHt0aW1lb3V0OiAxMCwgbWV0YWRhdGE6IHtrZXk6ICd2YWx1ZSd9fWAuXG4gKiBEcml2ZXIgY29udmVydHMgc3VjaCBvYmplY3RzIHRvIHtAbGluayBUeENvbmZpZ30gaW1tZWRpYXRlbHkgYW5kIHVzZXMgY29udmVydGVkIHZhbHVlcyBldmVyeXdoZXJlLlxuICovXG52YXIgVHhDb25maWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIHJhdyBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIFR4Q29uZmlnKGNvbmZpZykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgVHhDb25maWcpO1xuICAgIGFzc2VydFZhbGlkQ29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy50aW1lb3V0ID0gZXh0cmFjdFRpbWVvdXQoY29uZmlnKTtcbiAgICB0aGlzLm1ldGFkYXRhID0gZXh0cmFjdE1ldGFkYXRhKGNvbmZpZyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbiBlbXB0eSBjb25maWcgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtUeENvbmZpZ30gYW4gZW1wdHkgY29uZmlnLlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoVHhDb25maWcsIFt7XG4gICAga2V5OiBcImlzRW1wdHlcIixcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgY29uZmlnIG9iamVjdCBpcyBlbXB0eS4gSS5lLiBoYXMgbm8gY29uZmlndXJhdGlvbiB2YWx1ZXMgc3BlY2lmaWVkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGlzIG9iamVjdCBpcyBlbXB0eSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzKS5ldmVyeShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJlbXB0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgICAgIHJldHVybiBFTVBUWV9DT05GSUc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUeENvbmZpZztcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBUeENvbmZpZztcbnZhciBFTVBUWV9DT05GSUcgPSBuZXcgVHhDb25maWcoe30pO1xuLyoqXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfG51bGx9XG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdFRpbWVvdXQoY29uZmlnKSB7XG4gIGlmICh1dGlsLmlzT2JqZWN0KGNvbmZpZykgJiYgKGNvbmZpZy50aW1lb3V0IHx8IGNvbmZpZy50aW1lb3V0ID09PSAwKSkge1xuICAgIHV0aWwuYXNzZXJ0TnVtYmVyT3JJbnRlZ2VyKGNvbmZpZy50aW1lb3V0LCAnVHJhbnNhY3Rpb24gdGltZW91dCcpO1xuICAgIHZhciB0aW1lb3V0ID0gKDAsIF9pbnRlZ2VyW1wiaW50XCJdKShjb25maWcudGltZW91dCk7XG5cbiAgICBpZiAodGltZW91dC5pc1plcm8oKSkge1xuICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ1RyYW5zYWN0aW9uIHRpbWVvdXQgc2hvdWxkIG5vdCBiZSB6ZXJvJyk7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVvdXQuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnVHJhbnNhY3Rpb24gdGltZW91dCBzaG91bGQgbm90IGJlIG5lZ2F0aXZlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpbWVvdXQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQHJldHVybiB7b2JqZWN0fG51bGx9XG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0TWV0YWRhdGEoY29uZmlnKSB7XG4gIGlmICh1dGlsLmlzT2JqZWN0KGNvbmZpZykgJiYgY29uZmlnLm1ldGFkYXRhKSB7XG4gICAgdmFyIG1ldGFkYXRhID0gY29uZmlnLm1ldGFkYXRhO1xuICAgIHV0aWwuYXNzZXJ0T2JqZWN0KG1ldGFkYXRhKTtcblxuICAgIGlmIChPYmplY3Qua2V5cyhtZXRhZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAvLyBub3QgYW4gZW1wdHkgb2JqZWN0XG4gICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkQ29uZmlnKGNvbmZpZykge1xuICBpZiAoY29uZmlnKSB7XG4gICAgdXRpbC5hc3NlcnRPYmplY3QoY29uZmlnLCAnVHJhbnNhY3Rpb24gY29uZmlnJyk7XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF91cmlKcyA9IHJlcXVpcmUoXCJ1cmktanNcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIERFRkFVTFRfQk9MVF9QT1JUID0gNzY4NztcbnZhciBERUZBVUxUX0hUVFBfUE9SVCA9IDc0NzQ7XG52YXIgREVGQVVMVF9IVFRQU19QT1JUID0gNzQ3MztcblxudmFyIFVybCA9IGZ1bmN0aW9uIFVybChzY2hlbWUsIGhvc3QsIHBvcnQsIGhvc3RBbmRQb3J0LCBxdWVyeSkge1xuICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFVybCk7XG5cbiAgLyoqXG4gICAqIE51bGxhYmxlIHNjaGVtZSAocHJvdG9jb2wpIG9mIHRoZSBVUkwuXG4gICAqIEV4YW1wbGU6ICdib2x0JywgJ25lbzRqJywgJ2h0dHAnLCAnaHR0cHMnLCBldGMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLnNjaGVtZSA9IHNjaGVtZTtcbiAgLyoqXG4gICAqIE5vbm51bGwgaG9zdCBuYW1lIG9yIElQIGFkZHJlc3MuIElQdjYgbm90IHdyYXBwZWQgaW4gc3F1YXJlIGJyYWNrZXRzLlxuICAgKiBFeGFtcGxlOiAnbmVvNGouY29tJywgJ2xvY2FsaG9zdCcsICcxMjcuMC4wLjEnLCAnMTkyLjE2OC4xMC4xNScsICc6OjEnLCAnMjAwMTo0ODYwOjQ4NjA6Ojg4NDQnLCBldGMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuXG4gIHRoaXMuaG9zdCA9IGhvc3Q7XG4gIC8qKlxuICAgKiBOb25udWxsIG51bWJlciByZXByZXNlbnRpbmcgcG9ydC4gRGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gc2NoZW1lIGlzIHVzZWQgaWYgZ2l2ZW4gVVJMIHN0cmluZ1xuICAgKiBkb2VzIG5vdCBjb250YWluIHBvcnQuIEV4YW1wbGU6IDc2ODcgZm9yIGJvbHQsIDc0NzQgZm9yIEhUVFAgYW5kIDc0NzMgZm9yIEhUVFBTLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLnBvcnQgPSBwb3J0O1xuICAvKipcbiAgICogTm9ubnVsbCBob3N0IG5hbWUgb3IgSVAgYWRkcmVzcyBwbHVzIHBvcnQsIHNlcGFyYXRlZCBieSAnOicuIElQdjYgd3JhcHBlZCBpbiBzcXVhcmUgYnJhY2tldHMuXG4gICAqIEV4YW1wbGU6ICduZW80ai5jb20nLCAnbmVvNGouY29tOjc2ODcnLCAnMTI3LjAuMC4xJywgJzEyNy4wLjAuMTo4MDgwJywgJ1syMDAxOjQ4NjA6NDg2MDo6ODg0NF0nLFxuICAgKiAnWzIwMDE6NDg2MDo0ODYwOjo4ODQ0XTo5MDkwJywgZXRjLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuICB0aGlzLmhvc3RBbmRQb3J0ID0gaG9zdEFuZFBvcnQ7XG4gIC8qKlxuICAgKiBOb25udWxsIG9iamVjdCByZXByZXNlbnRpbmcgcGFyc2VkIHF1ZXJ5IHN0cmluZyBrZXktdmFsdWUgcGFpcnMuIER1cGxpY2F0ZWQga2V5cyBub3Qgc3VwcG9ydGVkLlxuICAgKiBFeGFtcGxlOiAne30nLCAneydrZXkxJzogJ3ZhbHVlMScsICdrZXkyJzogJ3ZhbHVlMid9JywgZXRjLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG59O1xuXG5mdW5jdGlvbiBwYXJzZURhdGFiYXNlVXJsKHVybCkge1xuICAoMCwgX3V0aWwuYXNzZXJ0U3RyaW5nKSh1cmwsICdVUkwnKTtcbiAgdmFyIHNhbml0aXplZCA9IHNhbml0aXplVXJsKHVybCk7XG4gIHZhciBwYXJzZWRVcmwgPSAoMCwgX3VyaUpzLnBhcnNlKShzYW5pdGl6ZWQudXJsKTtcbiAgdmFyIHNjaGVtZSA9IHNhbml0aXplZC5zY2hlbWVNaXNzaW5nID8gbnVsbCA6IGV4dHJhY3RTY2hlbWUocGFyc2VkVXJsLnNjaGVtZSk7XG4gIHZhciBob3N0ID0gZXh0cmFjdEhvc3QocGFyc2VkVXJsLmhvc3QpOyAvLyBubyBzcXVhcmUgYnJhY2tldHMgZm9yIElQdjZcblxuICB2YXIgZm9ybWF0dGVkSG9zdCA9IGZvcm1hdEhvc3QoaG9zdCk7IC8vIGhhcyBzcXVhcmUgYnJhY2tldHMgZm9yIElQdjZcblxuICB2YXIgcG9ydCA9IGV4dHJhY3RQb3J0KHBhcnNlZFVybC5wb3J0LCBzY2hlbWUpO1xuICB2YXIgaG9zdEFuZFBvcnQgPSBcIlwiLmNvbmNhdChmb3JtYXR0ZWRIb3N0LCBcIjpcIikuY29uY2F0KHBvcnQpO1xuICB2YXIgcXVlcnkgPSBleHRyYWN0UXVlcnkocGFyc2VkVXJsLnF1ZXJ5LCB1cmwpO1xuICByZXR1cm4gbmV3IFVybChzY2hlbWUsIGhvc3QsIHBvcnQsIGhvc3RBbmRQb3J0LCBxdWVyeSk7XG59XG5cbmZ1bmN0aW9uIHNhbml0aXplVXJsKHVybCkge1xuICB1cmwgPSB1cmwudHJpbSgpO1xuXG4gIGlmICh1cmwuaW5kZXhPZignOi8vJykgPT09IC0xKSB7XG4gICAgLy8gdXJsIGRvZXMgbm90IGNvbnRhaW4gc2NoZW1lLCBhZGQgZHVtbXkgJ25vbmU6Ly8nIHRvIG1ha2UgcGFyc2VyIHdvcmsgY29ycmVjdGx5XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtZU1pc3Npbmc6IHRydWUsXG4gICAgICB1cmw6IFwibm9uZTovL1wiLmNvbmNhdCh1cmwpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2NoZW1lTWlzc2luZzogZmFsc2UsXG4gICAgdXJsOiB1cmxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFNjaGVtZShzY2hlbWUpIHtcbiAgaWYgKHNjaGVtZSkge1xuICAgIHNjaGVtZSA9IHNjaGVtZS50cmltKCk7XG5cbiAgICBpZiAoc2NoZW1lLmNoYXJBdChzY2hlbWUubGVuZ3RoIC0gMSkgPT09ICc6Jykge1xuICAgICAgc2NoZW1lID0gc2NoZW1lLnN1YnN0cmluZygwLCBzY2hlbWUubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SG9zdChob3N0LCB1cmwpIHtcbiAgaWYgKCFob3N0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGV4dHJhY3QgaG9zdCBmcm9tIFwiLmNvbmNhdCh1cmwpKTtcbiAgfVxuXG4gIHJldHVybiBob3N0LnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFBvcnQocG9ydFN0cmluZywgc2NoZW1lKSB7XG4gIHZhciBwb3J0ID0gcGFyc2VJbnQocG9ydFN0cmluZywgMTApO1xuICByZXR1cm4gcG9ydCA9PT0gMCB8fCBwb3J0ID8gcG9ydCA6IGRlZmF1bHRQb3J0Rm9yU2NoZW1lKHNjaGVtZSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RRdWVyeShxdWVyeVN0cmluZywgdXJsKSB7XG4gIHZhciBxdWVyeSA9IHRyaW1BbmRTYW5pdGl6ZVF1ZXJ5KHF1ZXJ5U3RyaW5nKTtcbiAgdmFyIGNvbnRleHQgPSB7fTtcblxuICBpZiAocXVlcnkpIHtcbiAgICBxdWVyeS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgIHZhciBrZXlWYWx1ZSA9IHBhaXIuc3BsaXQoJz0nKTtcblxuICAgICAgaWYgKGtleVZhbHVlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhcmFtZXRlcnM6ICdcIi5jb25jYXQoa2V5VmFsdWUsIFwiJyBpbiBVUkwgJ1wiKS5jb25jYXQodXJsLCBcIicuXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleSA9IHRyaW1BbmRWZXJpZnlRdWVyeUVsZW1lbnQoa2V5VmFsdWVbMF0sICdrZXknLCB1cmwpO1xuICAgICAgdmFyIHZhbHVlID0gdHJpbUFuZFZlcmlmeVF1ZXJ5RWxlbWVudChrZXlWYWx1ZVsxXSwgJ3ZhbHVlJywgdXJsKTtcblxuICAgICAgaWYgKGNvbnRleHRba2V5XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGVkIHF1ZXJ5IHBhcmFtZXRlcnMgd2l0aCBrZXkgJ1wiLmNvbmNhdChrZXksIFwiJyBpbiBVUkwgJ1wiKS5jb25jYXQodXJsLCBcIidcIikpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiB0cmltQW5kU2FuaXRpemVRdWVyeShxdWVyeSkge1xuICBxdWVyeSA9IChxdWVyeSB8fCAnJykudHJpbSgpO1xuXG4gIGlmIChxdWVyeSAmJiBxdWVyeS5jaGFyQXQoMCkgPT09ICc/Jykge1xuICAgIHF1ZXJ5ID0gcXVlcnkuc3Vic3RyaW5nKDEsIHF1ZXJ5Lmxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gcXVlcnk7XG59XG5cbmZ1bmN0aW9uIHRyaW1BbmRWZXJpZnlRdWVyeUVsZW1lbnQoZWxlbWVudCwgbmFtZSwgdXJsKSB7XG4gIGVsZW1lbnQgPSAoZWxlbWVudCB8fCAnJykudHJpbSgpO1xuXG4gIGlmICghZWxlbWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgZW1wdHkgXCIuY29uY2F0KG5hbWUsIFwiIGluIFVSTCBxdWVyeSAnXCIpLmNvbmNhdCh1cmwsIFwiJ1wiKSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZXNjYXBlSVB2NkFkZHJlc3MoYWRkcmVzcykge1xuICB2YXIgc3RhcnRzV2l0aFNxdWFyZUJyYWNrZXQgPSBhZGRyZXNzLmNoYXJBdCgwKSA9PT0gJ1snO1xuICB2YXIgZW5kc1dpdGhTcXVhcmVCcmFja2V0ID0gYWRkcmVzcy5jaGFyQXQoYWRkcmVzcy5sZW5ndGggLSAxKSA9PT0gJ10nO1xuXG4gIGlmICghc3RhcnRzV2l0aFNxdWFyZUJyYWNrZXQgJiYgIWVuZHNXaXRoU3F1YXJlQnJhY2tldCkge1xuICAgIHJldHVybiBcIltcIi5jb25jYXQoYWRkcmVzcywgXCJdXCIpO1xuICB9IGVsc2UgaWYgKHN0YXJ0c1dpdGhTcXVhcmVCcmFja2V0ICYmIGVuZHNXaXRoU3F1YXJlQnJhY2tldCkge1xuICAgIHJldHVybiBhZGRyZXNzO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgSVB2NiBhZGRyZXNzIFwiLmNvbmNhdChhZGRyZXNzKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0SG9zdChob3N0KSB7XG4gIGlmICghaG9zdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgaG9zdCBcIi5jb25jYXQoaG9zdCkpO1xuICB9XG5cbiAgdmFyIGlzSVB2NkFkZHJlc3MgPSBob3N0LmluZGV4T2YoJzonKSA+PSAwO1xuICByZXR1cm4gaXNJUHY2QWRkcmVzcyA/IGVzY2FwZUlQdjZBZGRyZXNzKGhvc3QpIDogaG9zdDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SVB2NEFkZHJlc3MoYWRkcmVzcywgcG9ydCkge1xuICByZXR1cm4gXCJcIi5jb25jYXQoYWRkcmVzcywgXCI6XCIpLmNvbmNhdChwb3J0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SVB2NkFkZHJlc3MoYWRkcmVzcywgcG9ydCkge1xuICB2YXIgZXNjYXBlZEFkZHJlc3MgPSBlc2NhcGVJUHY2QWRkcmVzcyhhZGRyZXNzKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGVzY2FwZWRBZGRyZXNzLCBcIjpcIikuY29uY2F0KHBvcnQpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UG9ydEZvclNjaGVtZShzY2hlbWUpIHtcbiAgaWYgKHNjaGVtZSA9PT0gJ2h0dHAnKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfSFRUUF9QT1JUO1xuICB9IGVsc2UgaWYgKHNjaGVtZSA9PT0gJ2h0dHBzJykge1xuICAgIHJldHVybiBERUZBVUxUX0hUVFBTX1BPUlQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERFRkFVTFRfQk9MVF9QT1JUO1xuICB9XG59XG5cbnZhciBfZGVmYXVsdCA9IHtcbiAgcGFyc2VEYXRhYmFzZVVybDogcGFyc2VEYXRhYmFzZVVybCxcbiAgZGVmYXVsdFBvcnRGb3JTY2hlbWU6IGRlZmF1bHRQb3J0Rm9yU2NoZW1lLFxuICBmb3JtYXRJUHY0QWRkcmVzczogZm9ybWF0SVB2NEFkZHJlc3MsXG4gIGZvcm1hdElQdjZBZGRyZXNzOiBmb3JtYXRJUHY2QWRkcmVzc1xufTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc0VtcHR5T2JqZWN0T3JOdWxsID0gaXNFbXB0eU9iamVjdE9yTnVsbDtcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0ID0gYXNzZXJ0T2JqZWN0O1xuZXhwb3J0cy5hc3NlcnRTdHJpbmcgPSBhc3NlcnRTdHJpbmc7XG5leHBvcnRzLmFzc2VydE51bWJlciA9IGFzc2VydE51bWJlcjtcbmV4cG9ydHMuYXNzZXJ0TnVtYmVyT3JJbnRlZ2VyID0gYXNzZXJ0TnVtYmVyT3JJbnRlZ2VyO1xuZXhwb3J0cy5hc3NlcnRWYWxpZERhdGUgPSBhc3NlcnRWYWxpZERhdGU7XG5leHBvcnRzLnZhbGlkYXRlUXVlcnlBbmRQYXJhbWV0ZXJzID0gdmFsaWRhdGVRdWVyeUFuZFBhcmFtZXRlcnM7XG5leHBvcnRzLkVOQ1JZUFRJT05fT0ZGID0gZXhwb3J0cy5FTkNSWVBUSU9OX09OID0gdm9pZCAwO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBfaW50ZWdlciA9IHJlcXVpcmUoXCIuLi9pbnRlZ2VyXCIpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBFTkNSWVBUSU9OX09OID0gJ0VOQ1JZUFRJT05fT04nO1xuZXhwb3J0cy5FTkNSWVBUSU9OX09OID0gRU5DUllQVElPTl9PTjtcbnZhciBFTkNSWVBUSU9OX09GRiA9ICdFTkNSWVBUSU9OX09GRic7XG5leHBvcnRzLkVOQ1JZUFRJT05fT0ZGID0gRU5DUllQVElPTl9PRkY7XG5cbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3RPck51bGwob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuICgwLCBfdHlwZW9mMltcImRlZmF1bHRcIl0pKG9iaikgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9iaikgJiYgb2JqICE9PSBudWxsO1xufVxuLyoqXG4gKiBDaGVjayBhbmQgbm9ybWFsaXplIGdpdmVuIHF1ZXJ5IGFuZCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtzdHJpbmd8e3RleHQ6IHN0cmluZywgcGFyYW1ldGVyczogb2JqZWN0fX0gcXVlcnkgdGhlIHF1ZXJ5IHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm4ge3txdWVyeTogc3RyaW5nLCBwYXJhbXM6IG9iamVjdH19IHRoZSBub3JtYWxpemVkIHF1ZXJ5IHdpdGggcGFyYW1ldGVycy5cbiAqIEB0aHJvd3MgVHlwZUVycm9yIHdoZW4gZWl0aGVyIGdpdmVuIHF1ZXJ5IG9yIHBhcmFtZXRlcnMgYXJlIGludmFsaWQuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVF1ZXJ5QW5kUGFyYW1ldGVycyhxdWVyeSwgcGFyYW1ldGVycykge1xuICB2YXIgdmFsaWRhdGVkUXVlcnkgPSBxdWVyeTtcbiAgdmFyIHBhcmFtcyA9IHBhcmFtZXRlcnMgfHwge307XG5cbiAgaWYgKCgwLCBfdHlwZW9mMltcImRlZmF1bHRcIl0pKHF1ZXJ5KSA9PT0gJ29iamVjdCcgJiYgcXVlcnkudGV4dCkge1xuICAgIHZhbGlkYXRlZFF1ZXJ5ID0gcXVlcnkudGV4dDtcbiAgICBwYXJhbXMgPSBxdWVyeS5wYXJhbWV0ZXJzIHx8IHt9O1xuICB9XG5cbiAgYXNzZXJ0Q3lwaGVyUXVlcnkodmFsaWRhdGVkUXVlcnkpO1xuICBhc3NlcnRRdWVyeVBhcmFtZXRlcnMocGFyYW1zKTtcbiAgcmV0dXJuIHtcbiAgICB2YWxpZGF0ZWRRdWVyeTogdmFsaWRhdGVkUXVlcnksXG4gICAgcGFyYW1zOiBwYXJhbXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KG9iaiwgb2JqTmFtZSkge1xuICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG9iak5hbWUgKyAnIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCBidXQgd2FzOiAnICsgSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTdHJpbmcob2JqLCBvYmpOYW1lKSB7XG4gIGlmICghaXNTdHJpbmcob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3Iob2JqTmFtZSArICcgZXhwZWN0ZWQgdG8gYmUgc3RyaW5nIGJ1dCB3YXM6ICcgKyBKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE51bWJlcihvYmosIG9iak5hbWUpIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihvYmpOYW1lICsgJyBleHBlY3RlZCB0byBiZSBhIG51bWJlciBidXQgd2FzOiAnICsgSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROdW1iZXJPckludGVnZXIob2JqLCBvYmpOYW1lKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnbnVtYmVyJyAmJiAhKDAsIF9pbnRlZ2VyLmlzSW50KShvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihvYmpOYW1lICsgJyBleHBlY3RlZCB0byBiZSBlaXRoZXIgYSBudW1iZXIgb3IgYW4gSW50ZWdlciBvYmplY3QgYnV0IHdhczogJyArIEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWREYXRlKG9iaiwgb2JqTmFtZSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgIT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3Iob2JqTmFtZSArICcgZXhwZWN0ZWQgdG8gYmUgYSBzdGFuZGFyZCBKYXZhU2NyaXB0IERhdGUgYnV0IHdhczogJyArIEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICB9XG5cbiAgaWYgKE51bWJlci5pc05hTihvYmouZ2V0VGltZSgpKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3Iob2JqTmFtZSArICcgZXhwZWN0ZWQgdG8gYmUgdmFsaWQgSmF2YVNjcmlwdCBEYXRlIGJ1dCBpdHMgdGltZSB3YXMgTmFOOiAnICsgSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDeXBoZXJRdWVyeShvYmopIHtcbiAgYXNzZXJ0U3RyaW5nKG9iaiwgJ0N5cGhlciBxdWVyeScpO1xuXG4gIGlmIChvYmoudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0N5cGhlciBxdWVyeSBpcyBleHBlY3RlZCB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UXVlcnlQYXJhbWV0ZXJzKG9iaikge1xuICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICAvLyBvYmplY3RzIGNyZWF0ZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZG8gbm90IGhhdmUgYSBjb25zdHJ1Y3RvciBwcm9wZXJ0eVxuICAgIHZhciBfY29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3IgPyAnICcgKyBvYmouY29uc3RydWN0b3IubmFtZSA6ICcnO1xuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlF1ZXJ5IHBhcmFtZXRlcnMgYXJlIGV4cGVjdGVkIHRvIGVpdGhlciBiZSB1bmRlZmluZWQvbnVsbCBvciBhbiBvYmplY3QsIGdpdmVuOlwiLmNvbmNhdChfY29uc3RydWN0b3IsIFwiIFwiKS5jb25jYXQob2JqKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3RyKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXlcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8pIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKG8gPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpKSB7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIGl0LCBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gZ2VuZXJhdGVGaWVsZExvb2t1cChrZXlzKSB7XG4gIHZhciBsb29rdXAgPSB7fTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lLCBpZHgpIHtcbiAgICBsb29rdXBbbmFtZV0gPSBpZHg7XG4gIH0pO1xuICByZXR1cm4gbG9va3VwO1xufVxuLyoqXG4gKiBSZWNvcmRzIG1ha2UgdXAgdGhlIGNvbnRlbnRzIG9mIHRoZSB7QGxpbmsgUmVzdWx0fSwgYW5kIGlzIGhvdyB5b3UgYWNjZXNzXG4gKiB0aGUgb3V0cHV0IG9mIGEgcXVlcnkuIEEgc2ltcGxlIHF1ZXJ5IG1pZ2h0IHlpZWxkIGEgcmVzdWx0IHN0cmVhbVxuICogd2l0aCBhIHNpbmdsZSByZWNvcmQsIGZvciBpbnN0YW5jZTpcbiAqXG4gKiAgICAgTUFUQ0ggKHU6VXNlcikgUkVUVVJOIHUubmFtZSwgdS5hZ2VcbiAqXG4gKiBUaGlzIHJldHVybnMgYSBzdHJlYW0gb2YgcmVjb3JkcyB3aXRoIHR3byBmaWVsZHMsIG5hbWVkIGB1Lm5hbWVgIGFuZCBgdS5hZ2VgLFxuICogZWFjaCByZWNvcmQgcmVwcmVzZW50cyBvbmUgdXNlciBmb3VuZCBieSB0aGUgcXVlcnkgYWJvdmUuIFlvdSBjYW4gYWNjZXNzXG4gKiB0aGUgdmFsdWVzIG9mIGVhY2ggZmllbGQgZWl0aGVyIGJ5IG5hbWU6XG4gKlxuICogICAgIHJlY29yZC5nZXQoXCJ1Lm5hbWVcIilcbiAqXG4gKiBPciBieSBpdCdzIHBvc2l0aW9uOlxuICpcbiAqICAgICByZWNvcmQuZ2V0KDApXG4gKlxuICogQGFjY2VzcyBwdWJsaWNcbiAqL1xuXG5cbnZhciBSZWNvcmQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHJlY29yZCBvYmplY3QuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGtleXMgQW4gYXJyYXkgb2YgZmllbGQga2V5cywgaW4gdGhlIG9yZGVyIHRoZSBmaWVsZHMgYXBwZWFyIGluIHRoZSByZWNvcmRcbiAgICogQHBhcmFtIHtBcnJheX0gZmllbGRzIEFuIGFycmF5IG9mIGZpZWxkIHZhbHVlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZmllbGRMb29rdXAgQW4gb2JqZWN0IG9mIGZpZWxkTmFtZSAtPiB2YWx1ZSBpbmRleCwgdXNlZCB0byBtYXBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgbmFtZXMgdG8gdmFsdWVzLiBJZiB0aGlzIGlzIG51bGwsIG9uZSB3aWxsIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFJlY29yZChrZXlzLCBmaWVsZHMpIHtcbiAgICB2YXIgZmllbGRMb29rdXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBSZWNvcmQpO1xuXG4gICAgLyoqXG4gICAgICogRmllbGQga2V5cywgaW4gdGhlIG9yZGVyIHRoZSBmaWVsZHMgYXBwZWFyIGluIHRoZSByZWNvcmQuXG4gICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGZpZWxkc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLmxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHRoaXMuX2ZpZWxkcyA9IGZpZWxkcztcbiAgICB0aGlzLl9maWVsZExvb2t1cCA9IGZpZWxkTG9va3VwIHx8IGdlbmVyYXRlRmllbGRMb29rdXAoa2V5cyk7XG4gIH1cbiAgLyoqXG4gICAqIFJ1biB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggZmllbGQgaW4gdGhpcyByZWNvcmQuIFRoZSBmdW5jdGlvblxuICAgKiB3aWxsIGdldCB0aHJlZSBhcmd1bWVudHMgLSB0aGUgdmFsdWUsIHRoZSBrZXkgYW5kIHRoaXMgcmVjb3JkLCBpbiB0aGF0XG4gICAqIG9yZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBPYmplY3QsIGtleTogc3RyaW5nLCByZWNvcmQ6IFJlY29yZCl9IHZpc2l0b3IgdGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggZmllbGQuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShSZWNvcmQsIFt7XG4gICAga2V5OiBcImZvckVhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaCh2aXNpdG9yKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5lbnRyaWVzKCkpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9ICgwLCBfc2xpY2VkVG9BcnJheTJbXCJkZWZhdWx0XCJdKShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIGtleSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgICAgICB2YWx1ZSA9IF9zdGVwJHZhbHVlWzFdO1xuXG4gICAgICAgICAgdmlzaXRvcih2YWx1ZSwga2V5LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gdGhlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGZpZWxkIGluIHRoaXMgcmVjb3JkLiBUaGUgZnVuY3Rpb25cbiAgICAgKiB3aWxsIGdldCB0aHJlZSBhcmd1bWVudHMgLSB0aGUgdmFsdWUsIHRoZSBrZXkgYW5kIHRoaXMgcmVjb3JkLCBpbiB0aGF0XG4gICAgICogb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBPYmplY3QsIGtleTogc3RyaW5nLCByZWNvcmQ6IFJlY29yZCl9IHZpc2l0b3IgdGhlIGZ1bmN0aW9uIHRvIGFwcGx5IG9uIGVhY2ggZmllbGRcbiAgICAgKiBhbmQgcmV0dXJuIGEgdmFsdWUgdGhhdCBpcyBzYXZlZCB0byB0aGUgcmV0dXJuZWQgQXJyYXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKHZpc2l0b3IpIHtcbiAgICAgIHZhciByZXN1bHRBcnJheSA9IFtdO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuZW50cmllcygpKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9ICgwLCBfc2xpY2VkVG9BcnJheTJbXCJkZWZhdWx0XCJdKShfc3RlcDIudmFsdWUsIDIpLFxuICAgICAgICAgICAgICBrZXkgPSBfc3RlcDIkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIHZhbHVlID0gX3N0ZXAyJHZhbHVlWzFdO1xuXG4gICAgICAgICAgcmVzdWx0QXJyYXkucHVzaCh2aXNpdG9yKHZhbHVlLCBrZXksIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRBcnJheTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBvdmVyIHJlc3VsdHMuIEVhY2ggaXRlcmF0aW9uIHdpbGwgeWllbGQgYW4gYXJyYXlcbiAgICAgKiBvZiBleGFjdGx5IHR3byBpdGVtcyAtIHRoZSBrZXksIGFuZCB0aGUgdmFsdWUgKGluIG9yZGVyKS5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0b3JcbiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGVJdGVyYXRvcjxBcnJheT59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbnRyaWVzXCIsXG4gICAgdmFsdWU6IC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHZhciBpO1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBlbnRyaWVzJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgaWYgKCEoaSA8IHRoaXMua2V5cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmtleXNbaV0sIHRoaXMuX2ZpZWxkc1tpXV07XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGVudHJpZXMsIHRoaXMpO1xuICAgIH0pXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBvdmVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0b3JcbiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGVJdGVyYXRvcjxPYmplY3Q+fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVzXCIsXG4gICAgdmFsdWU6IC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgdmFyIGk7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIHZhbHVlcyQoX2NvbnRleHQyKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGlmICghKGkgPCB0aGlzLmtleXMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkc1tpXTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB2YWx1ZXMsIHRoaXMpO1xuICAgIH0pXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBvdmVyIHZhbHVlcy4gRGVsZWdhdGVzIHRvIHtAbGluayBSZWNvcmQjdmFsdWVzfVxuICAgICAqXG4gICAgICogQGdlbmVyYXRvclxuICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPE9iamVjdD59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogU3ltYm9sLml0ZXJhdG9yLFxuICAgIHZhbHVlOiAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiB2YWx1ZSQoX2NvbnRleHQzKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuZGVsZWdhdGVZaWVsZCh0aGlzLnZhbHVlcygpLCBcInQwXCIsIDEpO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdmFsdWUsIHRoaXMpO1xuICAgIH0pXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIG9iamVjdCBvdXQgb2YgdGhlIGN1cnJlbnQgUmVjb3JkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9PYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICB2YXIgb2JqZWN0ID0ge307XG5cbiAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5lbnRyaWVzKCkpLFxuICAgICAgICAgIF9zdGVwMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAzJHZhbHVlID0gKDAsIF9zbGljZWRUb0FycmF5MltcImRlZmF1bHRcIl0pKF9zdGVwMy52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIGtleSA9IF9zdGVwMyR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgX3ZhbHVlID0gX3N0ZXAzJHZhbHVlWzFdO1xuXG4gICAgICAgICAgb2JqZWN0W2tleV0gPSBfdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSB2YWx1ZSBmcm9tIHRoaXMgcmVjb3JkLCBlaXRoZXIgYnkgaW5kZXggb3IgYnkgZmllbGQga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8TnVtYmVyfSBrZXkgRmllbGQga2V5LCBvciB0aGUgaW5kZXggb2YgdGhlIGZpZWxkLlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgIHZhciBpbmRleDtcblxuICAgICAgaWYgKCEodHlwZW9mIGtleSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5fZmllbGRMb29rdXBba2V5XTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKFwiVGhpcyByZWNvcmQgaGFzIG5vIGZpZWxkIHdpdGgga2V5ICdcIiArIGtleSArIFwiJywgYXZhaWxhYmxlIGtleSBhcmU6IFtcIiArIHRoaXMua2V5cyArICddLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IGtleTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID4gdGhpcy5fZmllbGRzLmxlbmd0aCAtIDEgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKFwiVGhpcyByZWNvcmQgaGFzIG5vIGZpZWxkIHdpdGggaW5kZXggJ1wiICsgaW5kZXggKyBcIicuIFJlbWVtYmVyIHRoYXQgaW5kZXhlcyBzdGFydCBhdCBgMGAsIFwiICsgJ2FuZCBtYWtlIHN1cmUgeW91ciBxdWVyeSByZXR1cm5zIHJlY29yZHMgaW4gdGhlIHNoYXBlIHlvdSBtZWFudCBpdCB0by4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkc1tpbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdmFsdWUgZnJvbSB0aGlzIHJlY29yZCwgZWl0aGVyIGJ5IGluZGV4IG9yIGJ5IGZpZWxkIGtleSwgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8TnVtYmVyfSBrZXkgRmllbGQga2V5LCBvciB0aGUgaW5kZXggb2YgdGhlIGZpZWxkLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgIC8vIGlmIGtleSBpcyBhIG51bWJlciwgd2UgY2hlY2sgaWYgaXQgaXMgaW4gdGhlIF9maWVsZHMgYXJyYXlcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4ga2V5ID49IDAgJiYga2V5IDwgdGhpcy5fZmllbGRzLmxlbmd0aDtcbiAgICAgIH0gLy8gaWYgaXQncyBub3QgYSBudW1iZXIsIHdlIGNoZWNrIF9maWVsZExvb2t1cCBkaWN0aW9uYXJ5IGRpcmVjdGx5XG5cblxuICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkTG9va3VwW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlY29yZDtcbn0oKTtcblxudmFyIF9kZWZhdWx0ID0gUmVjb3JkO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuXG52YXIgX3Jlc3VsdFN1bW1hcnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Jlc3VsdC1zdW1tYXJ5XCIpKTtcblxudmFyIF9yeGpzID0gcmVxdWlyZShcInJ4anNcIik7XG5cbnZhciBfb3BlcmF0b3JzID0gcmVxdWlyZShcInJ4anMvb3BlcmF0b3JzXCIpO1xuXG52YXIgX3JlY29yZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVjb3JkXCIpKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgU3RhdGVzID0ge1xuICBSRUFEWTogMCxcbiAgU1RSRUFNSU5HOiAxLFxuICBDT01QTEVURUQ6IDJcbn07XG4vKipcbiAqIFRoZSByZWFjdGl2ZSByZXN1bHQgaW50ZXJmYWNlLlxuICovXG5cbnZhciBSeFJlc3VsdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge09ic2VydmFibGU8UmVzdWx0Pn0gcmVzdWx0IC0gQW4gb2JzZXJ2YWJsZSBvZiBzaW5nbGUgUmVzdWx0IGluc3RhbmNlIHRvIHJlbGF5IHJlcXVlc3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gUnhSZXN1bHQocmVzdWx0KSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBSeFJlc3VsdCk7XG4gICAgdmFyIHJlcGxheWVkUmVzdWx0ID0gcmVzdWx0LnBpcGUoKDAsIF9vcGVyYXRvcnMucHVibGlzaFJlcGxheSkoMSksICgwLCBfb3BlcmF0b3JzLnJlZkNvdW50KSgpKTtcbiAgICB0aGlzLl9yZXN1bHQgPSByZXBsYXllZFJlc3VsdDtcbiAgICB0aGlzLl9rZXlzID0gcmVwbGF5ZWRSZXN1bHQucGlwZSgoMCwgX29wZXJhdG9ycy5mbGF0TWFwKShmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuICgwLCBfcnhqcy5mcm9tKShyLmtleXMoKSk7XG4gICAgfSksICgwLCBfb3BlcmF0b3JzLnB1Ymxpc2hSZXBsYXkpKDEpLCAoMCwgX29wZXJhdG9ycy5yZWZDb3VudCkoKSk7XG4gICAgdGhpcy5fcmVjb3JkcyA9IG5ldyBfcnhqcy5TdWJqZWN0KCk7XG4gICAgdGhpcy5fc3VtbWFyeSA9IG5ldyBfcnhqcy5SZXBsYXlTdWJqZWN0KCk7XG4gICAgdGhpcy5fc3RhdGUgPSBTdGF0ZXMuUkVBRFk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IGV4cG9zZXMgYSBzaW5nbGUgaXRlbSBjb250YWluaW5nIGZpZWxkIG5hbWVzXG4gICAqIHJldHVybmVkIGJ5IHRoZSBleGVjdXRpbmcgcXVlcnkuXG4gICAqXG4gICAqIEVycm9ycyByYWlzZWQgYnkgYWN0dWFsIHF1ZXJ5IGV4ZWN1dGlvbiBjYW4gc3VyZmFjZSBvbiB0aGUgcmV0dXJuZWRcbiAgICogb2JzZXJ2YWJsZSBzdHJlYW0uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge09ic2VydmFibGU8c3RyaW5nW10+fSAtIEFuIG9ic2VydmFibGUgc3RyZWFtICh3aXRoIGV4YWN0bHkgb25lIGVsZW1lbnQpIG9mIGZpZWxkIG5hbWVzLlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUnhSZXN1bHQsIFt7XG4gICAga2V5OiBcImtleXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9rZXlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgdGhhdCBleHBvc2VzIGVhY2ggcmVjb3JkIHJldHVybmVkIGJ5IHRoZSBleGVjdXRpbmcgcXVlcnkuXG4gICAgICpcbiAgICAgKiBFcnJvcnMgcmFpc2VkIGR1cmluZyB0aGUgc3RyZWFtaW5nIHBoYXNlIGNhbiBzdXJmYWNlIG9uIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTxSZWNvcmQ+fSAtIEFuIG9ic2VydmFibGUgc3RyZWFtIG9mIHJlY29yZHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWNvcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29yZHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVzdWx0LnBpcGUoKDAsIF9vcGVyYXRvcnMuZmxhdE1hcCkoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbmV3IF9yeGpzLk9ic2VydmFibGUoZnVuY3Rpb24gKHJlY29yZHNPYnNlcnZlcikge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fc3RhcnRTdHJlYW1pbmcoe1xuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICByZWNvcmRzT2JzZXJ2ZXI6IHJlY29yZHNPYnNlcnZlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgZXhwb3NlcyBhIHNpbmdsZSBpdGVtIG9mIHtAbGluayBSZXN1bHRTdW1tYXJ5fSB0aGF0IGlzIGdlbmVyYXRlZCBieVxuICAgICAqIHRoZSBzZXJ2ZXIgYWZ0ZXIgdGhlIHN0cmVhbWluZyBvZiB0aGUgZXhlY3V0aW5nIHF1ZXJ5IGlzIGNvbXBsZXRlZC5cbiAgICAgKlxuICAgICAqICpTdWJzY3JpYmluZyB0byB0aGlzIHN0cmVhbSBiZWZvcmUgc3Vic2NyaWJpbmcgdG8gcmVjb3JkcygpIHN0cmVhbSBjYXVzZXMgdGhlIHJlc3VsdHMgdG8gYmUgZGlzY2FyZGVkIG9uIHRoZSBzZXJ2ZXIuKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlPFJlc3VsdFN1bW1hcnk+fSAtIEFuIG9ic2VydmFibGUgc3RyZWFtICh3aXRoIGV4YWN0bHkgb25lIGVsZW1lbnQpIG9mIHJlc3VsdCBzdW1tYXJ5LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uc3VtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdW1lKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXN1bHQucGlwZSgoMCwgX29wZXJhdG9ycy5mbGF0TWFwKShmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBuZXcgX3J4anMuT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3VtbWFyeU9ic2VydmVyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5fc3RhcnRTdHJlYW1pbmcoe1xuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICBzdW1tYXJ5T2JzZXJ2ZXI6IHN1bW1hcnlPYnNlcnZlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YXJ0U3RyZWFtaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydFN0cmVhbWluZygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgcmVzdWx0ID0gX3JlZi5yZXN1bHQsXG4gICAgICAgICAgX3JlZiRyZWNvcmRzT2JzZXJ2ZXIgPSBfcmVmLnJlY29yZHNPYnNlcnZlcixcbiAgICAgICAgICByZWNvcmRzT2JzZXJ2ZXIgPSBfcmVmJHJlY29yZHNPYnNlcnZlciA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkcmVjb3Jkc09ic2VydmVyLFxuICAgICAgICAgIF9yZWYkc3VtbWFyeU9ic2VydmVyID0gX3JlZi5zdW1tYXJ5T2JzZXJ2ZXIsXG4gICAgICAgICAgc3VtbWFyeU9ic2VydmVyID0gX3JlZiRzdW1tYXJ5T2JzZXJ2ZXIgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmJHN1bW1hcnlPYnNlcnZlcjtcblxuICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBbXTtcblxuICAgICAgaWYgKHN1bW1hcnlPYnNlcnZlcikge1xuICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2godGhpcy5fc3VtbWFyeS5zdWJzY3JpYmUoc3VtbWFyeU9ic2VydmVyKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA8IFN0YXRlcy5TVFJFQU1JTkcpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBTdGF0ZXMuU1RSRUFNSU5HO1xuXG4gICAgICAgIGlmIChyZWNvcmRzT2JzZXJ2ZXIpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2godGhpcy5fcmVjb3Jkcy5zdWJzY3JpYmUocmVjb3Jkc09ic2VydmVyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goe1xuICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuX2NhbmNlbCkge1xuICAgICAgICAgICAgICByZXN1bHQuX2NhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlY29yZHMub2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJlc3VsdC5fY2FuY2VsKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuc3Vic2NyaWJlKHtcbiAgICAgICAgICBvbk5leHQ6IGZ1bmN0aW9uIG9uTmV4dChyZWNvcmQpIHtcbiAgICAgICAgICAgIF90aGlzMy5fcmVjb3Jkcy5uZXh0KHJlY29yZCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gb25Db21wbGV0ZWQoc3VtbWFyeSkge1xuICAgICAgICAgICAgX3RoaXMzLl9yZWNvcmRzLmNvbXBsZXRlKCk7XG5cbiAgICAgICAgICAgIF90aGlzMy5fc3VtbWFyeS5uZXh0KHN1bW1hcnkpO1xuXG4gICAgICAgICAgICBfdGhpczMuX3N1bW1hcnkuY29tcGxldGUoKTtcblxuICAgICAgICAgICAgX3RoaXMzLl9zdGF0ZSA9IFN0YXRlcy5DT01QTEVURUQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgICAgICAgICAgX3RoaXMzLl9yZWNvcmRzLmVycm9yKGVycik7XG5cbiAgICAgICAgICAgIF90aGlzMy5fc3VtbWFyeS5lcnJvcihlcnIpO1xuXG4gICAgICAgICAgICBfdGhpczMuX3N0YXRlID0gU3RhdGVzLkNPTVBMRVRFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmRzT2JzZXJ2ZXIpIHtcbiAgICAgICAgcmVjb3Jkc09ic2VydmVyLmVycm9yKCgwLCBfZXJyb3IubmV3RXJyb3IpKCdTdHJlYW1pbmcgaGFzIGFscmVhZHkgc3RhcnRlZC9jb25zdW1lZCB3aXRoIGEgcHJldmlvdXMgcmVjb3JkcyBvciBzdW1tYXJ5IHN1YnNjcmlwdGlvbi4nKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgIHJldHVybiBzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJ4UmVzdWx0O1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJ4UmVzdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZXhwb3J0cy5xdWVyeVR5cGUgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW50ZWdlciA9IHJlcXVpcmUoXCIuL2ludGVnZXJcIik7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEEgUmVzdWx0U3VtbWFyeSBpbnN0YW5jZSBjb250YWlucyBzdHJ1Y3R1cmVkIG1ldGFkYXRhIGZvciBhIHtAbGluayBSZXN1bHR9LlxuICogQGFjY2VzcyBwdWJsaWNcbiAqL1xudmFyIFJlc3VsdFN1bW1hcnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIFRoZSBxdWVyeSB0aGlzIHN1bW1hcnkgaXMgZm9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gUGFyYW1ldGVycyBmb3IgdGhlIHF1ZXJ5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhZGF0YSAtIFF1ZXJ5IG1ldGFkYXRhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcm90b2NvbFZlcnNpb24gLSBCb2x0IHByb3RvY29sIHZlcnNpb25cbiAgICovXG4gIGZ1bmN0aW9uIFJlc3VsdFN1bW1hcnkocXVlcnksIHBhcmFtZXRlcnMsIG1ldGFkYXRhLCBwcm90b2NvbFZlcnNpb24pIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFJlc3VsdFN1bW1hcnkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHF1ZXJ5IGFuZCBwYXJhbWV0ZXJzIHRoaXMgc3VtbWFyeSBpcyBmb3IuXG4gICAgICogQHR5cGUge3t0ZXh0OiBzdHJpbmcsIHBhcmFtZXRlcnM6IE9iamVjdH19XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMucXVlcnkgPSB7XG4gICAgICB0ZXh0OiBxdWVyeSxcbiAgICAgIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnNcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHF1ZXJ5IGV4ZWN1dGVkLiBDYW4gYmUgXCJyXCIgZm9yIHJlYWQtb25seSBxdWVyeSwgXCJyd1wiIGZvciByZWFkLXdyaXRlIHF1ZXJ5LFxuICAgICAqIFwid1wiIGZvciB3cml0ZS1vbmx5IHF1ZXJ5IGFuZCBcInNcIiBmb3Igc2NoZW1hLXdyaXRlIHF1ZXJ5LlxuICAgICAqIFN0cmluZyBjb25zdGFudHMgYXJlIGF2YWlsYWJsZSBpbiB7QGxpbmsgcXVlcnlUeXBlfSBvYmplY3QuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHVibGljXG4gICAgICovXG5cbiAgICB0aGlzLnF1ZXJ5VHlwZSA9IG1ldGFkYXRhLnR5cGU7XG4gICAgLyoqXG4gICAgICogQ291bnRlcnMgZm9yIG9wZXJhdGlvbnMgdGhlIHF1ZXJ5IHRyaWdnZXJlZC5cbiAgICAgKiBAdHlwZSB7UXVlcnlTdGF0aXN0aWNzfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cblxuICAgIHRoaXMuY291bnRlcnMgPSBuZXcgUXVlcnlTdGF0aXN0aWNzKG1ldGFkYXRhLnN0YXRzIHx8IHt9KTsgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCByZW1vdmUgaW4gZnV0dXJlIHZlcnNpb25cblxuICAgIC8qKlxuICAgICAqIFVzZSB7QGxpbmsgUmVzdWx0U3VtbWFyeS5jb3VudGVyc30gaW5zdGVhZC5cbiAgICAgKiBAdHlwZSB7UXVlcnlTdGF0aXN0aWNzfVxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG5cbiAgICB0aGlzLnVwZGF0ZVN0YXRpc3RpY3MgPSB0aGlzLmNvdW50ZXJzO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZGVzY3JpYmVzIGhvdyB0aGUgZGF0YWJhc2Ugd2lsbCBleGVjdXRlIHRoZSBxdWVyeS5cbiAgICAgKiBRdWVyeSBwbGFuIGZvciB0aGUgZXhlY3V0ZWQgcXVlcnkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgICAqIFdpbGwgb25seSBiZSBwb3B1bGF0ZWQgZm9yIHF1ZXJpZXMgdGhhdCBzdGFydCB3aXRoIFwiRVhQTEFJTlwiLlxuICAgICAqIEB0eXBlIHtQbGFufVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cblxuICAgIHRoaXMucGxhbiA9IG1ldGFkYXRhLnBsYW4gfHwgbWV0YWRhdGEucHJvZmlsZSA/IG5ldyBQbGFuKG1ldGFkYXRhLnBsYW4gfHwgbWV0YWRhdGEucHJvZmlsZSkgOiBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGRlc2NyaWJlcyBob3cgdGhlIGRhdGFiYXNlIGRpZCBleGVjdXRlIHlvdXIgcXVlcnkuIFRoaXMgd2lsbCBjb250YWluIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IHdoYXRcbiAgICAgKiBlYWNoIHN0ZXAgb2YgdGhlIHBsYW4gZGlkLiBQcm9maWxlZCBxdWVyeSBwbGFuIGZvciB0aGUgZXhlY3V0ZWQgcXVlcnkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgICAqIFdpbGwgb25seSBiZSBwb3B1bGF0ZWQgZm9yIHF1ZXJpZXMgdGhhdCBzdGFydCB3aXRoIFwiUFJPRklMRVwiLlxuICAgICAqIEB0eXBlIHtQcm9maWxlZFBsYW59XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuXG4gICAgdGhpcy5wcm9maWxlID0gbWV0YWRhdGEucHJvZmlsZSA/IG5ldyBQcm9maWxlZFBsYW4obWV0YWRhdGEucHJvZmlsZSkgOiBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBub3RpZmljYXRpb25zIHRoYXQgbWlnaHQgYXJpc2Ugd2hlbiBleGVjdXRpbmcgdGhlIHF1ZXJ5LiBOb3RpZmljYXRpb25zIGNhbiBiZSB3YXJuaW5ncyBhYm91dFxuICAgICAqIHByb2JsZW1hdGljIHF1ZXJpZXMgb3Igb3RoZXIgdmFsdWFibGUgaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgcHJlc2VudGVkIGluIGEgY2xpZW50LiBVbmxpa2UgZmFpbHVyZXNcbiAgICAgKiBvciBlcnJvcnMsIG5vdGlmaWNhdGlvbnMgZG8gbm90IGFmZmVjdCB0aGUgZXhlY3V0aW9uIG9mIGEgcXVlcnkuXG4gICAgICogQHR5cGUge0FycmF5PE5vdGlmaWNhdGlvbj59XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuXG4gICAgdGhpcy5ub3RpZmljYXRpb25zID0gdGhpcy5fYnVpbGROb3RpZmljYXRpb25zKG1ldGFkYXRhLm5vdGlmaWNhdGlvbnMpO1xuICAgIC8qKlxuICAgICAqIFRoZSBiYXNpYyBpbmZvcm1hdGlvbiBvZiB0aGUgc2VydmVyIHdoZXJlIHRoZSByZXN1bHQgaXMgb2J0YWluZWQgZnJvbS5cbiAgICAgKiBAdHlwZSB7U2VydmVySW5mb31cbiAgICAgKiBAcHVibGljXG4gICAgICovXG5cbiAgICB0aGlzLnNlcnZlciA9IG5ldyBTZXJ2ZXJJbmZvKG1ldGFkYXRhLnNlcnZlciwgcHJvdG9jb2xWZXJzaW9uKTtcbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSBpdCB0b29rIHRoZSBzZXJ2ZXIgdG8gY29uc3VtZSB0aGUgcmVzdWx0LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuXG4gICAgdGhpcy5yZXN1bHRDb25zdW1lZEFmdGVyID0gbWV0YWRhdGEucmVzdWx0X2NvbnN1bWVkX2FmdGVyO1xuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lIGl0IHRvb2sgdGhlIHNlcnZlciB0byBtYWtlIHRoZSByZXN1bHQgYXZhaWxhYmxlIGZvciBjb25zdW1wdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG5cbiAgICB0aGlzLnJlc3VsdEF2YWlsYWJsZUFmdGVyID0gbWV0YWRhdGEucmVzdWx0X2F2YWlsYWJsZV9hZnRlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YWJhc2UgbmFtZSB3aGVyZSB0aGlzIHN1bW1hcnkgaXMgb2J0YWluZWQgZnJvbS5cbiAgICAgKiBAdHlwZSB7e25hbWU6IHN0cmluZ319XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuXG4gICAgdGhpcy5kYXRhYmFzZSA9IHtcbiAgICAgIG5hbWU6IG1ldGFkYXRhLmRiIHx8IG51bGxcbiAgICB9O1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShSZXN1bHRTdW1tYXJ5LCBbe1xuICAgIGtleTogXCJfYnVpbGROb3RpZmljYXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9idWlsZE5vdGlmaWNhdGlvbnMobm90aWZpY2F0aW9ucykge1xuICAgICAgaWYgKCFub3RpZmljYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vdGlmaWNhdGlvbnMubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm90aWZpY2F0aW9uKG4pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSByZXN1bHQgc3VtbWFyeSBoYXMgYSBwbGFuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhhc1BsYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUGxhbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsYW4gaW5zdGFuY2VvZiBQbGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcmVzdWx0IHN1bW1hcnkgaGFzIGEgcHJvZmlsZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoYXNQcm9maWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1Byb2ZpbGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9maWxlIGluc3RhbmNlb2YgUHJvZmlsZWRQbGFuO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUmVzdWx0U3VtbWFyeTtcbn0oKTtcbi8qKlxuICogQ2xhc3MgZm9yIGV4ZWN1dGlvbiBwbGFuIHJlY2VpdmVkIGJ5IHByZXBlbmRpbmcgQ3lwaGVyIHdpdGggRVhQTEFJTi5cbiAqIEBhY2Nlc3MgcHVibGljXG4gKi9cblxuXG52YXIgUGxhbiA9XG4vKipcbiAqIENyZWF0ZSBhIFBsYW4gaW5zdGFuY2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IHBsYW4gLSBPYmplY3Qgd2l0aCBwbGFuIGRhdGFcbiAqL1xuZnVuY3Rpb24gUGxhbihwbGFuKSB7XG4gICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUGxhbik7XG4gIHRoaXMub3BlcmF0b3JUeXBlID0gcGxhbi5vcGVyYXRvclR5cGU7XG4gIHRoaXMuaWRlbnRpZmllcnMgPSBwbGFuLmlkZW50aWZpZXJzO1xuICB0aGlzLmFyZ3VtZW50cyA9IHBsYW4uYXJncztcbiAgdGhpcy5jaGlsZHJlbiA9IHBsYW4uY2hpbGRyZW4gPyBwbGFuLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gbmV3IFBsYW4oY2hpbGQpO1xuICB9KSA6IFtdO1xufTtcbi8qKlxuICogQ2xhc3MgZm9yIGV4ZWN1dGlvbiBwbGFuIHJlY2VpdmVkIGJ5IHByZXBlbmRpbmcgQ3lwaGVyIHdpdGggUFJPRklMRS5cbiAqIEBhY2Nlc3MgcHVibGljXG4gKi9cblxuXG52YXIgUHJvZmlsZWRQbGFuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIFByb2ZpbGVkUGxhbiBpbnN0YW5jZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb2ZpbGUgLSBPYmplY3Qgd2l0aCBwcm9maWxlIGRhdGFcbiAgICovXG4gIGZ1bmN0aW9uIFByb2ZpbGVkUGxhbihwcm9maWxlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBQcm9maWxlZFBsYW4pO1xuICAgIHRoaXMub3BlcmF0b3JUeXBlID0gcHJvZmlsZS5vcGVyYXRvclR5cGU7XG4gICAgdGhpcy5pZGVudGlmaWVycyA9IHByb2ZpbGUuaWRlbnRpZmllcnM7XG4gICAgdGhpcy5hcmd1bWVudHMgPSBwcm9maWxlLmFyZ3M7XG4gICAgdGhpcy5kYkhpdHMgPSB2YWx1ZU9yRGVmYXVsdCgnZGJIaXRzJywgcHJvZmlsZSk7XG4gICAgdGhpcy5yb3dzID0gdmFsdWVPckRlZmF1bHQoJ3Jvd3MnLCBwcm9maWxlKTtcbiAgICB0aGlzLnBhZ2VDYWNoZU1pc3NlcyA9IHZhbHVlT3JEZWZhdWx0KCdwYWdlQ2FjaGVNaXNzZXMnLCBwcm9maWxlKTtcbiAgICB0aGlzLnBhZ2VDYWNoZUhpdHMgPSB2YWx1ZU9yRGVmYXVsdCgncGFnZUNhY2hlSGl0cycsIHByb2ZpbGUpO1xuICAgIHRoaXMucGFnZUNhY2hlSGl0UmF0aW8gPSB2YWx1ZU9yRGVmYXVsdCgncGFnZUNhY2hlSGl0UmF0aW8nLCBwcm9maWxlKTtcbiAgICB0aGlzLnRpbWUgPSB2YWx1ZU9yRGVmYXVsdCgndGltZScsIHByb2ZpbGUpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBwcm9maWxlLmNoaWxkcmVuID8gcHJvZmlsZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gbmV3IFByb2ZpbGVkUGxhbihjaGlsZCk7XG4gICAgfSkgOiBbXTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUHJvZmlsZWRQbGFuLCBbe1xuICAgIGtleTogXCJoYXNQYWdlQ2FjaGVTdGF0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNQYWdlQ2FjaGVTdGF0cygpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhZ2VDYWNoZU1pc3NlcyA+IDAgfHwgdGhpcy5wYWdlQ2FjaGVIaXRzID4gMCB8fCB0aGlzLnBhZ2VDYWNoZUhpdFJhdGlvID4gMDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFByb2ZpbGVkUGxhbjtcbn0oKTtcbi8qKlxuICogR2V0IHN0YXRpc3RpY2FsIGluZm9ybWF0aW9uIGZvciBhIHtAbGluayBSZXN1bHR9LlxuICogQGFjY2VzcyBwdWJsaWNcbiAqL1xuXG5cbnZhciBRdWVyeVN0YXRpc3RpY3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogU3RydWN0dXJpemUgdGhlIHN0YXRpc3RpY3NcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0aXN0aWNzIC0gUmVzdWx0IHN0YXRpc3RpY3NcbiAgICovXG4gIGZ1bmN0aW9uIFF1ZXJ5U3RhdGlzdGljcyhzdGF0aXN0aWNzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUXVlcnlTdGF0aXN0aWNzKTtcbiAgICB0aGlzLl9zdGF0cyA9IHtcbiAgICAgIG5vZGVzQ3JlYXRlZDogMCxcbiAgICAgIG5vZGVzRGVsZXRlZDogMCxcbiAgICAgIHJlbGF0aW9uc2hpcHNDcmVhdGVkOiAwLFxuICAgICAgcmVsYXRpb25zaGlwc0RlbGV0ZWQ6IDAsXG4gICAgICBwcm9wZXJ0aWVzU2V0OiAwLFxuICAgICAgbGFiZWxzQWRkZWQ6IDAsXG4gICAgICBsYWJlbHNSZW1vdmVkOiAwLFxuICAgICAgaW5kZXhlc0FkZGVkOiAwLFxuICAgICAgaW5kZXhlc1JlbW92ZWQ6IDAsXG4gICAgICBjb25zdHJhaW50c0FkZGVkOiAwLFxuICAgICAgY29uc3RyYWludHNSZW1vdmVkOiAwXG4gICAgfTtcbiAgICB0aGlzLl9zeXN0ZW1VcGRhdGVzID0gMDtcbiAgICBPYmplY3Qua2V5cyhzdGF0aXN0aWNzKS5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgLy8gVG8gY2FtZWxDYXNlXG4gICAgICB2YXIgY2FtZWxDYXNlSW5kZXggPSBpbmRleC5yZXBsYWNlKC8oLVxcdykvZywgZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIG1bMV0udG9VcHBlckNhc2UoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY2FtZWxDYXNlSW5kZXggaW4gX3RoaXMuX3N0YXRzKSB7XG4gICAgICAgIF90aGlzLl9zdGF0c1tjYW1lbENhc2VJbmRleF0gPSBpbnRWYWx1ZShzdGF0aXN0aWNzW2luZGV4XSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbWVsQ2FzZUluZGV4ID09PSAnc3lzdGVtVXBkYXRlcycpIHtcbiAgICAgICAgX3RoaXMuX3N5c3RlbVVwZGF0ZXMgPSBpbnRWYWx1ZShzdGF0aXN0aWNzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fc3RhdHMgPSBPYmplY3QuZnJlZXplKHRoaXMuX3N0YXRzKTtcbiAgfVxuICAvKipcbiAgICogRGlkIHRoZSBkYXRhYmFzZSBnZXQgdXBkYXRlZD9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFF1ZXJ5U3RhdGlzdGljcywgW3tcbiAgICBrZXk6IFwiY29udGFpbnNVcGRhdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRhaW5zVXBkYXRlcygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc3RhdHMpLnJlZHVjZShmdW5jdGlvbiAobGFzdCwgY3VycmVudCkge1xuICAgICAgICByZXR1cm4gbGFzdCArIF90aGlzMi5fc3RhdHNbY3VycmVudF07XG4gICAgICB9LCAwKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHF1ZXJ5IHN0YXRpc3RpY3MgdXBkYXRlcyBpbiBhIGRpY3Rpb25hcnkuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBzeXN0ZW0gZGF0YWJhc2UgZ2V0IHVwZGF0ZWQsIG90aGVyd2lzZSBmYWxzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIElmIHRoZSBzeXN0ZW0gZGF0YWJhc2UgZ2V0IHVwZGF0ZWQgb3Igbm90LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGFpbnNTeXN0ZW1VcGRhdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRhaW5zU3lzdGVtVXBkYXRlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zeXN0ZW1VcGRhdGVzID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSBOdW1iZXIgb2Ygc3lzdGVtIHVwZGF0ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN5c3RlbVVwZGF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3lzdGVtVXBkYXRlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zeXN0ZW1VcGRhdGVzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUXVlcnlTdGF0aXN0aWNzO1xufSgpO1xuLyoqXG4gKiBDbGFzcyBmb3IgQ3lwaGVyIG5vdGlmaWNhdGlvbnNcbiAqIEBhY2Nlc3MgcHVibGljXG4gKi9cblxuXG52YXIgTm90aWZpY2F0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIE5vdGlmaWNhdGlvbiBpbnN0YW5jZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG5vdGlmaWNhdGlvbiAtIE9iamVjdCB3aXRoIG5vdGlmaWNhdGlvbiBkYXRhXG4gICAqL1xuICBmdW5jdGlvbiBOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBOb3RpZmljYXRpb24pO1xuICAgIHRoaXMuY29kZSA9IG5vdGlmaWNhdGlvbi5jb2RlO1xuICAgIHRoaXMudGl0bGUgPSBub3RpZmljYXRpb24udGl0bGU7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IG5vdGlmaWNhdGlvbi5kZXNjcmlwdGlvbjtcbiAgICB0aGlzLnNldmVyaXR5ID0gbm90aWZpY2F0aW9uLnNldmVyaXR5O1xuICAgIHRoaXMucG9zaXRpb24gPSBOb3RpZmljYXRpb24uX2NvbnN0cnVjdFBvc2l0aW9uKG5vdGlmaWNhdGlvbi5wb3NpdGlvbik7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKE5vdGlmaWNhdGlvbiwgbnVsbCwgW3tcbiAgICBrZXk6IFwiX2NvbnN0cnVjdFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb25zdHJ1Y3RQb3NpdGlvbihwb3MpIHtcbiAgICAgIGlmICghcG9zKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0OiBpbnRWYWx1ZShwb3Mub2Zmc2V0KSxcbiAgICAgICAgbGluZTogaW50VmFsdWUocG9zLmxpbmUpLFxuICAgICAgICBjb2x1bW46IGludFZhbHVlKHBvcy5jb2x1bW4pXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTm90aWZpY2F0aW9uO1xufSgpO1xuLyoqXG4gKiBDbGFzcyBmb3IgZXhwb3Npbmcgc2VydmVyIGluZm8gZnJvbSBhIHJlc3VsdC5cbiAqIEBhY2Nlc3MgcHVibGljXG4gKi9cblxuXG52YXIgU2VydmVySW5mbyA9XG4vKipcbiAqIENyZWF0ZSBhIFNlcnZlckluZm8gaW5zdGFuY2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IHNlcnZlck1ldGEgLSBPYmplY3Qgd2l0aCBzZXJ2ZXJNZXRhIGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm90b2NvbFZlcnNpb24gLSBCb2x0IHByb3RvY29sIHZlcnNpb25cbiAqL1xuZnVuY3Rpb24gU2VydmVySW5mbyhzZXJ2ZXJNZXRhLCBwcm90b2NvbFZlcnNpb24pIHtcbiAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBTZXJ2ZXJJbmZvKTtcblxuICBpZiAoc2VydmVyTWV0YSkge1xuICAgIHRoaXMuYWRkcmVzcyA9IHNlcnZlck1ldGEuYWRkcmVzcztcbiAgICB0aGlzLnZlcnNpb24gPSBzZXJ2ZXJNZXRhLnZlcnNpb247XG4gIH1cblxuICB0aGlzLnByb3RvY29sVmVyc2lvbiA9IHByb3RvY29sVmVyc2lvbjtcbn07XG5cbmZ1bmN0aW9uIGludFZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiAoMCwgX2ludGVnZXIuaXNJbnQpKHZhbHVlKSA/IHZhbHVlLnRvSW50KCkgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdmFsdWVPckRlZmF1bHQoa2V5LCB2YWx1ZXMpIHtcbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuICBpZiAoa2V5IGluIHZhbHVlcykge1xuICAgIHZhciB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgIHJldHVybiAoMCwgX2ludGVnZXIuaXNJbnQpKHZhbHVlKSA/IHZhbHVlLnRvSW50KCkgOiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9XG59XG4vKipcbiAqIFRoZSBjb25zdGFudHMgZm9yIHF1ZXJ5IHR5cGVzXG4gKiBAdHlwZSB7e1NDSEVNQV9XUklURTogc3RyaW5nLCBXUklURV9PTkxZOiBzdHJpbmcsIFJFQURfT05MWTogc3RyaW5nLCBSRUFEX1dSSVRFOiBzdHJpbmd9fVxuICovXG5cblxudmFyIHF1ZXJ5VHlwZSA9IHtcbiAgUkVBRF9PTkxZOiAncicsXG4gIFJFQURfV1JJVEU6ICdydycsXG4gIFdSSVRFX09OTFk6ICd3JyxcbiAgU0NIRU1BX1dSSVRFOiAncydcbn07XG5leHBvcnRzLnF1ZXJ5VHlwZSA9IHF1ZXJ5VHlwZTtcbnZhciBfZGVmYXVsdCA9IFJlc3VsdFN1bW1hcnk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Jlc3VsdFN1bW1hcnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Jlc3VsdC1zdW1tYXJ5XCIpKTtcblxudmFyIF9jb25uZWN0aW9uSG9sZGVyID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvY29ubmVjdGlvbi1ob2xkZXJcIik7XG5cbnZhciBfc3RyZWFtT2JzZXJ2ZXJzID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvc3RyZWFtLW9ic2VydmVyc1wiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgREVGQVVMVF9PTl9FUlJPUiA9IGZ1bmN0aW9uIERFRkFVTFRfT05fRVJST1IoZXJyb3IpIHtcbiAgY29uc29sZS5sb2coJ1VuY2F1Z2h0IGVycm9yIHdoZW4gcHJvY2Vzc2luZyByZXN1bHQ6ICcgKyBlcnJvcik7XG59O1xuXG52YXIgREVGQVVMVF9PTl9DT01QTEVURUQgPSBmdW5jdGlvbiBERUZBVUxUX09OX0NPTVBMRVRFRChzdW1tYXJ5KSB7fTtcblxudmFyIERFRkFVTFRfTUVUQURBVEFfU1VQUExJRVIgPSBmdW5jdGlvbiBERUZBVUxUX01FVEFEQVRBX1NVUFBMSUVSKG1ldGFkYXRhKSB7fTtcbi8qKlxuICogQSBzdHJlYW0gb2Yge0BsaW5rIFJlY29yZH0gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQgb2YgYSBxdWVyeS5cbiAqIENhbiBiZSBjb25zdW1lZCBlYWdlcmx5IGFzIHtAbGluayBQcm9taXNlfSByZXNvbHZlZCB3aXRoIGFycmF5IG9mIHJlY29yZHMgYW5kIHtAbGluayBSZXN1bHRTdW1tYXJ5fVxuICogc3VtbWFyeSwgb3IgcmVqZWN0ZWQgd2l0aCBlcnJvciB0aGF0IGNvbnRhaW5zIHtAbGluayBzdHJpbmd9IGNvZGUgYW5kIHtAbGluayBzdHJpbmd9IG1lc3NhZ2UuXG4gKiBBbHRlcm5hdGl2ZWx5IGNhbiBiZSBjb25zdW1lZCBsYXppbHkgdXNpbmcge0BsaW5rIFJlc3VsdCNzdWJzY3JpYmV9IGZ1bmN0aW9uLlxuICogQGFjY2VzcyBwdWJsaWNcbiAqL1xuXG5cbnZhciBSZXN1bHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogSW5qZWN0IHRoZSBvYnNlcnZlciB0byBiZSB1c2VkLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBwYXJhbSB7UHJvbWlzZTxSZXN1bHRTdHJlYW1PYnNlcnZlcj59IHN0cmVhbU9ic2VydmVyUHJvbWlzZVxuICAgKiBAcGFyYW0ge21peGVkfSBxdWVyeSAtIEN5cGhlciBxdWVyeSB0byBleGVjdXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gTWFwIHdpdGggcGFyYW1ldGVycyB0byB1c2UgaW4gcXVlcnlcbiAgICogQHBhcmFtIHtDb25uZWN0aW9uSG9sZGVyfSBjb25uZWN0aW9uSG9sZGVyIC0gdG8gYmUgbm90aWZpZWQgd2hlbiByZXN1bHQgaXMgZWl0aGVyIGZ1bGx5IGNvbnN1bWVkIG9yIGVycm9yIGhhcHBlbmVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUmVzdWx0KHN0cmVhbU9ic2VydmVyUHJvbWlzZSwgcXVlcnksIHBhcmFtZXRlcnMsIGNvbm5lY3Rpb25Ib2xkZXIpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFJlc3VsdCk7XG4gICAgdGhpcy5fc3RhY2sgPSBjYXB0dXJlU3RhY2t0cmFjZSgpO1xuICAgIHRoaXMuX3N0cmVhbU9ic2VydmVyUHJvbWlzZSA9IHN0cmVhbU9ic2VydmVyUHJvbWlzZTtcbiAgICB0aGlzLl9wID0gbnVsbDtcbiAgICB0aGlzLl9xdWVyeSA9IHF1ZXJ5O1xuICAgIHRoaXMuX3BhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25Ib2xkZXIgPSBjb25uZWN0aW9uSG9sZGVyIHx8IF9jb25uZWN0aW9uSG9sZGVyLkVNUFRZX0NPTk5FQ1RJT05fSE9MREVSO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGZpZWxkIGtleXMuXG4gICAqXG4gICAqICpTaG91bGQgbm90IGJlIGNvbWJpbmVkIHdpdGgge0BsaW5rIFJlc3VsdCNzdWJzY3JpYmV9IGZ1bmN0aW9uLipcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IC0gRmllbGQga2V5cywgaW4gdGhlIG9yZGVyIHRoZXkgd2lsbCBhcHBlYXIgaW4gcmVjb3Jkcy5cbiAgIH1cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFJlc3VsdCwgW3tcbiAgICBrZXk6IFwia2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXMuX3N0cmVhbU9ic2VydmVyUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgIHJldHVybiBvYnNlcnZlci5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgb25LZXlzOiBmdW5jdGlvbiBvbktleXMoa2V5cykge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShrZXlzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzdWx0IHN1bW1hcnkuXG4gICAgICpcbiAgICAgKiAqU2hvdWxkIG5vdCBiZSBjb21iaW5lZCB3aXRoIHtAbGluayBSZXN1bHQjc3Vic2NyaWJlfSBmdW5jdGlvbi4qXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0U3VtbWFyeT59IC0gUmVzdWx0IHN1bW1hcnkuXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN1bW1hcnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VtbWFyeSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfdGhpczIuX3N0cmVhbU9ic2VydmVyUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgby5jYW5jZWwoKTtcbiAgICAgICAgICBvLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gb25Db21wbGV0ZWQobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobWV0YWRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCByZXR1cm4gbmV3IFByb21pc2VcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gbmV3IFByb21pc2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0T3JDcmVhdGVQcm9taXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRPckNyZWF0ZVByb21pc2UoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLl9wKSB7XG4gICAgICAgIHRoaXMuX3AgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlY29yZHMgPSBbXTtcbiAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgICBvbk5leHQ6IGZ1bmN0aW9uIG9uTmV4dChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Db21wbGV0ZWQ6IGZ1bmN0aW9uIG9uQ29tcGxldGVkKHN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgcmVjb3JkczogcmVjb3JkcyxcbiAgICAgICAgICAgICAgICBzdW1tYXJ5OiBzdW1tYXJ5XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMzLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgZm9yIGFsbCByZXN1bHRzIGFuZCBjYWxscyB0aGUgcGFzc2VkIGluIGZ1bmN0aW9uIHdpdGggdGhlIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiAqU2hvdWxkIG5vdCBiZSBjb21iaW5lZCB3aXRoIHtAbGluayBSZXN1bHQjc3Vic2NyaWJlfSBmdW5jdGlvbi4qXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHJlc3VsdDoge3JlY29yZHM6QXJyYXk8UmVjb3JkPiwgc3VtbWFyeTogUmVzdWx0U3VtbWFyeX0pfSBvbkZ1bGZpbGxlZCAtIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgICAqIHdoZW4gZmluaXNoZWQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnJvcjoge21lc3NhZ2U6c3RyaW5nLCBjb2RlOnN0cmluZ30pfSBvblJlamVjdGVkIC0gZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHVwb24gZXJyb3JzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0aGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZVByb21pc2UoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2F0Y2ggZXJyb3JzIHdoZW4gdXNpbmcgcHJvbWlzZXMuXG4gICAgICpcbiAgICAgKiAqU2hvdWxkIG5vdCBiZSBjb21iaW5lZCB3aXRoIHtAbGluayBSZXN1bHQjc3Vic2NyaWJlfSBmdW5jdGlvbi4qXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycm9yOiBOZW80akVycm9yKX0gb25SZWplY3RlZCAtIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB1cG9uIGVycm9ycy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2F0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZVByb21pc2UoKVtcImNhdGNoXCJdKG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gcmVjb3JkcyB0byBvYnNlcnZlciBhcyB0aGV5IGNvbWUgaW4sIHRoaXMgaXMgYSBtb3JlIGVmZmljaWVudCBtZXRob2RcbiAgICAgKiBvZiBoYW5kbGluZyB0aGUgcmVzdWx0cywgYW5kIGFsbG93cyB5b3UgdG8gaGFuZGxlIGFyYml0cmFyaWx5IGxhcmdlIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgLSBPYnNlcnZlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGtleXM6IHN0cmluZ1tdKX0gb2JzZXJ2ZXIub25LZXlzIC0gaGFuZGxlIHN0cmVhbSBoZWFkLCB0aGUgZmllbGQga2V5cy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHJlY29yZDogUmVjb3JkKX0gb2JzZXJ2ZXIub25OZXh0IC0gaGFuZGxlIHJlY29yZHMsIG9uZSBieSBvbmUuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihzdW1tYXJ5OiBSZXN1bHRTdW1tYXJ5KX0gb2JzZXJ2ZXIub25Db21wbGV0ZWQgLSBoYW5kbGUgc3RyZWFtIHRhaWwsIHRoZSByZXN1bHQgc3VtbWFyeS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycm9yOiB7bWVzc2FnZTpzdHJpbmcsIGNvZGU6c3RyaW5nfSl9IG9ic2VydmVyLm9uRXJyb3IgLSBoYW5kbGUgZXJyb3JzLlxuICAgICAqIEByZXR1cm5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN1YnNjcmliZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgb25Db21wbGV0ZWRPcmlnaW5hbCA9IG9ic2VydmVyLm9uQ29tcGxldGVkIHx8IERFRkFVTFRfT05fQ09NUExFVEVEO1xuXG4gICAgICB2YXIgb25Db21wbGV0ZWRXcmFwcGVyID0gZnVuY3Rpb24gb25Db21wbGV0ZWRXcmFwcGVyKG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciBjb25uZWN0aW9uSG9sZGVyID0gX3RoaXM0Ll9jb25uZWN0aW9uSG9sZGVyO1xuICAgICAgICB2YXIgcXVlcnkgPSBfdGhpczQuX3F1ZXJ5O1xuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IF90aGlzNC5fcGFyYW1ldGVycztcblxuICAgICAgICBmdW5jdGlvbiByZWxlYXNlKHByb3RvY29sVmVyc2lvbikge1xuICAgICAgICAgIC8vIG5vdGlmeSBjb25uZWN0aW9uIGhvbGRlciB0aGF0IHRoZSB1c2VkIGNvbm5lY3Rpb24gaXMgbm90IG5lZWRlZCBhbnkgbW9yZSBiZWNhdXNlIHJlc3VsdCBoYXNcbiAgICAgICAgICAvLyBiZWVuIGZ1bGx5IGNvbnN1bWVkOyBjYWxsIHRoZSBvcmlnaW5hbCBvbkNvbXBsZXRlZCBjYWxsYmFjayBhZnRlciB0aGF0XG4gICAgICAgICAgY29ubmVjdGlvbkhvbGRlci5yZWxlYXNlQ29ubmVjdGlvbigpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb25Db21wbGV0ZWRPcmlnaW5hbC5jYWxsKG9ic2VydmVyLCBuZXcgX3Jlc3VsdFN1bW1hcnlbXCJkZWZhdWx0XCJdKHF1ZXJ5LCBwYXJhbWV0ZXJzLCBtZXRhZGF0YSwgcHJvdG9jb2xWZXJzaW9uKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25uZWN0aW9uSG9sZGVyLmdldENvbm5lY3Rpb24oKS50aGVuKCAvLyBvbkZ1bGZpbGxlZDpcbiAgICAgICAgZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICByZWxlYXNlKGNvbm5lY3Rpb24gPyBjb25uZWN0aW9uLnByb3RvY29sKCkudmVyc2lvbiA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH0sIC8vIG9uUmVqZWN0ZWQ6XG4gICAgICAgIGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIG9ic2VydmVyLm9uQ29tcGxldGVkID0gb25Db21wbGV0ZWRXcmFwcGVyO1xuICAgICAgdmFyIG9uRXJyb3JPcmlnaW5hbCA9IG9ic2VydmVyLm9uRXJyb3IgfHwgREVGQVVMVF9PTl9FUlJPUjtcblxuICAgICAgdmFyIG9uRXJyb3JXcmFwcGVyID0gZnVuY3Rpb24gb25FcnJvcldyYXBwZXIoZXJyb3IpIHtcbiAgICAgICAgLy8gbm90aWZ5IGNvbm5lY3Rpb24gaG9sZGVyIHRoYXQgdGhlIHVzZWQgY29ubmVjdGlvbiBpcyBub3QgbmVlZGVkIGFueSBtb3JlIGJlY2F1c2UgZXJyb3IgaGFwcGVuZWRcbiAgICAgICAgLy8gYW5kIHJlc3VsdCBjYW4ndCBiZWUgY29uc3VtZWQgYW55IGZ1cnRoZXI7IGNhbGwgdGhlIG9yaWdpbmFsIG9uRXJyb3IgY2FsbGJhY2sgYWZ0ZXIgdGhhdFxuICAgICAgICBfdGhpczQuX2Nvbm5lY3Rpb25Ib2xkZXIucmVsZWFzZUNvbm5lY3Rpb24oKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXBsYWNlU3RhY2t0cmFjZShlcnJvciwgX3RoaXM0Ll9zdGFjayk7XG4gICAgICAgICAgb25FcnJvck9yaWdpbmFsLmNhbGwob2JzZXJ2ZXIsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBvYnNlcnZlci5vbkVycm9yID0gb25FcnJvcldyYXBwZXI7XG5cbiAgICAgIHRoaXMuX3N0cmVhbU9ic2VydmVyUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbmFscyB0aGUgc3RyZWFtIG9ic2VydmVyIHRoYXQgdGhlIGZ1dHVyZSByZWNvcmRzIHNob3VsZCBiZSBkaXNjYXJkZWQgb24gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jYW5jZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbmNlbCgpIHtcbiAgICAgIHRoaXMuX3N0cmVhbU9ic2VydmVyUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvLmNhbmNlbCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSZXN1bHQ7XG59KCk7XG5cbmZ1bmN0aW9uIGNhcHR1cmVTdGFja3RyYWNlKCkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJycpO1xuXG4gIGlmIChlcnJvci5zdGFjaykge1xuICAgIHJldHVybiBlcnJvci5zdGFjay5yZXBsYWNlKC9eRXJyb3IoXFxuXFxyKSovLCAnJyk7IC8vIHdlIGRvbid0IG5lZWQgdGhlICdFcnJvclxcbicgcGFydCwgaWYgb25seSBpdCBleGlzdHNcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlU3RhY2t0cmFjZShlcnJvciwgbmV3U3RhY2spIHtcbiAgaWYgKG5ld1N0YWNrKSB7XG4gICAgLy8gRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nKCkgY29uY2F0ZW5hdGVzIGVycm9yLm5hbWUgYW5kIGVycm9yLm1lc3NhZ2UgbmljZWx5XG4gICAgLy8gdGhlbiB3ZSBhZGQgdGhlIHJlc3Qgb2YgdGhlIHN0YWNrIHRyYWNlXG4gICAgZXJyb3Iuc3RhY2sgPSBlcnJvci50b1N0cmluZygpICsgJ1xcbicgKyBuZXdTdGFjaztcbiAgfVxufVxuXG52YXIgX2RlZmF1bHQgPSBSZXN1bHQ7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9kcml2ZXIgPSByZXF1aXJlKFwiLi9kcml2ZXJcIik7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcblxudmFyIF9jb25uZWN0aW9uUHJvdmlkZXJSb3V0aW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC9jb25uZWN0aW9uLXByb3ZpZGVyLXJvdXRpbmdcIikpO1xuXG52YXIgX2xlYXN0Q29ubmVjdGVkTG9hZEJhbGFuY2luZ1N0cmF0ZWd5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC9sZWFzdC1jb25uZWN0ZWQtbG9hZC1iYWxhbmNpbmctc3RyYXRlZ3lcIikpO1xuXG52YXIgX2Nvbm5lY3Rpb25FcnJvckhhbmRsZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL2Nvbm5lY3Rpb24tZXJyb3ItaGFuZGxlclwiKSk7XG5cbnZhciBfY29uZmlndXJlZEN1c3RvbVJlc29sdmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC9yZXNvbHZlci9jb25maWd1cmVkLWN1c3RvbS1yZXNvbHZlclwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yW1wiZGVmYXVsdFwiXSkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQSBkcml2ZXIgdGhhdCBzdXBwb3J0cyByb3V0aW5nIGluIGEgY2F1c2FsIGNsdXN0ZXIuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgUm91dGluZ0RyaXZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0RyaXZlcikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKFJvdXRpbmdEcml2ZXIsIF9Ecml2ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUm91dGluZ0RyaXZlcik7XG5cbiAgZnVuY3Rpb24gUm91dGluZ0RyaXZlcihhZGRyZXNzLCByb3V0aW5nQ29udGV4dCwgdXNlckFnZW50KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHRva2VuID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICB2YXIgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFJvdXRpbmdEcml2ZXIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYWRkcmVzcywgdXNlckFnZW50LCB0b2tlbiwgdmFsaWRhdGVDb25maWcoY29uZmlnKSk7XG4gICAgX3RoaXMuX3JvdXRpbmdDb250ZXh0ID0gcm91dGluZ0NvbnRleHQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShSb3V0aW5nRHJpdmVyLCBbe1xuICAgIGtleTogXCJfYWZ0ZXJDb25zdHJ1Y3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FmdGVyQ29uc3RydWN0aW9uKCkge1xuICAgICAgdGhpcy5fbG9nLmluZm8oXCJSb3V0aW5nIGRyaXZlciBcIi5jb25jYXQodGhpcy5faWQsIFwiIGNyZWF0ZWQgZm9yIHNlcnZlciBhZGRyZXNzIFwiKS5jb25jYXQodGhpcy5fYWRkcmVzcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQ29ubmVjdGlvblByb3ZpZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVDb25uZWN0aW9uUHJvdmlkZXIoYWRkcmVzcywgdXNlckFnZW50LCBhdXRoVG9rZW4pIHtcbiAgICAgIHJldHVybiBuZXcgX2Nvbm5lY3Rpb25Qcm92aWRlclJvdXRpbmdbXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICByb3V0aW5nQ29udGV4dDogdGhpcy5fcm91dGluZ0NvbnRleHQsXG4gICAgICAgIGhvc3ROYW1lUmVzb2x2ZXI6IGNyZWF0ZUhvc3ROYW1lUmVzb2x2ZXIodGhpcy5fY29uZmlnKSxcbiAgICAgICAgY29uZmlnOiB0aGlzLl9jb25maWcsXG4gICAgICAgIGxvZzogdGhpcy5fbG9nLFxuICAgICAgICB1c2VyQWdlbnQ6IHVzZXJBZ2VudCxcbiAgICAgICAgYXV0aFRva2VuOiBhdXRoVG9rZW5cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc3VwcG9ydHNSb3V0aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdXBwb3J0c1JvdXRpbmcoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJvdXRpbmdEcml2ZXI7XG59KF9kcml2ZXIuRHJpdmVyKTtcbi8qKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm5zIHtDb25maWd1cmVkQ3VzdG9tUmVzb2x2ZXJ9IG5ldyBjdXN0b20gcmVzb2x2ZXIgdGhhdCB3cmFwcyB0aGUgcGFzc2VkLWluIHJlc29sdmVyIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgIElmIHJlc29sdmVkIGZ1bmN0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGl0IGRlZmF1bHRzIHRvIGFuIGlkZW50aXR5IHJlc29sdmVyLlxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlSG9zdE5hbWVSZXNvbHZlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBfY29uZmlndXJlZEN1c3RvbVJlc29sdmVyW1wiZGVmYXVsdFwiXShjb25maWcucmVzb2x2ZXIpO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge09iamVjdH0gdGhlIGdpdmVuIGNvbmZpZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29uZmlnKGNvbmZpZykge1xuICB2YXIgcmVzb2x2ZXIgPSBjb25maWcucmVzb2x2ZXI7XG5cbiAgaWYgKHJlc29sdmVyICYmIHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb25maWd1cmVkIHJlc29sdmVyIHNob3VsZCBiZSBhIGZ1bmN0aW9uLiBHb3Q6IFwiLmNvbmNhdChyZXNvbHZlcikpO1xuICB9XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cblxudmFyIF9kZWZhdWx0ID0gUm91dGluZ0RyaXZlcjtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcnhqcyA9IHJlcXVpcmUoXCJyeGpzXCIpO1xuXG52YXIgX29wZXJhdG9ycyA9IHJlcXVpcmUoXCJyeGpzL29wZXJhdG9yc1wiKTtcblxudmFyIF9yZXN1bHRSeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVzdWx0LXJ4XCIpKTtcblxudmFyIF9zZXNzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zZXNzaW9uXCIpKTtcblxudmFyIF90cmFuc2FjdGlvblJ4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi1yeFwiKSk7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvY29uc3RhbnRzXCIpO1xuXG52YXIgX3R4Q29uZmlnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC90eC1jb25maWdcIikpO1xuXG52YXIgX3JldHJ5TG9naWNSeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW50ZXJuYWwvcmV0cnktbG9naWMtcnhcIikpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBBIFJlYWN0aXZlIHNlc3Npb24sIHdoaWNoIHByb3ZpZGVzIHRoZSBzYW1lIGZ1bmN0aW9uYWxpdHkgYXMge0BsaW5rIFNlc3Npb259IGJ1dCB0aHJvdWdoIGEgUmVhY3RpdmUgQVBJLlxuICovXG52YXIgUnhTZXNzaW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSByZWFjdGl2ZSBzZXNzaW9uIHdpdGggZ2l2ZW4gZGVmYXVsdCBzZXNzaW9uIGluc3RhbmNlIGFuZCBwcm92aWRlZCBkcml2ZXIgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gLSBPYmplY3QgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSB7U2Vzc2lvbn0gcGFyYW0uc2Vzc2lvbiAtIFRoZSB1bmRlcmx5aW5nIHNlc3Npb24gaW5zdGFuY2UgdG8gcmVsYXkgcmVxdWVzdHNcbiAgICovXG4gIGZ1bmN0aW9uIFJ4U2Vzc2lvbigpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIHNlc3Npb24gPSBfcmVmLnNlc3Npb24sXG4gICAgICAgIGNvbmZpZyA9IF9yZWYuY29uZmlnO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBSeFNlc3Npb24pO1xuICAgIHRoaXMuX3Nlc3Npb24gPSBzZXNzaW9uO1xuICAgIHRoaXMuX3JldHJ5TG9naWMgPSBfY3JlYXRlUmV0cnlMb2dpYyhjb25maWcpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVhY3RpdmUgcmVzdWx0IHRoYXQgd2lsbCBleGVjdXRlIHRoZSAgcXVlcnkgd2l0aCB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycyBhbmQgdGhlIHByb3ZpZGVkXG4gICAqIHRyYW5zYWN0aW9uIGNvbmZpZ3VyYXRpb24gdGhhdCBhcHBsaWVzIHRvIHRoZSB1bmRlcmx5aW5nIGF1dG8tY29tbWl0IHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIFF1ZXJ5IHRvIGJlIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyAtIFBhcmFtZXRlciB2YWx1ZXMgdG8gdXNlIGluIHF1ZXJ5IGV4ZWN1dGlvbi5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpZ30gdHJhbnNhY3Rpb25Db25maWcgLSBDb25maWd1cmF0aW9uIGZvciB0aGUgbmV3IGF1dG8tY29tbWl0IHRyYW5zYWN0aW9uLlxuICAgKiBAcmV0dXJucyB7UnhSZXN1bHR9IC0gQSByZWFjdGl2ZSByZXN1bHRcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFJ4U2Vzc2lvbiwgW3tcbiAgICBrZXk6IFwicnVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bihxdWVyeSwgcGFyYW1ldGVycywgdHJhbnNhY3Rpb25Db25maWcpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgX3Jlc3VsdFJ4W1wiZGVmYXVsdFwiXShuZXcgX3J4anMuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvYnNlcnZlci5uZXh0KF90aGlzLl9zZXNzaW9uLnJ1bihxdWVyeSwgcGFyYW1ldGVycywgdHJhbnNhY3Rpb25Db25maWcpKTtcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgZXhwbGljaXQgdHJhbnNhY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgdHJhbnNhY3Rpb24gY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlnfSB0cmFuc2FjdGlvbkNvbmZpZyAtIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBuZXcgdHJhbnNhY3Rpb24uXG4gICAgICogQHJldHVybnMge09ic2VydmFibGU8UnhUcmFuc2FjdGlvbj59IC0gQSByZWFjdGl2ZSBzdHJlYW0gdGhhdCB3aWxsIGdlbmVyYXRlIGF0IG1vc3QgKipvbmUqKiBSeFRyYW5zYWN0aW9uIGluc3RhbmNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYmVnaW5UcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWdpblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uQ29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYmVnaW5UcmFuc2FjdGlvbih0aGlzLl9zZXNzaW9uLl9tb2RlLCB0cmFuc2FjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBwcm92aWRlZCB1bml0IG9mIHdvcmsgaW4gYSB7QGxpbmsgUkVBRH0gcmVhY3RpdmUgdHJhbnNhY3Rpb24gd2hpY2ggaXMgY3JlYXRlZCB3aXRoIHRoZSBwcm92aWRlZFxuICAgICAqIHRyYW5zYWN0aW9uIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24odHhjOiBSeFRyYW5zYWN0aW9uKTogT2JzZXJ2YWJsZX0gd29yayAtIEEgdW5pdCBvZiB3b3JrIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maWd9IHRyYW5zYWN0aW9uQ29uZmlnIC0gQ29uZmlndXJhdGlvbiBmb3IgdGhlIGVuY2xvc2luZyB0cmFuc2FjdGlvbiBjcmVhdGVkIGJ5IHRoZSBkcml2ZXIuXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IC0gQSByZWFjdGl2ZSBzdHJlYW0gcmV0dXJuZWQgYnkgdGhlIHVuaXQgb2Ygd29yay5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRUcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkVHJhbnNhY3Rpb24od29yaywgdHJhbnNhY3Rpb25Db25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UcmFuc2FjdGlvbihfY29uc3RhbnRzLkFDQ0VTU19NT0RFX1JFQUQsIHdvcmssIHRyYW5zYWN0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIHVuaXQgb2Ygd29yayBpbiBhIHtAbGluayBXUklURX0gcmVhY3RpdmUgdHJhbnNhY3Rpb24gd2hpY2ggaXMgY3JlYXRlZCB3aXRoIHRoZSBwcm92aWRlZFxuICAgICAqIHRyYW5zYWN0aW9uIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24odHhjOiBSeFRyYW5zYWN0aW9uKTogT2JzZXJ2YWJsZX0gd29yayAtIEEgdW5pdCBvZiB3b3JrIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maWd9IHRyYW5zYWN0aW9uQ29uZmlnIC0gQ29uZmlndXJhdGlvbiBmb3IgdGhlIGVuY2xvc2luZyB0cmFuc2FjdGlvbiBjcmVhdGVkIGJ5IHRoZSBkcml2ZXIuXG4gICAgICogQHJldHVybnMge09ic2VydmFibGV9IC0gQSByZWFjdGl2ZSBzdHJlYW0gcmV0dXJuZWQgYnkgdGhlIHVuaXQgb2Ygd29yay5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlVHJhbnNhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVUcmFuc2FjdGlvbih3b3JrLCB0cmFuc2FjdGlvbkNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRyYW5zYWN0aW9uKF9jb25zdGFudHMuQUNDRVNTX01PREVfV1JJVEUsIHdvcmssIHRyYW5zYWN0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoaXMgcmVhY3RpdmUgc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZX0gLSBBbiBlbXB0eSByZWFjdGl2ZSBzdHJlYW1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgX3J4anMuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgX3RoaXMyLl9zZXNzaW9uLmNsb3NlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJvb2ttYXJrIHJlY2VpdmVkIGZvbGxvd2luZyB0aGUgbGFzdCBzdWNjZXNzZnVsbHkgY29tcGxldGVkIHF1ZXJ5LCB3aGljaCBpcyBleGVjdXRlZFxuICAgICAqIGVpdGhlciBpbiBhbiB7QGxpbmsgUnhUcmFuc2FjdGlvbn0gb2J0YWluZWQgZnJvbSB0aGlzIHNlc3Npb24gaW5zdGFuY2Ugb3IgZGlyZWN0bHkgdGhyb3VnaCBvbmUgb2ZcbiAgICAgKiB0aGUge0BsaW5rIFJ4U2Vzc2lvbiNydW59IG1ldGhvZCBvZiB0aGlzIHNlc3Npb24gaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBJZiBubyBib29rbWFyayB3YXMgcmVjZWl2ZWQgb3IgaWYgdGhpcyB0cmFuc2FjdGlvbiB3YXMgcm9sbGVkIGJhY2ssIHRoZSBib29rbWFyayB2YWx1ZSB3aWxsIG5vdCBiZVxuICAgICAqIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxhc3RCb29rbWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0Qm9va21hcmsoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbi5sYXN0Qm9va21hcmsoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9iZWdpblRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iZWdpblRyYW5zYWN0aW9uKGFjY2Vzc01vZGUsIHRyYW5zYWN0aW9uQ29uZmlnKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHR4Q29uZmlnID0gX3R4Q29uZmlnW1wiZGVmYXVsdFwiXS5lbXB0eSgpO1xuXG4gICAgICBpZiAodHJhbnNhY3Rpb25Db25maWcpIHtcbiAgICAgICAgdHhDb25maWcgPSBuZXcgX3R4Q29uZmlnW1wiZGVmYXVsdFwiXSh0cmFuc2FjdGlvbkNvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgX3J4anMuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvYnNlcnZlci5uZXh0KG5ldyBfdHJhbnNhY3Rpb25SeFtcImRlZmF1bHRcIl0oX3RoaXMzLl9zZXNzaW9uLl9iZWdpblRyYW5zYWN0aW9uKGFjY2Vzc01vZGUsIHR4Q29uZmlnKSkpO1xuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ydW5UcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcnVuVHJhbnNhY3Rpb24oYWNjZXNzTW9kZSwgd29yaywgdHJhbnNhY3Rpb25Db25maWcpIHtcbiAgICAgIHZhciB0eENvbmZpZyA9IF90eENvbmZpZ1tcImRlZmF1bHRcIl0uZW1wdHkoKTtcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uQ29uZmlnKSB7XG4gICAgICAgIHR4Q29uZmlnID0gbmV3IF90eENvbmZpZ1tcImRlZmF1bHRcIl0odHJhbnNhY3Rpb25Db25maWcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcmV0cnlMb2dpYy5yZXRyeSh0aGlzLl9iZWdpblRyYW5zYWN0aW9uKGFjY2Vzc01vZGUsIHRyYW5zYWN0aW9uQ29uZmlnKS5waXBlKCgwLCBfb3BlcmF0b3JzLmZsYXRNYXApKGZ1bmN0aW9uICh0eGMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfcnhqcy5kZWZlcikoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gd29yayh0eGMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcnhqcy50aHJvd0Vycm9yKShlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkucGlwZSgoMCwgX29wZXJhdG9ycy5jYXRjaEVycm9yKShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHR4Yy5yb2xsYmFjaygpLnBpcGUoKDAsIF9vcGVyYXRvcnMuY29uY2F0KSgoMCwgX3J4anMudGhyb3dFcnJvcikoZXJyKSkpO1xuICAgICAgICB9KSwgKDAsIF9vcGVyYXRvcnMuY29uY2F0KSh0eGMuY29tbWl0KCkpKTtcbiAgICAgIH0pKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSeFNlc3Npb247XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUnhTZXNzaW9uO1xuXG5mdW5jdGlvbiBfY3JlYXRlUmV0cnlMb2dpYyhjb25maWcpIHtcbiAgdmFyIG1heFJldHJ5VGltZW91dCA9IGNvbmZpZyAmJiBjb25maWcubWF4VHJhbnNhY3Rpb25SZXRyeVRpbWUgPyBjb25maWcubWF4VHJhbnNhY3Rpb25SZXRyeVRpbWUgOiBudWxsO1xuICByZXR1cm4gbmV3IF9yZXRyeUxvZ2ljUnhbXCJkZWZhdWx0XCJdKHtcbiAgICBtYXhSZXRyeVRpbWVvdXQ6IG1heFJldHJ5VGltZW91dFxuICB9KTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfc3RyZWFtT2JzZXJ2ZXJzID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvc3RyZWFtLW9ic2VydmVyc1wiKTtcblxudmFyIF9yZXN1bHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Jlc3VsdFwiKSk7XG5cbnZhciBfdHJhbnNhY3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpKTtcblxudmFyIF9lcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC91dGlsXCIpO1xuXG52YXIgX2Nvbm5lY3Rpb25Ib2xkZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL2Nvbm5lY3Rpb24taG9sZGVyXCIpKTtcblxudmFyIF9kcml2ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2RyaXZlclwiKSk7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvY29uc3RhbnRzXCIpO1xuXG52YXIgX3RyYW5zYWN0aW9uRXhlY3V0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL3RyYW5zYWN0aW9uLWV4ZWN1dG9yXCIpKTtcblxudmFyIF9ib29rbWFyayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW50ZXJuYWwvYm9va21hcmtcIikpO1xuXG52YXIgX3R4Q29uZmlnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC90eC1jb25maWdcIikpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAwMi0yMDIwIFwiTmVvNGosXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cDovL25lbzRqLmNvbV1cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBOZW80ai5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBBIFNlc3Npb24gaW5zdGFuY2UgaXMgdXNlZCBmb3IgaGFuZGxpbmcgdGhlIGNvbm5lY3Rpb24gYW5kXG4gKiBzZW5kaW5nIHF1ZXJpZXMgdGhyb3VnaCB0aGUgY29ubmVjdGlvbi5cbiAqIEluIGEgc2luZ2xlIHNlc3Npb24sIG11bHRpcGxlIHF1ZXJpZXMgd2lsbCBiZSBleGVjdXRlZCBzZXJpYWxseS5cbiAqIEluIG9yZGVyIHRvIGV4ZWN1dGUgcGFyYWxsZWwgcXVlcmllcywgbXVsdGlwbGUgc2Vzc2lvbnMgYXJlIHJlcXVpcmVkLlxuICogQGFjY2VzcyBwdWJsaWNcbiAqL1xudmFyIFNlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MubW9kZSB0aGUgZGVmYXVsdCBhY2Nlc3MgbW9kZSBmb3IgdGhpcyBzZXNzaW9uLlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25Qcm92aWRlcn0gYXJncy5jb25uZWN0aW9uUHJvdmlkZXIgLSBUaGUgY29ubmVjdGlvbiBwcm92aWRlciB0byBhY3F1aXJlIGNvbm5lY3Rpb25zIGZyb20uXG4gICAqIEBwYXJhbSB7Qm9va21hcmt9IGFyZ3MuYm9va21hcmsgLSBUaGUgaW5pdGlhbCBib29rbWFyayBmb3IgdGhpcyBzZXNzaW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXJncy5kYXRhYmFzZSB0aGUgZGF0YWJhc2UgbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncy5jb25maWc9e30gLSBUaGlzIGRyaXZlciBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFyZ3MucmVhY3RpdmUgLSBXaGV0aGVyIHRoaXMgc2Vzc2lvbiBzaG91bGQgY3JlYXRlIHJlYWN0aXZlIHN0cmVhbXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuZmV0Y2hTaXplIC0gRGVmaW5lcyBob3cgbWFueSByZWNvcmRzIGlzIHB1bGxlZCBpbiBlYWNoIHB1bGxpbmcgYmF0Y2hcbiAgICovXG4gIGZ1bmN0aW9uIFNlc3Npb24oX3JlZikge1xuICAgIHZhciBtb2RlID0gX3JlZi5tb2RlLFxuICAgICAgICBjb25uZWN0aW9uUHJvdmlkZXIgPSBfcmVmLmNvbm5lY3Rpb25Qcm92aWRlcixcbiAgICAgICAgYm9va21hcmsgPSBfcmVmLmJvb2ttYXJrLFxuICAgICAgICBkYXRhYmFzZSA9IF9yZWYuZGF0YWJhc2UsXG4gICAgICAgIGNvbmZpZyA9IF9yZWYuY29uZmlnLFxuICAgICAgICByZWFjdGl2ZSA9IF9yZWYucmVhY3RpdmUsXG4gICAgICAgIGZldGNoU2l6ZSA9IF9yZWYuZmV0Y2hTaXplO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgU2Vzc2lvbik7XG4gICAgdGhpcy5fbW9kZSA9IG1vZGU7XG4gICAgdGhpcy5fZGF0YWJhc2UgPSBkYXRhYmFzZTtcbiAgICB0aGlzLl9yZWFjdGl2ZSA9IHJlYWN0aXZlO1xuICAgIHRoaXMuX2ZldGNoU2l6ZSA9IGZldGNoU2l6ZTtcbiAgICB0aGlzLl9yZWFkQ29ubmVjdGlvbkhvbGRlciA9IG5ldyBfY29ubmVjdGlvbkhvbGRlcltcImRlZmF1bHRcIl0oe1xuICAgICAgbW9kZTogX2NvbnN0YW50cy5BQ0NFU1NfTU9ERV9SRUFELFxuICAgICAgZGF0YWJhc2U6IGRhdGFiYXNlLFxuICAgICAgYm9va21hcms6IGJvb2ttYXJrLFxuICAgICAgY29ubmVjdGlvblByb3ZpZGVyOiBjb25uZWN0aW9uUHJvdmlkZXJcbiAgICB9KTtcbiAgICB0aGlzLl93cml0ZUNvbm5lY3Rpb25Ib2xkZXIgPSBuZXcgX2Nvbm5lY3Rpb25Ib2xkZXJbXCJkZWZhdWx0XCJdKHtcbiAgICAgIG1vZGU6IF9jb25zdGFudHMuQUNDRVNTX01PREVfV1JJVEUsXG4gICAgICBkYXRhYmFzZTogZGF0YWJhc2UsXG4gICAgICBib29rbWFyazogYm9va21hcmssXG4gICAgICBjb25uZWN0aW9uUHJvdmlkZXI6IGNvbm5lY3Rpb25Qcm92aWRlclxuICAgIH0pO1xuICAgIHRoaXMuX29wZW4gPSB0cnVlO1xuICAgIHRoaXMuX2hhc1R4ID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdEJvb2ttYXJrID0gYm9va21hcms7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb25FeGVjdXRvciA9IF9jcmVhdGVUcmFuc2FjdGlvbkV4ZWN1dG9yKGNvbmZpZyk7XG4gICAgdGhpcy5fb25Db21wbGV0ZSA9IHRoaXMuX29uQ29tcGxldGVDYWxsYmFjay5iaW5kKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBSdW4gQ3lwaGVyIHF1ZXJ5XG4gICAqIENvdWxkIGJlIGNhbGxlZCB3aXRoIGEgcXVlcnkgb2JqZWN0IGkuZS46IGB7dGV4dDogXCJNQVRDSCAuLi5cIiwgcHJhbWV0ZXJzOiB7cGFyYW06IDF9fWBcbiAgICogb3Igd2l0aCB0aGUgcXVlcnkgYW5kIHBhcmFtZXRlcnMgYXMgc2VwYXJhdGUgYXJndW1lbnRzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7bWl4ZWR9IHF1ZXJ5IC0gQ3lwaGVyIHF1ZXJ5IHRvIGV4ZWN1dGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBNYXAgd2l0aCBwYXJhbWV0ZXJzIHRvIHVzZSBpbiBxdWVyeVxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlnfSBbdHJhbnNhY3Rpb25Db25maWddIC0gQ29uZmlndXJhdGlvbiBmb3IgdGhlIG5ldyBhdXRvLWNvbW1pdCB0cmFuc2FjdGlvbi5cbiAgICogQHJldHVybiB7UmVzdWx0fSBOZXcgUmVzdWx0LlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoU2Vzc2lvbiwgW3tcbiAgICBrZXk6IFwicnVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bihxdWVyeSwgcGFyYW1ldGVycywgdHJhbnNhY3Rpb25Db25maWcpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBfdmFsaWRhdGVRdWVyeUFuZFBhcmEgPSAoMCwgX3V0aWwudmFsaWRhdGVRdWVyeUFuZFBhcmFtZXRlcnMpKHF1ZXJ5LCBwYXJhbWV0ZXJzKSxcbiAgICAgICAgICB2YWxpZGF0ZWRRdWVyeSA9IF92YWxpZGF0ZVF1ZXJ5QW5kUGFyYS52YWxpZGF0ZWRRdWVyeSxcbiAgICAgICAgICBwYXJhbXMgPSBfdmFsaWRhdGVRdWVyeUFuZFBhcmEucGFyYW1zO1xuXG4gICAgICB2YXIgYXV0b0NvbW1pdFR4Q29uZmlnID0gdHJhbnNhY3Rpb25Db25maWcgPyBuZXcgX3R4Q29uZmlnW1wiZGVmYXVsdFwiXSh0cmFuc2FjdGlvbkNvbmZpZykgOiBfdHhDb25maWdbXCJkZWZhdWx0XCJdLmVtcHR5KCk7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuKHZhbGlkYXRlZFF1ZXJ5LCBwYXJhbXMsIGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgIF90aGlzLl9hc3NlcnRTZXNzaW9uSXNPcGVuKCk7XG5cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24ucHJvdG9jb2woKS5ydW4odmFsaWRhdGVkUXVlcnksIHBhcmFtcywge1xuICAgICAgICAgIGJvb2ttYXJrOiBfdGhpcy5fbGFzdEJvb2ttYXJrLFxuICAgICAgICAgIHR4Q29uZmlnOiBhdXRvQ29tbWl0VHhDb25maWcsXG4gICAgICAgICAgbW9kZTogX3RoaXMuX21vZGUsXG4gICAgICAgICAgZGF0YWJhc2U6IF90aGlzLl9kYXRhYmFzZSxcbiAgICAgICAgICBhZnRlckNvbXBsZXRlOiBfdGhpcy5fb25Db21wbGV0ZSxcbiAgICAgICAgICByZWFjdGl2ZTogX3RoaXMuX3JlYWN0aXZlLFxuICAgICAgICAgIGZldGNoU2l6ZTogX3RoaXMuX2ZldGNoU2l6ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcnVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ydW4ocXVlcnksIHBhcmFtZXRlcnMsIGN1c3RvbVJ1bm5lcikge1xuICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSB0aGlzLl9jb25uZWN0aW9uSG9sZGVyV2l0aE1vZGUodGhpcy5fbW9kZSk7XG5cbiAgICAgIHZhciBvYnNlcnZlclByb21pc2U7XG5cbiAgICAgIGlmICghdGhpcy5fb3Blbikge1xuICAgICAgICBvYnNlcnZlclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobmV3IF9zdHJlYW1PYnNlcnZlcnMuRmFpbGVkT2JzZXJ2ZXIoe1xuICAgICAgICAgIGVycm9yOiAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnQ2Fubm90IHJ1biBxdWVyeSBpbiBhIGNsb3NlZCBzZXNzaW9uLicpXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2hhc1R4ICYmIGNvbm5lY3Rpb25Ib2xkZXIuaW5pdGlhbGl6ZUNvbm5lY3Rpb24oKSkge1xuICAgICAgICBvYnNlcnZlclByb21pc2UgPSBjb25uZWN0aW9uSG9sZGVyLmdldENvbm5lY3Rpb24oKS50aGVuKGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGN1c3RvbVJ1bm5lcihjb25uZWN0aW9uKTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBfc3RyZWFtT2JzZXJ2ZXJzLkZhaWxlZE9ic2VydmVyKHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYnNlcnZlclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobmV3IF9zdHJlYW1PYnNlcnZlcnMuRmFpbGVkT2JzZXJ2ZXIoe1xuICAgICAgICAgIGVycm9yOiAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnUXVlcmllcyBjYW5ub3QgYmUgcnVuIGRpcmVjdGx5IG9uIGEgJyArICdzZXNzaW9uIHdpdGggYW4gb3BlbiB0cmFuc2FjdGlvbjsgZWl0aGVyIHJ1biBmcm9tIHdpdGhpbiB0aGUgJyArICd0cmFuc2FjdGlvbiBvciB1c2UgYSBkaWZmZXJlbnQgc2Vzc2lvbi4nKVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgX3Jlc3VsdFtcImRlZmF1bHRcIl0ob2JzZXJ2ZXJQcm9taXNlLCBxdWVyeSwgcGFyYW1ldGVycywgY29ubmVjdGlvbkhvbGRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJlZ2luIGEgbmV3IHRyYW5zYWN0aW9uIGluIHRoaXMgc2Vzc2lvbi4gQSBzZXNzaW9uIGNhbiBoYXZlIGF0IG1vc3Qgb25lIHRyYW5zYWN0aW9uIHJ1bm5pbmcgYXQgYSB0aW1lLCBpZiB5b3VcbiAgICAgKiB3YW50IHRvIHJ1biBtdWx0aXBsZSBjb25jdXJyZW50IHRyYW5zYWN0aW9ucywgeW91IHNob3VsZCB1c2UgbXVsdGlwbGUgY29uY3VycmVudCBzZXNzaW9ucy5cbiAgICAgKlxuICAgICAqIFdoaWxlIGEgdHJhbnNhY3Rpb24gaXMgb3BlbiB0aGUgc2Vzc2lvbiBjYW5ub3QgYmUgdXNlZCB0byBydW4gcXVlcmllcyBvdXRzaWRlIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maWd9IFt0cmFuc2FjdGlvbkNvbmZpZ10gLSBDb25maWd1cmF0aW9uIGZvciB0aGUgbmV3IGF1dG8tY29tbWl0IHRyYW5zYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn0gTmV3IFRyYW5zYWN0aW9uLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYmVnaW5UcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWdpblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uQ29uZmlnKSB7XG4gICAgICAvLyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIHN1cHBvcnQgYm9va21hcmtzIHBhcmFtZXRlciBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgIC8vIHBhcmFtZXRlciB3YXMgb2YgdHlwZSB7c3RyaW5nfHN0cmluZ1tdfSBhbmQgcmVwcmVzZW50ZWQgZWl0aGVyIGEgc2luZ2xlIG9yIG11bHRpcGxlIGJvb2ttYXJrc1xuICAgICAgLy8gdGhhdCdzIHdoeSB3ZSBuZWVkIHRvIGNoZWNrIHBhcmFtZXRlciB0eXBlIGFuZCBkZWNpZGUgaG93IHRvIGludGVycHJldCB0aGUgdmFsdWVcbiAgICAgIHZhciBhcmcgPSB0cmFuc2FjdGlvbkNvbmZpZztcblxuICAgICAgdmFyIHR4Q29uZmlnID0gX3R4Q29uZmlnW1wiZGVmYXVsdFwiXS5lbXB0eSgpO1xuXG4gICAgICBpZiAoYXJnKSB7XG4gICAgICAgIHR4Q29uZmlnID0gbmV3IF90eENvbmZpZ1tcImRlZmF1bHRcIl0oYXJnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2JlZ2luVHJhbnNhY3Rpb24odGhpcy5fbW9kZSwgdHhDb25maWcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYmVnaW5UcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmVnaW5UcmFuc2FjdGlvbihhY2Nlc3NNb2RlLCB0eENvbmZpZykge1xuICAgICAgaWYgKCF0aGlzLl9vcGVuKSB7XG4gICAgICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdDYW5ub3QgYmVnaW4gYSB0cmFuc2FjdGlvbiBvbiBhIGNsb3NlZCBzZXNzaW9uLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faGFzVHgpIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ1lvdSBjYW5ub3QgYmVnaW4gYSB0cmFuc2FjdGlvbiBvbiBhIHNlc3Npb24gd2l0aCBhbiBvcGVuIHRyYW5zYWN0aW9uOyAnICsgJ2VpdGhlciBydW4gZnJvbSB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIG9yIHVzZSBhIGRpZmZlcmVudCBzZXNzaW9uLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbW9kZSA9IF9kcml2ZXJbXCJkZWZhdWx0XCJdLl92YWxpZGF0ZVNlc3Npb25Nb2RlKGFjY2Vzc01vZGUpO1xuXG4gICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IHRoaXMuX2Nvbm5lY3Rpb25Ib2xkZXJXaXRoTW9kZShtb2RlKTtcblxuICAgICAgY29ubmVjdGlvbkhvbGRlci5pbml0aWFsaXplQ29ubmVjdGlvbigpO1xuICAgICAgdGhpcy5faGFzVHggPSB0cnVlO1xuICAgICAgdmFyIHR4ID0gbmV3IF90cmFuc2FjdGlvbltcImRlZmF1bHRcIl0oe1xuICAgICAgICBjb25uZWN0aW9uSG9sZGVyOiBjb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICBvbkNsb3NlOiB0aGlzLl90cmFuc2FjdGlvbkNsb3NlZC5iaW5kKHRoaXMpLFxuICAgICAgICBvbkJvb2ttYXJrOiB0aGlzLl91cGRhdGVCb29rbWFyay5iaW5kKHRoaXMpLFxuICAgICAgICBvbkNvbm5lY3Rpb246IHRoaXMuX2Fzc2VydFNlc3Npb25Jc09wZW4uYmluZCh0aGlzKSxcbiAgICAgICAgcmVhY3RpdmU6IHRoaXMuX3JlYWN0aXZlLFxuICAgICAgICBmZXRjaFNpemU6IHRoaXMuX2ZldGNoU2l6ZVxuICAgICAgfSk7XG5cbiAgICAgIHR4Ll9iZWdpbih0aGlzLl9sYXN0Qm9va21hcmssIHR4Q29uZmlnKTtcblxuICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYXNzZXJ0U2Vzc2lvbklzT3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXNzZXJ0U2Vzc2lvbklzT3BlbigpIHtcbiAgICAgIGlmICghdGhpcy5fb3Blbikge1xuICAgICAgICB0aHJvdyAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnWW91IGNhbm5vdCBydW4gbW9yZSB0cmFuc2FjdGlvbnMgb24gYSBjbG9zZWQgc2Vzc2lvbi4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyYW5zYWN0aW9uQ2xvc2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2FjdGlvbkNsb3NlZCgpIHtcbiAgICAgIHRoaXMuX2hhc1R4ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYm9va21hcmsgcmVjZWl2ZWQgZm9sbG93aW5nIHRoZSBsYXN0IGNvbXBsZXRlZCB7QGxpbmsgVHJhbnNhY3Rpb259LlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nW119IEEgcmVmZXJlbmNlIHRvIGEgcHJldmlvdXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsYXN0Qm9va21hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGFzdEJvb2ttYXJrKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xhc3RCb29rbWFyay52YWx1ZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBnaXZlbiB1bml0IG9mIHdvcmsgaW4gYSB7QGxpbmsgUkVBRH0gdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBUcmFuc2FjdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgY29tbWl0dGVkIHVubGVzcyB0aGUgZ2l2ZW4gZnVuY3Rpb24gdGhyb3dzIG9yIHJldHVybnMgYSByZWplY3RlZCBwcm9taXNlLlxuICAgICAqIFNvbWUgZmFpbHVyZXMgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uIG9yIHRoZSBjb21taXQgaXRzZWxmIHdpbGwgYmUgcmV0cmllZCB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmYgd2l0aCBpbml0aWFsXG4gICAgICogZGVsYXkgb2YgMSBzZWNvbmQgYW5kIG1heGltdW0gcmV0cnkgdGltZSBvZiAzMCBzZWNvbmRzLiBNYXhpbXVtIHJldHJ5IHRpbWUgaXMgY29uZmlndXJhYmxlIHZpYSBkcml2ZXIgY29uZmlnJ3NcbiAgICAgKiBgbWF4VHJhbnNhY3Rpb25SZXRyeVRpbWVgIHByb3BlcnR5IGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24odHg6IFRyYW5zYWN0aW9uKTogUHJvbWlzZX0gdHJhbnNhY3Rpb25Xb3JrIC0gQ2FsbGJhY2sgdGhhdCBleGVjdXRlcyBvcGVyYXRpb25zIGFnYWluc3RcbiAgICAgKiBhIGdpdmVuIHtAbGluayBUcmFuc2FjdGlvbn0uXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpZ30gW3RyYW5zYWN0aW9uQ29uZmlnXSAtIENvbmZpZ3VyYXRpb24gZm9yIGFsbCB0cmFuc2FjdGlvbnMgc3RhcnRlZCB0byBleGVjdXRlIHRoZSB1bml0IG9mIHdvcmsuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgcHJvbWlzZSBhcyByZXR1cm5lZCBieSB0aGUgZ2l2ZW4gZnVuY3Rpb24gb3IgcmVqZWN0ZWQgcHJvbWlzZSB3aGVuIGdpdmVuXG4gICAgICogZnVuY3Rpb24gb3IgY29tbWl0IGZhaWxzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbldvcmssIHRyYW5zYWN0aW9uQ29uZmlnKSB7XG4gICAgICB2YXIgY29uZmlnID0gbmV3IF90eENvbmZpZ1tcImRlZmF1bHRcIl0odHJhbnNhY3Rpb25Db25maWcpO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRyYW5zYWN0aW9uKF9jb25zdGFudHMuQUNDRVNTX01PREVfUkVBRCwgY29uZmlnLCB0cmFuc2FjdGlvbldvcmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGdpdmVuIHVuaXQgb2Ygd29yayBpbiBhIHtAbGluayBXUklURX0gdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBUcmFuc2FjdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgY29tbWl0dGVkIHVubGVzcyB0aGUgZ2l2ZW4gZnVuY3Rpb24gdGhyb3dzIG9yIHJldHVybnMgYSByZWplY3RlZCBwcm9taXNlLlxuICAgICAqIFNvbWUgZmFpbHVyZXMgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uIG9yIHRoZSBjb21taXQgaXRzZWxmIHdpbGwgYmUgcmV0cmllZCB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmYgd2l0aCBpbml0aWFsXG4gICAgICogZGVsYXkgb2YgMSBzZWNvbmQgYW5kIG1heGltdW0gcmV0cnkgdGltZSBvZiAzMCBzZWNvbmRzLiBNYXhpbXVtIHJldHJ5IHRpbWUgaXMgY29uZmlndXJhYmxlIHZpYSBkcml2ZXIgY29uZmlnJ3NcbiAgICAgKiBgbWF4VHJhbnNhY3Rpb25SZXRyeVRpbWVgIHByb3BlcnR5IGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24odHg6IFRyYW5zYWN0aW9uKTogUHJvbWlzZX0gdHJhbnNhY3Rpb25Xb3JrIC0gQ2FsbGJhY2sgdGhhdCBleGVjdXRlcyBvcGVyYXRpb25zIGFnYWluc3RcbiAgICAgKiBhIGdpdmVuIHtAbGluayBUcmFuc2FjdGlvbn0uXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpZ30gW3RyYW5zYWN0aW9uQ29uZmlnXSAtIENvbmZpZ3VyYXRpb24gZm9yIGFsbCB0cmFuc2FjdGlvbnMgc3RhcnRlZCB0byBleGVjdXRlIHRoZSB1bml0IG9mIHdvcmsuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgcHJvbWlzZSBhcyByZXR1cm5lZCBieSB0aGUgZ2l2ZW4gZnVuY3Rpb24gb3IgcmVqZWN0ZWQgcHJvbWlzZSB3aGVuIGdpdmVuXG4gICAgICogZnVuY3Rpb24gb3IgY29tbWl0IGZhaWxzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVUcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uV29yaywgdHJhbnNhY3Rpb25Db25maWcpIHtcbiAgICAgIHZhciBjb25maWcgPSBuZXcgX3R4Q29uZmlnW1wiZGVmYXVsdFwiXSh0cmFuc2FjdGlvbkNvbmZpZyk7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVHJhbnNhY3Rpb24oX2NvbnN0YW50cy5BQ0NFU1NfTU9ERV9XUklURSwgY29uZmlnLCB0cmFuc2FjdGlvbldvcmspO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcnVuVHJhbnNhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3J1blRyYW5zYWN0aW9uKGFjY2Vzc01vZGUsIHRyYW5zYWN0aW9uQ29uZmlnLCB0cmFuc2FjdGlvbldvcmspIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25FeGVjdXRvci5leGVjdXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5fYmVnaW5UcmFuc2FjdGlvbihhY2Nlc3NNb2RlLCB0cmFuc2FjdGlvbkNvbmZpZyk7XG4gICAgICB9LCB0cmFuc2FjdGlvbldvcmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdmFsdWUgb2YgdGhlIGxhc3QgYm9va21hcmsuXG4gICAgICogQHBhcmFtIHtCb29rbWFya30gbmV3Qm9va21hcmsgLSBUaGUgbmV3IGJvb2ttYXJrLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUJvb2ttYXJrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVCb29rbWFyayhuZXdCb29rbWFyaykge1xuICAgICAgaWYgKG5ld0Jvb2ttYXJrICYmICFuZXdCb29rbWFyay5pc0VtcHR5KCkpIHtcbiAgICAgICAgdGhpcy5fbGFzdEJvb2ttYXJrID0gbmV3Qm9va21hcms7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoaXMgc2Vzc2lvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jbG9zZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fb3Blbikge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9vcGVuID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2FjdGlvbkV4ZWN1dG9yLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZENvbm5lY3Rpb25Ib2xkZXIuY2xvc2UoKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlQ29ubmVjdGlvbkhvbGRlci5jbG9zZSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiBfY2xvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb3NlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9jb25uZWN0aW9uSG9sZGVyV2l0aE1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Nvbm5lY3Rpb25Ib2xkZXJXaXRoTW9kZShtb2RlKSB7XG4gICAgICBpZiAobW9kZSA9PT0gX2NvbnN0YW50cy5BQ0NFU1NfTU9ERV9SRUFEKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkQ29ubmVjdGlvbkhvbGRlcjtcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gX2NvbnN0YW50cy5BQ0NFU1NfTU9ERV9XUklURSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVDb25uZWN0aW9uSG9sZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoJ1Vua25vd24gYWNjZXNzIG1vZGU6ICcgKyBtb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uQ29tcGxldGVDYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Db21wbGV0ZUNhbGxiYWNrKG1ldGEpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUJvb2ttYXJrKG5ldyBfYm9va21hcmtbXCJkZWZhdWx0XCJdKG1ldGEuYm9va21hcmspKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNlc3Npb247XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVUcmFuc2FjdGlvbkV4ZWN1dG9yKGNvbmZpZykge1xuICB2YXIgbWF4UmV0cnlUaW1lTXMgPSBjb25maWcgJiYgY29uZmlnLm1heFRyYW5zYWN0aW9uUmV0cnlUaW1lID8gY29uZmlnLm1heFRyYW5zYWN0aW9uUmV0cnlUaW1lIDogbnVsbDtcbiAgcmV0dXJuIG5ldyBfdHJhbnNhY3Rpb25FeGVjdXRvcltcImRlZmF1bHRcIl0obWF4UmV0cnlUaW1lTXMpO1xufVxuXG52YXIgX2RlZmF1bHQgPSBTZXNzaW9uO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzUG9pbnQgPSBpc1BvaW50O1xuZXhwb3J0cy5Qb2ludCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvdXRpbFwiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgUE9JTlRfSURFTlRJRklFUl9QUk9QRVJUWSA9ICdfX2lzUG9pbnRfXyc7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBzaW5nbGUgdHdvIG9yIHRocmVlLWRpbWVuc2lvbmFsIHBvaW50IGluIGEgcGFydGljdWxhciBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW0uXG4gKiBDcmVhdGVkIGBQb2ludGAgb2JqZWN0cyBhcmUgZnJvemVuIHdpdGggYE9iamVjdC5mcmVlemUoKWAgaW4gY29uc3RydWN0b3IgYW5kIHRodXMgaW1tdXRhYmxlLlxuICovXG5cbnZhciBQb2ludCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gc3JpZCAtIFRoZSBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW0gaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbej11bmRlZmluZWRdIC0gVGhlIGB6YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBvciBgdW5kZWZpbmVkYCBpZiBwb2ludCBoYXMgMiBkaW1lbnNpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUG9pbnQoc3JpZCwgeCwgeSwgeikge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUG9pbnQpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbSBpZGVudGlmaWVyLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNyaWQgPSAoMCwgX3V0aWwuYXNzZXJ0TnVtYmVyT3JJbnRlZ2VyKShzcmlkLCAnU1JJRCcpO1xuICAgIC8qKlxuICAgICAqIFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMueCA9ICgwLCBfdXRpbC5hc3NlcnROdW1iZXIpKHgsICdYIGNvb3JkaW5hdGUnKTtcbiAgICAvKipcbiAgICAgKiBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLnkgPSAoMCwgX3V0aWwuYXNzZXJ0TnVtYmVyKSh5LCAnWSBjb29yZGluYXRlJyk7XG4gICAgLyoqXG4gICAgICogVGhlIGB6YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBvciBgdW5kZWZpbmVkYCBpZiBwb2ludCBpcyAyLWRpbWVuc2lvbmFsLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLnogPSB6ID09PSBudWxsIHx8IHogPT09IHVuZGVmaW5lZCA/IHogOiAoMCwgX3V0aWwuYXNzZXJ0TnVtYmVyKSh6LCAnWiBjb29yZGluYXRlJyk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUG9pbnQsIFt7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMueiB8fCB0aGlzLnogPT09IDAgPyBcIlBvaW50e3NyaWQ9XCIuY29uY2F0KGZvcm1hdEFzRmxvYXQodGhpcy5zcmlkKSwgXCIsIHg9XCIpLmNvbmNhdChmb3JtYXRBc0Zsb2F0KHRoaXMueCksIFwiLCB5PVwiKS5jb25jYXQoZm9ybWF0QXNGbG9hdCh0aGlzLnkpLCBcIiwgej1cIikuY29uY2F0KGZvcm1hdEFzRmxvYXQodGhpcy56KSwgXCJ9XCIpIDogXCJQb2ludHtzcmlkPVwiLmNvbmNhdChmb3JtYXRBc0Zsb2F0KHRoaXMuc3JpZCksIFwiLCB4PVwiKS5jb25jYXQoZm9ybWF0QXNGbG9hdCh0aGlzLngpLCBcIiwgeT1cIikuY29uY2F0KGZvcm1hdEFzRmxvYXQodGhpcy55KSwgXCJ9XCIpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUG9pbnQ7XG59KCk7XG5cbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcblxuZnVuY3Rpb24gZm9ybWF0QXNGbG9hdChudW1iZXIpIHtcbiAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIobnVtYmVyKSA/IG51bWJlciArICcuMCcgOiBudW1iZXIudG9TdHJpbmcoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvaW50LnByb3RvdHlwZSwgUE9JTlRfSURFTlRJRklFUl9QUk9QRVJUWSwge1xuICB2YWx1ZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZVxufSk7XG4vKipcbiAqIFRlc3QgaWYgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIHtAbGluayBQb2ludH0gY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBvYmplY3QgaXMgYSB7QGxpbmsgUG9pbnR9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc1BvaW50KG9iaikge1xuICByZXR1cm4gKG9iaiAmJiBvYmpbUE9JTlRfSURFTlRJRklFUl9QUk9QRVJUWV0pID09PSB0cnVlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkXCIpO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNEdXJhdGlvbiA9IGlzRHVyYXRpb247XG5leHBvcnRzLmlzTG9jYWxUaW1lID0gaXNMb2NhbFRpbWU7XG5leHBvcnRzLmlzVGltZSA9IGlzVGltZTtcbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuZXhwb3J0cy5pc0xvY2FsRGF0ZVRpbWUgPSBpc0xvY2FsRGF0ZVRpbWU7XG5leHBvcnRzLmlzRGF0ZVRpbWUgPSBpc0RhdGVUaW1lO1xuZXhwb3J0cy5EYXRlVGltZSA9IGV4cG9ydHMuTG9jYWxEYXRlVGltZSA9IGV4cG9ydHMuRGF0ZSA9IGV4cG9ydHMuVGltZSA9IGV4cG9ydHMuTG9jYWxUaW1lID0gZXhwb3J0cy5EdXJhdGlvbiA9IHZvaWQgMDtcblxudmFyIF9zbGljZWRUb0FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheVwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciB1dGlsID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vaW50ZXJuYWwvdGVtcG9yYWwtdXRpbFwiKSk7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL2ludGVybmFsL3V0aWxcIik7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgSURFTlRJRklFUl9QUk9QRVJUWV9BVFRSSUJVVEVTID0ge1xuICB2YWx1ZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZVxufTtcbnZhciBEVVJBVElPTl9JREVOVElGSUVSX1BST1BFUlRZID0gJ19faXNEdXJhdGlvbl9fJztcbnZhciBMT0NBTF9USU1FX0lERU5USUZJRVJfUFJPUEVSVFkgPSAnX19pc0xvY2FsVGltZV9fJztcbnZhciBUSU1FX0lERU5USUZJRVJfUFJPUEVSVFkgPSAnX19pc1RpbWVfXyc7XG52YXIgREFURV9JREVOVElGSUVSX1BST1BFUlRZID0gJ19faXNEYXRlX18nO1xudmFyIExPQ0FMX0RBVEVfVElNRV9JREVOVElGSUVSX1BST1BFUlRZID0gJ19faXNMb2NhbERhdGVUaW1lX18nO1xudmFyIERBVEVfVElNRV9JREVOVElGSUVSX1BST1BFUlRZID0gJ19faXNEYXRlVGltZV9fJztcbi8qKlxuICogUmVwcmVzZW50cyBhbiBJU08gODYwMSBkdXJhdGlvbi4gQ29udGFpbnMgYm90aCBkYXRlLWJhc2VkIHZhbHVlcyAoeWVhcnMsIG1vbnRocywgZGF5cykgYW5kIHRpbWUtYmFzZWQgdmFsdWVzIChzZWNvbmRzLCBuYW5vc2Vjb25kcykuXG4gKiBDcmVhdGVkIGBEdXJhdGlvbmAgb2JqZWN0cyBhcmUgZnJvemVuIHdpdGggYE9iamVjdC5mcmVlemUoKWAgaW4gY29uc3RydWN0b3IgYW5kIHRodXMgaW1tdXRhYmxlLlxuICovXG5cbnZhciBEdXJhdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gbW9udGhzIC0gVGhlIG51bWJlciBvZiBtb250aHMgZm9yIHRoZSBuZXcgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IGRheXMgLSBUaGUgbnVtYmVyIG9mIGRheXMgZm9yIHRoZSBuZXcgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IHNlY29uZHMgLSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgZm9yIHRoZSBuZXcgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IG5hbm9zZWNvbmRzIC0gVGhlIG51bWJlciBvZiBuYW5vc2Vjb25kcyBmb3IgdGhlIG5ldyBkdXJhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIER1cmF0aW9uKG1vbnRocywgZGF5cywgc2Vjb25kcywgbmFub3NlY29uZHMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIER1cmF0aW9uKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbW9udGhzLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1vbnRocyA9ICgwLCBfdXRpbC5hc3NlcnROdW1iZXJPckludGVnZXIpKG1vbnRocywgJ01vbnRocycpO1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZGF5cy5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLmRheXMgPSAoMCwgX3V0aWwuYXNzZXJ0TnVtYmVyT3JJbnRlZ2VyKShkYXlzLCAnRGF5cycpO1xuICAgICgwLCBfdXRpbC5hc3NlcnROdW1iZXJPckludGVnZXIpKHNlY29uZHMsICdTZWNvbmRzJyk7XG4gICAgKDAsIF91dGlsLmFzc2VydE51bWJlck9ySW50ZWdlcikobmFub3NlY29uZHMsICdOYW5vc2Vjb25kcycpO1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2Ygc2Vjb25kcy5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLnNlY29uZHMgPSB1dGlsLm5vcm1hbGl6ZVNlY29uZHNGb3JEdXJhdGlvbihzZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBuYW5vc2Vjb25kcy5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLm5hbm9zZWNvbmRzID0gdXRpbC5ub3JtYWxpemVOYW5vc2Vjb25kc0ZvckR1cmF0aW9uKG5hbm9zZWNvbmRzKTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShEdXJhdGlvbiwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdXRpbC5kdXJhdGlvblRvSXNvU3RyaW5nKHRoaXMubW9udGhzLCB0aGlzLmRheXMsIHRoaXMuc2Vjb25kcywgdGhpcy5uYW5vc2Vjb25kcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEdXJhdGlvbjtcbn0oKTtcblxuZXhwb3J0cy5EdXJhdGlvbiA9IER1cmF0aW9uO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cmF0aW9uLnByb3RvdHlwZSwgRFVSQVRJT05fSURFTlRJRklFUl9QUk9QRVJUWSwgSURFTlRJRklFUl9QUk9QRVJUWV9BVFRSSUJVVEVTKTtcbi8qKlxuICogVGVzdCBpZiBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIER1cmF0aW9ufSBjbGFzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIG9iamVjdCBpcyBhIHtAbGluayBEdXJhdGlvbn0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzRHVyYXRpb24ob2JqKSB7XG4gIHJldHVybiBoYXNJZGVudGlmaWVyUHJvcGVydHkob2JqLCBEVVJBVElPTl9JREVOVElGSUVSX1BST1BFUlRZKTtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBpbnN0YW50IGNhcHR1cmluZyB0aGUgdGltZSBvZiBkYXksIGJ1dCBub3QgdGhlIGRhdGUsIG5vciB0aGUgdGltZXpvbmUuXG4gKiBDcmVhdGVkIHtAbGluayBMb2NhbFRpbWV9IG9iamVjdHMgYXJlIGZyb3plbiB3aXRoIGBPYmplY3QuZnJlZXplKClgIGluIGNvbnN0cnVjdG9yIGFuZCB0aHVzIGltbXV0YWJsZS5cbiAqL1xuXG5cbnZhciBMb2NhbFRpbWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IGhvdXIgLSBUaGUgaG91ciBmb3IgdGhlIG5ldyBsb2NhbCB0aW1lLlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBtaW51dGUgLSBUaGUgbWludXRlIGZvciB0aGUgbmV3IGxvY2FsIHRpbWUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IHNlY29uZCAtIFRoZSBzZWNvbmQgZm9yIHRoZSBuZXcgbG9jYWwgdGltZS5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gbmFub3NlY29uZCAtIFRoZSBuYW5vc2Vjb25kIGZvciB0aGUgbmV3IGxvY2FsIHRpbWUuXG4gICAqL1xuICBmdW5jdGlvbiBMb2NhbFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9zZWNvbmQpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIExvY2FsVGltZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaG91ci5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ob3VyID0gdXRpbC5hc3NlcnRWYWxpZEhvdXIoaG91cik7XG4gICAgLyoqXG4gICAgICogVGhlIG1pbnV0ZS5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLm1pbnV0ZSA9IHV0aWwuYXNzZXJ0VmFsaWRNaW51dGUobWludXRlKTtcbiAgICAvKipcbiAgICAgKiBUaGUgc2Vjb25kLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuc2Vjb25kID0gdXRpbC5hc3NlcnRWYWxpZFNlY29uZChzZWNvbmQpO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW5vc2Vjb25kLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMubmFub3NlY29uZCA9IHV0aWwuYXNzZXJ0VmFsaWROYW5vc2Vjb25kKG5hbm9zZWNvbmQpO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHtAbGluayBMb2NhbFRpbWV9IG9iamVjdCBmcm9tIHRoZSBnaXZlbiBzdGFuZGFyZCBKYXZhU2NyaXB0IGBEYXRlYCBhbmQgb3B0aW9uYWwgbmFub3NlY29uZHMuXG4gICAqIFllYXIsIG1vbnRoLCBkYXkgYW5kIHRpbWUgem9uZSBvZmZzZXQgY29tcG9uZW50cyBvZiB0aGUgZ2l2ZW4gZGF0ZSBhcmUgaWdub3JlZC5cbiAgICogQHBhcmFtIHtnbG9iYWwuRGF0ZX0gc3RhbmRhcmREYXRlIC0gVGhlIHN0YW5kYXJkIEphdmFTY3JpcHQgZGF0ZSB0byBjb252ZXJ0LlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHVuZGVmaW5lZH0gbmFub3NlY29uZCAtIFRoZSBvcHRpb25hbCBhbW91bnQgb2YgbmFub3NlY29uZHMuXG4gICAqIEByZXR1cm4ge0xvY2FsVGltZX0gTmV3IExvY2FsVGltZS5cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKExvY2FsVGltZSwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcblxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdXRpbC50aW1lVG9Jc29TdHJpbmcodGhpcy5ob3VyLCB0aGlzLm1pbnV0ZSwgdGhpcy5zZWNvbmQsIHRoaXMubmFub3NlY29uZCk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbVN0YW5kYXJkRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU3RhbmRhcmREYXRlKHN0YW5kYXJkRGF0ZSwgbmFub3NlY29uZCkge1xuICAgICAgdmVyaWZ5U3RhbmRhcmREYXRlQW5kTmFub3Moc3RhbmRhcmREYXRlLCBuYW5vc2Vjb25kKTtcbiAgICAgIHJldHVybiBuZXcgTG9jYWxUaW1lKHN0YW5kYXJkRGF0ZS5nZXRIb3VycygpLCBzdGFuZGFyZERhdGUuZ2V0TWludXRlcygpLCBzdGFuZGFyZERhdGUuZ2V0U2Vjb25kcygpLCB1dGlsLnRvdGFsTmFub3NlY29uZHMoc3RhbmRhcmREYXRlLCBuYW5vc2Vjb25kKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMb2NhbFRpbWU7XG59KCk7XG5cbmV4cG9ydHMuTG9jYWxUaW1lID0gTG9jYWxUaW1lO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KExvY2FsVGltZS5wcm90b3R5cGUsIExPQ0FMX1RJTUVfSURFTlRJRklFUl9QUk9QRVJUWSwgSURFTlRJRklFUl9QUk9QRVJUWV9BVFRSSUJVVEVTKTtcbi8qKlxuICogVGVzdCBpZiBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIExvY2FsVGltZX0gY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBvYmplY3QgaXMgYSB7QGxpbmsgTG9jYWxUaW1lfSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNMb2NhbFRpbWUob2JqKSB7XG4gIHJldHVybiBoYXNJZGVudGlmaWVyUHJvcGVydHkob2JqLCBMT0NBTF9USU1FX0lERU5USUZJRVJfUFJPUEVSVFkpO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGluc3RhbnQgY2FwdHVyaW5nIHRoZSB0aW1lIG9mIGRheSwgYW5kIHRoZSB0aW1lem9uZSBvZmZzZXQgaW4gc2Vjb25kcywgYnV0IG5vdCB0aGUgZGF0ZS5cbiAqIENyZWF0ZWQge0BsaW5rIFRpbWV9IG9iamVjdHMgYXJlIGZyb3plbiB3aXRoIGBPYmplY3QuZnJlZXplKClgIGluIGNvbnN0cnVjdG9yIGFuZCB0aHVzIGltbXV0YWJsZS5cbiAqL1xuXG5cbnZhciBUaW1lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBob3VyIC0gVGhlIGhvdXIgZm9yIHRoZSBuZXcgbG9jYWwgdGltZS5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gbWludXRlIC0gVGhlIG1pbnV0ZSBmb3IgdGhlIG5ldyBsb2NhbCB0aW1lLlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBzZWNvbmQgLSBUaGUgc2Vjb25kIGZvciB0aGUgbmV3IGxvY2FsIHRpbWUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IG5hbm9zZWNvbmQgLSBUaGUgbmFub3NlY29uZCBmb3IgdGhlIG5ldyBsb2NhbCB0aW1lLlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSB0aW1lWm9uZU9mZnNldFNlY29uZHMgLSBUaGUgdGltZSB6b25lIG9mZnNldCBpbiBzZWNvbmRzLiBWYWx1ZSByZXByZXNlbnRzIHRoZSBkaWZmZXJlbmNlLCBpbiBzZWNvbmRzLCBmcm9tIFVUQyB0byBsb2NhbCB0aW1lLlxuICAgKiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIHN0YW5kYXJkIEphdmFTY3JpcHQgYERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKWAgd2hpY2ggaXMgdGhlIGRpZmZlcmVuY2UsIGluIG1pbnV0ZXMsIGZyb20gbG9jYWwgdGltZSB0byBVVEMuXG4gICAqL1xuICBmdW5jdGlvbiBUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vc2Vjb25kLCB0aW1lWm9uZU9mZnNldFNlY29uZHMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFRpbWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhvdXIuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaG91ciA9IHV0aWwuYXNzZXJ0VmFsaWRIb3VyKGhvdXIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtaW51dGUuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5taW51dGUgPSB1dGlsLmFzc2VydFZhbGlkTWludXRlKG1pbnV0ZSk7XG4gICAgLyoqXG4gICAgICogVGhlIHNlY29uZC5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLnNlY29uZCA9IHV0aWwuYXNzZXJ0VmFsaWRTZWNvbmQoc2Vjb25kKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFub3NlY29uZC5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLm5hbm9zZWNvbmQgPSB1dGlsLmFzc2VydFZhbGlkTmFub3NlY29uZChuYW5vc2Vjb25kKTtcbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSB6b25lIG9mZnNldCBpbiBzZWNvbmRzLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMudGltZVpvbmVPZmZzZXRTZWNvbmRzID0gKDAsIF91dGlsLmFzc2VydE51bWJlck9ySW50ZWdlcikodGltZVpvbmVPZmZzZXRTZWNvbmRzLCAnVGltZSB6b25lIG9mZnNldCBpbiBzZWNvbmRzJyk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEge0BsaW5rIFRpbWV9IG9iamVjdCBmcm9tIHRoZSBnaXZlbiBzdGFuZGFyZCBKYXZhU2NyaXB0IGBEYXRlYCBhbmQgb3B0aW9uYWwgbmFub3NlY29uZHMuXG4gICAqIFllYXIsIG1vbnRoIGFuZCBkYXkgY29tcG9uZW50cyBvZiB0aGUgZ2l2ZW4gZGF0ZSBhcmUgaWdub3JlZC5cbiAgICogQHBhcmFtIHtnbG9iYWwuRGF0ZX0gc3RhbmRhcmREYXRlIC0gVGhlIHN0YW5kYXJkIEphdmFTY3JpcHQgZGF0ZSB0byBjb252ZXJ0LlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHVuZGVmaW5lZH0gbmFub3NlY29uZCAtIFRoZSBvcHRpb25hbCBhbW91bnQgb2YgbmFub3NlY29uZHMuXG4gICAqIEByZXR1cm4ge1RpbWV9IE5ldyBUaW1lLlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoVGltZSwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcblxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdXRpbC50aW1lVG9Jc29TdHJpbmcodGhpcy5ob3VyLCB0aGlzLm1pbnV0ZSwgdGhpcy5zZWNvbmQsIHRoaXMubmFub3NlY29uZCkgKyB1dGlsLnRpbWVab25lT2Zmc2V0VG9Jc29TdHJpbmcodGhpcy50aW1lWm9uZU9mZnNldFNlY29uZHMpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21TdGFuZGFyZERhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVN0YW5kYXJkRGF0ZShzdGFuZGFyZERhdGUsIG5hbm9zZWNvbmQpIHtcbiAgICAgIHZlcmlmeVN0YW5kYXJkRGF0ZUFuZE5hbm9zKHN0YW5kYXJkRGF0ZSwgbmFub3NlY29uZCk7XG4gICAgICByZXR1cm4gbmV3IFRpbWUoc3RhbmRhcmREYXRlLmdldEhvdXJzKCksIHN0YW5kYXJkRGF0ZS5nZXRNaW51dGVzKCksIHN0YW5kYXJkRGF0ZS5nZXRTZWNvbmRzKCksIHV0aWwudG90YWxOYW5vc2Vjb25kcyhzdGFuZGFyZERhdGUsIG5hbm9zZWNvbmQpLCB1dGlsLnRpbWVab25lT2Zmc2V0SW5TZWNvbmRzKHN0YW5kYXJkRGF0ZSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGltZTtcbn0oKTtcblxuZXhwb3J0cy5UaW1lID0gVGltZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaW1lLnByb3RvdHlwZSwgVElNRV9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgVGltZX0gY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBvYmplY3QgaXMgYSB7QGxpbmsgVGltZX0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzVGltZShvYmopIHtcbiAgcmV0dXJuIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIFRJTUVfSURFTlRJRklFUl9QUk9QRVJUWSk7XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gaW5zdGFudCBjYXB0dXJpbmcgdGhlIGRhdGUsIGJ1dCBub3QgdGhlIHRpbWUsIG5vciB0aGUgdGltZXpvbmUuXG4gKiBDcmVhdGVkIHtAbGluayBEYXRlfSBvYmplY3RzIGFyZSBmcm96ZW4gd2l0aCBgT2JqZWN0LmZyZWV6ZSgpYCBpbiBjb25zdHJ1Y3RvciBhbmQgdGh1cyBpbW11dGFibGUuXG4gKi9cblxuXG52YXIgRGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0geWVhciAtIFRoZSB5ZWFyIGZvciB0aGUgbmV3IGxvY2FsIGRhdGUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IG1vbnRoIC0gVGhlIG1vbnRoIGZvciB0aGUgbmV3IGxvY2FsIGRhdGUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IGRheSAtIFRoZSBkYXkgZm9yIHRoZSBuZXcgbG9jYWwgZGF0ZS5cbiAgICovXG4gIGZ1bmN0aW9uIERhdGUoeWVhciwgbW9udGgsIGRheSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgRGF0ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgeWVhci5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy55ZWFyID0gdXRpbC5hc3NlcnRWYWxpZFllYXIoeWVhcik7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbnRoLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMubW9udGggPSB1dGlsLmFzc2VydFZhbGlkTW9udGgobW9udGgpO1xuICAgIC8qKlxuICAgICAqIFRoZSBkYXkuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5kYXkgPSB1dGlsLmFzc2VydFZhbGlkRGF5KGRheSk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEge0BsaW5rIERhdGV9IG9iamVjdCBmcm9tIHRoZSBnaXZlbiBzdGFuZGFyZCBKYXZhU2NyaXB0IGBEYXRlYC5cbiAgICogSG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kIGFuZCB0aW1lIHpvbmUgb2Zmc2V0IGNvbXBvbmVudHMgb2YgdGhlIGdpdmVuIGRhdGUgYXJlIGlnbm9yZWQuXG4gICAqIEBwYXJhbSB7Z2xvYmFsLkRhdGV9IHN0YW5kYXJkRGF0ZSAtIFRoZSBzdGFuZGFyZCBKYXZhU2NyaXB0IGRhdGUgdG8gY29udmVydC5cbiAgICogQHJldHVybiB7RGF0ZX0gTmV3IERhdGUuXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShEYXRlLCBbe1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuXG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB1dGlsLmRhdGVUb0lzb1N0cmluZyh0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF5KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tU3RhbmRhcmREYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TdGFuZGFyZERhdGUoc3RhbmRhcmREYXRlKSB7XG4gICAgICB2ZXJpZnlTdGFuZGFyZERhdGVBbmROYW5vcyhzdGFuZGFyZERhdGUsIG51bGwpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHN0YW5kYXJkRGF0ZS5nZXRGdWxsWWVhcigpLCBzdGFuZGFyZERhdGUuZ2V0TW9udGgoKSArIDEsIHN0YW5kYXJkRGF0ZS5nZXREYXRlKCkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRGF0ZTtcbn0oKTtcblxuZXhwb3J0cy5EYXRlID0gRGF0ZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRlLnByb3RvdHlwZSwgREFURV9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgRGF0ZX0gY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIG9iamVjdCBpcyBhIHtAbGluayBEYXRlfSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNEYXRlKG9iaikge1xuICByZXR1cm4gaGFzSWRlbnRpZmllclByb3BlcnR5KG9iaiwgREFURV9JREVOVElGSUVSX1BST1BFUlRZKTtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBpbnN0YW50IGNhcHR1cmluZyB0aGUgZGF0ZSBhbmQgdGhlIHRpbWUsIGJ1dCBub3QgdGhlIHRpbWV6b25lLlxuICogQ3JlYXRlZCB7QGxpbmsgTG9jYWxEYXRlVGltZX0gb2JqZWN0cyBhcmUgZnJvemVuIHdpdGggYE9iamVjdC5mcmVlemUoKWAgaW4gY29uc3RydWN0b3IgYW5kIHRodXMgaW1tdXRhYmxlLlxuICovXG5cblxudmFyIExvY2FsRGF0ZVRpbWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IHllYXIgLSBUaGUgeWVhciBmb3IgdGhlIG5ldyBsb2NhbCBkYXRlLlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBtb250aCAtIFRoZSBtb250aCBmb3IgdGhlIG5ldyBsb2NhbCBkYXRlLlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBkYXkgLSBUaGUgZGF5IGZvciB0aGUgbmV3IGxvY2FsIGRhdGUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IGhvdXIgLSBUaGUgaG91ciBmb3IgdGhlIG5ldyBsb2NhbCB0aW1lLlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBtaW51dGUgLSBUaGUgbWludXRlIGZvciB0aGUgbmV3IGxvY2FsIHRpbWUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IHNlY29uZCAtIFRoZSBzZWNvbmQgZm9yIHRoZSBuZXcgbG9jYWwgdGltZS5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gbmFub3NlY29uZCAtIFRoZSBuYW5vc2Vjb25kIGZvciB0aGUgbmV3IGxvY2FsIHRpbWUuXG4gICAqL1xuICBmdW5jdGlvbiBMb2NhbERhdGVUaW1lKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vc2Vjb25kKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBMb2NhbERhdGVUaW1lKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB5ZWFyLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnllYXIgPSB1dGlsLmFzc2VydFZhbGlkWWVhcih5ZWFyKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9udGguXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5tb250aCA9IHV0aWwuYXNzZXJ0VmFsaWRNb250aChtb250aCk7XG4gICAgLyoqXG4gICAgICogVGhlIGRheS5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLmRheSA9IHV0aWwuYXNzZXJ0VmFsaWREYXkoZGF5KTtcbiAgICAvKipcbiAgICAgKiBUaGUgaG91ci5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLmhvdXIgPSB1dGlsLmFzc2VydFZhbGlkSG91cihob3VyKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWludXRlLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMubWludXRlID0gdXRpbC5hc3NlcnRWYWxpZE1pbnV0ZShtaW51dGUpO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZWNvbmQuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5zZWNvbmQgPSB1dGlsLmFzc2VydFZhbGlkU2Vjb25kKHNlY29uZCk7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbm9zZWNvbmQuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5uYW5vc2Vjb25kID0gdXRpbC5hc3NlcnRWYWxpZE5hbm9zZWNvbmQobmFub3NlY29uZCk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEge0BsaW5rIExvY2FsRGF0ZVRpbWV9IG9iamVjdCBmcm9tIHRoZSBnaXZlbiBzdGFuZGFyZCBKYXZhU2NyaXB0IGBEYXRlYCBhbmQgb3B0aW9uYWwgbmFub3NlY29uZHMuXG4gICAqIFRpbWUgem9uZSBvZmZzZXQgY29tcG9uZW50IG9mIHRoZSBnaXZlbiBkYXRlIGlzIGlnbm9yZWQuXG4gICAqIEBwYXJhbSB7Z2xvYmFsLkRhdGV9IHN0YW5kYXJkRGF0ZSAtIFRoZSBzdGFuZGFyZCBKYXZhU2NyaXB0IGRhdGUgdG8gY29udmVydC5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnx1bmRlZmluZWR9IG5hbm9zZWNvbmQgLSBUaGUgb3B0aW9uYWwgYW1vdW50IG9mIG5hbm9zZWNvbmRzLlxuICAgKiBAcmV0dXJuIHtMb2NhbERhdGVUaW1lfSBOZXcgTG9jYWxEYXRlVGltZS5cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKExvY2FsRGF0ZVRpbWUsIFt7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG5cbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGxvY2FsRGF0ZVRpbWVUb1N0cmluZyh0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF5LCB0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5uYW5vc2Vjb25kKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tU3RhbmRhcmREYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TdGFuZGFyZERhdGUoc3RhbmRhcmREYXRlLCBuYW5vc2Vjb25kKSB7XG4gICAgICB2ZXJpZnlTdGFuZGFyZERhdGVBbmROYW5vcyhzdGFuZGFyZERhdGUsIG5hbm9zZWNvbmQpO1xuICAgICAgcmV0dXJuIG5ldyBMb2NhbERhdGVUaW1lKHN0YW5kYXJkRGF0ZS5nZXRGdWxsWWVhcigpLCBzdGFuZGFyZERhdGUuZ2V0TW9udGgoKSArIDEsIHN0YW5kYXJkRGF0ZS5nZXREYXRlKCksIHN0YW5kYXJkRGF0ZS5nZXRIb3VycygpLCBzdGFuZGFyZERhdGUuZ2V0TWludXRlcygpLCBzdGFuZGFyZERhdGUuZ2V0U2Vjb25kcygpLCB1dGlsLnRvdGFsTmFub3NlY29uZHMoc3RhbmRhcmREYXRlLCBuYW5vc2Vjb25kKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMb2NhbERhdGVUaW1lO1xufSgpO1xuXG5leHBvcnRzLkxvY2FsRGF0ZVRpbWUgPSBMb2NhbERhdGVUaW1lO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KExvY2FsRGF0ZVRpbWUucHJvdG90eXBlLCBMT0NBTF9EQVRFX1RJTUVfSURFTlRJRklFUl9QUk9QRVJUWSwgSURFTlRJRklFUl9QUk9QRVJUWV9BVFRSSUJVVEVTKTtcbi8qKlxuICogVGVzdCBpZiBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIExvY2FsRGF0ZVRpbWV9IGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBvYmplY3QgaXMgYSB7QGxpbmsgTG9jYWxEYXRlVGltZX0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzTG9jYWxEYXRlVGltZShvYmopIHtcbiAgcmV0dXJuIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIExPQ0FMX0RBVEVfVElNRV9JREVOVElGSUVSX1BST1BFUlRZKTtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBpbnN0YW50IGNhcHR1cmluZyB0aGUgZGF0ZSwgdGhlIHRpbWUgYW5kIHRoZSB0aW1lem9uZSBpZGVudGlmaWVyLlxuICogQ3JlYXRlZCB7QCBEYXRlVGltZX0gb2JqZWN0cyBhcmUgZnJvemVuIHdpdGggYE9iamVjdC5mcmVlemUoKWAgaW4gY29uc3RydWN0b3IgYW5kIHRodXMgaW1tdXRhYmxlLlxuICovXG5cblxudmFyIERhdGVUaW1lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSB5ZWFyIC0gVGhlIHllYXIgZm9yIHRoZSBuZXcgZGF0ZS10aW1lLlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBtb250aCAtIFRoZSBtb250aCBmb3IgdGhlIG5ldyBkYXRlLXRpbWUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IGRheSAtIFRoZSBkYXkgZm9yIHRoZSBuZXcgZGF0ZS10aW1lLlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBob3VyIC0gVGhlIGhvdXIgZm9yIHRoZSBuZXcgZGF0ZS10aW1lLlxuICAgKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBtaW51dGUgLSBUaGUgbWludXRlIGZvciB0aGUgbmV3IGRhdGUtdGltZS5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gc2Vjb25kIC0gVGhlIHNlY29uZCBmb3IgdGhlIG5ldyBkYXRlLXRpbWUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IG5hbm9zZWNvbmQgLSBUaGUgbmFub3NlY29uZCBmb3IgdGhlIG5ldyBkYXRlLXRpbWUuXG4gICAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IHRpbWVab25lT2Zmc2V0U2Vjb25kcyAtIFRoZSB0aW1lIHpvbmUgb2Zmc2V0IGluIHNlY29uZHMuIEVpdGhlciB0aGlzIGFyZ3VtZW50IG9yIGB0aW1lWm9uZUlkYCBzaG91bGQgYmUgZGVmaW5lZC5cbiAgICogVmFsdWUgcmVwcmVzZW50cyB0aGUgZGlmZmVyZW5jZSwgaW4gc2Vjb25kcywgZnJvbSBVVEMgdG8gbG9jYWwgdGltZS5cbiAgICogVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBzdGFuZGFyZCBKYXZhU2NyaXB0IGBEYXRlLmdldFRpbWV6b25lT2Zmc2V0KClgIHdoaWNoIGlzIHRoZSBkaWZmZXJlbmNlLCBpbiBtaW51dGVzLCBmcm9tIGxvY2FsIHRpbWUgdG8gVVRDLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB0aW1lWm9uZUlkIC0gVGhlIHRpbWUgem9uZSBpZCBmb3IgdGhlIG5ldyBkYXRlLXRpbWUuIEVpdGhlciB0aGlzIGFyZ3VtZW50IG9yIGB0aW1lWm9uZU9mZnNldFNlY29uZHNgIHNob3VsZCBiZSBkZWZpbmVkLlxuICAgKi9cbiAgZnVuY3Rpb24gRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9zZWNvbmQsIHRpbWVab25lT2Zmc2V0U2Vjb25kcywgdGltZVpvbmVJZCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgRGF0ZVRpbWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHllYXIuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMueWVhciA9IHV0aWwuYXNzZXJ0VmFsaWRZZWFyKHllYXIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb250aC5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLm1vbnRoID0gdXRpbC5hc3NlcnRWYWxpZE1vbnRoKG1vbnRoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGF5LlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuZGF5ID0gdXRpbC5hc3NlcnRWYWxpZERheShkYXkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBob3VyLlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuaG91ciA9IHV0aWwuYXNzZXJ0VmFsaWRIb3VyKGhvdXIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtaW51dGUuXG4gICAgICogQHR5cGUge0ludGVnZXJ8bnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5taW51dGUgPSB1dGlsLmFzc2VydFZhbGlkTWludXRlKG1pbnV0ZSk7XG4gICAgLyoqXG4gICAgICogVGhlIHNlY29uZC5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLnNlY29uZCA9IHV0aWwuYXNzZXJ0VmFsaWRTZWNvbmQoc2Vjb25kKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFub3NlY29uZC5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcnxudW1iZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLm5hbm9zZWNvbmQgPSB1dGlsLmFzc2VydFZhbGlkTmFub3NlY29uZChuYW5vc2Vjb25kKTtcblxuICAgIHZhciBfdmVyaWZ5VGltZVpvbmVBcmd1bWUgPSB2ZXJpZnlUaW1lWm9uZUFyZ3VtZW50cyh0aW1lWm9uZU9mZnNldFNlY29uZHMsIHRpbWVab25lSWQpLFxuICAgICAgICBfdmVyaWZ5VGltZVpvbmVBcmd1bWUyID0gKDAsIF9zbGljZWRUb0FycmF5MltcImRlZmF1bHRcIl0pKF92ZXJpZnlUaW1lWm9uZUFyZ3VtZSwgMiksXG4gICAgICAgIG9mZnNldCA9IF92ZXJpZnlUaW1lWm9uZUFyZ3VtZTJbMF0sXG4gICAgICAgIGlkID0gX3ZlcmlmeVRpbWVab25lQXJndW1lMlsxXTtcbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSB6b25lIG9mZnNldCBpbiBzZWNvbmRzLlxuICAgICAqXG4gICAgICogKkVpdGhlciB0aGlzIG9yIHtAbGluayB0aW1lWm9uZUlkfSBpcyBkZWZpbmVkLipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtJbnRlZ2VyfG51bWJlcn1cbiAgICAgKi9cblxuXG4gICAgdGhpcy50aW1lWm9uZU9mZnNldFNlY29uZHMgPSBvZmZzZXQ7XG4gICAgLyoqXG4gICAgICogVGhlIHRpbWUgem9uZSBpZC5cbiAgICAgKlxuICAgICAqICpFaXRoZXIgdGhpcyBvciB7QGxpbmsgdGltZVpvbmVPZmZzZXRTZWNvbmRzfSBpcyBkZWZpbmVkLipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgICB0aGlzLnRpbWVab25lSWQgPSBpZDtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB7QGxpbmsgRGF0ZVRpbWV9IG9iamVjdCBmcm9tIHRoZSBnaXZlbiBzdGFuZGFyZCBKYXZhU2NyaXB0IGBEYXRlYCBhbmQgb3B0aW9uYWwgbmFub3NlY29uZHMuXG4gICAqIEBwYXJhbSB7Z2xvYmFsLkRhdGV9IHN0YW5kYXJkRGF0ZSAtIFRoZSBzdGFuZGFyZCBKYXZhU2NyaXB0IGRhdGUgdG8gY29udmVydC5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnx1bmRlZmluZWR9IG5hbm9zZWNvbmQgLSBUaGUgb3B0aW9uYWwgYW1vdW50IG9mIG5hbm9zZWNvbmRzLlxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX0gTmV3IERhdGVUaW1lLlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoRGF0ZVRpbWUsIFt7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG5cbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIGxvY2FsRGF0ZVRpbWVTdHIgPSBsb2NhbERhdGVUaW1lVG9TdHJpbmcodGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSwgdGhpcy5ob3VyLCB0aGlzLm1pbnV0ZSwgdGhpcy5zZWNvbmQsIHRoaXMubmFub3NlY29uZCk7XG4gICAgICB2YXIgdGltZVpvbmVTdHIgPSB0aGlzLnRpbWVab25lSWQgPyBcIltcIi5jb25jYXQodGhpcy50aW1lWm9uZUlkLCBcIl1cIikgOiB1dGlsLnRpbWVab25lT2Zmc2V0VG9Jc29TdHJpbmcodGhpcy50aW1lWm9uZU9mZnNldFNlY29uZHMpO1xuICAgICAgcmV0dXJuIGxvY2FsRGF0ZVRpbWVTdHIgKyB0aW1lWm9uZVN0cjtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tU3RhbmRhcmREYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TdGFuZGFyZERhdGUoc3RhbmRhcmREYXRlLCBuYW5vc2Vjb25kKSB7XG4gICAgICB2ZXJpZnlTdGFuZGFyZERhdGVBbmROYW5vcyhzdGFuZGFyZERhdGUsIG5hbm9zZWNvbmQpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZShzdGFuZGFyZERhdGUuZ2V0RnVsbFllYXIoKSwgc3RhbmRhcmREYXRlLmdldE1vbnRoKCkgKyAxLCBzdGFuZGFyZERhdGUuZ2V0RGF0ZSgpLCBzdGFuZGFyZERhdGUuZ2V0SG91cnMoKSwgc3RhbmRhcmREYXRlLmdldE1pbnV0ZXMoKSwgc3RhbmRhcmREYXRlLmdldFNlY29uZHMoKSwgdXRpbC50b3RhbE5hbm9zZWNvbmRzKHN0YW5kYXJkRGF0ZSwgbmFub3NlY29uZCksIHV0aWwudGltZVpvbmVPZmZzZXRJblNlY29uZHMoc3RhbmRhcmREYXRlKSwgbnVsbFxuICAgICAgLyogbm8gdGltZSB6b25lIGlkICovXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRGF0ZVRpbWU7XG59KCk7XG5cbmV4cG9ydHMuRGF0ZVRpbWUgPSBEYXRlVGltZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRlVGltZS5wcm90b3R5cGUsIERBVEVfVElNRV9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgRGF0ZVRpbWV9IGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBvYmplY3QgaXMgYSB7QGxpbmsgRGF0ZVRpbWV9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc0RhdGVUaW1lKG9iaikge1xuICByZXR1cm4gaGFzSWRlbnRpZmllclByb3BlcnR5KG9iaiwgREFURV9USU1FX0lERU5USUZJRVJfUFJPUEVSVFkpO1xufVxuXG5mdW5jdGlvbiBoYXNJZGVudGlmaWVyUHJvcGVydHkob2JqLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gKG9iaiAmJiBvYmpbcHJvcGVydHldKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbG9jYWxEYXRlVGltZVRvU3RyaW5nKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vc2Vjb25kKSB7XG4gIHJldHVybiB1dGlsLmRhdGVUb0lzb1N0cmluZyh5ZWFyLCBtb250aCwgZGF5KSArICdUJyArIHV0aWwudGltZVRvSXNvU3RyaW5nKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vc2Vjb25kKTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5VGltZVpvbmVBcmd1bWVudHModGltZVpvbmVPZmZzZXRTZWNvbmRzLCB0aW1lWm9uZUlkKSB7XG4gIHZhciBvZmZzZXREZWZpbmVkID0gdGltZVpvbmVPZmZzZXRTZWNvbmRzIHx8IHRpbWVab25lT2Zmc2V0U2Vjb25kcyA9PT0gMDtcbiAgdmFyIGlkRGVmaW5lZCA9IHRpbWVab25lSWQgJiYgdGltZVpvbmVJZCAhPT0gJyc7XG5cbiAgaWYgKG9mZnNldERlZmluZWQgJiYgIWlkRGVmaW5lZCkge1xuICAgICgwLCBfdXRpbC5hc3NlcnROdW1iZXJPckludGVnZXIpKHRpbWVab25lT2Zmc2V0U2Vjb25kcywgJ1RpbWUgem9uZSBvZmZzZXQgaW4gc2Vjb25kcycpO1xuICAgIHJldHVybiBbdGltZVpvbmVPZmZzZXRTZWNvbmRzLCBudWxsXTtcbiAgfSBlbHNlIGlmICghb2Zmc2V0RGVmaW5lZCAmJiBpZERlZmluZWQpIHtcbiAgICAoMCwgX3V0aWwuYXNzZXJ0U3RyaW5nKSh0aW1lWm9uZUlkLCAnVGltZSB6b25lIElEJyk7XG4gICAgcmV0dXJuIFtudWxsLCB0aW1lWm9uZUlkXTtcbiAgfSBlbHNlIGlmIChvZmZzZXREZWZpbmVkICYmIGlkRGVmaW5lZCkge1xuICAgIHRocm93ICgwLCBfZXJyb3IubmV3RXJyb3IpKFwiVW5hYmxlIHRvIGNyZWF0ZSBEYXRlVGltZSB3aXRoIGJvdGggdGltZSB6b25lIG9mZnNldCBhbmQgaWQuIFBsZWFzZSBzcGVjaWZ5IGVpdGhlciBvZiB0aGVtLiBHaXZlbiBvZmZzZXQ6IFwiLmNvbmNhdCh0aW1lWm9uZU9mZnNldFNlY29uZHMsIFwiIGFuZCBpZDogXCIpLmNvbmNhdCh0aW1lWm9uZUlkKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgKDAsIF9lcnJvci5uZXdFcnJvcikoXCJVbmFibGUgdG8gY3JlYXRlIERhdGVUaW1lIHdpdGhvdXQgZWl0aGVyIHRpbWUgem9uZSBvZmZzZXQgb3IgaWQuIFBsZWFzZSBzcGVjaWZ5IGVpdGhlciBvZiB0aGVtLiBHaXZlbiBvZmZzZXQ6IFwiLmNvbmNhdCh0aW1lWm9uZU9mZnNldFNlY29uZHMsIFwiIGFuZCBpZDogXCIpLmNvbmNhdCh0aW1lWm9uZUlkKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmVyaWZ5U3RhbmRhcmREYXRlQW5kTmFub3Moc3RhbmRhcmREYXRlLCBuYW5vc2Vjb25kKSB7XG4gICgwLCBfdXRpbC5hc3NlcnRWYWxpZERhdGUpKHN0YW5kYXJkRGF0ZSwgJ1N0YW5kYXJkIGRhdGUnKTtcblxuICBpZiAobmFub3NlY29uZCAhPT0gbnVsbCAmJiBuYW5vc2Vjb25kICE9PSB1bmRlZmluZWQpIHtcbiAgICAoMCwgX3V0aWwuYXNzZXJ0TnVtYmVyT3JJbnRlZ2VyKShuYW5vc2Vjb25kLCAnTmFub3NlY29uZCcpO1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcnhqcyA9IHJlcXVpcmUoXCJyeGpzXCIpO1xuXG52YXIgX3Jlc3VsdFJ4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZXN1bHQtcnhcIikpO1xuXG52YXIgX3RyYW5zYWN0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDAyLTIwMjAgXCJOZW80aixcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwOi8vbmVvNGouY29tXVxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIE5lbzRqLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEEgcmVhY3RpdmUgdHJhbnNhY3Rpb24sIHdoaWNoIHByb3ZpZGVzIHRoZSBzYW1lIGZ1bmN0aW9uYWxpdHkgYXMge0BsaW5rIFRyYW5zYWN0aW9ufSBidXQgdGhyb3VnaCBhIFJlYWN0aXZlIEFQSS5cbiAqL1xudmFyIFJ4VHJhbnNhY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHhjIC0gVGhlIHVuZGVybHlpbmcgdHJhbnNhY3Rpb24gaW5zdGFuY2UgdG8gcmVsYXkgcmVxdWVzdHNcbiAgICovXG4gIGZ1bmN0aW9uIFJ4VHJhbnNhY3Rpb24odHhjKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBSeFRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLl90eGMgPSB0eGM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZWFjdGl2ZSByZXN1bHQgdGhhdCB3aWxsIGV4ZWN1dGUgdGhlIHF1ZXJ5IGluIHRoaXMgdHJhbnNhY3Rpb24sIHdpdGggdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gUXVlcnkgdG8gYmUgZXhlY3V0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gUGFyYW1ldGVyIHZhbHVlcyB0byB1c2UgaW4gcXVlcnkgZXhlY3V0aW9uLlxuICAgKiBAcmV0dXJucyB7UnhSZXN1bHR9IC0gQSByZWFjdGl2ZSByZXN1bHRcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFJ4VHJhbnNhY3Rpb24sIFt7XG4gICAga2V5OiBcInJ1blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW4ocXVlcnksIHBhcmFtZXRlcnMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgX3Jlc3VsdFJ4W1wiZGVmYXVsdFwiXShuZXcgX3J4anMuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvYnNlcnZlci5uZXh0KF90aGlzLl90eGMucnVuKHF1ZXJ5LCBwYXJhbWV0ZXJzKSk7XG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbW1pdHMgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSAtIEFuIGVtcHR5IG9ic2VydmFibGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21taXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBfcnhqcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBfdGhpczIuX3R4Yy5jb21taXQoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJvbGxzIGJhY2sgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlfSAtIEFuIGVtcHR5IG9ic2VydmFibGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJvbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvbGxiYWNrKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgX3J4anMuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgX3RoaXMzLl90eGMucm9sbGJhY2soKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJ4VHJhbnNhY3Rpb247XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUnhUcmFuc2FjdGlvbjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZFwiKTtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9yZXN1bHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Jlc3VsdFwiKSk7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL2ludGVybmFsL3V0aWxcIik7XG5cbnZhciBfY29ubmVjdGlvbkhvbGRlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2ludGVybmFsL2Nvbm5lY3Rpb24taG9sZGVyXCIpKTtcblxudmFyIF9ib29rbWFyayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW50ZXJuYWwvYm9va21hcmtcIikpO1xuXG52YXIgX3R4Q29uZmlnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC90eC1jb25maWdcIikpO1xuXG52YXIgX3N0cmVhbU9ic2VydmVycyA9IHJlcXVpcmUoXCIuL2ludGVybmFsL3N0cmVhbS1vYnNlcnZlcnNcIik7XG5cbnZhciBfZXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRyYW5zYWN0aW9uIGluIHRoZSBOZW80aiBkYXRhYmFzZS5cbiAqXG4gKiBAYWNjZXNzIHB1YmxpY1xuICovXG52YXIgVHJhbnNhY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbkhvbGRlcn0gY29ubmVjdGlvbkhvbGRlciAtIHRoZSBjb25uZWN0aW9uIGhvbGRlciB0byBnZXQgY29ubmVjdGlvbiBmcm9tLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IG9uQ2xvc2UgLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0cmFuc2FjdGlvbiBpcyBjb21taXR0ZWQgb3Igcm9sbGVkIGJhY2suXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oYm9va21hcms6IEJvb2ttYXJrKX0gb25Cb29rbWFyayBjYWxsYmFjayBpbnZva2VkIHdoZW4gbmV3IGJvb2ttYXJrIGlzIHByb2R1Y2VkLlxuICAgKiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gb25Db25uZWN0aW9uIC0gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gYSBjb25uZWN0aW9uIGlzIG9idGFpbmVkIHRvIGVuc3VyZSB0aGUgY29ubmVjaXRvblxuICAgKiBpcyBub3QgeWV0IHJlbGVhc2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYWN0aXZlIHdoZXRoZXIgdGhpcyB0cmFuc2FjdGlvbiBnZW5lcmF0ZXMgcmVhY3RpdmUgc3RyZWFtc1xuICAgKiBAcGFyYW0ge251bWJlcn0gZmV0Y2hTaXplIC0gdGhlIHJlY29yZCBmZXRjaCBzaXplIGluIGVhY2ggcHVsbGluZyBiYXRjaC5cbiAgICovXG4gIGZ1bmN0aW9uIFRyYW5zYWN0aW9uKF9yZWYpIHtcbiAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9yZWYuY29ubmVjdGlvbkhvbGRlcixcbiAgICAgICAgb25DbG9zZSA9IF9yZWYub25DbG9zZSxcbiAgICAgICAgb25Cb29rbWFyayA9IF9yZWYub25Cb29rbWFyayxcbiAgICAgICAgb25Db25uZWN0aW9uID0gX3JlZi5vbkNvbm5lY3Rpb24sXG4gICAgICAgIHJlYWN0aXZlID0gX3JlZi5yZWFjdGl2ZSxcbiAgICAgICAgZmV0Y2hTaXplID0gX3JlZi5mZXRjaFNpemU7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBUcmFuc2FjdGlvbik7XG4gICAgdGhpcy5fY29ubmVjdGlvbkhvbGRlciA9IGNvbm5lY3Rpb25Ib2xkZXI7XG4gICAgdGhpcy5fcmVhY3RpdmUgPSByZWFjdGl2ZTtcbiAgICB0aGlzLl9zdGF0ZSA9IF9zdGF0ZXMuQUNUSVZFO1xuICAgIHRoaXMuX29uQ2xvc2UgPSBvbkNsb3NlO1xuICAgIHRoaXMuX29uQm9va21hcmsgPSBvbkJvb2ttYXJrO1xuICAgIHRoaXMuX29uQ29ubmVjdGlvbiA9IG9uQ29ubmVjdGlvbjtcbiAgICB0aGlzLl9vbkVycm9yID0gdGhpcy5fb25FcnJvckNhbGxiYWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Db21wbGV0ZSA9IHRoaXMuX29uQ29tcGxldGVDYWxsYmFjay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2ZldGNoU2l6ZSA9IGZldGNoU2l6ZTtcbiAgICB0aGlzLl9yZXN1bHRzID0gW107XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFRyYW5zYWN0aW9uLCBbe1xuICAgIGtleTogXCJfYmVnaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JlZ2luKGJvb2ttYXJrLCB0eENvbmZpZykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5fY29ubmVjdGlvbkhvbGRlci5nZXRDb25uZWN0aW9uKCkudGhlbihmdW5jdGlvbiAoY29ubikge1xuICAgICAgICBfdGhpcy5fb25Db25uZWN0aW9uKCk7XG5cbiAgICAgICAgcmV0dXJuIGNvbm4ucHJvdG9jb2woKS5iZWdpblRyYW5zYWN0aW9uKHtcbiAgICAgICAgICBib29rbWFyazogYm9va21hcmssXG4gICAgICAgICAgdHhDb25maWc6IHR4Q29uZmlnLFxuICAgICAgICAgIG1vZGU6IF90aGlzLl9jb25uZWN0aW9uSG9sZGVyLm1vZGUoKSxcbiAgICAgICAgICBkYXRhYmFzZTogX3RoaXMuX2Nvbm5lY3Rpb25Ib2xkZXIuZGF0YWJhc2UoKSxcbiAgICAgICAgICBiZWZvcmVFcnJvcjogX3RoaXMuX29uRXJyb3IsXG4gICAgICAgICAgYWZ0ZXJDb21wbGV0ZTogX3RoaXMuX29uQ29tcGxldGVcbiAgICAgICAgfSk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZXR1cm4gX3RoaXMuX29uRXJyb3IoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biBDeXBoZXIgcXVlcnlcbiAgICAgKiBDb3VsZCBiZSBjYWxsZWQgd2l0aCBhIHF1ZXJ5IG9iamVjdCBpLmUuOiBge3RleHQ6IFwiTUFUQ0ggLi4uXCIsIHBhcmFtZXRlcnM6IHtwYXJhbTogMX19YFxuICAgICAqIG9yIHdpdGggdGhlIHF1ZXJ5IGFuZCBwYXJhbWV0ZXJzIGFzIHNlcGFyYXRlIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge21peGVkfSBxdWVyeSAtIEN5cGhlciBxdWVyeSB0byBleGVjdXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBNYXAgd2l0aCBwYXJhbWV0ZXJzIHRvIHVzZSBpbiBxdWVyeVxuICAgICAqIEByZXR1cm4ge1Jlc3VsdH0gTmV3IFJlc3VsdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicnVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bihxdWVyeSwgcGFyYW1ldGVycykge1xuICAgICAgdmFyIF92YWxpZGF0ZVF1ZXJ5QW5kUGFyYSA9ICgwLCBfdXRpbC52YWxpZGF0ZVF1ZXJ5QW5kUGFyYW1ldGVycykocXVlcnksIHBhcmFtZXRlcnMpLFxuICAgICAgICAgIHZhbGlkYXRlZFF1ZXJ5ID0gX3ZhbGlkYXRlUXVlcnlBbmRQYXJhLnZhbGlkYXRlZFF1ZXJ5LFxuICAgICAgICAgIHBhcmFtcyA9IF92YWxpZGF0ZVF1ZXJ5QW5kUGFyYS5wYXJhbXM7XG5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9zdGF0ZS5ydW4odmFsaWRhdGVkUXVlcnksIHBhcmFtcywge1xuICAgICAgICBjb25uZWN0aW9uSG9sZGVyOiB0aGlzLl9jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLFxuICAgICAgICBvbkNvbXBsZXRlOiB0aGlzLl9vbkNvbXBsZXRlLFxuICAgICAgICBvbkNvbm5lY3Rpb246IHRoaXMuX29uQ29ubmVjdGlvbixcbiAgICAgICAgcmVhY3RpdmU6IHRoaXMuX3JlYWN0aXZlLFxuICAgICAgICBmZXRjaFNpemU6IHRoaXMuX2ZldGNoU2l6ZVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3Jlc3VsdHMucHVzaChyZXN1bHQpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21taXRzIHRoZSB0cmFuc2FjdGlvbiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogQWZ0ZXIgY29tbWl0dGluZyB0aGUgdHJhbnNhY3Rpb24gY2FuIG5vIGxvbmdlciBiZSB1c2VkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEFuIGVtcHR5IHByb21pc2UgaWYgY29tbWl0dGVkIHN1Y2Nlc3NmdWxseSBvciBlcnJvciBpZiBhbnkgZXJyb3IgaGFwcGVuZWQgZHVyaW5nIGNvbW1pdC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21taXQoKSB7XG4gICAgICB2YXIgY29tbWl0dGVkID0gdGhpcy5fc3RhdGUuY29tbWl0KHtcbiAgICAgICAgY29ubmVjdGlvbkhvbGRlcjogdGhpcy5fY29ubmVjdGlvbkhvbGRlcixcbiAgICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvcixcbiAgICAgICAgb25Db21wbGV0ZTogdGhpcy5fb25Db21wbGV0ZSxcbiAgICAgICAgb25Db25uZWN0aW9uOiB0aGlzLl9vbkNvbm5lY3Rpb24sXG4gICAgICAgIHBlbmRpbmdSZXN1bHRzOiB0aGlzLl9yZXN1bHRzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fc3RhdGUgPSBjb21taXR0ZWQuc3RhdGU7IC8vIGNsZWFuIHVwXG5cbiAgICAgIHRoaXMuX29uQ2xvc2UoKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgY29tbWl0dGVkLnJlc3VsdC5zdWJzY3JpYmUoe1xuICAgICAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiBvbkNvbXBsZXRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvbGxiYWNrcyB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBBZnRlciByb2xsaW5nIGJhY2ssIHRoZSB0cmFuc2FjdGlvbiBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQW4gZW1wdHkgcHJvbWlzZSBpZiByb2xsZWQgYmFjayBzdWNjZXNzZnVsbHkgb3IgZXJyb3IgaWYgYW55IGVycm9yIGhhcHBlbmVkIGR1cmluZ1xuICAgICAqIHJvbGxiYWNrLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicm9sbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm9sbGJhY2soKSB7XG4gICAgICB2YXIgcm9sbGVkYmFjayA9IHRoaXMuX3N0YXRlLnJvbGxiYWNrKHtcbiAgICAgICAgY29ubmVjdGlvbkhvbGRlcjogdGhpcy5fY29ubmVjdGlvbkhvbGRlcixcbiAgICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvcixcbiAgICAgICAgb25Db21wbGV0ZTogdGhpcy5fb25Db21wbGV0ZSxcbiAgICAgICAgb25Db25uZWN0aW9uOiB0aGlzLl9vbkNvbm5lY3Rpb24sXG4gICAgICAgIHBlbmRpbmdSZXN1bHRzOiB0aGlzLl9yZXN1bHRzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fc3RhdGUgPSByb2xsZWRiYWNrLnN0YXRlOyAvLyBjbGVhbiB1cFxuXG4gICAgICB0aGlzLl9vbkNsb3NlKCk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJvbGxlZGJhY2sucmVzdWx0LnN1YnNjcmliZSh7XG4gICAgICAgICAgb25Db21wbGV0ZWQ6IGZ1bmN0aW9uIG9uQ29tcGxldGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBhY3RpdmUsIHdoaWNoIG1lYW5zIGNvbW1pdCBhbmQgcm9sbGJhY2sgZGlkIG5vdCBoYXBwZW4uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIHdoZW4gbm90IGNvbW1pdHRlZCBhbmQgbm90IHJvbGxlZCBiYWNrLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzT3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc09wZW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhdGUgPT09IF9zdGF0ZXMuQUNUSVZFO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25FcnJvckNhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkVycm9yQ2FsbGJhY2soZXJyKSB7XG4gICAgICAvLyBlcnJvciB3aWxsIGJlIFwiYWNrbm93bGVkZ2VkXCIgYnkgc2VuZGluZyBhIFJFU0VUIG1lc3NhZ2VcbiAgICAgIC8vIGRhdGFiYXNlIHdpbGwgdGhlbiBmb3JnZXQgYWJvdXQgdGhpcyB0cmFuc2FjdGlvbiBhbmQgY2xlYW51cCBhbGwgY29ycmVzcG9uZGluZyByZXNvdXJjZXNcbiAgICAgIC8vIGl0IGlzIHRodXMgc2FmZSB0byBtb3ZlIHRoaXMgdHJhbnNhY3Rpb24gdG8gYSBGQUlMRUQgc3RhdGUgYW5kIGRpc2FsbG93IGFueSBmdXJ0aGVyIGludGVyYWN0aW9ucyB3aXRoIGl0XG4gICAgICB0aGlzLl9zdGF0ZSA9IF9zdGF0ZXMuRkFJTEVEO1xuXG4gICAgICB0aGlzLl9vbkNsb3NlKCk7IC8vIHJlbGVhc2UgY29ubmVjdGlvbiBiYWNrIHRvIHRoZSBwb29sXG5cblxuICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25Ib2xkZXIucmVsZWFzZUNvbm5lY3Rpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uQ29tcGxldGVDYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Db21wbGV0ZUNhbGxiYWNrKG1ldGEpIHtcbiAgICAgIHRoaXMuX29uQm9va21hcmsobmV3IF9ib29rbWFya1tcImRlZmF1bHRcIl0obWV0YS5ib29rbWFyaykpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHJhbnNhY3Rpb247XG59KCk7XG5cbnZhciBfc3RhdGVzID0ge1xuICAvLyBUaGUgdHJhbnNhY3Rpb24gaXMgcnVubmluZyB3aXRoIG5vIGV4cGxpY2l0IHN1Y2Nlc3Mgb3IgZmFpbHVyZSBtYXJrZWRcbiAgQUNUSVZFOiB7XG4gICAgY29tbWl0OiBmdW5jdGlvbiBjb21taXQoX3JlZjIpIHtcbiAgICAgIHZhciBjb25uZWN0aW9uSG9sZGVyID0gX3JlZjIuY29ubmVjdGlvbkhvbGRlcixcbiAgICAgICAgICBvbkVycm9yID0gX3JlZjIub25FcnJvcixcbiAgICAgICAgICBvbkNvbXBsZXRlID0gX3JlZjIub25Db21wbGV0ZSxcbiAgICAgICAgICBvbkNvbm5lY3Rpb24gPSBfcmVmMi5vbkNvbm5lY3Rpb24sXG4gICAgICAgICAgcGVuZGluZ1Jlc3VsdHMgPSBfcmVmMi5wZW5kaW5nUmVzdWx0cztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogZmluaXNoVHJhbnNhY3Rpb24odHJ1ZSwgY29ubmVjdGlvbkhvbGRlciwgb25FcnJvciwgb25Db21wbGV0ZSwgb25Db25uZWN0aW9uLCBwZW5kaW5nUmVzdWx0cyksXG4gICAgICAgIHN0YXRlOiBfc3RhdGVzLlNVQ0NFRURFRFxuICAgICAgfTtcbiAgICB9LFxuICAgIHJvbGxiYWNrOiBmdW5jdGlvbiByb2xsYmFjayhfcmVmMykge1xuICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfcmVmMy5jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICAgIG9uRXJyb3IgPSBfcmVmMy5vbkVycm9yLFxuICAgICAgICAgIG9uQ29tcGxldGUgPSBfcmVmMy5vbkNvbXBsZXRlLFxuICAgICAgICAgIG9uQ29ubmVjdGlvbiA9IF9yZWYzLm9uQ29ubmVjdGlvbixcbiAgICAgICAgICBwZW5kaW5nUmVzdWx0cyA9IF9yZWYzLnBlbmRpbmdSZXN1bHRzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBmaW5pc2hUcmFuc2FjdGlvbihmYWxzZSwgY29ubmVjdGlvbkhvbGRlciwgb25FcnJvciwgb25Db21wbGV0ZSwgb25Db25uZWN0aW9uLCBwZW5kaW5nUmVzdWx0cyksXG4gICAgICAgIHN0YXRlOiBfc3RhdGVzLlJPTExFRF9CQUNLXG4gICAgICB9O1xuICAgIH0sXG4gICAgcnVuOiBmdW5jdGlvbiBydW4ocXVlcnksIHBhcmFtZXRlcnMsIF9yZWY0KSB7XG4gICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9yZWY0LmNvbm5lY3Rpb25Ib2xkZXIsXG4gICAgICAgICAgb25FcnJvciA9IF9yZWY0Lm9uRXJyb3IsXG4gICAgICAgICAgb25Db21wbGV0ZSA9IF9yZWY0Lm9uQ29tcGxldGUsXG4gICAgICAgICAgb25Db25uZWN0aW9uID0gX3JlZjQub25Db25uZWN0aW9uLFxuICAgICAgICAgIHJlYWN0aXZlID0gX3JlZjQucmVhY3RpdmUsXG4gICAgICAgICAgZmV0Y2hTaXplID0gX3JlZjQuZmV0Y2hTaXplO1xuICAgICAgLy8gUlVOIGluIGV4cGxpY2l0IHRyYW5zYWN0aW9uIGNhbid0IGNvbnRhaW4gYm9va21hcmtzIGFuZCB0cmFuc2FjdGlvbiBjb25maWd1cmF0aW9uXG4gICAgICAvLyBObyBuZWVkIHRvIGluY2x1ZGUgbW9kZSBhbmQgZGF0YWJhc2UgbmFtZSBhcyBpdCBzaGFsbCBiZSBpbmNsdWVkIGluIGJlZ2luXG4gICAgICB2YXIgb2JzZXJ2ZXJQcm9taXNlID0gY29ubmVjdGlvbkhvbGRlci5nZXRDb25uZWN0aW9uKCkudGhlbihmdW5jdGlvbiAoY29ubikge1xuICAgICAgICBvbkNvbm5lY3Rpb24oKTtcbiAgICAgICAgcmV0dXJuIGNvbm4ucHJvdG9jb2woKS5ydW4ocXVlcnksIHBhcmFtZXRlcnMsIHtcbiAgICAgICAgICBib29rbWFyazogX2Jvb2ttYXJrW1wiZGVmYXVsdFwiXS5lbXB0eSgpLFxuICAgICAgICAgIHR4Q29uZmlnOiBfdHhDb25maWdbXCJkZWZhdWx0XCJdLmVtcHR5KCksXG4gICAgICAgICAgYmVmb3JlRXJyb3I6IG9uRXJyb3IsXG4gICAgICAgICAgYWZ0ZXJDb21wbGV0ZTogb25Db21wbGV0ZSxcbiAgICAgICAgICByZWFjdGl2ZTogcmVhY3RpdmUsXG4gICAgICAgICAgZmV0Y2hTaXplOiBmZXRjaFNpemVcbiAgICAgICAgfSk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbmV3IF9zdHJlYW1PYnNlcnZlcnMuRmFpbGVkT2JzZXJ2ZXIoe1xuICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3Q29tcGxldGVkUmVzdWx0KG9ic2VydmVyUHJvbWlzZSwgcXVlcnksIHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgfSxcbiAgLy8gQW4gZXJyb3IgaGFzIG9jY3VycmVkLCB0cmFuc2FjdGlvbiBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgYW5kIG5vIG1vcmUgbWVzc2FnZXMgd2lsbFxuICAvLyBiZSBzZW50IGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICBGQUlMRUQ6IHtcbiAgICBjb21taXQ6IGZ1bmN0aW9uIGNvbW1pdChfcmVmNSkge1xuICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfcmVmNS5jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICAgIG9uRXJyb3IgPSBfcmVmNS5vbkVycm9yLFxuICAgICAgICAgIG9uQ29tcGxldGUgPSBfcmVmNS5vbkNvbXBsZXRlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBuZXdDb21wbGV0ZWRSZXN1bHQobmV3IF9zdHJlYW1PYnNlcnZlcnMuRmFpbGVkT2JzZXJ2ZXIoe1xuICAgICAgICAgIGVycm9yOiAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnQ2Fubm90IGNvbW1pdCB0aGlzIHRyYW5zYWN0aW9uLCBiZWNhdXNlIGl0IGhhcyBiZWVuIHJvbGxlZCBiYWNrIGVpdGhlciBiZWNhdXNlIG9mIGFuIGVycm9yIG9yIGV4cGxpY2l0IHRlcm1pbmF0aW9uLicpLFxuICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICAgICAgfSksICdDT01NSVQnLCB7fSksXG4gICAgICAgIHN0YXRlOiBfc3RhdGVzLkZBSUxFRFxuICAgICAgfTtcbiAgICB9LFxuICAgIHJvbGxiYWNrOiBmdW5jdGlvbiByb2xsYmFjayhfcmVmNikge1xuICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfcmVmNi5jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICAgIG9uRXJyb3IgPSBfcmVmNi5vbkVycm9yLFxuICAgICAgICAgIG9uQ29tcGxldGUgPSBfcmVmNi5vbkNvbXBsZXRlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBuZXdDb21wbGV0ZWRSZXN1bHQobmV3IF9zdHJlYW1PYnNlcnZlcnMuQ29tcGxldGVkT2JzZXJ2ZXIoKSwgJ1JPTExCQUNLJywge30pLFxuICAgICAgICBzdGF0ZTogX3N0YXRlcy5GQUlMRURcbiAgICAgIH07XG4gICAgfSxcbiAgICBydW46IGZ1bmN0aW9uIHJ1bihxdWVyeSwgcGFyYW1ldGVycywgX3JlZjcpIHtcbiAgICAgIHZhciBjb25uZWN0aW9uSG9sZGVyID0gX3JlZjcuY29ubmVjdGlvbkhvbGRlcixcbiAgICAgICAgICBvbkVycm9yID0gX3JlZjcub25FcnJvcixcbiAgICAgICAgICBvbkNvbXBsZXRlID0gX3JlZjcub25Db21wbGV0ZTtcbiAgICAgIHJldHVybiBuZXdDb21wbGV0ZWRSZXN1bHQobmV3IF9zdHJlYW1PYnNlcnZlcnMuRmFpbGVkT2JzZXJ2ZXIoe1xuICAgICAgICBlcnJvcjogKDAsIF9lcnJvci5uZXdFcnJvcikoJ0Nhbm5vdCBydW4gcXVlcnkgaW4gdGhpcyB0cmFuc2FjdGlvbiwgYmVjYXVzZSBpdCBoYXMgYmVlbiByb2xsZWQgYmFjayBlaXRoZXIgYmVjYXVzZSBvZiBhbiBlcnJvciBvciBleHBsaWNpdCB0ZXJtaW5hdGlvbi4nKSxcbiAgICAgICAgb25FcnJvcjogb25FcnJvclxuICAgICAgfSksIHF1ZXJ5LCBwYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH0sXG4gIC8vIFRoaXMgdHJhbnNhY3Rpb24gaGFzIHN1Y2Nlc3NmdWxseSBjb21taXR0ZWRcbiAgU1VDQ0VFREVEOiB7XG4gICAgY29tbWl0OiBmdW5jdGlvbiBjb21taXQoX3JlZjgpIHtcbiAgICAgIHZhciBjb25uZWN0aW9uSG9sZGVyID0gX3JlZjguY29ubmVjdGlvbkhvbGRlcixcbiAgICAgICAgICBvbkVycm9yID0gX3JlZjgub25FcnJvcixcbiAgICAgICAgICBvbkNvbXBsZXRlID0gX3JlZjgub25Db21wbGV0ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogbmV3Q29tcGxldGVkUmVzdWx0KG5ldyBfc3RyZWFtT2JzZXJ2ZXJzLkZhaWxlZE9ic2VydmVyKHtcbiAgICAgICAgICBlcnJvcjogKDAsIF9lcnJvci5uZXdFcnJvcikoJ0Nhbm5vdCBjb21taXQgdGhpcyB0cmFuc2FjdGlvbiwgYmVjYXVzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIGNvbW1pdHRlZC4nKSxcbiAgICAgICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgICAgIH0pLCAnQ09NTUlUJywge30pLFxuICAgICAgICBzdGF0ZTogX3N0YXRlcy5TVUNDRUVERURcbiAgICAgIH07XG4gICAgfSxcbiAgICByb2xsYmFjazogZnVuY3Rpb24gcm9sbGJhY2soX3JlZjkpIHtcbiAgICAgIHZhciBjb25uZWN0aW9uSG9sZGVyID0gX3JlZjkuY29ubmVjdGlvbkhvbGRlcixcbiAgICAgICAgICBvbkVycm9yID0gX3JlZjkub25FcnJvcixcbiAgICAgICAgICBvbkNvbXBsZXRlID0gX3JlZjkub25Db21wbGV0ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogbmV3Q29tcGxldGVkUmVzdWx0KG5ldyBfc3RyZWFtT2JzZXJ2ZXJzLkZhaWxlZE9ic2VydmVyKHtcbiAgICAgICAgICBlcnJvcjogKDAsIF9lcnJvci5uZXdFcnJvcikoJ0Nhbm5vdCByb2xsYmFjayB0aGlzIHRyYW5zYWN0aW9uLCBiZWNhdXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gY29tbWl0dGVkLicpLFxuICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICAgICAgfSksICdST0xMQkFDSycsIHt9KSxcbiAgICAgICAgc3RhdGU6IF9zdGF0ZXMuU1VDQ0VFREVEXG4gICAgICB9O1xuICAgIH0sXG4gICAgcnVuOiBmdW5jdGlvbiBydW4ocXVlcnksIHBhcmFtZXRlcnMsIF9yZWYxMCkge1xuICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfcmVmMTAuY29ubmVjdGlvbkhvbGRlcixcbiAgICAgICAgICBvbkVycm9yID0gX3JlZjEwLm9uRXJyb3IsXG4gICAgICAgICAgb25Db21wbGV0ZSA9IF9yZWYxMC5vbkNvbXBsZXRlO1xuICAgICAgcmV0dXJuIG5ld0NvbXBsZXRlZFJlc3VsdChuZXcgX3N0cmVhbU9ic2VydmVycy5GYWlsZWRPYnNlcnZlcih7XG4gICAgICAgIGVycm9yOiAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnQ2Fubm90IHJ1biBxdWVyeSBpbiB0aGlzIHRyYW5zYWN0aW9uLCBiZWNhdXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gY29tbWl0dGVkLicpLFxuICAgICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgICB9KSwgcXVlcnksIHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgfSxcbiAgLy8gVGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiByb2xsZWQgYmFja1xuICBST0xMRURfQkFDSzoge1xuICAgIGNvbW1pdDogZnVuY3Rpb24gY29tbWl0KF9yZWYxMSkge1xuICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfcmVmMTEuY29ubmVjdGlvbkhvbGRlcixcbiAgICAgICAgICBvbkVycm9yID0gX3JlZjExLm9uRXJyb3IsXG4gICAgICAgICAgb25Db21wbGV0ZSA9IF9yZWYxMS5vbkNvbXBsZXRlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBuZXdDb21wbGV0ZWRSZXN1bHQobmV3IF9zdHJlYW1PYnNlcnZlcnMuRmFpbGVkT2JzZXJ2ZXIoe1xuICAgICAgICAgIGVycm9yOiAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnQ2Fubm90IGNvbW1pdCB0aGlzIHRyYW5zYWN0aW9uLCBiZWNhdXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gcm9sbGVkIGJhY2suJyksXG4gICAgICAgICAgb25FcnJvcjogb25FcnJvclxuICAgICAgICB9KSwgJ0NPTU1JVCcsIHt9KSxcbiAgICAgICAgc3RhdGU6IF9zdGF0ZXMuUk9MTEVEX0JBQ0tcbiAgICAgIH07XG4gICAgfSxcbiAgICByb2xsYmFjazogZnVuY3Rpb24gcm9sbGJhY2soX3JlZjEyKSB7XG4gICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9yZWYxMi5jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICAgIG9uRXJyb3IgPSBfcmVmMTIub25FcnJvcixcbiAgICAgICAgICBvbkNvbXBsZXRlID0gX3JlZjEyLm9uQ29tcGxldGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IG5ld0NvbXBsZXRlZFJlc3VsdChuZXcgX3N0cmVhbU9ic2VydmVycy5GYWlsZWRPYnNlcnZlcih7XG4gICAgICAgICAgZXJyb3I6ICgwLCBfZXJyb3IubmV3RXJyb3IpKCdDYW5ub3Qgcm9sbGJhY2sgdGhpcyB0cmFuc2FjdGlvbiwgYmVjYXVzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIHJvbGxlZCBiYWNrLicpXG4gICAgICAgIH0pLCAnUk9MTEJBQ0snLCB7fSksXG4gICAgICAgIHN0YXRlOiBfc3RhdGVzLlJPTExFRF9CQUNLXG4gICAgICB9O1xuICAgIH0sXG4gICAgcnVuOiBmdW5jdGlvbiBydW4ocXVlcnksIHBhcmFtZXRlcnMsIF9yZWYxMykge1xuICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfcmVmMTMuY29ubmVjdGlvbkhvbGRlcixcbiAgICAgICAgICBvbkVycm9yID0gX3JlZjEzLm9uRXJyb3IsXG4gICAgICAgICAgb25Db21wbGV0ZSA9IF9yZWYxMy5vbkNvbXBsZXRlO1xuICAgICAgcmV0dXJuIG5ld0NvbXBsZXRlZFJlc3VsdChuZXcgX3N0cmVhbU9ic2VydmVycy5GYWlsZWRPYnNlcnZlcih7XG4gICAgICAgIGVycm9yOiAoMCwgX2Vycm9yLm5ld0Vycm9yKSgnQ2Fubm90IHJ1biBxdWVyeSBpbiB0aGlzIHRyYW5zYWN0aW9uLCBiZWNhdXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gcm9sbGVkIGJhY2suJyksXG4gICAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICAgIH0pLCBxdWVyeSwgcGFyYW1ldGVycyk7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBjb21taXRcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbkhvbGRlcn0gY29ubmVjdGlvbkhvbGRlclxuICogQHBhcmFtIHtmdW5jdGlvbihlcnI6RXJyb3IpOiBhbnl9IG9uRXJyb3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obWV0YWRhdGE6b2JqZWN0KTogYW55fSBvbkNvbXBsZXRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCkgOiBhbnl9IG9uQ29ubmVjdGlvblxuICogQHBhcmFtIHtsaXN0PFJlc3VsdD4+fXBlbmRpbmdSZXN1bHRzIGFsbCBydW4gcmVzdWx0cyBpbiB0aGlzIHRyYW5zYWN0aW9uXG4gKi9cblxuZnVuY3Rpb24gZmluaXNoVHJhbnNhY3Rpb24oY29tbWl0LCBjb25uZWN0aW9uSG9sZGVyLCBvbkVycm9yLCBvbkNvbXBsZXRlLCBvbkNvbm5lY3Rpb24sIHBlbmRpbmdSZXN1bHRzKSB7XG4gIHZhciBvYnNlcnZlclByb21pc2UgPSBjb25uZWN0aW9uSG9sZGVyLmdldENvbm5lY3Rpb24oKS50aGVuKGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgb25Db25uZWN0aW9uKCk7XG4gICAgcGVuZGluZ1Jlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIHIuX2NhbmNlbCgpO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nUmVzdWx0cykudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgaWYgKGNvbW1pdCkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5wcm90b2NvbCgpLmNvbW1pdFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICBiZWZvcmVFcnJvcjogb25FcnJvcixcbiAgICAgICAgICBhZnRlckNvbXBsZXRlOiBvbkNvbXBsZXRlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24ucHJvdG9jb2woKS5yb2xsYmFja1RyYW5zYWN0aW9uKHtcbiAgICAgICAgICBiZWZvcmVFcnJvcjogb25FcnJvcixcbiAgICAgICAgICBhZnRlckNvbXBsZXRlOiBvbkNvbXBsZXRlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiBuZXcgX3N0cmVhbU9ic2VydmVycy5GYWlsZWRPYnNlcnZlcih7XG4gICAgICBlcnJvcjogZXJyb3IsXG4gICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgfSk7XG4gIH0pOyAvLyBmb3IgY29tbWl0ICYgcm9sbGJhY2sgd2UgbmVlZCByZXN1bHQgdGhhdCB1c2VzIHJlYWwgY29ubmVjdGlvbiBob2xkZXIgYW5kIG5vdGlmaWVzIGl0IHdoZW5cbiAgLy8gY29ubmVjdGlvbiBpcyBub3QgbmVlZGVkIGFuZCBjYW4gYmUgc2FmZWx5IHJlbGVhc2VkIHRvIHRoZSBwb29sXG5cbiAgcmV0dXJuIG5ldyBfcmVzdWx0W1wiZGVmYXVsdFwiXShvYnNlcnZlclByb21pc2UsIGNvbW1pdCA/ICdDT01NSVQnIDogJ1JPTExCQUNLJywge30sIGNvbm5lY3Rpb25Ib2xkZXIpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFJlc3VsdH0gd2l0aCBlbXB0eSBjb25uZWN0aW9uIGhvbGRlci5cbiAqIEZvciBjYXNlcyB3aGVuIHJlc3VsdCByZXByZXNlbnRzIGFuIGludGVybWVkaWF0ZSBvciBmYWlsZWQgYWN0aW9uLCBkb2VzIG5vdCByZXF1aXJlIGFueSBtZXRhZGF0YSBhbmQgZG9lcyBub3RcbiAqIG5lZWQgdG8gaW5mbHVlbmNlIHJlYWwgY29ubmVjdGlvbiBob2xkZXIgdG8gcmVsZWFzZSBjb25uZWN0aW9ucy5cbiAqIEBwYXJhbSB7UmVzdWx0U3RyZWFtT2JzZXJ2ZXJ9IG9ic2VydmVyIC0gYW4gb2JzZXJ2ZXIgZm9yIHRoZSBjcmVhdGVkIHJlc3VsdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIHRoZSBjeXBoZXIgcXVlcnkgdGhhdCBwcm9kdWNlZCB0aGUgcmVzdWx0LlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSB0aGUgcGFyYW1ldGVycyBmb3IgY3lwaGVyIHF1ZXJ5IHRoYXQgcHJvZHVjZWQgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1Jlc3VsdH0gbmV3IHJlc3VsdC5cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBuZXdDb21wbGV0ZWRSZXN1bHQob2JzZXJ2ZXJQcm9taXNlLCBxdWVyeSwgcGFyYW1ldGVycykge1xuICByZXR1cm4gbmV3IF9yZXN1bHRbXCJkZWZhdWx0XCJdKFByb21pc2UucmVzb2x2ZShvYnNlcnZlclByb21pc2UpLCBxdWVyeSwgcGFyYW1ldGVycywgX2Nvbm5lY3Rpb25Ib2xkZXIuRU1QVFlfQ09OTkVDVElPTl9IT0xERVIpO1xufVxuXG52YXIgX2RlZmF1bHQgPSBUcmFuc2FjdGlvbjtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDItMjAyMCBcIk5lbzRqLFwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHA6Ly9uZW80ai5jb21dXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTmVvNGouXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBETyBOT1QgQ0hBTkdFIFRIRSBWRVJTSU9OIEJFTE9XIEhFUkVcbi8vIFRoaXMgaXMgc2V0IGJ5IHRoZSBidWlsZCBzeXN0ZW0gYXQgcmVsZWFzZSB0aW1lLCB1c2luZ1xuLy8gICBndWxwIHNldCAtLXZlcnNpb24gPHJlbGVhc2V2ZXJzaW9uPlxuLy9cbi8vIFRoaXMgaXMgc2V0IHVwIHRoaXMgd2F5IHRvIGtlZXAgdGhlIHZlcnNpb24gaW4gdGhlIGNvZGUgaW5cbi8vIHN5bmMgd2l0aCB0aGUgbnBtIHBhY2thZ2UgdmVyc2lvbiwgYW5kIHRvIGFsbG93IHRoZSBidWlsZFxuLy8gc3lzdGVtIHRvIGNvbnRyb2wgdmVyc2lvbiBuYW1lcyBhdCBwYWNrYWdpbmcgdGltZS5cbnZhciBfZGVmYXVsdCA9ICcwLjAuMC1kZXYnO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDsiXSwic291cmNlUm9vdCI6IiJ9